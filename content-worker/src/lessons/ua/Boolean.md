# ![ico-35 study] Логічні конструкції JS

У цьому розділі ми познайомимося з логічними значеннями, логічними змінними, логічними виразами та логічними операторами.

## ![ico-30 icon] Змінні логічного типу (boolean)

Коли людина заявляє, що її синові 18 років, то цей вираз буде правдою протягом одного року, а до цього року і після цього року цей вираз стане брехнею. І то за умови, що в цієї людини є син.

![](illustrations/logical-expressions.svg)

Припустимо, що це твердження людина написала на своїй сторінці в соціальних мережах, коли їй було 15 років.
У нього ще не було сина, і це твердження було брехнею.
Потім чоловік подорослішав, одружився і в нього народився син, але це твердження залишалося неправдою, тому що його синові ще не було 18 років.
Нарешті, коли його синові виповнилося 18, це твердження стало істиною.
Але це тривало один рік.
Потім його синові виповнилося 19, і це твердження знову стало хибним.

Таким чином, це твердження є **змінною**. Адже його значення може змінюватися.
Значення, які може набувати ця змінна, - «істина» (**~true~**) або «брехня» (**~false~**).

**~true~** і **~false~** - це **логічні значення**.
![ico-25 warn] **Інших логічних значень не існує.**
^^У нас немає такого лукавого поняття, як «Не все так однозначно». Усе однозначно. Або чорне, або біле. Наш світ простий.^^

Отже, наша змінна може приймати одне з двох можливих логічних значень (**~true~** або **~false~**).
Це змінна **логічного типу** (**~boolean~**).

______________________________________

## ![ico-30 icon] Логічні вирази

Твердження '_Яблуко червоне і кругле_' можна розкласти на дві частини: '_Яблуко червоне_' + '_Яблуко кругле_'.

![](illustrations/logical-expressions-1.svg)

Тобто фактично ми маємо справу з двома логічними змінними, кожна з яких приймає логічне значення, тобто є змінною логічного типу.

◘◘ ![ico-25 coffee] ** 1**◘◘
~~~js
var apple = {
  color: 'yellow',
  shape: 'square'
}
~~~

Нехай логічна змінна **~appleIsRed~** приймає значення **~true~**, коли властивість **~apple.color~** має значення 'red', а логічна змінна **~appleIsRound~** приймає значення **~true~**, коли властивість **~apple.shape~** має значення 'round'.

Змінна **~appleIsRedAndRound~** приймає значення **~true~**, коли одночасно змінна **~appleIsRed~** приймає значення **~true~** і змінна **~appleIsRound~** приймає значення **~true~**.

| apple.color | apple.shape | appleIsRed | appleIsRound | appleIsRedAndRound |
|   'red'     |   'round'   |   ~true~   | ~true~       |   ~true~           |
|   'yellow'  |   'round'   |   ~false~  | ~true~       |   ~false~          |
|   'red'     |   'square'  |   ~true~   | ~false~      |   ~false~          |
|   'green'   |   'square'  |   ~false~  | ~false~      |   ~false~          |

Тоді змінна **~appleIsRedAndRound~** вже є **логічним виразом**, оскільки вимагає обчислення її значення на основі значень змінних **~appleIsRed~** і **~appleIsRound~**.

І цей логічний вираз матиме значення **~true~** тільки тоді, коли обидві змінні **~appleIsRed~** і **~appleIsRound~** матимуть значення **~true~**.

**Логічний вираз** - це вираз, у результаті обчислення якого буде отримано логічне значення.

Найпростішим випадком логічного виразу є логічне значення.

Давайте подивимося, як можна побудувати більш складні логічні вирази.

_________________________________________________________________________

### ![ico-25 icon] Оператори порівняння

Найпростіший спосіб побудови логічних виразів - це використання **операторів порівняння**.
Це бінарні оператори, тобто вони мають два операнди.
Операнди можуть бути змінними або виразами.

![ico-25 warn] Оператори порівняння порівнюють не тільки **значення**, а й **типи даних** операндів.
Оператори порівняння завжди повертають **логічне значення**.

| Оператор  | Опис |
| **~==~**  | нестрога рівність ^^(порівнюються тільки значення операндів, під капотом відбувається приведення типів даних)^^ |
| **~===~** | сувора рівність ^^(порівнюються типи даних операндів, і якщо тип даних операндів один і той самий, то порівнюються значення операндів)^^ |
| **~!=~**  | нестрога нерівність ^^(значення не рівні, тип даних ігнорується)^^ |
| **~!==~** | сувора нерівність ^^(не рівні не тільки значення, а й типи даних)^^ |
| **~ > ~** | більше              |
| **~ < ~** | менше               |
| **~>=~**  | більше або дорівнює |
| **~<=~**  | менше або дорівнює  |

Порівняння рядків відбувається посимвольно.
Кожен символ має числовий код, і порівнюються коди символів.
Якщо перші символи рядків-операндів рівні, то порівнюють наступні символи, і так доти, доки один із символів не виявиться більшим або меншим за другий.

§§§§ Demo | boolean_01_template §§§§

_________________________________________________________________________

### ![ico-30 hw] Тести

◘◘![ico-25 hw]** 1**◘◘

→→→ 5 > '4' | true, false | true→→→

◘◘![ico-25 hw]** 2**◘◘

→→→ 5 !== '5' | true, false | true→→→

◘◘![ico-25 hw]** 3**◘◘

→→→ 10 != '10' | true, false | false→→→

◘◘![ico-25 hw]** 4**◘◘

→→→ true != 1 | true, false | false→→→

◘◘![ico-25 hw]** 5**◘◘

→→→ true !== '1' | true, false, 'Не все так однозначно' | true→→→

◘◘![ico-25 hw]** 6**◘◘

→→→ true <= 1 | true, false | true→→→

◘◘![ico-25 hw]** 7**◘◘

→→→ 'abc' < 'cde' | true, false | true→→→

◘◘![ico-25 hw]** 8**◘◘

→→→ 'Welcome!'.length < 'How are you?'.length | true, false | true→→→

__________________________________________________________________________

## ![ico-30 icon] Логічні оператори

Логічних операторів у JS три: **логічне множення**, **логічне додавання** і **логічне заперечення**.

Оператор **логічного заперечення** - це унарний оператор, тобто він має лише один операнд.
Логічні оператори «і» (множення) та «або» (додавання) - це бінарні оператори, у них два операнди.

Логічне заперечення завжди повертає логічне значення, навіть якщо операнд не є логічним виразом (або логічним значенням).
Оператори **логічного множення**, **логічного додавання** не завжди повертають логічне значення.

При виконанні логічних операцій під капотом движок приводить операнди до типу даних **~boolean~**.
Це називається [►►►**неявне приведення типів**►►►►](page/Implicit-type-conversion).

Оскільки приведення до типу **~boolean~** є досить простим, ми можемо трохи «забігти наперед»:

1. Порожній рядок приводиться до **~false~**. Якщо довжина рядка більша за 0, то такий рядок буде приведений до **~true~** незалежно від того, які символи є в цьому рядку.
2. Числа, відмінні від 0, і **~NaN~**, приводяться до **~true~**, а 0 і **~NaN~** приводяться до **~false~**.
3. **~null~** і **~undefined~** приводяться до **~false~**.
4. Будь-які структури даних (масиви, об'єкти) завжди приводяться до **~true~**, незалежно від вмісту цих структур даних або повної відсутності вмісту.

_____________________________________________

### ![ico-25 icon] Оператор заперечення

Твердження «Яблуко не червоне» є запереченням твердження «Яблуко червоне».
Тобто яблуко може бути будь-якого кольору, тільки не червоного.
Якщо повернутися до прикладу 1:

~~~js
var apple = {
  color: 'yellow',
  shape: 'square'
}

var appleIsRed = apple.color === 'red'
var appleIsRound = apple.shape === 'round'
~~~

то нова змінна логічного типу **~appleIsNotRed~** може бути обчислена на підставі значення змінної **~appleIsRed~** шляхом заперечення.

Для логічного заперечення в JS використовується символ **~ !~** (знак оклику):

~~~js
var appleIsNotRed = !appleIsRed
~~~

![ico-25 warn] Логічне заперечення завжди повертає **логічне значення** незалежно від типу даних операнда.
Тобто яким би не був тип даних операнда, оператор **~ !~** завжди поверне **~true~** або **~false~**.

◘◘![ico-25 coffee] ** 2**◘◘

~~~js
!(5 > 8)    // true

// explanation:

5 > 8      // false,
!false     // true
~~~

◘◘![ico-25 coffee] ** 3**◘◘

~~~js
!(5 > 4)   // false

// explanation:

5 > 4      // true,
!true      // false
~~~

§§§§ Demo | boolean_02_template §§§§

____________________________________________________________

### ![ico-25 icon] Логічне множення

Синтаксис: ~operand1 **&&** operand2~

Повернемося до прикладу 1:

~~~js
var apple = {
  color: 'yellow',
  shape: 'square'
}

var appleIsRed = apple.color === 'red'
var appleIsRound = apple.shape === 'round'
~~~

Якщо обидва операнди є логічними виразами (або логічними змінними), то результат матиме тип даних **~boolean~**.

~~~js
var appleIsRedAndRound = appleIsRed && appleIsRound
~~~

§§§§ Demo | boolean_03_template §§§§

У наступних прикладах ми використовуємо логічний оператор **~&&~** до операндів, які є **логічними виразами**.
Логічні вирази ми будуємо за допомогою операторів порівняння.

◘◘![ico-25 coffee] ** 4**◘◘

~~~js
5 > 8 && 4 < 5   // false  
// explanation:
5 > 8            // false
4 < 5            // true
false && true    // false
~~~

◘◘![ico-25 coffee] ** 5**◘◘

~~~js
8 < 5 && 4 < 5   // false
// explanation:
8 > 5            // false
4 < 5            // true
false && true    // false
~~~

◘◘![ico-25 coffee] ** 6**◘◘

~~~js
var x = 4, y = 10, z = 8

x > y && z < y   // false
// explanation:
x > y            // false,
z < y            // true,
false && true    // false
~~~

◘◘![ico-25 coffee] ** 7**◘◘

~~~js
var x = 4, y = 10, z = 8

x < y && z < y   // true
// explanation:
x < y            // true,
z < y            // true,
true && true     // true
~~~

Однак це JS, і ми можемо застосовувати логічні оператори до даних будь-якого типу.
У цьому випадку починає працювати [►►►**неявне приведення типів**►►►►](page/Implicit-type-conversion), тобто операнди приводяться до логічного типу, після чого обчислюється значення виразу в такий спосіб: якщо після приведення першого операнда до логічного типу даних буде отримано значення ~false~, то повертається значення першого операнда, в іншому разі повертається значення другого операнда.

§§§§ Demo | boolean_04_template §§§§

Для більш складних виразів:

![](illustrations/logical-operators.svg)

Зверніть увагу на той факт, що використання логічного оператора **~&&~** не визначає однозначно тип результату.
Тип даних значення, яке буде отримано движком у результаті обчислення виразу, залежить від типу даних операндів.

§§§§ Demo | boolean_05_template §§§§

_________________________________________________

### ![ico-25 icon] Логічне складання

Синтаксис: ~operand1 **◧** operand2~

§§§§ Demo | boolean_06_template §§§§

◘◘![ico-25 coffee] ** 8**◘◘

~~~js
5 > 8 || 4 < 5   // true

// explanation:

5 > 8            // false,
4 < 5            // true,
false || true    // true
~~~

◘◘![ico-25 coffee] ** 9**◘◘

~~~js
5 > 8 || 4 > 5   // false

// explanation:

5 > 8            // false,
4 > 5            // false,
false || false   // false
~~~

◘◘![ico-25 coffee] **10**◘◘

~~~js
var x = 4, y = 10, z = 8

x > y || z < y   // true

// explanation:

x > y            // false,
z < y            // true,
false || true    // true
~~~

◘◘![ico-25 coffee] **11**◘◘

~~~js
x > y || z > y   // false

// explanation:

x > y            // false,
z > y            // false,
false || false   // false
~~~

Отже, логічне складання працює за принципом: якщо після приведення до типу даних **~boolean~** **хоч би одного з операндів** буде отримано **~true~**, то весь вираз матиме значення **~true~**. Оскільки значення інших операндів уже не змінять результат, то движок зупиняється на першому ж операнді, який після приведення типів дасть **~true~**. Однак оператор **~◧~** повертає не **~true~**, а початкове значення операнда.

![](illustrations/logical-operators-1.svg)

◘◘![ico-25 coffee] **12**◘◘

~~~js
var object = {
  color: 'yellow',
  shape: 'square',
  size: 100
}

var test = object.color === 'red' || object.shape === 'circle' || object.size > 50
~~~

~~~console
true
~~~
_________________________________________________________________________

![ico-25 exclamation] Незалежно від типу даних і значення змінної **~test~**:

~~~js
!test || !!test    // завжди  true

!test && !!test    // завжди  false
~~~

_________________________________________________________________________

### ![ico-25 icon] Tests

◘◘![ico-25 hw] ** 1**◘◘

~~~js
var x = undefined
~~~

→→→ x ◧ !x | undefined, null, true, false | true →→→

◘◘![ico-25 hw] ** 2**◘◘

~~~js
var x = undefined
~~~

→→→ x && !x | undefined, null, true, false | undefined →→→

◘◘![ico-25 hw] ** 3**◘◘

~~~js
var x = null
~~~

→→→ x ◧ !x | undefined, null, true, false | true →→→

◘◘![ico-25 hw] ** 4**◘◘

~~~js
var x = null
~~~

→→→ x && !x | undefined, null, true, false | null →→→

◘◘![ico-25 hw] ** 5**◘◘

~~~js
var x = NaN
~~~

→→→ x ◧ !x | NaN, null, true, false | true →→→

◘◘![ico-25 hw] ** 6**◘◘

~~~js
var x = NaN
~~~

→→→ x && !x | NaN, null, true, false | NaN →→→

◘◘![ico-25 hw] ** 7**◘◘

~~~js
var x = 5
~~~

→→→ x ◧ !x | NaN, null, 5, true, false | 5 →→→

◘◘![ico-25 hw] ** 8**◘◘

~~~js
var x = 5
~~~

→→→ x && !x | NaN, null, 5, true, false | false →→→


◘◘![ico-25 hw] ** 9**◘◘

~~~js
var x = 'Hi!'
~~~

→→→ x ◧ !x | undefined, 'Hi!', true, false | Hi! →→→


◘◘![ico-25 hw] **10**◘◘

~~~js
var x = 'Hi!'
~~~

→→→ x && !x | undefined, 'Hi!', true, false | false →→→

◘◘![ico-25 hw] **11**◘◘

~~~js
var x = ''
~~~

→→→ x ◧ !x | undefined, '""', true, false | true →→→


◘◘![ico-25 hw] **12**◘◘

~~~js
var x = ''
~~~

→→→ x && !x | undefined, '""', true, false | "" →→→


◘◘![ico-25 hw] **13**◘◘

~~~js
var x = 4, y = 10
~~~

→→→ (x > y) ◧ (x < 5) | 4, 10, true, false | true →→→


◘◘![ico-25 hw] **14**◘◘

~~~js
var x = 4, y = 10
~~~

→→→ (x > y) && (x < 5) | 4, 10, true, false | false →→→


◘◘![ico-25 hw] **15**◘◘

~~~js
var students = ['Piter', 'Anna', 'Demid', 'Josef']
~~~

→→→ students.length && students[1] | 4, 'Piter', 'Anna', 'Demid', 'Josef', true, false | Anna →→→


◘◘![ico-25 hw] **16**◘◘

~~~js
var students = ['Piter', 'Anna', 'Demid', 'Josef']
~~~

→→→ students.length ◧ students[2] | 4, 'Piter', 'Anna', 'Demid', 'Josef', true, false | 4 →→→


◘◘![ico-25 hw] **17**◘◘

~~~js
var students = ['Piter', 'Anna', 'Demid', 'Josef']
~~~

→→→ students.length > 4 ◧ students[2] | 4, 'Piter', 'Anna', 'Demid', 'Josef', true, false | Demid →→→


◘◘![ico-25 hw] **18**◘◘

~~~js
var array = [true, 'Google', NaN, undefined]
~~~

→→→ array.length > 4 ◧ typeof array[2] | 4, 'string', 'number', 'boolean', 'object', true, false | number →→→

◘◘![ico-25 hw] **19**◘◘

~~~js
var array = [true, 'Google', NaN, undefined]
~~~

→→→ array.length > 4 ◧ typeof array[2] | 4, 'string', 'number', 'boolean', 'object', true, false | number →→→


◘◘![ico-25 hw] **20**◘◘

~~~js
var alpha = NaN
var betta = typeof alpha
~~~

→→→ b === 'number' | NaN, 'number', 'boolean', true, false | true →→→


◘◘![ico-25 hw] **21**◘◘

~~~js
var alpha = NaN
var betta = typeof alpha === 'string'
~~~

→→→  !a && !b | NaN, true, false | true →→→
