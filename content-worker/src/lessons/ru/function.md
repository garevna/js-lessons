# ![ico-35 study] Функции

@@@@
Сейчас мы научимся работать с еще одним очень важным типом данных: **~function~**.<br>На функциях держится вся наша "вселенная JS".<br><br>**Функции - это ссылочный тип данных**.<br><br>Это означает, что после объявления функции у нас "в руках" будет переменная, в которой будет ссылка на функцию.
![](images/funcs-are-our-jam.svg)
@@@@

Когда кто-то болеет, то вызывают врача, когда возникают проблемы с водопроводом или канализацией - вызывают сантехника, а когда проблемы с проводкой в доме - вызывают электрика. Хорошо, что есть врачи, сантехники и электрики. Обратите внимание, что они не живут у нас в доме и не делают свою работу постоянно. Иначе в нашем доме был бы ад, толпы людей, которые все время что-то делают... Нет-нет, мы вызываем их только тогда, когда возникает необходимость. Они приходят, делают свою работу и уходят. Но у нас остается телефон или другой способ их вызова, если проблема возникнет опять.

То же самое с функциями.
Каждая функция умеет что-то делать.
Каждая функция может быть вызвана, когда возникнет необходимость.

Давайте для начала научимся их вызывать.
^^Действительно, если есть готовая дрель, то стоит научиться ею пользоваться ![ico-20 wink].^^

## ![ico-30 icon] Вызов функции

У нас есть много встроенных функций, а также есть функции, которые предоставляет нам браузер.
Вызов функции состоит из двух частей: имени функции и следующих за именем функции круглых скобок, в которых могут быть переданы **аргументы**, т.е. какие-то данные, которые функция будет использовать в своей работе.

Есть функции, которые не требуют передачи **аругментов** при вызове. В этом случае вы можете вызвать такую функцию с пустыми круглыми скобками, но ![ico-20 warn]  круглые скобки должны быть обязательно. Если вы передадите такой функции аргументы, она их просто проигнорирует, поскольку они не нужны для ее работы. Если вы передатите агрументов больше, чем надо, лишние аргументы будут отброшены.

### ![ico-25 icon] console.log

Например, мы пользуемся консолью браузера, и код, который мы набираем в консоли, автоматически исполняется после нажатия _Enter_.
Но до сих пор мы не знали, что можем обратиться к консоли напрямую (**~console~**) и вызвать одну из ее функций:

§§§§ Demo | function_console_template §§§§

![ico-25 warn] Для того, чтобы набрать в консоли многострочный код, используйте сочетание клавиш ~_Shift_ + _Enter_~, поскольку _Enter_ сразу запускает набранную строчку кода на исполнение:

§§§§ Demo | function_console_01_template §§§§

Теперь с помощью ~_Shift_ + _Enter_~ мы можем объявить объект:

§§§§ Demo | function_console_02_template §§§§

_________________________________________________

### ![ico-25 icon] parseInt

В нашем распоряжении так же несколько очень полезных встроенных функций, например, **~parseInt~**, которая пасит переданный ей аргумент как целое число.
Если это строка, начинающаяся с цифр, то остальная часть строки отбрасывается, и возвращается целая часть числа, состоящего из этих цифр.
Если это число с плавающей точкой, то возвращается целая часть числа.
Если это что-то, что не приводится к числу, то возвращается **~NaN~**:

§§§§ Demo | function_parseInt_template §§§§

Как видите, эта функция ждет агумент при вызове, и если вы его не передадите, т.е. вызовете функцию с пустыми круглыми скобками:

~~~js
parseInt()
~~~

то значением аргумента будет **~undefined~**.

Однако эта функция может принимать и **второй аргумент**.
По умолчанию этот аргумент равен **10**.
Если вы укажете 2, то первый аргумент будет рассматриваться как число в **двоичной системе исчисления**. Если в этом случае первый аргумент будет содержать цифры, отличные от 0 или 1, то функция **~parseInt~** вернет **~NaN~**.
Если вторым аргументом вы передадите 8, то первый аргумент будет рассматриваться как число в **восьмеричной системе исчисления**.
Если вторым аргументом вы передадите 16, то первый аргумент будет рассматриваться как число в **шестнадцатеричной системе исчисления**.

§§§§ Demo | function_parseInt_01_template §§§§

**Возвращаемое значение всегда будет десятичным числом**.

_____________________________________________________________________

### ![ico-25 icon] Библиотека Math

Так же у нас есть встроенная библиотека математических функций **Math**.

Мы можем посмотреть в консоли ее содержимое:

~~~js
console.log(Math)
~~~

И увидим длинный список всех математических констант (например, число PI), а так же функций:

~~~~console
▼ Math {abs: ƒ, acos: ƒ, acosh: ƒ, asin: ƒ, asinh: ƒ, …}
    E: 2.718281828459045
    LN2: 0.6931471805599453
    LN10: 2.302585092994046
    LOG2E: 1.4426950408889634
    LOG10E: 0.4342944819032518
    PI: 3.141592653589793
    SQRT1_2: 0.7071067811865476
    SQRT2: 1.4142135623730951
  ► abs: ƒ abs()
  ► acos: ƒ acos()
  ► acosh: ƒ acosh()
  ► asin: ƒ asin()
  ► asinh: ƒ asinh()
  ► atan: ƒ atan()
  ► atan2: ƒ atan2()
  ► atanh: ƒ atanh()
  ► cbrt: ƒ cbrt()
  ► ceil: ƒ ceil()
  ► clz32: ƒ clz32()
  ► cos: ƒ cos()
  ► cosh: ƒ cosh()
  ► exp: ƒ exp()
  ► expm1: ƒ expm1()
  ► floor: ƒ floor()
  ► fround: ƒ fround()
  ► hypot: ƒ hypot()
  ► imul: ƒ imul()
  ► log: ƒ log()
  ► log1p: ƒ log1p()
  ► log2: ƒ log2()
  ► log10: ƒ log10()
  ► max: ƒ max()
  ► min: ƒ min()
  ► pow: ƒ pow()
  ► random: ƒ random()
  ► round: ƒ round()
  ► sign: ƒ sign()
  ► sin: ƒ sin()
  ► sinh: ƒ sinh()
  ► sqrt: ƒ sqrt()
  ► tan: ƒ tan()
  ► tanh: ƒ tanh()
  ► trunc: ƒ trunc()
    Symbol(Symbol.toStringTag): "Math"
  ► [[Prototype]]: Object
~~~~

^^Обратите внимание, что имена констант пишутся в верхнем регистре, т.е. заглавными буквами.^^
^^Функции выделяются литерой **~ ƒ~** и обязательно имеют имя. Иначе как бы мы их вызвали?^^

~~~console
round: ƒ round()
~~~

Попробуем вызвать некоторые функции библиотеки **Math**:

§§§§ Demo | function_math_template §§§§

В круглых скобках мы передаем функциям при вызове **аргументы**.
Например, мы передаем функции извлечения квадратного корня число 16 при вызове:

~~~console
Math.sqrt(16)
~~~

и получаем результат: 4.

Т.е. все математические функции возвращают **значение**.

Посмотрим на такой оператор присваивания:

~~~js
var sin = Math.sin(Math.PI / 2)
~~~

В правой части оператора присваивания находится **выражение**.
Для того, чтобы выполнить присваивание, движок должен вычислить **значение** выражения в правой части, а для этого вызвать функцию и передать ей число.
Но в круглых скобках вызова функции опять стоит **выражение** ~Math.PI / 2~.
Т.е. движок должен сначала вычислить выражение в круглых скобках, и затем полученное значение передать функции ~Math.sin~ при вызове.

§§§§ Demo | function_math_01_template §§§§

Обратите внимание, что когда мы запускаем на исполнение в консоли код:

~~~console
var argument = Math.PI / 2
~~~

то консоль возвращает ~undefined~.

Это происходит потому, что оператор присваивания не возвращает никакого значения.

А вот когда мы запрашиваем значение переменной:

~~~console
argument
~~~

то возвращается уже не ~undefined~, а число, и это число мы видим в консоли вместо ~undefined~.

Аналогично, когда мы вызываем функцию:

~~~console
Math.sin(argument)
~~~

то возвращается значение 1, и мы видим в консоли это значение вместо ~undefined~.

Однако если мы сделаем так:

~~~console
var sin = Math.sin(argument)
~~~

то мы опять увидим в консоли ~undefined~, потому что присваивание не возвращает значения.

______________________________________________

Итак, для вызова функции нужно имя функции, после которого должны быть круглые скобки.
В круглых скобках мы можем передать функции **аргументы**, т.е. данные, которые функция будет использовать при вычислении возвращаемого значения.
Однако функция может не возвращать никакого значения, тогда движок воспринимает это так, как если бы функция вернула ~undefined~.

Любая строчка кода, которую мы запускаем в консоли нажатием клавиши _Enter_, воспринимается как вызов **анонимной** функции.
Если эта строчка содержит оператор присваивания, то такая строчка кода не вернет никакого значения, поэтому мы видим в консоли ~undefined~.
Если мы вызываем функцию **~console.log~**, она выводит переданные ей аргументы в консоль, но не возвращает никакого значения, поэтому после вывода в консоль мы опять увидим ~undefined~.

Наконец, давайте посмотрим, что же вернет нам оператор **~typeof~**:

§§§§ Demo | function_console_03_template §§§§

______________________________________________

## ![ico-30 icon] Объявление функции

Мы уже научились вызывать функции. Пора нам научиться создавать их, а точнее - объявлять функции.
Именно объявлять, потому что нашей целью не является немедленный вызов функции в том месте, где мы ее объявили.

Для того, чтобы правильно объявить функцию, нам нужно понять, чем функция отличается от всех остальных типов данных.

Во-первых, функция содержит код, который будет выполнен в момент вызова функции.
Этот код помещается в фигурные скобки и называется **телом функции**.

~~~js
{
  var number = 5
  var name = 'Google'
}
~~~

Здесь явно чего-то не хватает, не так ли?
Во-первых, у функции должно быть имя, чтобы мы могли ее вызвать.
Во-вторых, мы видим блок кода в фигурных скобках, и если его так и поместить в наш код, то он будет просто выполнен, как и все строчки кода до него и после него.

§§§§ Demo | function_00_template §§§§

Нет, нам явно нужно нечто другое.
Ну, например, чтобы код был сохранен под каким-то именем, но не был исполнен в том месте, где появился.
Чтобы можно было потом, когда понадобится, запустить этот код на исполнение. Не сразу, а когда-то потом.

Но если мы просто запишем:

~~~js
var func = {
  var number = 5
  var name = 'Google'
}
~~~

то движок подумает, что мы хотим создать объект (помните, как мы создавали структуры данных?).
Но мы не можем использовать ключевое слово **_~var~_** и оператор присваивания внутри фигурных скобок при объявлении объекта, потому что там должны быть перечислены через запятую пары (ключ: значение).
Что же ответит нам движок на наш код?
Движок сгенерирует исключение **SyntaxError**:

~~~error
    Uncaught SyntaxError: Unexpected identifier 'number'
~~~

Так как же нам объяснить движку, что это не объект, а тело функции?

Нам для этого нужно ключевое слово **~function~**.

Давайте попробуем исправить ситуацию так:

~~~js
var func = function {
  var number = 5
  var name = 'Google'
}
~~~

и опять движок генерирует исключение **SyntaxError**:

~~~error
    Uncaught SyntaxError: Unexpected token '{'
~~~

Движку явно не нравится фигурная скобка после слова **~function~**...
Хм... Может, там должно быть что-то другое?

И теперь мы вспоминаем, что вызываем-то мы функцию всегда с помощью круглых скобок, в которых могут быть переданы аргументы.

Ага, так и есть, нам нужно вставить круглые скобки между ключевым словом **~function~** и открывающей фигурной скобкой '{':

~~~js
var func = function () {
  var number = 5
  var name = 'Google'
}
~~~

Итак, мы использовали оператор присваивания, в правой части которого мы поместили такое выражение: ключевое слово **~function~**, за которым обязательно следуют круглые скобки, и далее - фигурные скобки для тела функции.

Как мы уже знаем, движок сначала вычислит выражение в правой части оператора присваивания, а затем полученное значение поместит в переменную **~func~**.
Так вот, после вычисления выражения в правой части оператора присваивания будет создан **объект функции** (в спецификации языка - "**вызываемый объект**"), а все объекты, как мы уже знаем, являются **ссылочным типом данных**, т.е. нам будет возвращена **ссылка**, которая и попадет в переменную **~func~**.

Итак, код внутри тела функции не был исполнен.
Проверим?

Обявим переменные **~number~** и **~name~** до объявления функции.

§§§§ Demo | function_01_template §§§§

Как видите, объявление функции никак не повлияло на значения переменных **~number~** и **~name~**.
Т.е. код в теле функции не сработал.
Однако когда мы вывели переменную **~func~** в консоль, мы увидели тело функции. Т.е. код функции где-то сохранен, но пока он не сработал.

Итак, ссылка на функцию у нас есть, осталось вызвать функцию:

~~~js
func()
~~~

§§§§ Demo | function_02_template §§§§

Вот такое присваивание:

~~~js
var func = function () {}
~~~

является одним из способов объявления функции, который называется **function expression**.

Действительно, если мы используем оператор присваивания, то в правой части у нас находится **выражение** (expression), отсюда и название **function expression**.

Однако это не единственный способ объявления функции.

_____________________________________________________________________

На самом деле нам вполне достаточно ключевого слова **_~function~_** вместо ключевого слова **_~var~_**:

~~~js
function func () {}
~~~

Это еще один способ объявления функции - **function declaration**.
Главное отличие от **function expression** - отсутствие оператора присваивания.
Позже мы разберем подробнее, на что это влияет и почему.

Фактически мы объявили переменную **_~func~_**, сразу же указав ее тип данных при объявлении, т.е. используя **_~function~_** вместо **_~var~_**.
Тот факт, что мы не используем оператор присваивания, не означает, что присваивания не происходит. Присваивание происходит "под капотом". Т.е. создается функция и ссылка на нее помещается в переменную **_~func~_**.

_________________________________________________

![ico-25 warn] Круглые скобки после имени переменной означают вызов функции и могут быть использованы только тогда, когда эта переменная является ссылкой на функцию.
В противном случае будет сгенерировано исключение **TypeError**:

~~~js
var func = 10
func()
~~~

~~~error
    Uncaught TypeError: func is not a function
~~~

Движок воспринимает вызов функции как выражение, значение которого нужно вычислить, для чего нужно запустить на исполнение код функции.
Это означает, что после вычисления выражения ~func()~ в том месте, где оно было встречено, будет некое значение...
Давайте разберемся, как определяется это значение.
_________________________________________________

## ![ico-30 icon] Формальные параметры

Давайте вернемся к тому, что при объявлении функции круглые скобки являются обязательными.
При вызове функции круглые скобки также являются обязательными.

Очевидно, что круглые скобки играют здесь важную роль.

Вспомним, как могут быть использованы круглые скобки при вызове функции: мы передаем функции **аргументы** в момент вызова, т.е. какие-то данные, которые функция использует во время работы.
Ок, а как функция "принимает" эти данные?
Их же нужно куда-то "положить".
А где мы храним данные? Ну, не ящиках, и не в тазиках, и не в кастрюлях.
Мы храним свои данные в **переменных**.

Т.е. чтобы принять переданные при вызове функции аргументы, нужно заранее приготовить переменные, в которые эти данные (аргументы) будут помещены.
И как-то само собой напрашивается, что нужно имена этих переменных разместить там, куда потом буду поступать аргументы.
Т.е. в кргулых скобках.
Логично?

§§§§ Demo | function_parameters_template §§§§

Таким образом, при объявлении функции мы используем круглые скобки для того, чтобы перечислить там имена переменных, которые мы будем использовать для вычислений в теле функции.
Эти переменные называются **формальные параметры** функции.
На момент объявления функции у этих переменных нет значений.
При вызове функции в круглых скобках будут перечислены **аргументы**, которые и станут значениями формальных параметров на данный момент.
Т.е. каждый раз при вызове функции мы можем передавать ей различные аргументы, тем самым получая различные результаты.

### ![ico-25 icon] Дефолтные значения

Конечно, большую проблему составляли для нас ошибки, связанные с передачей некорректных значений аргументов.
В арифметических операциях в случае ошибки мы будем получать коварное значение **~NaN~**, которое будет доставлять нам много неприятностей.

§§§§ Demo | function_parameters_01_template §§§§

Но в 2015 году вышла новая версия спецификации языка (ES6), в которой у нас появилась возможность задавать дефолтные значения параметров функции при ее объявлении, что позволяет избежать проблем с вызовом функции без параметров или когда эти параметры имеют значения **~undefined~**:

§§§§ Demo | function_parameters_02_template §§§§

Более того, можно сделать дефолтные значения параметров функции **вычисляемыми**:

§§§§ Demo | function_parameters_03_template §§§§

![ico-25 warn] Обратите внимание, что **значения параметров функции по умолчанию** используются только в том случае, если при вызове функции передано значение **~undefined~** (или вообще не передано никакого значения). Т.е. это не избавляет вас от необходимости проверять другие "нежелательные" значения аргументов, такие как **~null~**, **~NaN~** или когда аргумент должен быть числом, а передано не числовое значение.

__________________________________________________________________

## ![ico-30 icon] Оператор return

Функции, которые мы объявляли до сих пор, были как бы "неполноценные", потому что они ничего не возвращали, поэтому мы в консоли все время видели это назойливое **~undefined~**.

Теперь, наконец, мы избавимся от этой "неполноценности" и заставим наши функции возвращать значение.
А сделать это очень легко: для это есть унарный оператор **~return~**.

~~~js
var calcs = function (x = 1, y = x * 2, z = 0) {
  return x + y - z
}
~~~

![ico-25 warn] Этот оператор может быть использован только в теле функции.
Если вы попытаетесь использовать его вне тела функции, то будет сгенерировано исключение:

~~~error
    Uncaught SyntaxError: Illegal return statement
~~~

Оператор **~return~** прерывает выполнение функции, и если после оператора **~return~** стоит какое-то выражение, то значение этого выражения будет вычислено и возвращено функцией.

Это унарный оператор, т.е. у него может быть только один операнд.
Если операнд не указан явно, подразумевается **~undefined~**.

____________________________________________________________________

## ![ico-25 icon] Тесты

◘◘** 1**◘◘
~~~js
var func = function (arg) {
  return Math.random() * arg
}
~~~

→→→ Что это такое? | 'function declaration', 'function expression' | function expression→→→

◘◘** 2**◘◘
~~~js
function greeting (userName) {
  return 'Hi ' + userName + '!'
}

console.log(greeting())
~~~

→→→ Что будет в консоли? | '""', 'Hi user!', 'Hi undefined!', 'Hi !' | Hi undefined!→→→

◘◘** 3**◘◘
~~~js
function greeting (userName = 'Human') {
  return 'Hi ' + userName + '!'
}

console.log(greeting())
~~~

→→→ Что будет в консоли? | '""', 'Hi !', 'Hi undefined!', 'Hi Human!' | Hi Human!→→→


◘◘** 4**◘◘
~~~js
function greeting (userName = 'Human') {
  return 'Welcome ' + userName + '!'
  return 'Hi ' + userName + '!'
}

console.log(greeting())
~~~

→→→ Что будет в консоли? | 'Hi !', 'Welcome !', 'Hi undefined!', 'Welcome undefined!', 'Hi Human!', 'Welcome Human!' | Welcome Human!→→→

◘◘** 5**◘◘
~~~js
function randomInteger (number = 100) {
  return Math.round(Math.random() * number)
}
~~~

→→→ randomInteger() > 100 | true, false, undefined, 0, NaN | false→→→

◘◘** 6**◘◘
~~~js
function hexToDecimal (hexNumber = 0) {
  return parseInt(hexNumber, 16) || 0
}
~~~

→→→ !hexToDecimal() | undefined, true, false, 0, NaN | true→→→

◘◘** 7**◘◘
~~~js
function binToDecimal (bin = '1111111') {
  return parseInt(bin, 2) || 0
}
~~~

→→→ binToDecimal('540') | undefined, true, false, 0, NaN | 0→→→

◘◘** 8**◘◘
~~~js
function hexToDecimal (hex = 'FF') {
  return parseInt(hex, 16) || 255
}
~~~

→→→ hexToDecimal('rob') | undefined, true, false, 0, NaN, 255 | 255→→→
____________________________________________________________________

[![ico-25 hw] Quiz](quiz/function)

_______________________________________
[![ico-20 link] w3schools](external/w3-function)
[![ico-20 link] MDN](external/mdn-function)
