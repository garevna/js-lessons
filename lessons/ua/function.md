# ![ico-35 study] Функції

@@@@
Зараз ми навчимося працювати зі ще одним дуже важливим типом даних: **~function~**.<br>На функціях тримається весь наш «всесвіт JS».<br><br>**Функції - це посилальний тип даних**.<br><br>Це означає, що після оголошення функції в нас «у руках» буде змінна, у якій буде посилання на функцію.
![](images/funcs-are-our-jam.svg)
@@@@

Коли хтось хворіє, то викликають лікаря, коли виникають проблеми з водопроводом чи каналізацією - викликають сантехніка, а коли проблеми з проводкою в будинку - викликають електрика. Добре, що є лікарі, сантехніки та електрики. Зверніть увагу, що вони не живуть у нас у будинку і не роблять свою роботу постійно. Інакше в нашому будинку було б пекло, натовпи людей, які весь час щось роблять... Ні-ні, ми викликаємо їх тільки тоді, коли виникає необхідність. Вони приходять, роблять свою роботу і йдуть. Але в нас залишається телефон або інший спосіб їхнього виклику, якщо проблема виникне знову.

Те ж саме з функціями.
Кожна функція вміє щось робити.
Кожна функція може бути викликана, коли виникне необхідність.

Давайте для початку навчимося їх викликати.
^^Дійсно, якщо є готовий дриль, то варто навчитися ним користуватися ![ico-20 wink].^^

## ![ico-30 icon] Виклик функції

У нас є багато вбудованих функцій, а також є функції, які надає нам браузер.
Виклик функції складається з двох частин: імені функції та круглих дужок, що слідують за ім'ям функції, у яких можуть бути передані **аргументи**, тобто якісь дані, які функція використовуватиме у своїй роботі.

Є функції, які не потребують передачі **аругментів** під час виклику. У цьому випадку ви можете викликати таку функцію з порожніми круглими дужками, але ![ico-20 warn] круглі дужки мають бути обов'язково. Якщо ви передасте такій функції аргументи, вона їх просто проігнорує, оскільки вони не потрібні для її роботи. Якщо ви передасте більше аргументів, ніж треба, зайві аргументи будуть відкинуті.

### ![ico-25 icon] console.log

Наприклад, ми користуємося консоллю браузера, і код, який ми набираємо в консолі, автоматично виконується після натискання _Enter_.
Але досі ми не знали, що можемо звернутися до консолі безпосередньо (**~console~**) і викликати одну з її функцій:

§§§§ Demo | function_console_template §§§§

![ico-25 warn] Для того, щоб набрати в консолі багаторядковий код, використовуйте поєднання клавіш ~_Shift_ + _Enter_~, оскільки ~_Enter_~ відразу запускає набраний рядок коду на виконання:

§§§§ Demo | function_console_01_template §§§§

Тепер за допомогою ~_Shift_ + _Enter_~ ми можемо оголосити об'єкт:

§§§§ Demo | function_console_02_template §§§§

_________________________________________________

### ![ico-25 icon] parseInt

У нашому розпорядженні так само кілька дуже корисних вбудованих функцій, наприклад, **~parseInt~**, яка парсить переданий їй аргумент як ціле число.
Якщо це рядок, що починається з цифр, то інша частина рядка відкидається, і повертається ціла частина числа, що складається з цих цифр.
Якщо це число з плаваючою крапкою, то повертається ціла частина числа.
Якщо це щось, що не приводиться до числа, то повертається **~NaN~**:

§§§§ Demo | function_parseInt_template §§§§

Як бачите, ця функція чекає на агумент під час виклику, і якщо ви його не передасте, тобто викличете функцію з порожніми круглими дужками:

~~~js
parseInt()
~~~

то значенням аргументу буде **~undefined~**.

Однак ця функція може приймати і **другий аргумент**.
За замовчуванням цей аргумент дорівнює **10**.
Якщо ви вкажете 2, то перший аргумент буде розглядатися як число в **двійковій системі числення**. Якщо в цьому випадку перший аргумент міститиме цифри, відмінні від 0 або 1, то функція **~parseInt~** поверне **~NaN~**.
Якщо другим аргументом ви передасте 8, то перший аргумент розглядатиметься як число у **восьмиричній системі числення**.
Якщо другим аргументом ви передасте 16, то перший аргумент буде розглядатися як число в **шістнадцятковій системі числення**.

§§§§ Demo | function_parseInt_01_template §§§§

**Повернуте значення завжди буде десятковим числом**.

_____________________________________________________________________

### ![ico-25 icon] Бібліотека Math

Так само в нас є вбудована бібліотека математичних функцій **Math**.

Ми можемо подивитися в консолі її вміст:

~~~js
console.log(Math)
~~~

І побачимо довгий список усіх математичних констант (наприклад, число ~PI~), а також функцій:

~~~~console
▼ Math {abs: ƒ, acos: ƒ, acosh: ƒ, asin: ƒ, asinh: ƒ, …}
    E: 2.718281828459045
    LN2: 0.6931471805599453
    LN10: 2.302585092994046
    LOG2E: 1.4426950408889634
    LOG10E: 0.4342944819032518
    PI: 3.141592653589793
    SQRT1_2: 0.7071067811865476
    SQRT2: 1.4142135623730951
  ► abs: ƒ abs()
  ► acos: ƒ acos()
  ► acosh: ƒ acosh()
  ► asin: ƒ asin()
  ► asinh: ƒ asinh()
  ► atan: ƒ atan()
  ► atan2: ƒ atan2()
  ► atanh: ƒ atanh()
  ► cbrt: ƒ cbrt()
  ► ceil: ƒ ceil()
  ► clz32: ƒ clz32()
  ► cos: ƒ cos()
  ► cosh: ƒ cosh()
  ► exp: ƒ exp()
  ► expm1: ƒ expm1()
  ► floor: ƒ floor()
  ► fround: ƒ fround()
  ► hypot: ƒ hypot()
  ► imul: ƒ imul()
  ► log: ƒ log()
  ► log1p: ƒ log1p()
  ► log2: ƒ log2()
  ► log10: ƒ log10()
  ► max: ƒ max()
  ► min: ƒ min()
  ► pow: ƒ pow()
  ► random: ƒ random()
  ► round: ƒ round()
  ► sign: ƒ sign()
  ► sin: ƒ sin()
  ► sinh: ƒ sinh()
  ► sqrt: ƒ sqrt()
  ► tan: ƒ tan()
  ► tanh: ƒ tanh()
  ► trunc: ƒ trunc()
    Symbol(Symbol.toStringTag): "Math"
  ► [[Prototype]]: Object
~~~~

^^Зверніть увагу, що імена констант пишуться у верхньому регістрі, тобто великими літерами.^^
^^Функції виділяються літерою **~ ƒ ~** і обов'язково мають ім'я. Інакше як би ми їх викликали?^^

~~~console
round: ƒ round()
~~~

Спробуємо викликати деякі функції бібліотеки **Math**:

§§§§ Demo | function_math_template §§§§

У круглих дужках ми передаємо функціям під час виклику **аргументи**.
Наприклад, ми передаємо функції вилучення квадратного кореня число 16 під час виклику:

~~~console
Math.sqrt(16)
~~~

і отримуємо результат: 4.

Тобто всі математичні функції повертають **значення**.

Подивимося на такий оператор присвоювання:

~~~js
var sin = Math.sin(Math.PI / 2)
~~~

У правій частині оператора присвоювання знаходиться **вираз**.
Для того, щоб виконати присвоювання, движок має обчислити **значення** виразу в правій частині, а для цього викликати функцію і передати їй число.
Але в круглих дужках виклику функції знову стоїть **вираз** ~Math.PI / 2~.
Тобто движок повинен спочатку обчислити вираз у круглих дужках, і потім отримане значення передати функції ~Math.sin~ під час виклику.

§§§§ Demo | function_math_01_template §§§§

Зверніть увагу, що коли ми запускаємо на виконання в консолі код:

~~~console
var argument = Math.PI / 2
~~~

то консоль повертає ~undefined~.

Це відбувається тому, що оператор присвоювання не повертає жодного значення.

А ось коли ми запитуємо значення змінної:

~~~console
argument
~~~

то повертається вже не ~undefined~, а число, і це число ми бачимо в консолі замість ~undefined~.

Аналогічно, коли ми викликаємо функцію:

~~~console
Math.sin(argument)
~~~

то повертається значення 1, і ми бачимо в консолі це значення замість ~undefined~.

Однак якщо ми зробимо так:

~~~console
var sin = Math.sin(argument)
~~~

то ми знову побачимо в консолі ~undefined~, тому що присвоювання не повертає значення.

______________________________________________

Отже, для виклику функції потрібне ім'я функції, після якого мають бути круглі дужки.
У круглих дужках ми можемо передати функції **аргументи**, тобто дані, які функція використовуватиме під час обчислення значення, що повертається.
Однак функція може не повертати жодного значення, тоді движок сприймає це так, як якщо б функція повернула ~undefined~.

Будь-який рядок коду, який ми запускаємо в консолі натисканням клавіші ~_Enter_~, сприймається як виклик **анонімної** функції.
Якщо цей рядок містить оператор присвоювання, то такий рядок коду не поверне жодного значення, тому ми бачимо в консолі ~undefined~.
Якщо ми викликаємо функцію **~console.log~**, вона виводить передані їй аргументи в консоль, але не повертає жодного значення, тому після виведення в консоль ми знову побачимо ~undefined~.

Нарешті, давайте подивимося, що ж поверне нам оператор **~typeof~**:

§§§§ Demo | function_console_03_template §§§§

______________________________________________

## ![ico-30 icon] Оголошення функції

Ми вже навчилися викликати функції. Пора нам навчитися створювати їх, а точніше - оголошувати функції.
Саме оголошувати, бо нашою метою не є негайний виклик функції в тому місці, де ми її оголосили.

Для того, щоб правильно оголосити функцію, нам потрібно зрозуміти, чим функція відрізняється від усіх інших типів даних.

По-перше, функція містить код, який буде виконано в момент виклику функції.
Цей код поміщається у фігурні дужки і називається **тілом функції**.

~~~js
{
  var number = 5
  var name = 'Google'
}
~~~

Тут явно чогось не вистачає, чи не так?
По-перше, у функції має бути ім'я, щоб ми могли її викликати.
По-друге, ми бачимо блок коду у фігурних дужках, і якщо його так і помістити в наш код, то він буде просто виконаний, як і всі рядки коду до нього і після нього.

§§§§ Demo | function_00_template §§§§

Ні, нам явно потрібно щось інше.
Ну, наприклад, щоб код був збережений під якимось ім'ям, але не був виконаний у тому місці, де з'явився.
Щоб можна було потім, коли знадобиться, запустити цей код на виконання. Не відразу, а колись потім.

Але якщо ми просто запишемо:

~~~js
var func = {
  var number = 5
  var name = 'Google'
}
~~~

то движок подумає, що ми хочемо створити об'єкт (пам'ятаєте, як ми створювали структури даних?).
Але ми не можемо використовувати ключове слово **_~var~__** і оператор присвоювання всередині фігурних дужок під час оголошення об'єкта, тому що там мають бути перераховані через кому пари (ключ: значення).
Що ж відповість нам движок на наш код?
Движок згенерує виняток **SyntaxError**:

~~~error
    Uncaught SyntaxError: Unexpected identifier 'number'
~~~

То як же нам пояснити движку, що це не об'єкт, а тіло функції?

Нам для цього потрібно ключове слово **~function~**.

Давайте спробуємо виправити ситуацію так:

~~~js
var func = function {
  var number = 5
  var name = 'Google'
}
~~~

і знову движок генерує виняток **SyntaxError**:

~~~error
    Uncaught SyntaxError: Unexpected token '{'
~~~

Движку явно не подобається фігурна дужка після слова **~function~**...
Хм... Може, там має бути щось інше?

І тепер ми згадуємо, що викликаємо ми функцію завжди за допомогою круглих дужок, у яких можуть бути передані аргументи.

Ага, так і є, нам потрібно вставити круглі дужки між ключовим словом **~function~** і фігурною дужкою, що відкриває, '{':

~~~js
var func = function () {
  var number = 5
  var name = 'Google'
}
~~~

Отже, ми використовували оператор присвоювання, у правій частині якого ми помістили такий вираз: ключове слово **~function~**, за яким обов'язково йдуть круглі дужки, і далі - фігурні дужки для тіла функції.

Як ми вже знаємо, движок спочатку обчислить вираз у правій частині оператора присвоювання, а потім отримане значення помістить у змінну **~func~**.
Так ось, після обчислення виразу в правій частині оператора присвоювання буде створено **об'єкт функції** (у специфікації мови - «**об'єкт, що **викликається**»), а всі об'єкти, як ми вже знаємо, є **посилальним типом даних**, тобто нам буде повернуто **посилання**, яке й потрапить у змінну **~func~**.

Отже, код усередині тіла функції не було виконано.
Перевіримо?

Оголосимо змінні **~number~** і **~name~** до оголошення функції.

§§§§ Demo | function_01_template §§§§

Як бачите, оголошення функції ніяк не вплинуло на значення змінних **~number~** і **~name~**.
Тобто код у тілі функції не спрацював.
Однак коли ми вивели змінну **~func~** у консоль, ми побачили тіло функції. Тобто код функції десь збережений, але поки він не спрацював.

Отже, посилання на функцію в нас є, залишилося викликати функцію:

~~~js
func()
~~~

§§§§ Demo | function_02_template §§§§

Ось таке присвоювання:

~~~js
var func = function () {}
~~~

є одним зі способів оголошення функції, який називається **function expression**.

Дійсно, якщо ми використовуємо оператор присвоювання, то в правій частині в нас міститься **вираз** (expression), звідси й назва **function expression**.

Однак це не єдиний спосіб оголошення функції.
_____________________________________________________________________

Насправді нам цілком достатньо ключового слова **_~function~_** замість ключового слова **_~var~_**:

~~~js
function func () {}
~~~

Це ще один спосіб оголошення функції - **function declaration**.
Головна відмінність від **function expression** - відсутність оператора присвоювання.
Пізніше ми розберемо детальніше, на що це впливає і чому.

Фактично ми оголосили змінну **__~func~_**, одразу ж вказавши її тип даних під час оголошення, тобто використовуючи **_~function~_** замість **_~var~_**.
Той факт, що ми не використовуємо оператор присвоювання, не означає, що присвоювання не відбувається. Присвоювання відбувається «під капотом». Тобто створюється функція і посилання на неї поміщається у змінну **_~func~_**.

_________________________________________________

![ico-25 warn] Круглі дужки після імені змінної означають виклик функції і можуть бути використані тільки тоді, коли ця змінна є посиланням на функцію.
В іншому випадку буде згенеровано виняток **TypeError**:

~~~js
var func = 10
func()
~~~

~~~error
    Uncaught TypeError: func is not a function
~~~
_________________________________________________

## ![ico-30 icon] Формальні параметри

Давайте повернемося до того, що при оголошенні функції круглі дужки є обов'язковими.
При виклику функції круглі дужки також є обов'язковими.

Очевидно, що круглі дужки відіграють тут важливу роль.

Згадаймо, як можуть бути використані круглі дужки під час виклику функції: ми передаємо функції **аргументи** у момент виклику, тобто якісь дані, які функція використовує під час роботи.
Ок, а як функція «приймає» ці дані?
Їх же потрібно кудись «покласти».
А де ми зберігаємо дані? Ну, не в ящиках, і не в тазиках, і не в каструлях.
Ми зберігаємо свої дані в **змінних**.

Тобто щоб прийняти передані під час виклику функції аргументи, потрібно заздалегідь приготувати змінні, в які ці дані (аргументи) будуть поміщені.
І якось само собою напрошується, що потрібно імена цих змінних розмістити там, куди потім будуть надходити аргументи.
Тобто в круглих дужках.
Логічно?

§§§§ Demo | function_parameters_template §§§§

Таким чином, під час оголошення функції ми використовуємо круглі дужки для того, щоб перерахувати там імена змінних, які ми будемо використовувати для обчислень у тілі функції.
Ці змінні називаються **формальні параметри** функції.
На момент оголошення функції ці змінні не мають значень.
Під час виклику функції в круглих дужках будуть перераховані **аргументи**, які і стануть значеннями формальних параметрів на даний момент.
Тобто щоразу під час виклику функції ми можемо передавати їй різні аргументи, тим самим отримуючи різні результати.

### ![ico-25 icon] Дефолтні значення

Звичайно, велику проблему становили для нас помилки, пов'язані з передачею некоректних значень аргументів.
В арифметичних операціях у разі помилки ми отримуватимемо підступне значення **~NaN~**, яке доставлятиме нам багато неприємностей.

§§§§ Demo | function_parameters_01_template §§§§

Але у 2015 році вийшла нова версія специфікації мови (ES6), у якій у нас з'явилася можливість задавати дефолтні значення параметрів функції під час її оголошення, що дає змогу уникнути проблем із викликом функції без параметрів або коли ці параметри мають значення **~undefined~**:

§§§§ Demo | function_parameters_02_template §§§§

Ба більше, можна зробити дефолтні значення параметрів функції **обчислюваними**:

§§§§ Demo | function_parameters_03_template §§§§

![ico-25 warn] Зверніть увагу, що **значення параметрів функції за замовчуванням** використовуються тільки в тому разі, якщо під час виклику функції передано значення **~undefined~** (або взагалі не передано жодного значення). Тобто це не позбавляє вас від необхідності перевіряти інші «небажані» значення аргументів, такі як **~null~**, **~NaN~** або коли аргумент має бути числом, а передано не числове значення.

__________________________________________________________________

## ![ico-30 icon] Оператор return

Функції, які ми оголошували досі, були наче «неповноцінні», тому що вони нічого не повертали, тому ми в консолі весь час бачили це настирливе **~undefined~**.

Тепер, нарешті, ми позбудемося цієї «неповноцінності» і змусимо наші функції повертати значення.
А зробити це дуже легко: для цього є унарний оператор **~return~**.

~~~js
var calcs = function (x = 1, y = x * 2, z = 0) {
  return x + y - z
}
~~~

![ico-25 warn] Цей оператор може бути використаний тільки в тілі функції.
Якщо ви спробуєте використати його поза тілом функції, то буде згенеровано виняток:

~~~error
    Uncaught SyntaxError: Illegal return statement
~~~

Оператор **~return~** перериває виконання функції, і якщо після оператора **~return~** стоїть якийсь вираз (операнд), то значення цього виразу (операнда) буде обчислено і повернуто функцією.

Якщо операнд не вказано явно, мається на увазі **~undefined~**.

____________________________________________________________________

## ![ico-25 icon] Тести

◘◘** 1**◘◘
~~~js
var func = function (arg) {
  return Math.random() * arg
}
~~~

→→→ Що це таке? | 'function declaration', 'function expression' | function expression→→→

◘◘** 2**◘◘
~~~js
function greeting (userName) {
  return 'Hi ' + userName + '!'
}

console.log(greeting())
~~~

→→→ Що буде в консолі? | '""', 'Hi user!', 'Hi undefined!', 'Hi !' | Hi undefined!→→→

◘◘** 3**◘◘
~~~js
function greeting (userName = 'Human') {
  return 'Hi ' + userName + '!'
}

console.log(greeting())
~~~

→→→ Що буде в консолі? | '""', 'Hi !', 'Hi undefined!', 'Hi Human!' | Hi Human!→→→


◘◘** 4**◘◘
~~~js
function greeting (userName = 'Human') {
  return 'Welcome ' + userName + '!'
  return 'Hi ' + userName + '!'
}

console.log(greeting())
~~~

→→→ Що буде в консолі? | 'Hi !', 'Welcome !', 'Hi undefined!', 'Welcome undefined!', 'Hi Human!', 'Welcome Human!' | Welcome Human!→→→

◘◘** 5**◘◘
~~~js
function randomInteger (number = 100) {
  return Math.round(Math.random() * number)
}
~~~

→→→ randomInteger() > 100 | true, false, undefined, 0, NaN | false→→→

◘◘** 6**◘◘
~~~js
function hexToDecimal (hexNumber = 0) {
  return parseInt(hexNumber, 16) || 0
}
~~~

→→→ !hexToDecimal() | undefined, true, false, 0, NaN | true→→→

◘◘** 7**◘◘
~~~js
function binToDecimal (bin = '1111111') {
  return parseInt(bin, 2) || 0
}
~~~

→→→ binToDecimal('540') | undefined, true, false, 0, NaN | 0→→→

◘◘** 8**◘◘
~~~js
function hexToDecimal (hex = 'FF') {
  return parseInt(hex, 16) || 255
}
~~~

→→→ hexToDecimal('rob') | undefined, true, false, 0, NaN, 255 | 255→→→
____________________________________________________________________

[![ico-25 hw] Quiz](quiz/function)

_______________________________________
[![ico-20 link] w3schools](external/w3-function)
[![ico-20 link] MDN](external/mdn-function)
