# ![ico-30 study] Design Patterns

Если нужен велосипед, не нужно его изобретать

Паттерны проектирования - это готовые конструкции "велосипедов" для различных ситуаций

В разработке часто встречаются одни и те же проблемы, и многие такие проблемы имеют уже готовый шаблон решения, поскольку многим уже пришлось сталкиваться с аналогичной проблемой до вас

Для создания паттерна проблему нужно формализовать, т.е. описать формальным языком суть проблемы

Следующий шаг - описание принципа решения этой проблемы

________________________________________

@@@@

![](https://img.artlebedev.ru/everything/izdal/yazyk-shablonov/yazyk-shablonov-cover.jpg)
Первым, кто описал концепцию паттернов, был Кристофер Александер
Применительно к сфере разработки программного обеспечения эту концепцию "адаптировали" Эрих Гамм, Ричард Хелм, Ральф Джонсон и Джон Влиссидес
[%%%Gang of Four%%%](http://www.sugardas.lt/~p2d/books/Priemioop.pdf)
![](https://i.pinimg.com/originals/0b/c7/f0/0bc7f0c5ab814da316948fd2c9dd39aa.jpg)
В их книге **Design Patterns: Elements of Reusable Object-Oriented Software** ( 1995 ) описаны 23 паттерна в ООП
@@@@
_____________________________________________________

## ![ico-25 icon] Поведенческие паттерны

К числу поведенческих паттернов относится уже знакомый нам **итератор**

Какую проблему общего порядка решает этот паттерн ?

Во-первых, он обеспечивает механизм последовательного доступа к элементам структуры данных
Во-вторых, итератор работает с "черным ящиком" - снаружи не видно, что именно он итерирует, до тех пор, пока не будут выполнены все итерации
В-третьих, итератор опосредует доступ к структуре данных, задавая строгий порядок операций с ее элементами

Наконец, структура данных может и не быть структурой данных - это может быть цепочка неких операций, вызовов функций и т.д.

_____________________________________________________

## ![ico-25 icon] Делегирование

В прототипной модели наследования, по-сути, отсутствует сам механизм наследования, поскольку он подменяется механизмом **делегирования**

Действительно, что такое прототип ? - это объект, отличный от того объекта, прототипом которого он является

Давайте создадим два объекта: **proto** и **media**

и сделаем объект **proto** прототипом объекта **media**

◘◘![ico-25 cap] ** 1**◘◘

~~~js
const proto = {
  showPicture () {
    document.body
      .appendChild(document.createElement('img'))
      .src = 'https://cdn.pixabay.com/photo/2014/04/04/10/51/darling-harbour-313216_960_720.jpg'
  }
}

const media = {
  sayHello () {
    document.body
      .appendChild(document.createElement('h3'))
      .innerText = 'Hello!'
  }
}

Object.setPrototypeOf(media, proto)
~~~

Если теперь мы вызовем метод **_showPicture_** объекта **media**:

~~~js
media.showPicture()
~~~

то, по-сути, мы делегируем объекту **proto** то, что не может сделать объект **media**,
поскольку у него нет такого метода

Поэтому вся цепочка прототипов является, по-сути, цепочкой делегирования, а не наследования

Если рассматиривать делегирование как паттерн проектирования в ООП, то можно привести и другие примеры

◘◘![ico-25 cap] ** 2**◘◘

~~~js
const media = {
  image: true,
  method () {
    document.body
      .appendChild(document.createElement('img'))
      .src = 'https://garevna.github.io/js-samples/images/js-ico.png'
  }
}

const speaker = {
  text: true,
  method () {
    document.body
      .appendChild(document.createElement('h3'))
      .innerText = 'Hello'
  }
}

const dispetcher = {
  workers: [speaker, media],
  getSignal (signal) {
    const worker = this.workers.find(worker => worker[signal])
    worker && worker.method()
  }
}
~~~

{{{pattern-1.js}}}

^^Преимущества делегирования (прототипного наследования) по сравнению с классической моделью наследования отлично показаны^^ [^^Henry Lieberman^^](http://web.media.mit.edu/~lieber/Lieberary/OOP/Delegation/Delegation.html)

_____________________________________________________
