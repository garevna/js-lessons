# ![ico-35 study] Структуры данных

Вообще говоря, теперь мы с вами приступаем к изучению **ссылочного типа данных**.
Попробуем разобраться, что же это такое.

Во-первых, когда мы говорим о каких-либо **структурах данных**, мы подразумеваем некий набор данных, собранных под одним именем.
Например, список студентов группы или список учеников класса является структурой данных, потому что содержит десятки строковых значений (переменных типа 'string').
Однако если вы просите список студентов группы, вы не будете перечислять содержимое списка, тем более, что вы можете и не знать его. Вы назовете шифр группы.
Так получается структура данных.
Имя одно, а данных, хранящихся под этим именем, может быть очень много.

Почему такие типы данных являются **ссылочными**?

Потому, что если вы передаете название структуры данных, то вы не передаете при этом ее содержание.
Вы передаете только **ссылку** на структуру данных.

Если мы будем передавать эту ссылку из одной переменной в другую, мы будем передавать не группу, а **ссылку** на нее.

Например, у вас есть некая структура данных (например, список студентов группы), ссылка на которую хранится в переменной **~group~**.

После выполнения присваивания:

~~~js
var students = group
~~~

в переменной **~students~** будет ссылка на ту же самую структуру данных.
Нового структуры данных при этом не создается, передается только **ссылка**.

@@@@
![](illustrations/reference-is-a-lockpick-ru.svg)
Если у вас есть ссылка на структуру данных, вы получаете доступ к содержимому этой структуры данных по ссылке.<br>
@@@@

Давайте познакомимся ближе со структурами данных в JS. По крайней мере, с двумя из них - массивами и объектами.
Они отличаются по способу организации доступа к элементам структуры данных.
В массивах элементы строго выстроены по порядку, и доступ к ним осуществляется по их порядковому номеру внутри коллекции.
В объектах нет строго порядка следования, и вместо порядкового номера элементы такой коллекции (структуры) имеют уникальные идентификаторы, по которым мы можем найти их в коллекции.

_________________________________________________

## ![ico-30 icon] Массивы

**тип данных: ~object~**

• Массив - это упорядоченный набор переменных.
• Каждая переменная называется **элементом массива**.
• Элементы массива имеют порядковый номер (**_индекс_** элемента массива).

![ico-20 warn] Индексация элементов массива начинается с нуля, т.е. первый элемент массива будет иметь индекс ~ 0~.

Объявить массив очень просто:

~~~js
var array = [3.14, false, 'mother', null, undefined]
~~~

То, что вы видите в правой части оператора присваивания - это **выражение**.
Прежде, чем выполнить присваивание, движок всегда вычисляет выражение в правой части оператора присваивания.
А в правой части оператора присваивания движок видит квадратные скобки с перечислением через запятую значений внутри квадратных скобок.
Движок понимает, что мы хотим создать массив, и создает массив (точнее, он вызвает для этого специальный конструктор, но об этом мы поговрим позже).
Где движок разместил созданную структуру данных (массив) - мы никогда не узнаем, потому что нам он вернул только **ссылку** на этот массив.
Именно эта ссылка помещена в переменную **~array~**.
![ico-25 warn] Не массив, а **ссылка** на массив.

Теперь доступ к содержимому массива осуществляется следующим образом:

~~~js
array[2]
~~~

т.е. мы используем для этого имя массива, после которого указываем **индекс** элемента в квадратных скобках.
Индекс - это порядковый номер, начиная с нуля:

| 0    | 1     | 2        | 3    | 4         |
| 3.14 | false | 'mother' | null | undefined |

В результате получаем значение элемента массива:

~~~console
'mother'
~~~

Мы имеем доступ к элементам массива не только для чтения.
Следующее присваивание изменит значение последнего элемента массива:

~~~js
array[4] = 'father'
~~~

После этого присваивания наш массив будет таким:

~~~console
► (5) [3.14, false, 'mother', null, 'father']
~~~

___________________________________

Если теперь мы выполним следующее присваивание:

~~~js
var collection = array
~~~

то в переменной **~collection~** будет ссылка на тот же самый массив.

Проверим?

Давайте изменим элемент массива **~collection~**:

~~~js
collection[3] = 'brother'
~~~

и посмотрим на массив **~array~**:

~~~js
array
~~~

~~~console
► (5) [3.14, false, 'mother', 'brother', 'father']
~~~

Как видите, изменения, которые мы внесли (по ссылке!) в массив **~collection~**, отобразились в массиве **~array~**.
Это происходит потому, что и переменная **~collection~**, и переменная **~array~** являются **ссылками на один и тот же массив**.

### ![ico-25 icon] length

У массивов, как и у строк, есть свойство **~length~** (длина массива, или число элементов массива).

Досту к этому свойству возможен в **точечной нотации** (через точку после имени массива):

~~~js
collection.length
~~~

~~~console
5
~~~

_________________________________________

### ![ico-25 hw] Tests

◘◘![ico-20 hw] 1◘◘

~~~js
var  students = ['Piter', 'Madelin', 'Gregory']
~~~

→→→ students[1] | 'Piter', 'Madelin', 'Gregory', null, undefinded | Madelin →→→

◘◘![ico-20 hw] 2◘◘

~~~js
var  students = ['Piter', 'Madelin', 'Gregory']
~~~

→→→ students[3] | 'Piter', 'Madelin', 'Gregory', null, undefinded | undefinded →→→

◘◘![ico-20 hw] 3◘◘

~~~js
var  students = ['Piter', 'Madelin', 'Gregory']
var group = students
group[3] = 'Frodo'
~~~

→→→ students[3] | 'Piter', 'Madelin', 'Gregory', 'Frodo', null, undefinded | Frodo →→→

◘◘![ico-20 hw] 4◘◘

~~~js
var  students = ['Piter', 'Madelin', 'Gregory']
var group = []
group[3] = students[0]
~~~

→→→ group.length | 0, 1, 2, 3, 4, undefinded | 4 →→→

◘◘![ico-20 hw] 5◘◘

~~~js
var  students = ['Piter', 'Madelin', 'Gregory']
var group = []
group[0] = students
~~~

→→→ group.length | 0, 1, 2, 3 | 1→→→

◘◘![ico-20 hw] 6◘◘

~~~js
var  students = ['Frodo', 'Stephan', 'Madelin', 'Helen']
var hello = 'Hi ' + students[1] + '!'
~~~

→→→ hello | 'Hi !', 'Hi Frodo!', 'Hi Stephan!', 'Hi Madelin!', 'Hi Helen!' | Hi Stephan!→→→

_____________________________________________________________

## ![ico-25 icon] Объекты

**тип данных: ~object~**

Если массивы мы создавали с помощью квадратных скобок, то для создания объектов мы будем использовать фигурные скобки ~{}~.
Содержимое массива мы перечисляли внутри квадратных скобок через запятую.
Индексы элементов в массиве определялись автоматически на основании порядка их следования при перечислении.
Содержимое объекта будет так же перечисляться через запятую, но есть нюанс: **объект не является упорядоченным набором элементов**.
Данные, которые будут храниться в объекте, не будут иметь индексов, а вместо индексов мы будем использовать ключи, т.е. текстовые строки (тип 'string').
И если данные в массиве мы называли **элементами массива**, то данные в объекте мы будем называть **свойствами объекта**.
Каждое свойство объекта имеет **имя** и **значение**.

Вот так определяется объект **~human~** с тремя свойствами: **~name~**, **~age~** и **~employed~**:

◘◘![ico-25 cap] 5◘◘

~~~js
var human = {
  name: 'Frodo',
  age: 35,
  employed: true
}
~~~

Чтобы движок понял вас правильно, перечисляемые свойства объекта внутри фигурных скобок должны быть выражением ~имя: значение~.

Имя свойства является **ключом** для доступа к значению свойства, так же, как индекс элемента массива является ключом для доступа к элементу массива.
Мы можем использовать **точечную нотацию** для доступа к своствам объекта:

~~~js
human.name
~~~

~~~console
'Frodo'
~~~

Однако можно так же использовать нотацию квадратных скобок, как у массивов, только вместо целочисленных индесов внутри квадратных скобок указываются ключи, т.е. строки:

~~~js
human['name']
~~~

~~~console
'Frodo'
~~~

Почему такая нотация бывает удобнее точечной?

Предположим, что имя ключа у нас находится в переменной:

~~~js
var propName = 'name'
~~~

Тогда мы можем получить значение свойства объекта по ключу, хранящемуся в переменной **~propName~**:

~~~js
human[propName]
~~~

~~~console
'Frodo'
~~~

Мы достаточно легко можем добавлять свойства объекту обычным присваиванием:

~~~js
human.hobby = ['sport', 'reading']
~~~

После такого присваивания объект **~human~** в консоли будет выглядеть следующим образом:

~~~console
▼ {name: 'Frodo', age: 35, employed: true, hobby: Array(2)}
    age: 35
    employed: true
    hobby: (2) ['sport', 'reading']
    name: "Frodo"
  ► [[Prototype]]: Object
~~~

Позже мы с вами узнаем, что это за свойство ~[[Prototype]]: Object~, которого мы с вами не добавляли объекту, но которое будет присутствовать в любом объекте.

Для удаления свойств нужно использовать оператор **~delete~**:

~~~js
delete human.hobby
~~~

Этот оператор применим только к свойствам объекта, и возвращает логическое значение ~true~ или ~false~ в засисимости от того, произошло удаление или нет.

________________________________________________________

### ![ico-25 hw] Tests

◘◘![ico-20 hw] 1◘◘

~~~js
var memo = [1, false, 4.8, 'Google', [0, 1]]
~~~

→→→ typeof memo[4] | 'string', 'number', 'boolean', 'object', undefinded | object →→→

◘◘![ico-20 hw] 2◘◘

~~~js
var memo = [1, false, 4.8, 'Google', { name: 'Figaro' }]
~~~

→→→ typeof memo[4] | 'string', 'number', 'boolean', 'object', undefinded | object →→→

◘◘![ico-20 hw] 3◘◘

~~~js
var memo = [1, false, 4.8, 'Google', { name: 'Figaro' }]
~~~

→→→ typeof memo[4].name | 'string', 'number', 'boolean', 'object', undefinded | string →→→

◘◘![ico-20 hw] 4◘◘

~~~js
var list = [{ name: 'Google' }, { name: 'Mozilla' }, { name: 'Microsoft' }, { name: 'Apple' }]
~~~

→→→ typeof list | 'string', 'number', 'boolean', 'object', undefinded | object →→→

◘◘![ico-20 hw] 5◘◘

~~~js
var list = [{ name: 'Google' }, { name: 'Mozilla' }, { name: 'Microsoft' }, { name: 'Apple' }]
~~~

→→→ typeof list[0] | 'string', 'number', 'boolean', 'object', undefinded | object →→→

◘◘![ico-20 hw] 5◘◘

~~~js
var list = [{ name: 'Google' }, { name: 'Mozilla' }, { name: 'Microsoft' }, { name: 'Apple' }]
~~~

→→→ typeof list[0].name | 'string', 'number', 'boolean', 'object', undefinded | string →→→

◘◘![ico-20 hw] 6◘◘

~~~js
var  students = {
  group: 'Dev-05',
  course: 'Programming',
  names: [
    'Piter Clark',
    'Helen Surmot',
    'Pavel Farios',
    'Alex Figa',
    'Gregory Trump'
  ]
}
~~~

→→→ students.group | 'Dev-05', 'Programming', 'Piter Clark', 'Helen Surmot', 'Pavel Farios', 'Alex Figa', 'Gregory Trump', undefinded | Dev-05 →→→

◘◘![ico-20 hw] 7◘◘

~~~js
var  students = {
  group: 'Dev-05',
  course: 'Programming',
  names: [
    'Piter Clark',
    'Helen Surmot',
    'Pavel Farios',
    'Alex Figa',
    'Gregory Trump'
  ]
}
~~~

→→→ students[1] | 'Piter Clark', 'Helen Surmot', 'Pavel Farios', 'Alex Figa', 'Gregory Trump', undefinded | undefinded →→→

◘◘![ico-20 hw] 8◘◘

~~~js
var  students = {
  group: 'Dev-05',
  course: 'Programming',
  names: [
    'Piter Clark',
    'Helen Surmot',
    'Pavel Farios',
    'Alex Figa',
    'Gregory Trump'
  ]
}
~~~

→→→ students.names[1] | 'Piter Clark', 'Helen Surmot', 'Pavel Farios', 'Alex Figa', 'Gregory Trump', undefinded | Helen Surmot →→→

◘◘![ico-20 hw] 9◘◘

~~~js
var  students = [
  {
    name: 'Piter Clark',
    homeworks: [10, 7, 8, 5, 9, 6, 4, 8, 7]
  },
  {
    name: 'Helen Surmot',
    homeworks: [5, 4, 7, 6, 8, 7, 7, 6, 8]
  },
  {
    name: 'Pavel Farios',
    homeworks: [9, 8, 9, 10, 7, 7, 8, 6, 8]
  },
  {
    name: 'Alex Figa',
    homeworks: [4, 5, 4, 6, 7, 5, 6, 7, 8]
  },
  {
    name: 'Gregory Trump',
    homeworks: [3, 5, 4, 6, 5, 7, 6, 6, 7]
  }
]
~~~

→→→ students[4].name | 'Piter Clark', 'Helen Surmot', 'Pavel Farios', 'Alex Figa', 'Gregory Trump', undefinded | Gregory Trump →→→

◘◘![ico-20 hw] 10◘◘

~~~js
var  students = [
  {
    name: 'Piter Clark',
    homeworks: [10, 7, 8, 5, 9, 6, 4, 8, 7]
  },
  {
    name: 'Helen Surmot',
    homeworks: [5, 4, 7, 6, 8, 7, 7, 6, 8]
  },
  {
    name: 'Pavel Farios',
    homeworks: [9, 8, 9, 10, 7, 7, 8, 6, 8]
  },
  {
    name: 'Alex Figa',
    homeworks: [4, 5, 4, 6, 7, 5, 6, 7, 8]
  },
  {
    name: 'Gregory Trump',
    homeworks: [3, 5, 4, 6, 5, 7, 6, 6, 7]
  }
]
~~~

→→→ students[4].homeworks[1] | 7, 10, 8, 4, 5, 9, undefinded | 5 →→→

________________________________________________________

[![ico-20 link] MDN](external/mdn-data-structures)
