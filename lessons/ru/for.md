# ![ico-35 study] Оператор for

Ну, вот мы и добрались до третьего основополагающего принципа структурного программирования - до циклов.
Как мы уже, я надеюсь, знаем, цикл - это повторение одних и тех же действий несколько раз.
Т.е. есть какой-то код, который должен быть выполнен неоднократно.
Этот код помещается в фигурные скобки **~{}~** и называется **телом цикла**.

Каждое повторение цикла называется **итерацией цикла**.

Таким образом, у любого оператора цикла будет тело, и это тело всегда заключено в фигурные скобки.
На каждой итерации цикла код внутри фигурных скобок будет исполняться.

Но у каждого цикла есть одна важная задача: во-время остановиться.
Мы же не можем бесконечно повторять выполнение кода в фигурных скобках.
Бесконечный цикл - это подвисание вкладки браузера. Нам это точно ни к чему.

Итак, цикл нужно во-время остановить.
Для этого определить, когда цикл должен быть остановлен.

Есть варианты:
• Прямо указать, сколько раз должен быть выполнен цикл;
• Задать некое условие, при выполении которого цикл будет повторяться. Такое условие (некое выражение) всегда помещается в круглые скобки.
Условие цикла может быть любым вычисляемым выражением (т.е. синтаксически корректным), но после вычисления значения этого выражения движок всегда приведет его к логическому типу (**~true~** или **~false~**).

Итак, у любого оператора цикла есть три обязательные части: **название оператора** (ключевое слово), **условие** в круглых скобках и **тело** в фигурных скобках.

Для оператора цикла **~for~** нужна переменная-счетчик (переменная цикла), которая должна:
1. иметь стартовое значение. Т.е. ее нужно объявить и присвоить ей начальное значение;
2. переменная должна менять свое значение после каждой итерации цикла (иначе цикл будет бесконечным);
3. на каждой итерации значение переменной цикла должно проверяться на предмет выполнения ограничения (иначе цикл будет бесконечным).

Мы начинаем наше путешествие по циклам с оператора цикла **~for~**.

## ![ico-30 icon] Syntax

Для оператора цикла **~for~** все, что касается переменной цикла (инициализация, изменение, проверка) помещается в круглые скобки:

~~~js
for (initialization; condition; update) {
  ...body od the loop
}
~~~

Например:
~~~js
// initialization:
var index = 0
// condition:
index < 10
// update:
index++
~~~

Тогда получаем во такую картину:

~~~js
for (var index = 0; index < 10; index++) {
  ...body of the loop
}
~~~

Осталось наполнить тело цикла кодом.

_____________________________________________________________________

## ![ico-30 icon] Директива break

Прерывает выполнение цикла.

Дело в том, что ни одна из фаз (initialization; condition; update) для переменной цикла не является обязательной.
Теоретически можно организовать цикл, в котором все три фазы будут пропущены:

~~~js
for (; ;) {
  console.log('Iteration')
  if (Math.random() < 0.5) break
}
~~~

^^Здесь мы использовали функцию **~random~** встроенной библиотеки <a href="#byblyoteka_Math">**Math**</a>.^^

В этом случае управление циклом переходит в тело цикла.
Не очень красивое решение, не так ли?
Уж если вы не хотите возиться с переменной цикла, то лучше использовать оператор цикла **~while~**, который будет рассмотрен далее.
Но чисто из спортивного интереса такой вариант рассмотреть стоит.

Например, если нужно вывести в консоль все числа от 1 до 10, то можно сделать так:

~~~js
for (var i = 1; ; i++) {
  if (i > 10) break
  console.log(i)
}
~~~

Здесь условие на переменную цикла пропущено, что привело бы к бесконечному циклу, если бы мы не поставили прерывание цикла ~break~ внутри его тела.

_____________________________________________________________________

## ![ico-25 icon] Директива continue

Прерывает выполнение текущей итерации цикла.

Например, если нужно вывести в консоль только четные числа до 10, то можно сделать так:

~~~js
for (var i = 1; i < 10; i++) {
  if (i % 2 === 0) console.log(i)
}
~~~

А можно и так:

~~~js
for (var i = 1; i < 10; i++) {
  if (i % 2 !== 0) continue
  console.log(i)
}
~~~

^^Поскольку в теле условного оператора  ~if~  всего одна операция, фигурные скобки мы опустили.^^

^^~ %~ - это операция взятия остатка от деления (~4 % 2~ будет 0, ~5 % 2~ будет 1)^^

^^~x !== y~  значение или тип данных переменной ** x** не совпадает со значением или типом данных переменной ** y**^^

______________________________________________________

## ![ico-30 icon] Examples

◘◘![ico-25 cap]** 1**◘◘

~~~js
var res = 0

for (var i = 0; i < 10; i++) {
  res += i * 2
}
~~~

Расшифровка выражения в круглых скобках:

~~~js
(var i = 0; i < 10; i++)
~~~

| ~var i = 0~ | ^^инициализируем переменную цикла, т.е. объявляем ее и присваиваем ей начальное значение 0^^ |
| ~i++~ | ^^способ изменения переменной цикла на каждой итерации<br>в данном случае после каждой итерации значение переменной цикла будет увеличиваться на единицу^^ |
| ~i < 10~ | ^^устанавливаем ограничение на число итераций цикла<br>( значение переменной цикла будет увеличиваться до тех пор, пока оно меньше 10)^^ |

• ^^В данном примере к значению переменной ~res~ 10 раз будет добавлено значение вычисляемого выражения  ~i * 2~^^
• ^^На первой итерации цикла значением переменной цикла ** i** будет 0, поэтому значение переменной ~res~ не изменится^^
• ^^После первой итерации значение переменной цикла ** i** будет увеличено на единицу, и станет равно 1^^
• ^^На второй итерации цикла значение выражения  ~i * 2~ уже будет равно 2, это значение будет добавлено к значению переменной ~res~, которое станет равно 2^^
• ^^После итерации значение переменной цикла ** i** опять увеличится на 1 и станет равно 2^^
• ^^На третьей итерации выражение  ~i * 2~ примет значение 4^^
• ^^Это значение будет добавлено к значению переменной ~res~, которое станет равно ~2 + 4 = 6~^^

^^И так далее...^^

_________________________________________________________________

◘◘![ico-25 cap]** 2**◘◘

~~~js
for (var i = 1; i < 10;) {
  console.log(i++)
}
~~~

В этом примере приращение переменной цикла осуществляется внутри тела цикла.
Однако делать так я не рекомендую.
Это требует повышенной внимательности и может приводить к ошибкам.
Такие "финты" хороши для операторов цикла **~while~** и **~do...while~**, а уж если вы используете оператор **~for~**, то лучше не выпендриваться и все настроки для переменной цикла делать в круглых скобках. Это нагляднее и проще в отладке.

_________________________________________________________________

◘◘![ico-25 cap]** 3**◘◘

~~~js
var res = 0

for (var i = 100; i > 0; i--) {
  res += i % 2
}

console.log(res)
~~~
_________________________________________________________________

◘◘![ico-25 cap]** 4**◘◘

~~~js
for (var i = 2; i < 100; i *= 2) {
  console.log(i)
}
~~~

Вывод в консоль степеней двойки.
____________________________________________________________________

◘◘![ico-25 cap] Массив◘◘

~~~js
var res = 0, arr = [2, 1, 5, 3], i

for (i = 0; i < arr.length; i++) {
  res += arr[i]
}
~~~

^^У массивов, так же, как у текстовых строк, есть свойство ~length~.^^

^^Это свойство содержит число элементов массива (или число символов в строке).^^

^^В качестве ограничения на число итераций цикла мы используем длину массива^^ ~arr.length~:

~~~js
i < arr.length
~~~

^^т.е. пока переменная цикла меньше длины массива, цикл будет повторяться.^^

^^В результате выполнения цикла в переменной ~res~ будет сумма элементов массива ~arr~.^^

^^![ico-20 warn] Можно изменять значение переменной цикла на каждой итерации на число, отличное от единицы.^^

^^Следующий код выведет в консоль все нечетные числа от 1 до 20:^^

~~~js
for (var i = 1; i < 20; i += 2) {
  console.log(i)
}
~~~

______________________________________________________

## ![ico-30 icon] Tests

◘◘![ico-25 hw]** 1**◘◘

~~~js
var number = 5

for (; number > 2; number -= 2) {
  ++number
}
~~~

→→→ Какое значение будет у переменной number после завершения цикла? | 1, 2, 3, 4, 5, 6 | 2→→→


◘◘![ico-25 hw] **2-3**◘◘
~~~js
var x = 0, y = 0, numbers = [1, 2, 3, 4]

var res_x = 0, res_y = 0

for (var i = 0; i < arr.length-1; i++) {
  res_x += numbers[x++]
  res_y += numbers[++y]
}
~~~

→→→ Какое значение будет у переменной res_x после завершения цикла? | 1, 3, 5, 6, 9, 10 | 6→→→
→→→ Какое значение будет у переменной res_y после завершения цикла? | 1, 3, 5, 6, 9, 10 | 9→→→

◘◘![ico-25 hw]** 4**◘◘

~~~js
for (var number = 11; number > 2; number -= 2) {
  number++
}
~~~

→→→ Какое значение будет у переменной number после завершения цикла? | 1, 2, 3, 4, 5, 6, 7 | 2→→→

◘◘![ico-25 hw]** 5**◘◘

~~~js
for (var number = 7; number > 2; --number) {
  number--
}
~~~

→→→ Какое значение будет у переменной number после завершения цикла? | 1, 2, 3, 4, 5, 6, 7 | 1→→→

◘◘![ico-25 hw]** 6**◘◘

~~~js
for (var number = -1; number-- > -11; number *= 2) {}
~~~

→→→ Какое значение будет у переменной number после завершения цикла? | 0, -1, -9, -11, -12, -20, -21, -22, -23 | -23→→→

◘◘![ico-25 hw]** 7**◘◘

~~~js
var messages = ['Hi! ', 'Welcome! ', 'Nice to see you. ', 'How are you?']

var message = ''

for (var index = -1; index < messages.length; index += 2) {
  message += messages[index] || ''
}
~~~

→→→ Что будет в переменной message после завершения цикла? | 'Hi! Welcome! Nice to see you. How are you?', 'Hi! How are you?', 'Hi! Welcome! ', 'Hi! Nice to see you.', 'Welcome! Nice to see you. How are you?', 'Welcome! How are you?', 'Nice to see you. How are you?', 'How are you?' | Welcome! How are you?→→→
____________________________________________________________________

[![ico-20 link] MDN](external/mdn-for)
