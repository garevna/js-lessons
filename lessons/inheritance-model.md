# ![ico-30 study] Модель наследования JS

Модель наследования **_JS_** основана на понятии **прототипа**

**Прототип** - это **объект**

^^Предшественником JS в плане прототипной модели наследования является язык^^ [<img src="assets/self-logo.png" width="80"/>](http://www.selflanguage.org/)

^^Стремление сделать синтаксис Javascript похожим на **Java** привело к появлению в языке таких "рудиментов", как ключевое слово **~new~**, лишенное практического смысла в языках с прототипной моделью наследования и создающее иллюзию наличия классов^^

Класс - это абстракция, объект - это воплощение

_________________________

@@@@

![](createPath("images", "smoke-monkey.gif"))
![ico-25 yes] Уважаемые дамы и господа<br>Курение вредит вашему здоровью,<br>а курение конкретно в этом подъезде может вообще резко подорвать его

@@@@

__________________________________


![ico-25 speach] **Класс и объект**
^^Чашка - это абстракция,^^
^^но чашка, из которой ты в данный момент пьешь чай - это конкретное воплощение абстракции "чашка"^^
^^Для создания конкретного экземпляра класса "чашка" в классической модели используется ключевое слово **~new~**^^

![ico-25 speach] **Наследование в классической модели**
^^Абстракция "чашка" вложена в другую абстракцию - "емкость", поскольку емкостью также является кастрюля, и цистерна, и колба^^
^^Таким образом, класс "чашка" наследует от класса "емкость"^^


Так вот:

![ico-25 yes] **в JS наследование происходит от _объекта_, а не _класса_**,

**т.е. от _конкретного воплощения_, а не от абстракции**

Другими словами, **JS** - очень конкретный язык ![ico-25 smile]

_____________________________________________________________

## ![ico-25 icon] prototype

Для создания объекта в JS нам достаточно сделать следующее:

◘◘![ico-25 cap] ** 1**◘◘

~~~js
var sample = {
  name: 'master'
}
~~~

При этом у нашего объекта "магическим образом" появляется свойство **_~&#95;&#95;proto&#95;&#95;~_**:

~~~console
▼ { name: "master" }
    name: "master"
  ► __proto__: Object
~~~

Это свойство является ссылкой на объект **~prototype~**, который реально существует

внутри встроенного нативного объекта **~Object~**

На мой взгляд, это вполне соотносится с реальностью: 
![ico-20 question] можно ли получить наследство от _класса_ "дедушка" ?

______________________

@@@@

![](createPath("images", "cat-no.gif"))
Даже кошке понятно, что только **конкретный** дедушка может оставить вам наследство

@@@@

__________________________

Таким образом, **~sample~** наследовал от **~Object~**

Чтобы посмотреть, что же унаследовал **~sample~** от **~Object~**, давайте развернем его свойство **_~&#95;&#95;proto&#95;&#95;~_** в консоли:

~~~~console
▼ { name: "master" }
    name: "master"
  ► __proto__:
      ► constructor: ƒ Object()
      ► hasOwnProperty: ƒ hasOwnProperty()
      ► isPrototypeOf: ƒ isPrototypeOf()
      ► propertyIsEnumerable: ƒ propertyIsEnumerable()
      ► toLocaleString: ƒ toLocaleString()
      ► toString: ƒ toString()
      ► valueOf: ƒ valueOf()
      ► __defineGetter__: ƒ __defineGetter__()
      ► __defineSetter__: ƒ __defineSetter__()
      ► __lookupGetter__: ƒ __lookupGetter__()
      ► __lookupSetter__: ƒ __lookupSetter__()
      ► get __proto__: ƒ __proto__()
      ► set __proto__: ƒ __proto__()
~~~~

Сам "дедушка" **~Object~** не является наследством

Логично, что наследство "дедушки" где-то хранится...

Оно хранится в свойстве **~prototype~** "дедушки" (объекта **~Object~**)

Проверим:

^^^[Object.prototype]
~~~console
▼ {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}
  ► constructor: ƒ Object()
  ► hasOwnProperty: ƒ hasOwnProperty()
  ► isPrototypeOf: ƒ isPrototypeOf()
  ► propertyIsEnumerable: ƒ propertyIsEnumerable()
  ► toLocaleString: ƒ toLocaleString()
  ► toString: ƒ toString()
  ► valueOf: ƒ valueOf()
  ► __defineGetter__: ƒ __defineGetter__()
  ► __defineSetter__: ƒ __defineSetter__()
  ► __lookupGetter__: ƒ __lookupGetter__()
  ► __lookupSetter__: ƒ __lookupSetter__()
  ► get __proto__: ƒ __proto__()
  ► set __proto__: ƒ __proto__()
~~~
^^^

Например, "наследство" включает метод **_~hasOwnProperty~_**

Давайте попробуем его использовать:

~~~js
sample.hasOwnProperty('name')   // true
~~~

О-па, мы получили ~true~, т.е. метод работает!

Значит, наследство благополучно получено ![ico-25 smile]

![ico-25 question] зачем нам вообще нужно ключевое слово **~new~** ?

Итак, сделаем выводы:

![ico-20 green-ok] "наследство" хранится в свойстве **~prototype~** "дедушки"
![ico-20 green-ok] "наследник" получает свойство **_~&#95;&#95;proto&#95;&#95;~_**
![ico-20 green-ok] свойство **_~&#95;&#95;proto&#95;&#95;~_** является ссылкой на  сундук с наследством ( объект **~prototype~** )

_________________________________________________________________

## ![ico-25 icon] constructor

Теперь обратим внимание на первое, что мы видим в объекте **~prototype~** конструктора и в свойстве **_~&#95;&#95;proto&#95;&#95;~_** экземпляра

Это свойство **~constructor~**

Значение у него ••_ ƒ_ Object()••

Буковка ~ ƒ~ говорит нам, что это функция

~Object()~ говорит нам, что эта функция - конструктор **~Object~**

Итак, мы выяснили, что встроенный нативный объект **~Object~**:

• является функцией
• выступает в роли **~constructor~**

Таким образом, в сундуке с наследством (объекте **~prototype~**) есть ссылка на "дедушку", от которого наследство получено

Кроме того, "дедушка" является **функцией**

И у "дедушки" вполне конкретная роль - он **~constructor~**

Теперь вопрос: а что сделало его **_конструктором_** ?

___________________________________________________________________

Проделаем следующий "финт":

◘◘![ico-25 cap] ** 2**◘◘

~~~js
console.dir(function Sigma () {})
~~~

и обратим внимание на наличие свойства **~prototype~**,

в котором есть свойство **~constructor~**

~~~console
▼ ƒ Sigma()
    arguments: null
    caller: null
    length: 0
    name: "Sigma"
  ▼ prototype:
    ► constructor: ƒ Sigma()
    ► __proto__: Object
  ► __proto__: ƒ ()
~~~

Куда показывает свойство **~constructor~** ? - на функцию **_~Sigma~_**

То есть она по дефолту уже конструктор

У нее есть все, чтобы выступать в роли "дедушки"

Давайте именовать такие объекты "**конструкторы**", а не "_дедушки_" - это ближе к семантике языка

И опять обращаю ваше внимание на тот факт, что у нас все совершенно конкретно, нет никаких абстракций, никаких классов - только объекты ( функции тоже объекты )

Совершенно конкретная функция **_~Sigma~_** уже готова предоставить своим наследникам свой совершенно конкретный объект **~prototype~** в качестве наследства

Осталось только вызвать ее с ключевым словом **~new~**:

~~~js
var obj = new Sigma
~~~

и мы получим наследника...

А можно ли без **~new~** передать наследство ?

~~~js
function Sigma () {}

Sigma.prototype.say = function () {
  console.log('I\'m the instance of Sigma: ', this instanceof Sigma)
}
var obj = {}
obj.__proto__ = Sigma.prototype
~~~

И у нас все в шоколаде!

Одна строчка:

~~~js
obj.__proto__ = Sigma.prototype
~~~

сделала объект **~obj~** наследником **~Sigma~**

Причем оператор _~instanceof~_ совершенно благопристойно возвращает нам ~true~, как будто **~obj~** является экземпляром класса **~Sigma~**:

~~~js
obj.say()
~~~

**Результат в консоли:** ••I'm the instance of Sigma:  true••

Но ведь не существует никакого класса **~Sigma~** - совершенно справедливо заметите вы

И правильно сделаете ![ico-20 smile]

**~Sigma~** - просто функция, а не класс

^^Мы ей дали имя, начинающееся с литеры в верхнем регистре, чтобы придать ей "статус класса" - чистая липа^^

На самом деле все, что произошло - это помещение ссылки на объект **_~prototype~_** функции **~Sigma~** в свойство **_~&#95;&#95;proto&#95;&#95;~_** объекта **~obj~**

^^Зачем же имитировать классовую модель, пряча "под капот" истинную природу наследования в JS ?^^

^^Это сбивает с толку, приводит к непониманию истинной природы происходящего^^

В этом примере мы столкнулись с еще одним важным явлением - **_~this~_**

Ранее мы уже сталкивались с ключевым словом **_~this~_** в контексте исполнения функций

Давайте заглянем еще разок

_________________________________________________________________________

## ![ico-25 icon] this

Итак, мы уже поняли, что любая функция в JS является конструктором по своей сути, поскольку имеет контейнер для "наследства" - свойство **_~prototype~_**

Но что еще мы знаем о функциях JS ?

Мы знаем, что в момент вызова у них появляется ссылка на контекст вызова - **~this~**

Вы заметили, что в примере выше внутри функции **~say~** использовано это ключевое слово ?

Сама функция **~say~** находится внутри объекта **_~prototype~_** функции **~Sigma~**

Давайте изменим функцию **~say~**, не трогая все остальное:

~~~js
Sigma.prototype.say = function () {
  console.log(`My name is ${this.name}`)
}
~~~

и добавим объекту **~obj~** свойство **_~name~_**:

~~~js
obj.name = 'Google'
~~~

Теперь вызовем метод **~say~**, который унаследовал объект **~obj~**:

~~~js
obj.say()   // My name is  Google
~~~

Тыц, _~this.name~_ оказался "Google" !

т.е. ~this~ является ссылкой на **~obj~** !

Это как?

Да все правильно и закономерно:

• во-первых, метод **_~say~_** доступен объекту **~obj~**, потому что унаследован
• а во-вторых, при вызове ~obj.say()~ мы конкретно указали контекст вызова

Другими словами, когда один из наследников вызывает унаследованный метод, то контекстом вызова этого метода будет данный конкретный наследник

Кто вызвал - на того и покажет **~this~** внутри метода

Ведь **~this~** - это же ссылка на **контекст вызова**

То есть каждый наследник может попользоваться, и в момент, когда он пользуется, этот метод принадлежит ему

ферштейн? ![ico-25 smile]

__________________________________________________________________________

## ![ico-25 icon] Цепочка прототипов

Обратите внимание, что в предыдущем примере мы создали объект **~obj~** с двумя вложенными свойствами **_~&#95;&#95;proto&#95;&#95;~_**

~~~console
▼ Sigma {name: "Google"}
    name: "Google"
  ▼ __proto__:
    ► say: ƒ ()
    ► constructor: ƒ Sigma()
    ► __proto__: Object
~~~

первое свойство **_~&#95;&#95;proto&#95;&#95;~_** является ссылкой на **_объект_**, который содержит:

• свойство **_~say~_**
    • функция, которая выводит в консоль значение _~this.name~_
• свойство **_~constructor~_**
    • ссылка на функцию **~Sigma~**
• еще одно свойство **_~&#95;&#95;proto&#95;&#95;~_**
    • ссылка на объект **_~prototype~_** конструктора **~Object~**

Итак, наша цепочка прототипов состоит уже из двух звеньев

Этих звеньев может быть значительно больше

Что это означает?

Что при обращении к какому-либо свойству ( методу ) экземпляра **~obj~** поиск будет происходить сверху вниз по цепочке прототипов

Значит, если свойство с таким именем есть на нескольких уровнях, то будет использовано значение, которое находится выше остальных в цепочке прототипов

________________________________________________________

## ![ico-25 icon] Конструктор Object

**~Object~** - это "Адам" всех объектов в JS

Корень, от которого все произрастает

Ссылка на его свойство **_~prototype~_** будет последним звеном в любой цепочке прототипов, перед "жирной точкой" в конце - **~null~**

Однако у вас полная свобода творить

Вы можете создать объект без прототипа, например, так:

~~~js
var obj = Object.create(null)
~~~

^^(сразу поставили "жирую точку")^^

или так:

~~~js
var obj = {}
obj.__proto__ = null
~~~

_____________________________________________________


### ![ico-20 icon] Статические свойства Object

**собственные свойства конструктора ~Object~**

Свойства и методы объекта  **Object**, которые не находятся в свойстве  **~prototype~**, не наследуются экземплярами, и могут быть вызваны только как свойства и методы объекта  **Object**:

~~~~console
▼ Object()
    arguments: (...)
  ► assign: ƒ assign()
    caller: (...)
  ► create: ƒ create()
  ► defineProperties: ƒ defineProperties()
  ► defineProperty: ƒ defineProperty()
  ► entries: ƒ entries()
  ► freeze: ƒ freeze()
  ► fromEntries: ƒ fromEntries()
  ► getOwnPropertyDescriptor: ƒ getOwnPropertyDescriptor()
  ► getOwnPropertyDescriptors: ƒ getOwnPropertyDescriptors()
  ► getOwnPropertyNames: ƒ getOwnPropertyNames()
  ► getOwnPropertySymbols: ƒ getOwnPropertySymbols()
  ► getPrototypeOf: ƒ getPrototypeOf()
  ► is: ƒ is()
  ► isExtensible: ƒ isExtensible()
  ► isFrozen: ƒ isFrozen()
  ► isSealed: ƒ isSealed()
  ► keys: ƒ keys()
    length: 1
    name: "Object"
  ► preventExtensions: ƒ preventExtensions()
  ► prototype: {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}
  ► seal: ƒ seal()
  ► setPrototypeOf: ƒ setPrototypeOf()
  ► values: ƒ values()
  ► __proto__: ƒ ()
~~~~

Поскольку они не передаются экземплярам, их называют **_статическими_**

____________________________________

Воспользуемся методом **~Object.create~** для создания нового экземпляра объекта:

◘◘![ico-25 cap] ** 3**◘◘

~~~js
var sample = Object.create({ type: 'figure' })
sample.name = 'circle'
~~~

и выведем его в консоль:

~~~console
▼ { name: "circle" }
    name: "circle"
  ▼ __proto__:
        type: "figure"
      ► __proto__: Object
~~~

Как видите, мы опять обошлись без ключевого слова **~new~**,
и благополучно создали экземпляр **~sample~**,
у которого первым звеном в цепочке прототипов является ссылка на безымянный объект ~{ type: "figure" }~,
а далее следует ссылка на свойство **_~prototype~_** конструктора **~Object~**

_________________________________________

Воспользуемся методом **~Object.setPrototypeOf()~**:

◘◘![ico-25 cap] ** 4**◘◘

~~~js
var sample = {
  name: 'circle'
}
var sample = Object.setPrototypeOf(sample, { type: 'figure' })
~~~

Результат будет абсолютно такой же, как в предыдущем примере, и мы опять обошлись без ключевого слова **~new~**

"Похимичим" далее:

~~~js
var test = Object.create(sample)
test.draw = function () {
  console.log(this.name)
}
~~~

Новый экземпляр ~test~ наследует от объекта ~sample~ все, включая его цепочку прототипов:

~~~console
▼ { draw: ƒ }
    draw: ƒ ()
  ▼ __proto__:
        name: "circle"
      ► __proto__:
            type: "figure"
          ► __proto__: Object
~~~

Правда, при этом у нас нет имитации классов ( в цепочке прототипов отсутствует свойство **~constructor~** ) и оператор **~instanceof~** становится бесполезен

Зато все по-честному ![ico-25 smile]

_______________________________________________________________________

### ![ico-20 icon] Object.&#95;&#95;proto&#95;&#95;

Выведем в консоль свойство **_~&#95;&#95;proto&#95;&#95;~_** конструктора **~Object~**

~~~~console
▼ __proto__: ƒ ()
    ► apply: ƒ ()
      arguments: (...)
    ► bind: ƒ ()
    ► call: ƒ ()
      caller: (...)
    ► constructor: ƒ ()
      length: 0
      name: ""
    ► toString: ƒ ()
    ► Symbol(Symbol.hasInstance): ƒ ()
    ► get arguments: ƒ ()
    ► set arguments: ƒ ()
    ► get caller: ƒ ()
    ► set caller: ƒ ()
    ► __proto__: Object
~~~~

а теперь выведем в консоль свойство **~prototype~** конструктора **Function**

~~~~console
▼ prototype: ƒ ()
    ► apply: ƒ ()
      arguments: (...)
    ► bind: ƒ ()
    ► call: ƒ ()
      caller: (...)
    ► constructor: ƒ ()
      length: 0
      name: ""
    ► toString: ƒ ()
    ► Symbol(Symbol.hasInstance): ƒ ()
    ► get arguments: ƒ ()
    ► set arguments: ƒ ()
    ► get caller: ƒ ()
    ► set caller: ƒ ()
    ► __proto__: Object
~~~~

Очевидно, что **~Object~** наследует от **~Function~**, что логично, поскольку **~Object~** - это конструктор, т.е. функция

~~~js
console.dir( Object.__proto__.constructor.name)
// Function
~~~

При этом объект **~Function.prototype~** наследует от **~Object~**

(свойство **~Function.prototype.&#95;&#95;proto&#95;&#95;~** является ссылкой на **~Object.prototype~**)

Вот такие "сиамские близнецы" ![ico-25 smile]

| ^^Свойство^^ | ^^ссылка на^^ |
| ~Object.&#95;&#95;proto&#95;&#95;~ | ~Function.prototype~ |
| ~Function.prototype.&#95;&#95;proto&#95;&#95;~ | ~Object.prototype~ |

_____________________________________________________

## ![ico-25 cap] Пример

host-объект  **~console~**  имеет свойства   ~log~,  ~dir~,  ~info~,  ~warn~,  ~error~...

^^для получения всех перечислимых свойств host-объекта ~console~ воспользуйтесь оператором  for...in^^

~~~js
for (var prop in console) console.log(prop)
~~~

Мы можем обращаться к этим свойствам как к элементам ассоциативного массива:

~~~js
console['log']
console['dir']
console['info']
console['warn']
console['error']
~~~

Перечисленные свойства имеют тип данных  "**~function~**"

Это означает, что они являются методами объекта  ~console~

^^Для вызова метода нужно использовать круглые скобки, в которых могут быть (а могут и не быть) аргументы^^

Перечисленные методы вызываются с аргументом

~~~js
console['log']('Привет!')
~~~

^^в консоль будет выведено "Привет!"^^

Создадим объект  **presence** следующей структуры:

~~~~js
var presence = {
  'Артюх Илья' : true,
  'Боднарь Михаил' : true,
  'Гончар Виктор' : true,
  'Дмитренко Пётр' : true,
  'Дорошенко Дмитрий' : true,
  'Калашников Григорий' : true,
  'Кержакова Марина' : true,
  'Москаленко Андрей' : true,
  'Ничипоренко Иван' : true,
  'Опрышкин Дмитрий' : true,
  'Подобреева Юлия' : true,
  'Саратова Ольга' : false,
  'Алескерова Евгения' : false
}
~~~~

Теперь выведем в консоль имена всех свойств объекта **presence** таким образом:

• если свойство имеет значение  _~true~_, то мы выведем имя свойства  в консоль с помощью метода **~console.info~**

• а если свойство имеет значение  _~false~_, то мы выведем имя свойства  в консоль  с помощью метода **~console.error~**

Для определения имени метода объекта  ~console~  используем тернарный оператор:

~~~js
presence[student] ? 'info' : 'error'
~~~

который вернет значение **"info"**, если  ~presence[student]~ будет **~true~**, или значение **"error"**, если  ~presence[student]~ будет **~false~**

~~~js
for (var student in presence) {
  console[presence[student] ? 'info' : 'error'](student)
}
~~~

Теперь создадим журнал группы:

~~~~js
var group = [
  {
    name: 'Артюх Илья',
    present: []
  },
  {
    name: 'Боднарь Михаил',
    present: []
  },
  {
    name: 'Гончар Виктор',
    present: []
  },
  {
    name: 'Дмитренко Пётр',
    present: []
  },
  {
    name: 'Дорошенко Дмитрий',
    present: []
  },
  {
    name: 'Калашников Григорий',
    present: []
  },
  {
    name: 'Кержакова Марина',
    present: []
  },
  {
    name: 'Москаленко Андрей',
    present: []
  },
  {
    name: 'Ничипоренко Иван',
    present: []
  },
  {
    name: 'Опрышкин Дмитрий',
    present: []
  },
  {
    name: 'Подобреева Юлия',
    present: []
  },
  {
    name: 'Саратова Ольга',
    present: []
  },
  {
    name: 'Алескерова Евгения',
    present: []
  }
]
~~~~
и запустим цикл:

~~~js
var lessonDate = new Date().toLocaleString().split(', ')[0]

for (var student of group) {
  student.present.push({
    data: lessonDate,
    name: presence[student.name]
  })
}
~~~

Выведите результат в консоль

_____________________________________________________

[![ico-30 hw] **Упражнения**](https://docs.google.com/forms/d/e/1FAIpQLSf-i0cr7AEXzSJrggqS1AgZz-OBW5ES-l_ntO1R4Q7XZqZaEw/viewform)

__________________________________________________

[![ico-20 link] ^^Global_Objects^^](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects)
[![ico-20 link] ^^Object-Oriented JavaScript^^](https://developer.mozilla.org/ru/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript)
