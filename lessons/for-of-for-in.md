# ![ico-30 study] Итерирование

Итерирование - это последовательный перебор элементов какого-то множества ( например, массива )

^^Для массивов и строк это не представляет проблемы, поскольку элементы массива упорядочены и пронумерованы,и последовательность их перебора очевидна^^
^^( на каждой итерации цикла будет взят следующий по порядку элемент массива, то есть порядковый номер итерации будет совпадать с порядковым номером элемента массива )^^
^^Символы в строке также расположены последовательно^^
^^Однако не все структуры данных упорядочены так, как массивы и строки^^
^^Не всегда у элементов множества есть порядковые номера^^

______________________________

## ![ico-25 icon] Итерабельные структуры данных

Для того, чтобы структуру данных можно было итерировать, у этой структуры данных должен быть определен

• протокол итерирования, задающий правило выбора очередного элемента из множества
• встроенный итератор, реализующий это правило

^^Итератор будет на каждой итерации возвращать следующий элемент итерируемого множества в соответствии с установленным для этого множества протоколом итерирования^^

____________________________________

## ![ico-25 icon] for...of

Оператор цикла  ~for ... of~  итерирует указанную **итерабельную** структуру данных, выполняя заданную в теле оператора последовательность действий над каждым элементом итерируемой совокупности

Обычные объекты JS не являются итерабельными, поэтому цикл ~for ... of~ не может быть использован с объектом

Например, код

~~~js
var iteratedObject = {
  name: 'Begemot',
  animal: true,
  age: 3
}

for (var item of iteratedObject) {
  console.log(item)
}
~~~

завершится ошибкой

![ico-20 err]  ~Uncaught TypeError: iteratedObject is not iterable~

Однако существуют итерабельные объекты

Примером итерабельного ( массиво-подобного ) объекта является объект  ~arguments~

____________________________________________

### ![ico-25 cap] Пример с массивом

~~~js
var iteratedArray = [10, 20, 30]

for (var num of iteratedArray) {
  num /= 10
  console.log(num)
}
~~~

^^На каждой итерации в консоль выводится значение очередного элемента массива ~iteratedArray~, деленное на 10^^

_________________________

### ![ico-25 cap] Пример со строкой

~~~js
var iteratedString = 'ABCDEF'

for (var char of iteratedString) {
  console.log(char)
}
~~~

^^На каждой итерации в консоль выводится очередносимвол строки *iteratedString*^^

________________________

Задача: проверить парность и правильность расстановки скобок в строке
^^(для упрощения задачи будем считать, что в тестируемой строке только скобки)^^

~~~js
function testBrackets ( string ) {
  var brackets = {
    '[': ']',
    '{': '}',
    '(': ')'
  }

  var stack = [], result = ''

  for (var symbol of string) {
    if (!brackets[symbol] && stack.length === 0) return false

    brackets[symbol]
      ? stack.push(symbol)
      : symbol = brackets[stack.pop()]

    result += symbol
  }
    return result === string && stack.length === 0
}
~~~

________________

### ![ico-25 cap] Пример с объектом arguments

~~~js
function showArguments () {
  for (var arg of arguments) {
    console.log(arg)
  }
}

showArguments('begemot', false, 3)
~~~

^^На каждой итерации в консоль выводится очередной элемент итерабельного объекта ~arguments~^^

___________________________

### ![ico-25 icon] continue | break

Цикл ~for ... of~ может быть прерван

Например, в результате выполнения кода

~~~js
var cities = [
  'Киев',
  'Львов',
  'Харьков',
  'Одесса',
  'Монреаль',
  'Копенгаген',
  'Вена',
  'Лондон'
]

for (var city of cities) {
  if (city === 'Копенгаген') continue
  console.log(city)
}
~~~

в консоль бедут выведены элементы

~~~js
Киев
Львов
Харьков
Одесса
Монреаль
Вена
Лондон
~~~

а в результате выполнения кода

~~~js
for (var city of cities) {
  if (city === 'Копенгаген') break
  console.log(city)
}
~~~

в консоль будет выведено

~~~js
Киев
Львов
Харьков
Одесса
Монреаль
~~~

Таким образом, с помощью оператора ~continue~ мы прерываем текущую итерацию цикла,

а с помощью оператора ~break~ прерываем выполнение цикла

_____________________

## ![ico-25 icon] for...in

А вот этот оператор как раз делает то, чего не делает оператор ~for...of~

Он итерирует объекты (_точнее, перечислимые свойства объектов_)

Давайте вернемся к примеру, который завершался ошибкой, но теперь вместо оператора ~for...of~  будем использовать оператор ~for...in~

### ![ico-25 cap] Пример

~~~js
var iteratedObject = {
  name: 'Begemot',
  animal: true,
  age: 3
}

for (var prop in iteratedObject) {
  console.log(prop)
}
~~~

В консоль будут выведены имена свойств объекта _name_, _animal_ и _age_

Если немного подправить код внутри цикла:

~~~js
for (var propName in iteratedObject) {
  console.log(iteratedObject[propName])
}
~~~

то мы получим в консоли значения свойств объекта _iteratedObject_:

~~~js
Begemot, true, 3
~~~

Давайте выведем в консоль и имя свойства, и значение:

~~~js
for (var propName in iteratedObject) {
    console.log(propName, ' : ',  iteratedObject[propName])
}
~~~

Теперь в косоли будет:

~~~js
name  :  Begemot
animal  :  true
age  :  3
~~~

_____________________________

### ![ico-20 icon] for...in с массивами

Элементы массива - это просто перечислимые свойства, имена которых являются целыми числами, а в остальном они идентичны свойствам объекта

^^![ico-20 warn] Однако использование оператора цикла ~for...in~  на массивах не рекомендуется, поскольку нет гарантии, что оператор вернет индексы в нужном порядке^^

### ![ico-25 cap] Пример 1

~~~js
var iteratedArray = [7, 8, 9]

for (var index in iteratedArray) {
  console.log(index, ' : ', iteratedArray[index])
}
~~~

**в консоли:**

~~~js
0  :  7
1  :  8
2  :  9
~~~

__________________________

### ![ico-20 icon] for...in со строками

~~~js
iteratedString = 'Котенок'
for (var index in iteratedString) {
  console.log(index, ' : ', iteratedString[index])
}
~~~

**в консоли:**

~~~js
0  :  К
1  :  о
2  :  т
3  :  е
4  :  н
5  :  о
6  :  к
~~~

![ico-20 warn] При переборе свойств объекта с помощью оператора ~for ... in~ имена свойств не обязательно будут перечислены именно в том порядке, в котором заданы

^^По соглашению, если имя свойства – строка, то такие свойства всегда перебираются в том же порядке, в каком присваивались^^
^^Если имя свойства – число, то браузеры сортируют такие свойства в целях внутренней оптимизации^^

_____________________________________________

### ![ico-25 cap] Пример 2

~~~js
var article = {
  title: 'Canvas',
  text: 'We will also look into how image smoothing',
  likes: 0
}

for (var prop in article) {
  console.log(article[prop])
}
~~~

^^В консоль будет выведено сначала значение свойства _title_,^^
^^затем - значение свойства _text_,^^
^^затем - значение свойства _likes_^^

_______________________________

### ![ico-25 cap] Пример 3

~~~js
var obj = {
  11: 'Canvas',
  2: 'Now we haven't looked at the actual pixels of our canvas',
  1: false
}

for (var prop in obj) {
  console.log(obj[prop])
}
~~~

В консоль будет выведено:

~~~js
false

Now we haven't looked at the actual pixels of our canvas

Canvas
~~~

_________________________________

### ![ico-25 cap] continue

Посмотрим, как действует оператор ~continue~ с циклом ~for...in~

~~~js
var obj = {
  '11': 'Canvas',
  '01': 'How to save images from your canvas',
  '05': false
}

for (var prop in obj) {
  if (prop == 1) continue
  console.log(prop)
}
~~~

В консоль будет выведено

~~~js
11
05
~~~

~continue~ прерывают только текущую итерацию цикла

__________________________

### ![ico-25 cap] break

При использовании же оператора ~break~

~~~js
for (var prop in obj) {
  if (prop == 1) break
  console.log(prop)
}
~~~

в консоли будет только ~11~

т.е. ~break~ прерывает выполнение цикла, как только доходит до ~prop == 1~ (а это "01")

---------------------------------

## ![ico-25 icon] for...of vs for...in

Давайте дальше поиграем с массивом

~~~js
var cities = [
  'Киев',
  'Львов',
  'Харьков',
  'Одесса',
  'Монреаль',
  'Копенгаген',
  'Вена',
  'Лондон'
]
~~~

Это массив, он итерабелен, и мы можем перебирать его элементы с помощью оператора ~for...of~  так же успешно, как и с помощью оператора  ~for...in~

Так в чем же разница?

Вспомним, что у любого массива есть свойство ~length~...

А раз есть свойство, значит, это вроде как ... объект?

Давайте проделаем такой трюк: добавим массиву **cities** свойство **_whereYouLive_**

Добавить свойство проще простого - используем обычный оператор присваивания:

~~~js
cities.whereYouLive = 'Париж'
~~~

Выведем массив **cities** в консоль

~~~js
console.log(cities)
~~~

и увидим:

~~~js
▼ (8) ['Киев', 'Львов', 'Харьков', 'Одесса', 'Монреаль', 'Копенгаген', 'Вена', 'Лондон', whereYouLive: 'Париж']
    0: 'Киев'
    1: 'Львов'
    2: 'Харьков'
    3: 'Одесса'
    4: 'Монреаль'
    5: 'Копенгаген'
    6: 'Вена'
    7: 'Лондон'
    whereYouLive: 'Париж'
    length: 8
  ► __proto__: Array(0)
~~~

Теперь посмотрим, как будут вести себя операторы ~for...of~ и ~for...in~

**Начнем с оператора ~for...of~**

~~~js
for (var city of cities) {
  console.log(city)
}
~~~

**в консоли:**

~~~console
Киев
Львов
Харьков
Одесса
Монреаль
Копенгаген
Вена
Лондон
~~~

**Теперь используем оператор ~for ... in~**

~~~js
for (var index in cities) {
  console.log(index)
}
~~~

**в консоли:**

~~~console
0
1
2
3
4
5
6
7
whereYouLive
~~~

Свойство  _~cities.length~_  по-прежнему выдает нам  8

Т.е. по индексу элемента мы можем получить только один из элементов

"Киев", "Львов", "Харьков", "Одесса", "Монреаль", "Копенгаген", "Вена", "Лондон"...

А как же теперь добраться до _~whereYouLive~_ ?

Нам нужно указать не индекс элемента, а имя, под которым мы "внесли" этот элемент в массив _cities_:

~~~js
cities['whereYouLive']
~~~

вернет нам "Париж"

________________

[![ico-30 hw] **Тесты**](https://garevna.github.io/js-quiz/#for-in-for-of)
