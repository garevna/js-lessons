# ![ico-30 icon] Event Loop

## ![ico-25 icon] Основні поняття

![ico-20 pin] **Процес** — це екземпляр виконуваної програми, на який виділяються системні ресурси (процесорний час і пам'ять).

![ico-20 pin] **Потік** (thread) – це послідовність команд (операторів мови, викликів функцій тощо), які виконуються послідовно одна за одною.

Кілька потоків можуть існувати в межах одного процесу і спільно використовувати ресурси (пам'ять).

^^^[Процес і потік]
^^![ico-20 warn] Кожен процес виконується в окремому адресному просторі.^^
^^![ico-20 warn] Один процес не може отримати доступ до даних іншого процесу.^^
^^![ico-20 warn] Кожна програма створює щонайменше один основний потік, який запускає функцію **~main()~**.^^
^^![ico-20 warn] Програма, що використовує тільки основний потік, є **_однопотоковою_**.^^

^^Багатопотокові мови використовують кілька потоків.^^

^^У багатопроцесорних (багатоядерних) системах кожен процесор (ядро) обслуговує окремий потік, тому потоки дійсно виконуються паралельно (одночасно).^^

^^За наявності лише одного процесора йому доводиться доволі часто перемикатися з одного потоку на інший, щоб створити ілюзію одночасного виконання коду в усіх потоках.^^

^^^

**Стек** — це «швидкий» шматок оперативної пам'яті.

^^^[Stack]
^^Стек створюється для кожного потоку в багатопотокових мовах.^^
^^Стек організований за принципом LIFO (останнім прийшов - першим пішов).^^
^^Розмір стека обмежений.^^
^^Він задається під час створення потоку.^^
^^Змінні, що знаходяться в стеку, завжди є локальними (**приватними**).^^
^^^

**Heap** ("купа") — це оперативна пам'ять, в якій зберігаються глобальні змінні.

^^^[Heap]
^^«Купа» допускає динамічне виділення пам'яті.^^
^^Доступ до даних, що зберігаються в «купі», забезпечується за допомогою посилань - змінних, значення яких є адресами інших змінних.^^
^^Тому «купа» працює повільніше, ніж стек.^^
^^Процесор не контролює «купу» (на відміну від стека), тому для звільнення пам'яті «купи» від непотрібних змінних потрібні «збирачі сміття».^^
^^^

![ico-25 warn] JS є однопотоковою мовою, тому у нас є лише один стек (**~Call Stack~**).

____________________________________

## ![ico-25 icon] Асинхронність

☼☼☼ Асинхронщина - це панування подій ☼☼☼

Однією з головних властивостей подій є те, що час їх настання непередбачувано.
Те, що неможливо передбачити, неможливо синхронізувати.

Ми не знаємо заздалегідь, коли користувач клацне на кнопці, і чи клацне взагалі.
Відправляючи запит на сервер, ми не можемо передбачити, скільки мілісекунд нам знадобиться, щоб отримати відповідь від сервера.

Друга властивість більшості подій - результат події недетермінований.

@@@@
Ми не можемо з упевненістю передбачити, чи буде статус відповіді сервера успішним, чи сервер поверне нам код http-помилки.
![](illustrations/async-fynny-02.gif)
@@@@

Якщо ми не можемо керувати подіями, ми можемо дозволити подіям керувати нашим кодом.

## ![ico-25 icon] Event-Driven Programming

Асинхронне програмування полягає у прив'язці функцій до конкретних подій.
Це так зване подієво-орієнтоване прораммування (**Event-Driven Programming**).

Зрозуміло, в середовищі (платформі), де буде запускатися ваш додаток, повинен бути механізм, що забезпечує реакцію на події.
Тобто такий механізм повинен забезпечити ваш додаток певним **Event API** (<b>A</b>pplication <b>P</b>rogramme <b>I</b>nterface), сервіси якого дозволять прив'язати ваші функції до певних подій.
Цей же механізм повинен забезпечити запуск виконання ваших функцій при настанні відповідної події.

У браузері такий механізм є і називається він **Event Loop**.

**_Event Loop_** - це нескінченний цикл виконання завдань.

[%%%MDN%%%](external/mdn-event-loop)

________________________________________

## ![ico-25 icon] Callback

![ico-20 warn] **У JS виконуються лише функції**.
Для виконання скрипту спочатку потрібно створити контекст виконання, який буде поміщений у **стек викликів**.
Тому він і називається **стек викликів** (**Call Stack**).
А що можна викликати? - тільки **функцію**.

@@@@ 1
![](illustrations/event-loop-01.png)
@@@@

Є два способи викликати функцію: це **прямий виклик** та **зворотний виклик**.

**Прямий виклик** - коли функцію викликають на ім'я з того скрипта, який виконується в даний момент.

Виконується - значить, якийсь скрипт уже "сидить" у **Call Stack**.
Він може зробити прямий виклик будь-якої іншої функції.
Але як він сам потрапив до **Call Stack**?

![ico-20 yes] Першим у Call Stack завжди потрапляє **callback** - _функція зворотного виклику_.

**Callback** - це функція, прив'язана до події, яка потрапить у стек викликів через механізм **Event Loop**.

@@@@ 1
![](illustrations/event-loop-script.png)
@@@@

^^Тут скрипт сніппета був "загорнутий" в якусь функцію **~anonimous~**, прив'язаний до події "запустити скрипт ~anonimous~", після чого ця подія була ініційована.^^
^^В результаті скрипт **~anonimous~** "окупував" **Call Stack** і почав виконуватися.^^
^^Функція **~anonimous~** стала колбеком і пройшла через **Event Loop**.^^
^^Тепер **~anonimous~** із стека викликів може здійснювати прямий виклик інших функцій.^^
----------------------------
@@@@ 1
![](illustrations/event-loop-02.png)
@@@@

^^Функція **~parent~** була викликана зі скрипту **~anonimous~**. Це **прямий виклик**.^^
----------------------------
@@@@ 1
![](illustrations/event-loop-03.png)
@@@@

^^Функція **~demo~** була викликана зі скрипту **~parent~**. Це **прямий виклик**.^^

^^Як бачимо, всі вони одночасно " сидять " у стеку викликів.^^
^^Зверху завжди знаходиться функція, яка виконується зараз.^^
^^Функція **~parent~** та функція **~demo~** потрапили у стік викликів на безпосереднє "запрошення".^^
_________________________________________________

Але ми маємо ще одну - анонімну - функцію, яку ми призначили обробником події **~click~** елемента ~document.body~.
Ця функція є **функцією зворотного виклику** (**callback**).
Зауважимо, що колбеку ім'я не потрібне. Зазвичай це анонімна функція.
**Callback** прив'язаний до події.
Його може запустити лише механізм **Event Loop**.
Якщо ця подія відбудеться, то **~callback~** отримає шанс потрапити до стеку викликів.
Однак тут доведеться постояти в черзі, тому що подій багато, і коллбеки, пов'язані з ними, утворюють чергу завдань (**task queue**).

@@@@ 1
![](illustrations/event-loop-04.png)
@@@@

Отже, ми бачимо, що першим у **Call Stack** завжди потрапляє **~callback~**.
І, перебуваючи в стеку викликів, він може викликати інші функції.
І кожна функція, що викликана ним, буде одночасно з ним стеку викликів.

@@@@ 1
![](illustrations/event-loop-05.png)
@@@@

Ця функція може викликати іншу функцію, контекст виконання якої також з'явиться у стеку викликів.
Так вони там утворюватимуть "шаровий пиріг".
Функція викликана останньою буде в стеку викликів зверху.
Вона ж перша покине **Call Stack**.

@@@@ 1
![](illustrations/event-loop-06.png)
@@@@

Останнім залишить стек викликів колбек, який і породив усю цю піраміду.
Зверніть увагу, що кожен колбек займає наш єдиний **Call Stack** до того часу, поки весь його код не буде виконаний до останнього рядка.
Він може викликати скільки завгодно функцій, які можуть викликати функції.
Поки вся ця бригада не залишить **Call Stack**, у черзі завдань будуть нудитися інші колбеки.

Отже, різниця між двома способами для функції потрапити у стек викликів:

| **Прямий виклик** | **Зворотній виклик** |
| Функцію буде запущено на виконання негайно | Колбек потрапить у чергу завдань |
| Її контекст виконання буде в стеку викликів одночасно з контекстом виконання скрипту, що викликав її | Контекст виконання потрапить у стек викликів, коли той звільниться |

_____________________

@@@@
![](images/funcs-rule.svg)
Як бачимо, не тільки модель успадкування, а й асинхронщина в JS тримається на функціях (конструкторах).<br><br>У прототипній моделі успадкування керують функції-**конструктори**, а в асинхронщині – функції-**колбеки**.
@@@@

☼☼☼ У JS функції реально рулять! ☼☼☼

___________________________________________

## ![ico-25 icon] Event API

@@@@ 3
Зі зрозумілих причин двигун JS не відстежує події.<br><br>Це робить браузер.
![](illustrations/js-engine.png)
^^Браузер - посередник між операційної системою і двигуном, відстежує події клавіатури, миші, системний годинник та ін.^^
@@@@

Браузер може надсилати запити до мережі та отримувати відповіді.

@@@@
Як "посередник", браузер пропонує програмний інтерфейс (**API**), який забезпечує JS-додатку доступ до потужних можливостей браузера.<br><br>У браузері є API для роботи з подіями, і його можна назвати **Event API**.
![](illustrations/web-api.png)
@@@@

Цей термін охоплює різні інтерфейси та методи, які дозволяють працювати з подіями у веб-додатках (найпоширеніші назви: **Event Handling API** или **Event Listener API**).

Найпростіший приклад браузерного API – метод глобального об'єкта **~setTimeout~**.
З його допомогою ми передаємо браузеру callback і вказуємо, через скільки мілісекунд цей callback повинен потрапити в чергу завдань.
Далі двигун "умиває руки", тому що події відстежує браузер. Таймер встановлений, і браузер вчасно повідомить движку про те, що час минув.
Після закінчення часу callback таймера буде поміщений у чергу завдань.
Не факт, що він потрапить у стек викликів досить швидко.
У черзі завдань може бути багато колбеків, і колбеку таймера доведеться чекати на свою чергу.
З черги завдань двигун витягне цей колббек, коли настане його черга і стек викликів буде вільний.

◘◘![ico-20 cap] ** 1**◘◘
~~~js
const start = Date.now()
const timer = (time = 0) => setTimeout(() => console.log(Date.now() - start), time)
let counter = 0
do {
  timer(500)
} while (counter++ < 10000)
~~~

{{{event-loop-01.js}}}

Зауважте, що всі таймери були встановлені на 500 мілісекунд.
Однак велика кількість колбеків таймерів у черзі завдань призвела до того, що зачіпка запуску чергового колбека зростала в міру просування черги завдань, і зрештою останній колбек увійшов у стек викликів не через 500 мілісекунд, а значно пізніше.

__________________________________________

## ![ico-25 icon] Блокуючі операції

![ico-20 warn] **"Тяжкі" таски блокують перемальовування сторінки браузером і роблять сторінку не інтерактивною, тобто. яка не реагує на дії користувача.**
"Тяжкий" таск - це callback, який надовго займе стек викликів і може серйозно затримати виконання інших завдань у черзі, які мали нещастя потрапити туди після нього.

@@@@
![](illustrations/event-loop-queue.png)
^^Це схоже на чергу до лікаря в тупій совковій системі.<br>У вас талон на 14:00, уже 15:25 і перед вами в черзі ще 5 осіб.<br>^^
^^Про що це говорить?<br>Про те, що код напиляно вкрай хреново.^^
^^<br>Так, совок був хреново напиляним кодом.^^
@@@@

Пишіть код так, щоб стек викликів не був зайнятий надовго.
Інакше ваша сторінка перестане реагувати на події, тому що колбеки не зможуть потрапити у стек викликів.

◘◘![ico-20 cap] ** 2**◘◘

~~~js
function message (text) {
  document.body.innerHTML += `<small>${text}</small><br>`
}

let start = new Date().getTime()

setTimeout(() => message(`Timer real time: ${new Date().getTime()-start} ms` ), 0)

for (var x = 0; x < 1000000000; x++) continue

message('Loop \'for\' finished')
~~~

У цьому прикладі таймер встановлено на затримку 0 сек.
Подивіться, що вийшло.

{{{Event-Loop-1.js}}}

__________________________________________________________

Оголосимо допоміжні функції **~createFigure~** та **~message~**:

◘◘![ico-20 cap] **createFigure**◘◘
~~~js
function createFigure () {
  const figure = section
    .appendChild(document.createElement('div'))
  return Object.assign(figure, {
    style: `
      position: absolute;
      top: 108px;
      left: 48px;
      width: 100px;
      height: 100px;
      border-radius: 4px;
      background: #fa0;
    `,
    move () {
      const { left } = figure.style
      Object.assign(figure.style, {
        left: parseInt(left) + 2 + 'px'
      })
      Date.now() - start < 5000 && requestAnimationFrame(figure.move)
    }
  })
}
~~~

◘◘![ico-20 cap] **message**◘◘
~~~js
function message (text) {
  document.body
    .appendChild(document.createElement('p'))
    .innerHTML = `${Date.now() - start}: ${text}`
}
~~~

щоб використовувати їх у наступних прикладах.

◘◘![ico-20 cap] ** 3**◘◘

~~~js
const start = Date.now()

const figure = createFigure()

message('Well, you\'re screwed, kid, now wait for the cycle to complete....')

figure.move()

setTimeout(function () {
  message('<b>Loop started</b>')
  for (var counter = 0; counter < 10000000000; counter++) continue
  message('<b>Loop finished</b>')
}, 0)
~~~

{{{Event-Loop-3.js}}}

Таск, запущений таймером, займає стек викликів і блокує навіть перемальовування сторінки та виведення повідомлень у консоль.

Зробіть висновок із цього прикладу, і тоді ви зрозумієте, чому ми не можемо створювати модальні вікна.
Браузер працює у багатопотоковому режимі, і кожен потік має свій стек викликів, тому для нього модальні вікна не проблема.
Але у нас лише один стек викликів.

____________________________________

Виправимо ситуацію:

◘◘![ico-20 cap] ** 4**◘◘
~~~js
const section = document.body

const start = Date.now()

const figure = createFigure()

figure.move()

const recurse = (counter => {
  message('<b>Loop started</b>')
  return function () {
    if (counter-- > 0) setTimeout(recurse)
    else message('<b>Loop finished</b>')
  }
})(1000)

recurse()
~~~

{{{Event-Loop-4.js}}}

Як бачите, цикл працює начебто "у фоновому режимі", не блокуючи перемальовку екрана та інші операції.
Однак "фоновий режим" у нас неможливий, оскільки JS – однопотоковий, з одним стеком викликів.
Тому ми імітуємо "багатопоточність" за допомогою Event Loop.

Пізніше ми познайомимося з асинхронними генераторами, які роблять щось подібне.
______________________________

## ![ico-25 icon] Microtask

☼☼☼ Мікротаски - це нахабні хлопці, які лізуть позачергово ☼☼☼

Колбеки таймерів та обробники подій UI – це таски (tasks).

Але ми маємо ще "магічні коробки з двома дірками" - проміси.
Метод **~then~** промісу теж приймає колбек.
І тут у циклі подій відбуваються такі дива:

◘◘![ico-20 cap] ** 5**◘◘
~~~js
const start = Date.now()

function message (text) {
  document.body.innerHTML += `<p>${Date.now() - start}: ${text}</p>`
}

const promise = text => new Promise(resolve => resolve(text))

message('Start')

setTimeout(message.bind(null, 'First macrotask'))
setTimeout(message.bind(null, 'Second macrotask'))
setTimeout(message.bind(null, 'Third macrotask'))

promise('First microtask').then(message)
promise('Second microtask').then(message)
promise('Third microtask').then(message)
~~~

{{{event-loop-microtask.js}}}

Колбеки таймерів потрапляють у **чергу завдань** раніше, ніж колбеки промісів (у таймерів не встановлений час, тобто за умоченням це 0).
То чому колбеки промісів потрапляють у **стек викликів** раніше?

![icp-25 yes] Тому що колбеки промісів - це **мікротаски**, і у них своя окрема черга.

Коли стек викликів звільняється, то движок переглядає спочатку чергу мікротасків.
Якщо там є колбеки, то вони будуть один за одним відправлятися в стек викликів, поки черга мікротасків не спорожніє.
Тільки тоді движок перейде до черги тасків.

Поки таски сидять і чекають своєї черги, щоб потрапити в Call Stack, спритні мікротаски проскакують туди у них під носом. ![ico-25 smile]

![](illustrations/event-loop-micro-task.gif)

________________________________________

Щойно ми запускаємо скрипт на виконання, ми стартуємо таск.

У наступному прикладі це виклик функції **~message~**, встановлення таймерів та обробника події ~click~ на _document.body_.

Крім того, ми запускаємо три асинхронні операції, використовуючи **Fetch API** браузера.

Ми знаємо, що метод **~fetch()~** повертає проміс.

Колбек, який передається методу **~then()~** промісу, є **мікро-таском**.

Таким чином, як тільки стек викликів звільниться, по черзі будуть виконані всі колбеки, які вже потрапили до черги мікротасків до цього моменту.
І лише потім виконуватимуться колбеки із **task queue**.

◘◘![ico-20 cap] ** 6**◘◘

~~~js
const start = Date.now()

function message (text) {
  document.body.innerHTML += `<p>${Date.now() - start}: ${text}</p>`
}

const timer = ms => setTimeout(() => setTimeout(message.bind(null, `timeout ${ms}`), 0), ms)

function getUser () {
  const since = Math.round(Math.random() * 20000)
  const index = Math.round(Math.random() * 30)
  return fetch(`https://api.github.com/users?since=${since}`)
    .then(response => response.json())
    .then(users => message(`github user ${since + index}: ${users[index].login}`))
}

message('start')

timer(1000)
timer(500)
timer(400)
timer(200)

getUser()
getUser()
getUser()
~~~

{{{Event-Loop-6.js}}}

У цьому прикладі, посилаючи **~fetch()~**-запит на сервер, ми отримуємо проміс, і передаємо методу **~then()~** цього промісу мікротаск, який отримує екземпляр конструктора **Response**, який потрібно розпарсити методом **~json()~**, щоб отримати вміст ~body~.
Метод **~json()~** знову повертає проміс, методу **~then()~** якого ми передаємо другий мікротаск, який вже отримає вміст відповіді сервера.
Таким чином, спочатку до черги мікротасків потрапить перший колбек, і тільки після того, як він «відпрацює», до черги мікротасків буде відправлено другий колбек.

Якби ми відправили методом **~setTimeout()~** тільки один колбек у чергу тасків, то всі колбеки таймерів потрапили б до стека викликів раніше, ніж останній мікротаск потрапив би до черги мікротасків.

Щоб «зрівняти шанси», колбек таймера знову встановлює таймер. Тоді в черзі тасків ситуація буде схожа з чергою мікротасків.

________________________________________________
