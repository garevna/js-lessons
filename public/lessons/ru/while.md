# ![ico-35 study] Циклы while и do...while

Очень часто число итераций цикла заранее неизвестно, и оно зависит от выполнения некоего условия.
Как в армейской поговорке, "копать от забора и до обеда".

Поэтому мы не можем использовать счетчик итераций, поскольку не можем установить ограничение на его значение.

В этом случае мы используем один из операторов цикла **~while~** или **~do...while~**.

## ![ico-30 icon] while

Синтаксически оператор **~while~** включает три обязательные части: само слово **~while~**, затем (через пробел) круглые скобки, в которых будет записано логическое выражение (условие цикла), и затем (через пробел) - тело цикла, заключенное в фигурные скобки:

~~~javascript
while (условие) {
  ...тело цикла
}
~~~

Что будет делать движок, столкнувшись с таким выражением?

1. Сначала он вычислит значение логического выражения в круглых скобках и приведет его к логическому типу.
2. Если условие выполнено (т.е. вычисленное значение будет ~true~), то выполняется код внутри фигурных скобок (очередная итерация цикла).
После чего движок вернется к пункту 1.

◘◘![ico-25 cap] ** 1**◘◘

~~~js
var n = 5

while (n < 5) {
  console.log(n)
}
~~~

^^Этот цикл не будет выполнен ни разу, поскольку условие ~n < 5~ не выполнено изначально, т.е. при вычислении выражения в круглых скобках будет получено значение ~false~.^^

◘◘![ico-25 cap] ** 2**◘◘

~~~js
var res = 0, n = 1

while (n) {
  n = prompt('Enter the number')
  res += (n - 0) || 0
}
~~~

^^Цикл будет суммировать введенные юзером числа до тех пор, пока в модальном окне ~prompt~ не будет нажата кнопка ~Cancel~.^^
^^Поскольку в модальном окне введенные значения будут строкового типа, мы приводим их к числу с помощью вычитания ~(n - 0)~.^^
^^Если в результате вычитания ~(n - 0)~ будет получено значение ~NaN~, то к переменной ~res~ будет добавлен 0.^^

В следующем примере мы воспользуемся функцией **~random~** библиотеки **~Math~**, которая генерирует псевдо-случайное число от 0 до 1:

◘◘![ico-25 cap] ** 3**◘◘

~~~js
var res = 0, n = 0

while (n < 0.5) {
  n = Math.random()
  res += n
}
~~~

Очевидно, что этот цикл не будет бесконечным, поскольку рано или поздно значение **~Math.random()~** окажется больше 0.5.

______________________

## ![ico-30 icon] do...while

Этот цикл сначала выполняет код в фигурных скобках, а потом проверяет выполнение условия.

~~~js
do {
  ...
} while (условие)
~~~

^^Цикл будет выполнен как минимум 1 раз, поскольку проверка истинности условия происходит после очередной итерации цикла.^^

Когда этот цикл предпочтительнее предыдущего?
Например, в таком случае:

◘◘![ico-25 cap] ** 4**◘◘

~~~js
do {
  var rand = Math.random()
  console.log(rand)
} while (rand < .5)
~~~

______________________________________________________

## ![ico-30 icon] Tests

◘◘![ico-25 hw]** 1**◘◘
~~~js
do {
  var rand = Math.random()
  if (rand > .5) break
} while (true)
~~~

→→→ Будет ли цикл бесконечным? | 'yes', 'no' | no→→→

◘◘![ico-25 hw]** 2**◘◘
~~~js
var num = 1

while (Math.random() < .5) {
  num *= (num + 1)
}
~~~

→→→ Будет ли цикл бесконечным? | 'yes', 'no' | no→→→

◘◘![ico-25 hw]** 3**◘◘
~~~js
var num = prompt('Enter the integer') - 0
var res = 0

while (true) {
  num >= 2 && res++
  num /= 2
  if (num < 2) {
    console.log(`2 ** ${res} = ${2 ** res}`)
    break
  }
}
~~~

→→→ Что будет в консоли, если в модальном окне ввести 8? | '', '2 ** 1 = 2', '2 ** 2 = 4', '2 ** 3 = 8', '2 ** 4 = 16' | 2 ** 3 = 8→→→

◘◘![ico-25 hw]** 4**◘◘
~~~js
var num = prompt('Enter the integer') - 0
var res = 1

while (true) {
  res *= num--
  if (num < 2) {
    console.log(`Factorial: ${res}`)
    break
  }
}
~~~

→→→ Что будет в консоли, если в модальном окне ввести 5? | 24, 0, 120, 20 | 120→→→

________________

[![ico-30 hw] **Quiz**](quiz/while)
