# ![ico-30 study] Приведение типов


## ![ico-25 icon] Неявное приведение типов

Неявное приведение типов происходит в процессе вычисления выражений

### ![ico-20 icon] Неявное приведение к string

При сложении числа и строки JavaScript обрабатывает число как строку

^^Например, после выполнения кода:^^

~~~js
var res = 20 + '5'
~~~

^^значением переменной **res** будет строка _"205"_^^

JavaScript вычисляет выражения слева направо

^^В результате выполнения кода:^^

~~~js
var res = 20 + 10 + '5'
~~~

^^в переменной ~res~ будет значение "305",^^

^^а в результате выполнения кода:^^

~~~js
var res = '3' + 20 + 10
~~~

^^в переменной ~res~ будет значение _"32010"_^^

![ico-20 warn] При сложении массива и любого другого операнда результат будет строкового типа ( ~string~ )

![ico-25 cap] ** 1**

~~~js
[] + 5             //  "5"
[] + false         //  "false"
[4] + NaN          //  "4NaN"
[4, 8] + null      //  "4,8null"
null + [4, 8]      //  "null4,8"
~~~

Это происходит потому, что массив преобразуется в строку:

~~~js
String([4, 8])
~~~

и результат будет   ~4,8~

![ico-20 warn] Однако, если в массиве не более одного элемента, и перед массивом стоит знак арифметической операции, он будет приведен к числу:

![ico-25 cap] ** 2**

~~~js
null + +[4]       // 4
+[5] + null         // 5
~~~

_____________________________________________________________________

### ![ico-20 icon] Неявное приведение к number


Неявное приведение к типу  ~number~ происходит в арифметических выражениях:

~~~js
var  x = '8' / 2
~~~

^^( значением переменной ~ x~ будет 4 )^^

![ico-20 warn] При участии в арифметических операциях пустая строка ( ~""~ ) и пустой массив ( ~[]~ ) преобразуется в ** 0**:

~~~js
var x = ''
var y = x / 5
~~~

^^( выражение  ~"" / 5~   будет приведено к   ~0 / 5~ )^^

~~~js
console.log(+'')         // 0
console.log(+[])         // 0
console.log(+[]+'')      // 0
~~~

![ico-20 warn] Если в арифметическом выражении участвуют специальные значения ~undefined~ или ~null~, то они преобразуются к числу так:

~~~js
Number(undefined)   // NaN
Number(null)        // 0
~~~

![ico-20 warn] Если в арифметическом выражении участвуют логические значения ~true~ или ~false~, то они преобразуются к числу так:

~~~js
var a = false
var b = true
var z = a + b    //  0 + 1 --> 1
~~~

![ico-20 warn] Кроме арифметических операций, преобразование к типу ~number~ происходит при участии переменной в операциях сравнения ( за исключением операций   ~===~  и  ~!==~,  когда сравниваются не только значения, но и типы данных )

____________________________________________________________

![ico-25 cap] ** 3**

~~~js
a = false, b = undefined
a > b       // 0 > NaN  --> false
a < b       // 0 < NaN  --> false
a == b      // 0 == NaN --> false
~~~

![ico-25 cap] ** 4**

~~~js
a = true,  b = null
a > b       // 1 > null   --> true ( 1 > 0 )
a < b       // 1 < null   --> false
a == b      // 1 == null  --> false
~~~

______________________________________________________

### ![ico-20 icon] Неявное приведение к boolean

Преобразование типов к логическому типу ( ~boolean~ ) происходит в условных операторах ( ~if~, тернарный оператор )

![ico-25 cap] ** 5**

~~~js
if ('5') console.log('Yes')
~~~

Будет вычисляться логическое значение выражения  в круглых скобках оператора ~if~, т.е. "под капотом" будет выполнена операция

~~~js
Boolean('5')
~~~

![ico-20 warn] При выполнении логических операций  ~&#10072;&#10072;~  и  ~&&~ происходит неявное приведение типов операндов к логическому значению, но при этом результатом логической операции будет изначальное значение одного из операндов, даже если оно не являются булевым

_______________________________________________

#### ![ico-20 icon] &&

^^^[Операция&nbsp;&&]

Операция ~&&~  перебирает операнды слева направо, приводя их к логическому значению, до тех пор, пока не встретится первый ~false~

в этом случае возвращается исходное значение последнего операнда

![ico-25 cap] ** 6**

~~~js
true && false && null   //  false
true && '5' && null     //  null
true && [] && null      //  null
~~~

![ico-25 cap] ** 7**

~~~js
true && ![] && null     //  false
~~~

^^вычисляется значение второго операнда ~![]~, оно будет ~false~, операция останавливается и возвращается последний операнд, на котором остановились )^^

~~~js
true && true && true && true     //    true
~~~

^^дошли до конца, но не встретили ~false~, возвращается последний операнд^^

^^^
__________________________________________________________________

#### ![ico-20 icon] ||

^^^[Операция ||]

Операция ~||~  перебирает операнды слева направо, приводя их к логическому значению, до тех пор, пока не встретится первый ~true~

в этом случае возвращается исходное значение последнего операнда, на котором остановились

![ico-25 cap] ** 8**

~~~js
null || false || 5 || ''          //   5
null || '' || 0 || 4 || 10        //   4
~~~

![ico-25 cap] ** 9**

~~~js
null || false || undefined || ''  //  ""
~~~

^^последовательно вычисляются логические значения^^

^^• первого операнда (~null~) - это ~false~,^^
^^• второго операнда - ~false~,^^
^^• третьего операнда (~undefined~) - это ~false~,^^
^^• четвертого операнда (~""~) - это ~false~^^

^^больше операндов нет, операция завершается и возвращает последний операнд, на котором остановилась ( ~""~ )^^

^^^

#### ![ico-20 icon] !!

^^^[Операция !!]

можно привести переменную любого типа к ~boolean~ с помощью логической операции двойного отрицания:

~~~js
var x = null
var y = !!x        // false
~~~

~~~js
var x = undefined
var y = !!x        // false
~~~

~~~js
!![ ]      // вернет   true
!!+[ ]     // вернет  false
~~~

^^^

{{{Implicit-type-conversion.js}}}

_____________________________

[![ico-30 hw] **Упражнения**](https://docs.google.com/forms/d/e/1FAIpQLSdFHuyyukF2rmA04BN1AmS5MCNXWgQmR5t7mmxyTpzdBZVGGw/viewform)

_____________________________________________________________________

[![ico-20 link] ^^w3schools^^](https://www.w3schools.com/jsref/jsref_infinity.asp)
[![ico-20 link] ^^Equality in JavaScript^^](https://dorey.github.io/JavaScript-Equality-Table/unified/)
