# ![ico-35 study] Переменные. Типы данных

Немного забегая вперед, введем понятие **глобального объекта**.
Глобальный объект - это та среда, в которой мы "живем" (функционируем) и за пределы которой мы выйти не можем.

@@@@
<br>На стороне клиента JS работает в браузере, в консоли которого, кстати, мы и выполняем все приведенные ниже операции.<br><br>Это возможно потому, что движок **V8**, встроенный в каждый браузер, интерпретирует наш код и выполняет его.
![](images/v8-logo.svg)
@@@@

Упрощенно говоря, глобальным объектом для нас является браузер (если точнее, то его объектная модель, но это мы будем разбирать позже).
Сам браузер функционирует в операционной системе и имеет доступ к ее возможностям.
Но мы не можем выйти за пределы браузера и взаимодействовать с операционной системой напрямую.

Итак, операционная система выделяет системные ресурсы, в частности - память, для работы приложений, в том числе браузера.
Браузер распоряжается выделенным ему ресурсом памяти, часть которого он выделяет движку **V8**.
Далее мы будем говорить о переменных, т.е именно о памяти, которую будет использовать наше приложение.

Для нашего кода доступ к глобальному объекту обеспечивается с помощью переменной **~window~**.

## ![ico-30 icon] Память и данные

Память представляет собой огромное количество ячеек, каждая из которых может содержать 0 или 1.

@@@@
Такая ячейка - это **бит** памяти.<br>Поэтому двоичная система исчисления стала базой для появления первых компьютеров.<br>Из **8 битов** получается **1 байт** памяти.
![](illustrations/vars-bit-and-byte.svg)
@@@@

В **1 байт** памяти можно поместить максимум 8 единиц, т.е. двоичное число 11111111.

В десятичной системе исчисления это будет число 255 без знака.
Если **байт** (8 бит) интерпретировать как знаковое число, то один бит будет содержать знак числа (**+ **или** -**), поэтому максимальное число со знаком, которое может "поместиться" в один байт, будет 127 (семь единиц).

••-1111111↓↓2 ↓↓ → -127↓↓10↓↓••

^^Любое число может быть представлено в двоичной системе исчисления набором нулей и единиц:^^

{{{vars-01.js}}}

^^Любое число можно разложить по степеням двойки + остаток (0 или 1).^^
^^Поскольку в двоичной системе двойка - это десятка, заменяем степени двойки на степени десятки, складываем и добавляем остаток.^^
^^Все достаточно просто.^^

{{{vars-binary.js}}}

Как вы уже догадались, компьютер может работать только с двоичными числами, т.е. с наборами нулей и единиц.
Логичный вопрос: как же в компьютере хранится текст, картинки и видео и т.п.

Любой оттенок представляется в виде нескольких чисел:

{{{vars-color.js}}}

Любой символ представляется его кодом (числом):

{{{vars-char.js}}}

Таким образом, любая информация представлена в памяти компьютера наборами нулей и единиц, и управление распределением памяти - очень сложный процесс.
Совершенно невероятно оперировать физическими адресами памяти для доступа к данным.
Это делает операционная система.
Вам не нужно знать физические адреса, по которым будут храниться ваши данные.
Для каждого элемента данных вам нужно придумать имя и сообщить движку, какой элемент данных вы будете хранить под этим именем.
Таким образом и создается **переменная**.
Итак, **переменные** облегчают вам манипуляции с данными и обеспечивают безопасность операционной системы и работающих приложений.
_________________________________________________________________

## ![ico-30 icon] var

Ваши данные (числа, строки и т.д.) будут храниться в памяти компьютера, пока работает ваше приложение, но вам не нужно знать точно, где именно движок хранит их.
Имена переменных - это удобная форма адресации, когда вам не нужно манипулировать физическими адресами памяти.
Вам достаточно указать движку имя переменной, и в дальнейшем вы сможете использовать это имя для получения доступа к данным.

Для объявления переменной используется ключевое слово **~var~**, за которым (через пробел) следует имя переменной.
Встретив такое объявление, движок резервирует определенный участок памяти компьтера и "привязывает" к указанному вами имени переменной адрес памяти, выделенной для ее хранения.
^^Обратите внимание, что в случае необходимости движок может переместить хранимое значение в другой участок памяти, при этом он автоматически изменит значение адреса, к которому привязано имя переменной, вы даже не узнаете об этом.^^

![ico-25 warn] Объявление переменной с помощью ключевого слова **~var~** помещает нашу переменную в глобальный объект **~window~**.
~~~js
var number
~~~
Что это означает для нас?
Что мы можем обратиться к значению этой переменной как напрямую по ее имени, так и опосредованно, через глобальный объект:

^^в точечной нотации:^^
••window.number••

^^или так:^^

••window['number']••

При объявлении переменной ей можно сразу присвоить начальное значение.

Для этого используется самый часто используемый **оператор языка** - оператор присваивания **~ =~**.

§§§§ Demo | var_01_template §§§§

В левой части оператора присваивания должно быть имя переменной, в правой - некое **выражение**.
Движок вычислит значение выражения в правой части оператора присваивания и поместит вычисленное значение в переменную, имя которой указано в левой части оператора.

~~~js
var number = 5 + 8 - 4
~~~

После выполнения этого кода в переменной **~number~** будет число 9.

Если в левой части оператора присваивания находится выражение, значение которого не является именем переменной:

~~~js
'user' + 'Name' = 9 + 8
~~~

то движок сгенерирует исключение:

~~~error
    Uncaught SyntaxError: Invalid left-hand side in assignment
~~~

Однако это не означает, что в левой части оператора присваивания не может быть выражения.

Рассмотрим пример.

^^^[![ico-25 coffee] 1]

Объявим переменную **~userName~** и присвоим ей значение 'Piter':

~~~js
var userName = 'Piter'
~~~

Наша переменная попала в глобальный объект **~window~**.
Поэтому мы имеем доступ к ней как к переменной **~window.userName~**.
Или как **~window['userName']~**.

Поэтому мы можем использовать в левой части оператора присваивания выражение, после вычисления которого движок получит ссылку на переменную:

~~~js
window['user' + 'Name'] = 'Helen'
~~~

Можете проверить самостоятельно, что значение переменной **~userName~** изменилось.

^^^

^^Когда мы дойдем до деструктуризации, вы увидите, какие еще выражения могут быть в левой части оператора присваивания.^^



![ico-25 warn] Если мы объявим переменные, но не присвоим им начальные значения:

~~~js
var x, y, z
~~~

то их значением будет **~undefined~** (не определено).

![ico-25 warn] Если мы не объявим переменную, но попытаемся обратиться к ней:

~~~js
console.log(sigma)
~~~

![ico-20 err] то в консоли появится сообщение об ошибке:

~~~error
    Uncaught ReferenceError: sigma is not defined
~~~

Можно объявить сразу несколько переменных в одной строке, разделяя их запятой:

~~~js
var person = 'Piter',  hobby = 'football',  age = 30
~~~

______________________________________________________________

## ![ico-30 icon] Имена переменных

![ico-25 warn] Имена переменных могут содержать буквы, цифры, символы подчеркивания и знаки доллара.

![ico-25 warn] Имена переменных могут начинаться с буквы, сиволов ~ $~ и ~ _~.

§§§§ Demo | var_02_template §§§§

Рекомендуется давать длинные и понятные имена переменных и функций, составленные из нескольких слов.
Это улучшает читабельность кода:

~~~js
var lastUserVisit = '2019-02-05'
~~~

![ico-25 warn] Имена переменных чувствительны к регистру (~name~ и ~Name~ - разные переменные).

§§§§ Demo | var_03_template §§§§

@@@@
![](illustrations/camel-case.png)
**Camel Case** - стиль написания имен переменных, состоящих из нескольких слов, когда каждое следующее слово начинается с литеры в верхнем регистре.<br><br>Первая литера, с которой начинается имя переменной, должно быть в нижнем регистре.
@@@@

^^С литеры в верхнем регистре принято начинать только имена конструкторов и классов, с которыми мы познакомимся позже.^^

^^На будущее: имена **функций** рекомендуется начинать с **глагола**, чтобы отличать их от имен переменных, в которых хранятся данные.^^

[![ico-25 warn] **_Зарезервированные слова_**](https://www.w3schools.com/js/js_reserved.asp ) не могут использоваться как имена переменных.

![ico-25 warn] Имена переменных не могут начинаться с цифры.

~~~js
var 14br = 10
~~~

~~~error
    Uncaught SyntaxError: Invalid or unexpected token
~~~

______________________________________________________________

## ![ico-30 icon] Типы данных

Как вы уже поняли, любые данные хранятся в памяти компьтера как набор нулей и единиц.
Для того, чтобы движок мог корректно интерпретировать этот набор нулей и единиц, он должен знать, что было сохранено по данному адресу: число, строка или что-то другое.

Предположим, по указанному адресу в памяти находится двоичное число:

••0100011001000111010010000100100101001011010011000100110101001110••

Его можно интерпретировать как десятичное целое число:

••5064095785634516000••

или как строку, каждый символ которой занимает 1 байт:

••FGHIKLMN••

Существует также масса других вариантов интепретации.

^^В переменных могут храниться числа, строки, логические значения, специфические значения **~null~** и **~undefined~**, а так же данные **ссылочного типа**, с которыми мы познакомися позже.^^

Итак, важно, чтобы движок знал тип данных, которые хранятся в переменной.

В отличие от языков со строгой типизацией, нам не нужно при объявлении переменной указывать тип данных, которые мы предполагаем хранить в этой переменной.

**Тип данных определяется в процессе присваивания значения.**
Это называется **динамической типизацией**.

______________________________________________________________

### ![ico-25 icon] String

Строка - это упорядоченный набор символов, которые заключаются в двойные (~"My name is Piter"~) или одинарные (~'My name is Piter'~) кавычки.

| ^^ 0^^ | ^^ 1^^ | ^^ 2^^ | ^^ 3^^ | ^^ 4^^ | ^^ 5^^ | ^^ 6^^ | ^^ 7^^ | ^^ 8^^ | ^^ 9^^ | ^^10^^ | ^^11^^ | ^^12^^ | ^^13^^ | ^^14^^ | ^^15^^ |
| ** M** | ** y** |        | ** n** | ** a** | ** m** | ** e** |        | ** i** | ** s** |        | ** P** | ** i** | ** t** | ** e** | ** r** |


Можно завернуть строку и в обратные кавычки **~ ` ~**, но обратные кавычки принято использовать для [►►►**темплейтных литералов**►►►](page/literals).

Если внутри строки встречаются двойные кавычки, то сама строка должна быть завернута в одинарные, и наоброт.

◘◘![ico-25 cap]◘◘

~~~js
var str = '"es2023" is a shorthand for "ECMAScript 2023 Language Specification".'
~~~
~~~js
var str = "'es2023, x' is a shorthand for 'ECMAScript 2023 Language Specification'."
~~~

Однако можно использовать экранирующий слеш **~&bsol;~**, чтобы дать понять движку, что это не закрывающая кавычка, а просто символ строки:

~~~js
str = '\'es2023, x\' is a shorthand for \'ECMAScript 2023 Language Specification\'.'
~~~

Каждый символ имеет свой числовой код.

Соответствие между символом и его кодом устанавливается в кодировочной таблице.

Самый широкий охват символов различных алфавитов представлен в кодировке **UTF-8** (Unicode Transformation Format, 8-bit).

Кодировка [%%% **UTF-8**%%%](https://blog.hubspot.com/website/what-is-utf-8 ) сейчас является доминирующей в веб.

_____________________________________

Поскольку строки - это упорядоченный набор символов, то число символов в строке определяет ее длину, логично?
Так что у строк есть свойство **~length~**, которое доступно нам следующим образом:

§§§§ Demo | var_string_length_template §§§§

Кстати, обратите внимание на следующее выражение:

~~~console
message + string
~~~

Здесь оператор **~ + ~** выступает в роли оператора **конкатенации строк**.
Это создает определенные неудобства, поскольку нам привычнее рассматривать его как **арифметический оператор** сложения.
^^Учитывая **динамическую типизацию**, такая двойственность оператора **~ + ~** может привести к неприятным побочным эффектам, которые мы рассмотрим в разделе "Приведение типов".^^
^^Позже мы познакомимся с **темплейтными литералами**, которые позволят нам избегать конкатенации строк.^^

______________________________________________________________

### ![ico-25 icon] Number

**тип данных: "number"**.

![ico-20 warn] Записывается без кавычек.

![ico-20 warn] Для отделения десятичных разрядов используется точка:

~~~js
var x = 53.25
~~~

Это самый проблемный тип данных в JavaScript.

Разберемся, в чем тут проблема.

К одному и тому же типу ~number~ относятся целые числа, десятичные числа (числа с плавающей точкой), числа в экспоненциальной форме (~5e+37~), а так же такие значения, как **~Infinity~** (бесконечность) и **~NaN~** (**Not a Number** - не число).

| целое число                    | ~15~                        |
| число с плавающей точкой       | ~5.80~                      |
| число в экспоненциальной форме | ~5e+37~                     |
| **~Infinity~**                 | бесконечность               |
| **~NaN~**                      | **Not a Number** - не число |

Существует ограничение на величину числа, что связано с выделением памяти на хранение данных типа **~number~**.

#### ![ico-20 icon] Целые числа

**Безопасное** целое число может содержать максимум 15 цифр:

{{{vars-number-1.js}}}

Обратите внимание, что после 20 цифр число автоматически представляется в экспоненциальной форме.

#### ![ico-20 icon] Экспоненциальная форма

Целые числа с большим количеством нулей (500000000000000) или очень маленькие числа с плавающей точкой (0.000000001) гораздо удобнее записывать в экспоненциальной форме.

Экспоненциальная форма записи числа имеет вид: **~1.8e+5~**, где символ **~e ~** разделяет мантиссу и порядок числа. В этом примере мантисса (содержательная часть числа) равна **~1.8~**, а **~5 ~**- это степень, в которую нужно возвести число **~10~**. Чтобы получить число в привычном для нас виде, нужно умножить мантиссу на число, получившееся в результате возведения в степень числа **~10~**:

••1.8 ✖ 10↑↑5 ↑↑••

В результате мы получим число **180000**.

••500 → 5e+2 (5 * 10↑↑2 ↑↑)••
••5000 → 5e+3 (5 * 10↑↑3 ↑↑)••
••50000 → 5e+4 (5 * 10↑↑4 ↑↑)••

••0.05 → 5e-2 (5 / 10↑↑2 ↑↑)••
••0.005 → 5e-3 (5 / 10↑↑3 ↑↑)••
••0.0005 → 5e-4 (5 / 10↑↑4 ↑↑)••

{{{vars-number-exponential-1.js}}}

Однако "под капотом" движок сам преобразовывает число к экспоненциальной форме для экономии памяти.

{{{vars-number-exponential-2.js}}}

_____________________________________

#### ![ico-20 icon] Infinity

![ico-20 warn] Значение **~Infinity~** может получиться при делении на ноль:

~~~js
var x = 1, y = 0
var z = x / y
~~~

^^Значением переменной **~z ~** будет  *~Infinity~*.^^

Вообще говоря, *~Infinity~* - это константа, имеющая определенное значение, что связано с ограничением объема памяти для хранения чисел.

{{{vars-number-infinity.js}}}

_____________________________________

#### ![ico-20 icon] NaN

![ico-20 warn] Значение **~NaN~** может получиться при попытке выполнения арифметических операций с операндами, которые не являются числами и не приводятся к числу, например:  ~5 * 'total'~, а так же при попытке разделить ноль на ноль: ~0/0~.

![ico-20 warn] Значение **~NaN~** не равно никакому другому значению, включая само значение **~NaN~**.

![ico-20 warn] Никакие арифметические операции в JS никогда не будут завершены с ошибкой, поскольку в случае ошибки операция вернет **~NaN~**.

__________________________________________________

#### ![ico-20 icon] Погрешность вычислений

А теперь поговорим о точности вычислений и округлении чисел.

{{{vars-number-4.js}}}

Итак, работа с числами у нас явно не в приоритете, и  если вы вдруг решите использовать **JS** как **Fortran**, то вам придется попариться с погрешностями вычислений.

_____________________________________

#### ![ico-20 icon] Тесты number

◘◘** 1**◘◘

→→→ 8e-2 | 800, 0.8, 0.08, 8 | 0.08 →→→

◘◘** 2**◘◘

→→→ 1.7e+2 | 170, 1.7, 0.17, 17 | 170 →→→

◘◘** 3**◘◘

→→→ 0.3e+310 | 3e+309, Infinity | Infinity →→→

◘◘** 4**◘◘

→→→ 3e-300 ✖ 1e+30 | 3e-900, Infinity, 0, 3e-270 | 3e-270 →→→

◘◘** 5**◘◘

→→→ 1e-5 + 2e-5 | 3e-5, 0.00003, 0.000030000000000000004, NaN | 0.000030000000000000004 →→→

◘◘** 6**◘◘

→→→ 0.003 + 0.0015 | 0.0045000000000000005, 0.0045, 45e-4, NaN | 0.0045000000000000005 →→→

◘◘** 7**◘◘

→→→ 5e+310 - Infinity | 0, Infinity, NaN | NaN →→→

◘◘** 8**◘◘

→→→ 0.005 + Infinity + NaN | 0.005, 0, Infinity, NaN | NaN →→→

◘◘** 9**◘◘

→→→ 5e+300 - Infinity | 5e+300, 0, -Infinity, NaN | -Infinity →→→

______________________________________________________________

### ![ico-20 icon] Boolean

Логический тип.

Принимает только два возможных значения:  **~true~**  или  **~false~**.

^^(без кавычек, '_true_' - это уже строка).^^

Данные этого типа автоматически получаются в результате сравнений:

~~~js
5 > 8
~~~
~~~console
false
~~~

~~~js
'a' < 'b'
~~~
~~~console
true
~~~

Заодно, кстати, мы познакомились с бинарными операторами сравнения ** >** и ** <**.
С помощью операторов сравнения создаются **логические выражения**.
Результатом вычисления значения **логического выражения** всегда будет **логическое значение** (**~true~**  или  **~false~**).

Т.е если мы объявим переменную **~bool~**:

~~~js
var bool = 5 > 8
~~~

то это будет переменная **логического типа** (**~boolean~**).

Далее мы будем часто сталкиваться с данными типа **~boolean~**.

______________________________________________________________

### ![ico-20 icon] undefined

**тип данных: "undefined"**.

Переменные иногда объявляются без присваивания им начального значения.

Если переменная объявлена без значения, ее значение будет **~undefined~**.

^^(без кавычек, _'undefined'_ - это уже строка).^^

______________________________________________________________

## ![ico-25 icon] Оператор typeof

^^Еще один оператор языка, с которым вы знакомитесь сегодня.^^
^^Первый, как вы помните, это **оператор присваивания**.^^
^^Далее мы познакомились с двумя **операторами сравнения**.^^

Операторы языка всегда имеют **операнды**.
Например, у оператора присваивания два операнда: один - слева, второй - справа.

![ico-20 warn] Операнды всегда отделяются от оператора пробелом.

В зависимости от числа операндов оператор может быть:

| оператор  | число операндов | пример |
| унарный   | 1               | **~typeof~** |
| бинарный  | 2               | **~ =~**, **~ >~**, **~ <~** |
| тернарный | 3               | этот оператор мы рассмотрим чуть позже |

Объявим переменную **~num~** и присвоим ей значение 10:

~~~js
var num = 10
~~~

А теперь воспользуемся оператором **~typeof~**, чтобы узнать тип данных переменной **~num~**:

~~~js
typeof num
~~~

В консоли мы увидим:

~~~console
'number'
~~~

Давайте разберемся, что делает движок, когда встречает выражение ~**typeof** num~.
Движок вычисляет значение этого выражения и заменяет выражение ~**typeof** num~ на вычисленное значение.

Посмотрим еще один пример:

~~~js
var companyName = 'Google'

typeof companyName
~~~

~~~console
'string'
~~~

![ico-25 warn] Оператор **~typeof~** возвращает **строку**.

Что это означает?

~~~js
var boolean = false

typeof boolean
~~~

~~~console
'boolean'
~~~

Это означает, что если движок столкнется с таким выражением (лишенным всякого смысла, кроме познавательного - для вас):

~~~js
typeof typeof boolean
~~~

то мы всегда получим один и тот же ответ:

~~~console
'string'
~~~

Возможные значения (строки), возвращаемые оператором **~typeof~**:

• ~string~
• ~number~
• ~bigint~
• ~boolean~
• ~object~
• ~undefined~
• ~function~
• ~symbol~

Как видите, в этом списке есть типы данных, которые мы пока не рассматривали и которые нам еще предстоит изучить.

__________________________________________________

### ![ico-20 icon] Тесты typeof

◘◘** 1**◘◘

→→→ typeof 2e-200 | 'number', 'string', 'boolean', 'undefined' | number →→→

◘◘** 2**◘◘

→→→ typeof NaN | 'number', 'string', 'boolean', 'undefined' | number →→→

◘◘** 3**◘◘

→→→ typeof 'Infinity' | 'number', 'string', 'boolean', 'undefined' | string →→→

◘◘** 4**◘◘

→→→ typeof 5 > 8 | 'number', 'string', 'boolean', 'undefined' | boolean →→→

◘◘** 5**◘◘

→→→ typeof undefined | 'number', 'string', 'boolean', 'undefined' | undefined →→→

__________________________________________________

## ![ico-25 icon] Спецификация ECMAScript

Современная [%%%спецификация языка%%%](https://tc39.es/ecma262/multipage/ecmascript-data-types-and-values.html ) определяет семь типов данных:

<span class="tab-2" />• **Undefined Type**
<span class="tab-2" />• **Null Type**
<span class="tab-2" />• **Boolean Type**
<span class="tab-2" />• **String Type**
<span class="tab-2" />• **Symbol Type**
<span class="tab-2" />• **Numeric Types**
<span class="tab-4" />• **Number Type**
<span class="tab-4" />• **BigInt Type**
<span class="tab-2" />• **Object Type**

Оператор **~typeof~** работает "по старинке", поскольку если бы принцип его работы был изменен, то многие сайты, созданные до 2015 года, просто посыпались бы.
Однако используя его, стоит помнить о его "несовершенстве".

При сравнении типов данных двух переменных учитывайте, что символы расположены в кодировочной таблице в алфавитном порядке, поэтому при сравнении большим будет тот,
который расположен дальше от начала таблицы.
