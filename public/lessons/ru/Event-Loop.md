# ![ico-30 icon] Event Loop

## ![ico-25 icon] Базовые понятия

![ico-20 pin] **Процесс** — это экземпляр исполняемой программы, которому выделены системные ресурсы (время процессора и память).

![ico-20 pin] **Поток** (thread) — это последовательность команд (операторов языка, вызовов функций и т.д.), которые выполняются последовательно друг за другом.

Несколько потоков могут существовать в рамках одного и того же процесса и совместно использовать ресурсы (память).

^^^[Процесс и поток]
^^![ico-20 warn] Каждый процесс выполняется в отдельном адресном пространстве.^^
^^![ico-20 warn] Один процесс не может получить доступ к данным другого процесса.^^
^^![ico-20 warn] Каждая программа создает по меньшей мере один основной поток, который запускает функцию **~main()~**.^^
^^![ico-20 warn] Программа, использующая только основной поток, является **_однопоточной_**.^^

^^Многопоточные языки используют несколько потоков.^^

^^В многопроцессорных (многоядерных) системах каждый процессор (ядро) обслуживает отдельный поток, поэтому потоки действительно выполняются параллельно (одновременно).^^

^^При наличии только одного процессора ему приходится довольно часто переключаться с одного потока на другой, чтобы создать иллюзию одновременного выполнения кода во всех потоках.^^

^^^

**Стек** — это "быстрый" кусок оперативной памяти.

^^^[Stack]
^^Стек создаётся _для каждого потока_ в многопоточных языках.^^
^^Стек организован по принципу LIFO (последним пришел - первым ушел).^^
^^Размер стека ограничен.^^
^^Он задаётся при создании потока.^^
^^Переменные, находящиеся в стеке, всегда являются _локальными_ (**приватными**).^^
^^^

**Heap** ("куча") — это оперативная память, где хранятся глобальные переменные.

^^^[Heap]
^^"Куча" допускает динамическое выделение памяти.^^

^^Доступ к данным, хранящимся в "куче", обеспечивается посредством ссылок - переменных, значения которых являются адресами других переменных.^^

^^Поэтому "куча" работает медленнее, чем стек.^^

^^Процессор не контролирует "кучу" (в отличие от стека), поэтому для освобождения памяти "кучи" от ненужных переменных требуются  "сборщики мусора".^^
^^^

![ico-25 warn] JS однопоточный язык, поэтому у нас только один стек (**~Call Stack~**).

____________________________________

## ![ico-25 icon] Асинхронщина

☼☼☼ Асинхронщина - это господство событий ☼☼☼

Одно из главных свойств событий - время их наступления непредсказуемо.

Что невозможно предсказать, то невозможно синхронизировать.

Мы не знаем заранее, когда пользователь кликнет на кнопке, и клинет ли вообще.
Посылая запрос на сервер, мы не можем предсказать, через сколько миллисекунд мы получим ответ сервера.

Второе свойство большинства событий - результат наступления события недетерминирован.

@@@@
Мы не можем с уверенностью предсказать, будет ли статус ответа сервера успешым, или же сервер вернет нам код http-ошибки.
![](illustrations/async-fynny-02.gif)
@@@@

Если мы не можем управлять событиями, то мы можем дать событиям управлять нашим кодом.

## ![ico-25 icon] Event-Driven Programming

Асинхронное программирование - это привязка функций к определенным событиям.
Это так называемое событийно-ориентированное прораммирование (**Event-Driven Programming**).

Понятное дело, что в той среде (платформе), где будет работать ваше приложение, должен быть механизм, который обеспечивает реакцию на события.
Т.е такой механизм должен предоставить вашему приложению некий **Event API** (<b>A</b>pplication <b>P</b>rogramme <b>I</b>nterface), сервисы которого позволят привязать ваши функции к определенным событиям.
Этот же механизм должен обеспечить запуск на исполнение ваших функций при наступлении соответствующего события.

В браузере такой механизм есть, и называется он **Event Loop**.

**_Event Loop_** - это бесконечный цикл выполнения задач.

[%%%MDN%%%](external/mdn-event-loop)

________________________________________

## ![ico-25 icon] Callback

![ico-20 warn] **В JS исполняются только функции**.
Для исполнения скрипта сначала нужно создать контекст выполнения, который будет помещен в **стек вызовов**.
Поэтому он и называется **стек вызовов** (**Call Stack**).
А что можно вызвать? - только **функцию**.

@@@@ 1
![](illustrations/event-loop-01.png)
@@@@

Есть два способа вызвать функцию: это **прямой вызов** и **обратный вызов**.

**Прямой вызов** - когда функцию вызывают по имени из того скрипта, который исполняется в данный момент.

Исполняется - значит, какой-то скрипт уже "сидит" в **Call Stack**.
Он может сделать прямой вызов любой другой функции.
Но как он сам попал в **Call Stack**?

![ico-20 yes] Первым в Call Stack всегда попадает **callback** - _функция обратного вызова_.

**Callback** - это функция, привязанная к событию, которая попадет в стек вызовов через механизм **Event Loop**.

@@@@ 1
![](illustrations/event-loop-script.png)
@@@@

^^Здесь скрипт сниппета был "завернут" в некую функцию **~anonimous~**, привязан к событию "запустить скрипт ~anonimous~", после чего это событие было инициировано.^^
^^В результате скрипт **~anonimous~** "оккупировал" Call Stack и начал исполняться.^^
^^Функция **~anonimous~** стала колбеком и прошла через **Event Loop**.^^
^^Теперь **~anonimous~** из стека вызовов может осуществлять **прямой вызов** других функций.^^
----------------------------
@@@@ 1
![](illustrations/event-loop-02.png)
@@@@

^^Функция **parent** была вызвана из скрипта **anonimous**. Это **прямой вызов**.^^
----------------------------
@@@@ 1
![](illustrations/event-loop-03.png)
@@@@

^^Функция **demo** была вызвана из скрипта **parent**. Это **прямой вызов**.^^

^^Как мы видим, все они одновременно "сидят" в стеке вызовов.^^
^^Сверху всегда находится функция, которая исполняется в данный момент.^^
^^Функция **parent** и функция **demo** попали в стек вызовов по непосредственному "приглашению" от скрипта **anonimous**.^^
_________________________________________________

Но у нас есть еще одна - анонимная - функция, которую мы назначили обработчиком события **~click~** элемента ~document.body~.
Эта функция по определению является функцией обратного вызова (**callback**).
Заметим, что колбеку имя не нужно. Обычно это анонимная функция.
Он привязан к событию.
Его может запустить на исполнение только механизм **Event Loop**.
Если это событие произойдет, то она получит шанс попасть в стек вызовов.
Однако тут придётся постоять в очереди, потому что событий много, и коллбеки, связанные с ними, образуют очередь задач (**task queue**).

@@@@ 1
![](illustrations/event-loop-04.png)
@@@@

Итак, мы видим, что первым в **Call Stack** всегда попадает колбек.
И, находясь в стеке вызовов, он может вызывать другие функции.
И каждая вызванная им функция будет одновременно с ним стеке вызовов.

@@@@ 1
![](illustrations/event-loop-05.png)
@@@@

Эта функция может вызвать другую функцию, контекст исполнения которой также появится в стеке вызовов.
Так они будут там образовывать "слоеный пирог".
Функция, вызванная последней, будет в стеке вызовов сверху.
Она же первая покинет **Call Stack**.

@@@@ 1
![](illustrations/event-loop-06.png)
@@@@

Последним покинет стек вызовов колбек, который и породил всю эту пирамиду.
Обратите внимание, что каждый колбек занимает наш единственный **Call Stack** до тех пор, пока весь его код не будет выполнен до последней строчки.
Он может вызывать сколько угодно функций, которые так же могут вызывать функции.
Пока вся эта бригада не покинет **Call Stack**, в очереди задач будут томиться другие колбеки.

Итак, разница между двумя способами для функции попасть в стек вызовов:

| **Прямой вызов** | **Обратный вызов** |
| Функция будет запущена на исполнение немедленно | Колбек попадет в очередь задач |
| Ее контекст исполнения будет в стеке вызовов одновременно с контекстом исполнения вызвавшего ее скрипта | Контекст исполнения попадет в стек вызовов, когда тот освободится |

_____________________

@@@@
![](images/funcs-rule.png)
Как мы видим, не только модель наследования, но и асинхронщина в JS держится на функциях (конструкторах).<br><br>В прототипной модели наследования рулят функции-конструкторы, а в асинхронщине - функции- колбеки.
@@@@

☼☼☼ В JS функции реально рулят! ☼☼☼

___________________________________________

## ![ico-25 icon] Event API

@@@@ 3
По понятным причинам движок JS не отслеживает события.<br><br>Это делает браузер.
![](illustrations/js-engine.png)
^^Браузер - посредник между операционкой и движком, отслеживает события клавиатуры, мыши, системные часы и т.д.^^
@@@@

Браузер может отправлять запросы в сеть и получать ответы.

@@@@
Как "посредник", браузер предлагает программный интерфейс (**API**), который обеспечивает JS-приложению доступ к мощным возможностям браузера.<br><br>В браузере есть API для работы с событиями, и его можно назвать **Event API**.
![](illustrations/web-api.png)
@@@@

 Этот термин охватывает различные интерфейсы и методы, которые позволяют работать с событиями в веб-приложениях (более распространенные названия: **Event Handling API** или **Event Listener API**).

Самый простой пример браузерного API - метод глобального объекта **~setTimeout~**.
С его помощью мы передаем браузеру коллбек и указываем, через сколько миллисекунд этот коллбек должен попасть в очередь задач.
Дальше движок "умывает руки", потому что события отслеживает браузер. Таймер установлен, и браузер своевременно сообщит движку о том, что время истекло.
По истечении времени коллбек таймера будет помещён в очередь задач.
Не факт, что он попадет в стек вызовов достаточно быстро.
В очереди задач может быть много колбеков, и колбеку таймера придется ждать своей очереди.
Из очереди задач движок вытянет этот коллбек, когда наступит его очередь и стек вызовов будет свободен.

◘◘![ico-20 cap] ** 1**◘◘
~~~js
const start = Date.now()
const timer = (time = 0) => setTimeout(() => console.log(Date.now() - start), time)
let counter = 0
do {
  timer(500)
} while (counter++ < 10000)
~~~

{{{event-loop-01.js}}}

Обратите внимание, что все таймеры были установлены на 500 милисекунд.
Однако большое число колбеков таймеров в очереди задач привело к тому, что задежка запуска очередного колбека возростала по мере продвижения очереди задач, и в конечном итоге последний колбек вошел в стек вызовов не через 500 милисекунд, а значительно позже.

__________________________________________

## ![ico-25 icon] Блокирующие операции

![ico-20 warn] **"Тяжелые" таски блокируют перерисовку страницы браузером и делают страницу не интерактивной, т.е. не реагирующей на действия пользователя.**
"Тяжелый" таск - это таск, который надолго займет колстек и может серьезно задержать выполнение других задач в очереди, которые имели несчастье попасть туда после него...

@@@@
![](illustrations/event-loop-queue.png)
^^Это похоже на очередь к врачу в тупой совковой системе.<br>У вас таллон на 14:00, уже 15:25 и перед вами в очереди еще 5 человек.<br>^^
^^О чем это говорит?<br>О том, что код напилен крайне хреново.^^
^^<br>Да, совок был хреново напиленным кодом.^^
@@@@

Пишите код так, чтобы стек вызовов не был занят надолго.
Иначе ваша страница перестанет реагировать на события, потому что коллбеки не смогут попасть в стек вызовов.

◘◘![ico-20 cap] ** 2**◘◘

~~~js
function message (text) {
  document.body.innerHTML += `<small>${text}</small><br>`
}

let start = new Date().getTime()

setTimeout(() => message(`Timer real time: ${new Date().getTime()-start} ms` ), 0)

for (var x = 0; x < 1000000000; x++) continue

message('Loop \'for\' finished')
~~~

В этом примере таймер был установлен на задержку 0 сек.
Посмотрите, что получилось

{{{Event-Loop-1.js}}}

__________________________________________________________

Объявим вспомогательные функции **~createFigure~** и **~message~**:

◘◘![ico-20 cap] **createFigure**◘◘
~~~js
function createFigure () {
  const figure = section
    .appendChild(document.createElement('div'))
  return Object.assign(figure, {
    style: `
      position: absolute;
      top: 108px;
      left: 48px;
      width: 100px;
      height: 100px;
      border-radius: 4px;
      background: #fa0;
    `,
    move () {
      const { left } = figure.style
      Object.assign(figure.style, {
        left: parseInt(left) + 2 + 'px'
      })
      Date.now() - start < 5000 && requestAnimationFrame(figure.move)
    }
  })
}
~~~

◘◘![ico-20 cap] **message**◘◘
~~~js
function message (text) {
  document.body
    .appendChild(document.createElement('p'))
    .innerHTML = `${Date.now() - start}: ${text}`
}
~~~

чтобы использовать ее в следующих примерах.

◘◘![ico-20 cap] ** 3**◘◘

~~~js
const start = Date.now()

const figure = createFigure()

message('Well, you\'re screwed, kid, now wait for the cycle to complete....')

figure.move()

setTimeout(function () {
  message('<b>Loop started</b>')
  for (var counter = 0; counter < 10000000000; counter++) continue
  message('<b>Loop finished</b>')
}, 0)
~~~

{{{Event-Loop-3.js}}}

Таск, запущенный таймером, занимает стек вызовов и блокирует даже перерисовку страницы и вывод сообщений в консоль.

Сделайте вывод из этого примера, и тогда вы поймете, почему мы не можем создавать модальные окна.
Браузер работает в многопоточном режиме, и каждый поток имеет свой стек вызовов, поэтому для него модальные окна не проблема.
Но у нас всего один стек вызовов.

____________________________________

Исправим ситуацию:

◘◘![ico-20 cap] ** 4**◘◘
~~~js
const section = document.body

const start = Date.now()

const figure = createFigure()

figure.move()

const recurse = (counter => {
  message('<b>Loop started</b>')
  return function () {
    if (counter-- > 0) setTimeout(recurse)
    else message('<b>Loop finished</b>')
  }
})(1000)

recurse()
~~~

{{{Event-Loop-4.js}}}

Как видите, цикл работает как будто "в фоновом режиме", не блокируя перерисовку экрана и другие операции.
Однако "фоновый режим" у нас невозможен, поскольку JS - однопоточный, с одним стеком вызовов.
Поэтому мы имитируем "многопоточность" с помощью **Event Loop**.

Позже мы познакомимся с асинхронными генераторами, которые делают нечто подобное.
______________________________

## ![ico-25 icon] Microtask

☼☼☼ Мікротаски - це нахабні хлопці, які лізуть позачергово ☼☼☼

Колбеки таймеров и обработчики событий UI - это таски (tasks).

Но у нас есть еще "магические коробки с двумя дырками" - промисы.
Метод **~then~** промиса тоже принимает колбек.
И тут в цикле событий происходят вот такие чудеса:

◘◘![ico-20 cap] ** 5**◘◘
~~~js
const start = Date.now()

function message (text) {
  document.body.innerHTML += `<p>${Date.now() - start}: ${text}</p>`
}

const promise = text => new Promise(resolve => resolve(text))

message('Start')

setTimeout(message.bind(null, 'First macrotask'))
setTimeout(message.bind(null, 'Second macrotask'))
setTimeout(message.bind(null, 'Third macrotask'))

promise('First microtask').then(message)
promise('Second microtask').then(message)
promise('Third microtask').then(message)
~~~

{{{event-loop-microtask.js}}}

Колбеки таймеров попадают в очередь задач раноше, чем колбеки промисов (у таймеров не установлено время, т.е. по умочанию это 0).
Так почему колбеки промисов попадают в стек вызовов раньше?

Потому, что колбеки промисов - это **микротаски**, и у них своя отдельная очередь.

Когда стек вызовов освобождается, то движок просматривает сначала очередь микротасков.
Если там есть колбеки, то они будут один за одним отправляться в стек вызовов, пока очередь микротасков не опустеет.
Только тогда движок перейдет к очереди тасков.

Пока таски сидят в и ожидают своей очереди, чтобы попасть в Call Stack, шустрые микротаски проскакивают туда у них под носом ![ico-25 smile]

![](illustrations/event-loop-micro-task.gif)

☼☼☼ Микротаски - это нахальные ребята, которые лезут в Call Stack без очереди ☼☼☼

________________________________________

Как только мы запускаем скрипт на исполнение, мы стартуем таск.

В следующем примере это вызов функции **message**, установка таймеров и обработчика события ~click~ на _document.body_.

Кроме того, мы запускаем три асинхронных операции, используя **Fetch API** браузера.

Мы в курсе, что метод **~fetch()~** возвращает промис.

Колбэк, передаваемый методу **~then()~** промиса, является **микро-таском**.

А у микро-тасков своя очередь, которая имеет более высокий приоритет и обслуживается раньше, чем очередь тасков.
Таким образом, как только стек вызовов освободится, поочередно будут выполнены все колбеки, которые уже попали в очередь микротасков к этому моменту.
И только потом будут выполняться колбеки из очереди тасков.

◘◘![ico-20 cap] ** 6**◘◘

~~~js
const start = Date.now()

function message (text) {
  document.body.innerHTML += `<p>${Date.now() - start}: ${text}</p>`
}

const timer = ms => setTimeout(() => setTimeout(message.bind(null, `timeout ${ms}`), 0), ms)

function getUser () {
  const since = Math.round(Math.random() * 20000)
  const index = Math.round(Math.random() * 30)
  return fetch(`https://api.github.com/users?since=${since}`)
    .then(response => response.json())
    .then(users => message(`github user ${since + index}: ${users[index].login}`))
}

message('start')

timer(1000)
timer(500)
timer(400)
timer(200)

getUser()
getUser()
getUser()
~~~

{{{Event-Loop-6.js}}}

В этом примере, посылая **~fetch()~**-запрос на сервер, мы получаем промис, и передаем методу **~then()~** этого промиса микротаск, который получает экземпляр конструктора **Response**, который нужно распарсить методом **~json()~**, чтобы получить содержимое ~body~.
Метод **~json()~** опять возвращает промис, методу **~then()~** которого мы передаем второй микротаск, который уже получит содержимое ответа сервера.
Таким образом, сначала в очередь микротасков попадет первый колбек, и только после того, как он "отработает", в очередь микротасков будет отправлен второй колбек.

Если бы мы отправили методом **~setTimeout()~** только один колбек в очередь тасков, то все колбеки таймеров попали бы в стек вызовов раньше, чем последний микротаск попал бы в очередь микротасков.

Чтобы "уравнять шансы" тасков и микротасков, колбек таймера опять устанавливает таймер. Тогда в очереди тасков ситуация будет схожая с очередью микротасков.

________________________________________________
