# ![ico-30 study] String

Переменные строчного типа являются, по сути, структурой данных - это упорядоченный набор символов

Каждый символ в строке имеет порядковый номер (начиная с 0)

Каждый символ имеет числовой код

## ![ico-25 icon] Операции со строками

Можно получить символ строки по его порядковому номеру
(в этом строки подобны массиву):

~~~js
var message = 'We aRe the champions'

console.log(message[4])  // R
~~~

Переменные строчного типа можно объединять в одну строку с помощью операции ** + **

Это называется **_конкатенация_** строк

^^Например, в результате выполнения следующего кода:^^

~~~js
var  message = 'Привет', user = 'студент'

console.log(message + ', ' + user)
~~~

^^в консоли будет:^^ ••Привет, студент••


## ![ico-25 icon] Методы работы со строками

Тот факт, что переменные строчного типа не являются примитивами, доказывает не только наличие у них свойства ~length~, но также методы, которые они наследуют от своего конструктора **~String~**

### indexOf

Этот метод позволяет найти подстроку в строке.
Он вернет индекс элемента, с которого начинается подстрока в строке.
![ico-20 warn] Если указанная подстрока не будет найдена в текущей строке, то метод ~indexOf()~ вернет значение **-1**

^^^[indexOf()]

^^Например, после выполнения кода:^^

~~~js
console.log('My new book'.indexOf('new'))
~~~

^^в консоли будет 3 (нумерация символов в строке начинается с 0)^^

^^После выполнения кода:^^

~~~js
var mainString = 'Дела идут неплохо'
var pos = mainString.indexOf('идут')
console.log(pos)
~~~

^^в консоли будет 5^^

^^^

### slice

Этот метод извлекает часть строки и возвращает извлеченную часть.
Исходная строка не меняется.

Метод принимает 2 числовых параметра:
1. индекс символа в строке, с которого начинать извлечение подстроки
2. индекс символа в строке, до которого продолжать извлечение

![ico-20 warn] "до которого" означает, что этот символ не будет включен в извлекаемую подстроку.

^^^[slice()]

^^Например, в результате выполнения следующего кода:^^

~~~js
var name = 'Меня зовут Мария'.slice(11, 16)
console.log(name)
~~~

^^в консоли будет:^^   ••Мария••

|^^ 0 ^^|^^ 1 ^^|^^ 2 ^^|^^ 3 ^^|^^ 4 ^^|^^ 5 ^^|^^ 6 ^^|^^ 7 ^^|^^ 8 ^^|^^ 9 ^^|^^ 10 ^^|^^ 11 ^^|^^ 12 ^^|^^ 13 ^^|^^ 14 ^^|^^ 15 ^^|
| ^^ М ^^ | ^^ е ^^ | ^^ н ^^ | ^^ я ^^ | ^^   ^^ | ^^ з ^^ | ^^ о ^^ | ^^ в ^^ | ^^ у ^^ | ^^ т ^^ | ^^   ^^ | ^^ М ^^ | ^^ а ^^ | ^^ р ^^ | ^^ и ^^ | ^^ я ^^ |

^^Аналогичный результат мы получим в результате выполнения кода:^^

~~~js
var str = 'Меня зовут Мария'
var name = str.slice(11, str.length)
console.log(name)
~~~

где ~str.length~ - длина строки, которая на единицу больше индекса последнего символа в строке ( потому что нумерация символов начинается с нуля )

Таким образом, если мы хотим извлечь фрагмент строки с какой-то позиции и до самого конца, то этот вариант будет наиболее подходящим

Если методу передать в качестве параметров отрицательные числа, то отсчет будет вестись от конца строки

|^^-16^^|^^-15^^|^^-14^^|^^-13^^|^^-12^^|^^-11^^|^^-10^^|^^-9^^|^^-8^^|^^-7^^|^^-6^^|^^-5^^|^^-4^^|^^-3^^|^^-2^^|^^-1^^|
| ^^ М ^^ | ^^ е ^^ | ^^ н ^^ | ^^ я ^^ | ^^   ^^ | ^^ з ^^ | ^^ о ^^ | ^^ в ^^ | ^^ у ^^ | ^^ т ^^ | ^^   ^^ | ^^ М ^^ | ^^ а ^^ | ^^ р ^^ | ^^ и ^^ | ^^ я ^^ |
|^^ 0 ^^|^^ 1 ^^|^^ 2 ^^|^^ 3 ^^|^^ 4 ^^|^^ 5 ^^|^^ 6 ^^|^^ 7 ^^|^^ 8 ^^|^^ 9 ^^|^^ 10 ^^|^^ 11 ^^|^^ 12 ^^|^^ 13 ^^|^^ 14 ^^|^^ 15 ^^|

~~~js
str.slice(-11, -6)                  // вернет  "зовут"
str.slice(-str.length, str.length)  // вернет  "Меня зовут Мария"
str.slice(-11, str.length)          // вернет  "зовут Мария"
str.slice(-13, str.length)          // вернет  "я зовут Мария"
str.slice(-15, -1)                  // вернет  "еня зовут Мари"
str.slice(-16, -1)                  // вернет  "Меня зовут Мари"
str.slice(-16,  0)                  // вернет  "" ( пустую строку )
~~~

Можно опустить второй аргумент:

~~~js
str.slice(-str.length)   // вернет  "Меня зовут Мария" ( всю строку )
str.slice(5)             // вернет  "зовут Мария" ( до конца строки )
~~~

^^^

### substring

Извлекает подстроку из строки.
Исходная строка не меняется.
Этот метод похож на ~slice()~, но не допускает отрицательных значений аргументов.

^^^[substring()]

~~~js
'Хорошего дня'.substring(9, 15) // "дня"
~~~

Если не указывать второй параметр, извлекать будет до конца строки:

~~~js
'Хорошего дня'.substring(9)    // "дня"
~~~

^^^

### substr

Извлекает подстроку из строки.
Исходная строка не меняется.
Этот метод похож на ~slice()~, но второй аргумент указывает длину извлекаемой подстроки.

^^^[substr()]

![ico-25 cap] ** 1 **

~~~js
var str = 'Веселый денек был сегодня'
console.log(str.substr(8, 5))
~~~

^^в консоли будет:^^ ••денек••


![ico-25 cap] ** 2 **

~~~js
var str = 'Веселый денек был сегодня'
console.log(str.substr(0, 7))
~~~

^^в консоли будет:^^ ••Веселый••

^^^

### toLowerCase

Преобразует символы строки к нижнему регистру

^^^[toLowerCase()]

![ico-25 cap]

~~~js
var str = 'ВЕСЕЛЫЙ ДЕНЕК БЫЛ СЕГОДНЯ'
console.log(str.toLowerCase ())
~~~

^^в консоли будет:^^ ••веселый денек был сегодня••

^^^

### toUpperCase

Преобразует символы строки к верхнему регистру.

^^^[toUpperCase()]

![ico-25 cap]

~~~js
var str = 'веселый денек был сегодня'
console.log(str.toUpperCase())
~~~

^^в консоли будет:^^ ••ВЕСЕЛЫЙ ДЕНЕК БЫЛ СЕГОДНЯ••

^^^

### split

Разбивает строку на массив подстрок и возвращает массив.
Исходная строка не изменяется.
Аргументом является символ-разделитель, по которому будет происходить "расчленение" строки.
Если в качестве разделителя использовать пустую строку, то строка будет разбита на символы.


^^^[split()]

![ico-25 cap] ** 1 **

~~~js
var str = 'веселый денек был сегодня'
console.log(str.split('е'))
~~~

^^в консоли будет:^^ ••[ "в", "с", "лый д", "н", "к был с", "годня" ]••

_______________________

![ico-25 cap] ** 2 **

~~~js
var str = 'one &#124; two &#124; three &#124; four &#124; five &#124; six'
console.log(str.split(' &#124; '))
~~~

^^в консоли будет:^^ ••[ "one", "two", "three", "four", "five", "six" ]••

^^^

### trim

Удаляет пробелы в начале и в конце строки.

^^^[trim()]

![ico-25 cap]

~~~js
var str = '   54   '
console.log(str.length)         // 8
console.log(str.trim().length)  // 2
~~~

^^^

### charAt

Возвращает символ, находящийся в заданной аргументом позиции строки.

^^^[charAt()]

![ico-25 cap]

~~~js
var str = 'ХОРОШО'
console.log(str.charAt(4))   //  Ш
~~~

^^^

### charCodeAt

Возвращает код символа, находящегося в заданной аргументом позиции строки.

^^^[charCodeAt()]

![ico-25 cap] ** 1 **

~~~js
var str = 'ХОРОШО'
console.log(str.charCodeAt(4))   //  1064
~~~

![ico-25 cap] ** 2 **

~~~js
var str = '1234567'
console.log(str.charCodeAt(4))  //  53
~~~

^^^

### repeat

Возвращает новую сроку, содержащую заданное аргументом число копий исходной строки.

^^^[repeat()]

![ico-25 cap]

~~~js
var str = 'ХОРОШО! '
console.log(str.repeat(4))
~~~

^^в консоли будет:^^ ••ХОРОШО! ХОРОШО! ХОРОШО! ХОРОШО!••

^^^

### replace

Возвращает новую строку, в которой заданная подстрока заменена на новое значение.
Аргументы: заменяемая подстрока, подстрока-заменитель.

^^^[replace()]

![ico-25 cap]

~~~js
var str = 'Ты проиграл! '
console.log(str.replace('проиграл', 'победил'))
~~~

^^в консоли будет:^^ ••Ты победил!••

^^^

### padStart | padEnd

**^^ES8 (2017)^^**

Методы ~padStart()~ и ~padEnd()~ дополняют строку другой строкой до тех пор, пока результирующая строка не достигнет указанной длины.
Дополняющая строка будет повторяться необходимое число раз.
Первый аргумент - результирующая длина строки.
Второй аргумент - строка-заполнитель.
Если второй аргумент опущен, то заполнение происходит символом пробела.
~padStart~ дополняет строку слева.
~padEnd~  дополняет строку справа.

^^^[padStart & padEnd]

![ico-25 cap] ** 1 **

~~~js
'Google'.padStart(5)               //  "Google"
'Google'.padStart(10)              //  "    Google"
'Google'.padStart(10).padEnd(15)   //  "    Google     "
'Google'
  .padStart(10, '789')
  .padEnd(15, '45')                //  "7897Google45454"
~~~

![ico-25 cap] ** 2 **

~~~js
var cities = ['Naples', 'Washington', 'Geneva']

for (var city of cities) {
  console.log(`City: ${city.padEnd(16)} (${cities.indexOf(city)})`)
}
~~~

^^Результат в консоли:^^

~~~console
City: Naples           (0)
City: Washington       (1)
City: Geneva           (2)
~~~

^^^

___________________________________________________________________________

[![ico-30 hw] **Тесты**](quiz/stringMethods)

___________________________________________________________________________

[^^![ico-20 link] MDN^^](external/mdn-string)
[^^![ico-20 link] String Methods^^](external/w3-string-methods)
[^^![ico-20 link] String Reference^^](external/w3-string)
