# ![ico-30 study] Объект function

_______________________________________


**Функция является вызываемым _объектом_**
**Функция, связанная с объектом через свойство, называется _методом_**

^^![ico-25 file] ECMAScript® 2016 Language Specification^^

_______________________________________________

## ![ico-25 icon] Объект arguments

Функции JavaScript имеют встроенный объект **~arguments~**.
У него есть свойство **~length~**, как у массива.
Его элементы доступны по индексу, как и элементы массива.

![ico-20 warn] Однако это не массив.

^^Поэтому к нему нельзя применить методы работы с массивами (**~push~**, **~pop~** и т.д.)^^
^^Его можно преобразовать в обычный массив с помощью метода  **~Array.from~**^^

~~~js
function test () {
  var args = Array.from(arguments)
  ...
}
~~~

В объекте **~arguments~**  находятся все аргументы, переданные функции при ее вызове.
Они будут доступны по индексу строго в том порядке, в каком они были переданы функции при вызове.

◘◘![ico-25 cap] **Пример 1**◘◘

~~~js
function testArguments () {
  for (var i = 0; i < arguments.length; i++) {
    console.log(`[${ (i + ' ]').padEnd(10) } ${ arguments[i] }`)
  }
}

testArguments(27, false, 'Fill', [7, 4, 5], null)
~~~

______________________________________

### ![ico-20 icon] arguments.callee

У объекта **~arguments~** есть свойство **_~callee~_** - ссылка на выполняемую функцию (функцию-"хозяина" объекта  ~arguments~).

~~~js
function testArguments () {
  console.log(arguments.callee.name)
}

testArguments() // testArguments
~~~

^^^[Пример 2]

^^Объявим функцию  **~getArguments~**:^^

~~~js
function getArguments (param) {
  return param ? param : arguments.callee
}
~~~

^^которая, если ей был передан аргумент, возвращает значение этого аргумента, в противном случае возвращает ссылку на саму себя.^^

^^Теперь вызовем эту функцию с параметром и без:^^

~~~js
var x = getArguments()
var y = getArguments('Привет!')
~~~

^^результат вызова функции без аргументов мы поместили в переменную  **~ x ~**,^^
^^а результат вызова с аргументом "Привет!" мы поместили в переменную  **~ y ~**^^

^^Теперь выведем в консоль переменные **~ x ~** и **~ y ~**^^

^^в переменной **~ x ~** находится точная копия функции **~getArguments~**^^

^^а в переменной **~ y ~** - строка "Привет!"^^

^^Вызовем функцию **~ x ~**:^^

~~~js
x('До свидания!')
~~~

и получим строку 'До свидания!'

^^^

^^^[Пример 3]

![ico-25 cap] ** 3 **

^^Объявим функцию, которая "сама себя лечит", т.е. сама добавляет себе свойства и методы:^^

~~~js
function setProperty (prop, val) {
  arguments.callee[prop] = val
}
~~~

^^Теперь заставим ее создать себе парочку свойств:^^

~~~js
setProperty('isActive', false)
setProperty('value', 50)
~~~

^^Ну, и для пущей убедительности заставим ее создать себе метод:^^

~~~js
setProperty('method', function () {
  console.log('А еще я умею вышивать крестиком')
})
~~~

^^здесь мы передаем ей в качестве второго аргумента функцию^^

^^Теперь проверим, что эти свойства и метод появились у функции  **~setProperty~**^^

^^Выведем в консоль свойства **~isActive~** и **~value~**   функции  **~setProperty~**  и вызовем ее метод  **~method~**^^

^^^

^^^[Пример 4]

![ico-25 cap] ** 4 **

^^Создадим функцию, которая "накапливает" результаты собственных вычислений^^

^^Пусть это будет функция, вычисляющая факториал числа^^

~~~js
var factorial = function (num) {
  var res = 1, n = 1
  while (n <= num) res *= n++
}
~~~

^^"модифицируем" ее следующим образом:^^

~~~js
var factorial = function (num) {
  if (!arguments.callee.res) arguments.callee.res = []
  var res = 1, n = 1
  while (n <= num) res *= n++
  arguments.callee.res.push(res)
  return res
}
~~~

^^Вызовем ее с различными значениями аргумента и выведем в консоль значение свойства **~res~**:^^

~~~js
factorial(5)
factorial(5)

console.log(factorial.res)
~~~

^^Получим массив ~[120, 3628800]~^^

^^^

^^![ico-20 warn] Следующий пример лучше рассмотреть после изучения событий элементов DOM^^

^^^[Пример 5]

![ico-25 cap] ** 5 **

^^В этом примере создаются анонимные функции, которые обрабатывают событие **~click~**  кнопок^^

^^Каждая функция "накапливает" данные о времени клика на кнопке в массиве **~arguments.callee.res~**^^

~~~js
var buttons = []

for (var n = 0; n < 5; n++) {
  buttons[n] = document.body
    .appendChild(document.createElement('button'))
  buttons[n].innerText = n
  buttons[n].onclick = function (event) {
    if (!arguments.callee.res) arguments.callee.res = []
    arguments.callee.res.push(Math.round(event.timeStamp))
    console.log(arguments.callee.res)
  }
}
~~~

^^Модифицируем этот код:^^

~~~js
var buttons = []

for (var n = 0; n < 5; n++) {
  buttons[n] = document.body
    .appendChild(document.createElement('button'))
  buttons[n].innerText = 0
  buttons[n].style = 'padding: 8px 16px'
  buttons[n].onclick = function (event) {
    var func = arguments.callee
    if (!func.clicksTime) func.clicksTime = []
    func.clicksTime.push(Math.round(event.timeStamp))
    console.log(func.clicksTime)
    var len = func.clicksTime.length
    event.target.innerText = len
    func.res = len > 1
      ? func.clicksTime[len - 1] - func.clicksTime[len - 2]
      : 0
    console.info(`Интервал между последними кликами: ${func.res}`)
  }
}
~~~

^^Что теперь делает каждый обработчик клика на кнопке ?^^

^^^

_______________________________________________

## ![ico-25 icon] Вызываемый объект

В этом смысле функцию можно сравнить с ![ico-30 ambulance]
Как и ![ico-20 ambulance], функция может перемещаться от одного объекта к другому (откуда она вызвана).

При этом объекты, вызывающие функцию, являются **контекстом вызова**.

Сама функция должна иметь "инструменты" для выполнения своей задачи в контексте вызова.

Все эти инструменты, не относящиеся к контексту вызова, а находящиеся исключительно в распоряжении функции, относятся к **контексту исполнения**.

Итак, куда поедет ![ico-20 ambulance] - это **контекст вызова**.
Что находится внутри ![ico-20 ambulance] - это **контекст исполнения**.

^^^[Контекст исполнения]

![ico-30 ambulance]

| **свойства** ^^(переменные)^^ | **методы** ^^(функции)^^ |
| ^^комплект инструментов, медикаментов, перевязочных матералов, различные приборы (капельницы, дефибриллятор, аппарат искусственного дыхания и т.д.)^^ | ^^профессиональные навыки персонала машины скорой помощи (могут сделать укол, поставить капельницу, применить дефибриллятор, перенести больного на носилках и т.д.)^^ |

^^Все это функция ![ico-20 ambulance] возит с собой^^

^^^

^^^[Контекст вызова]

![ico-30 ambulance]

^^• конкретные условия (частный дом, квартира в многоэтажке, наличие или отсутствие лифта, водопровода и т.д.)^^
^^• конкретный больной с конкретными симптомами, возрастом, историей болезни, характером и т.д.^^

^^^

## ![ico-25 icon] Контекст вызова

Контекст вызова - это **объект**.

Обычно при вызове функции имя этого объекта стоит перед именем функции, и отделено от него точкой:

~~~js
patient.emergency()
~~~

Как правило, если имя объекта перед именем функции не указано, то контекстом вызова функции является глобальный объект **~window~**.

^^Исключение составляют функции, контекст вызова которых установлен с помощью метода ~bind()~.^^

![ico-20 warn] Отсюда следует, что все функции JS являются методами
Если объект ("хозяин" метода) не указан, подразумевается глобальный объект

_______________________________

^^^[Пример 6]

![ico-25 cap] ** 6 **

^^Объявим три функции:^^

~~~js
function first () {
  console.log('Function "first" is working now.')
}
function second () {
  console.log('Function "second" is working now.')
}
function third () {
  console.log('Function "third" is working now.')
}
~~~

^^Все три функции объявлены в глобальном контексте, то есть они являются методами глобального объекта **~window~**.^^

^^Как мы уже знаем, можно обращаться к свойствам объекта как к элементам ассициативного массива.^^

^^Тогда конструкция:^^

~~~js
window['first']
~~~

^^вернет нам функцию  **~first~**, которая является свойством (методом) глобального объекта **~window~**.^^

^^Для вызова этой функции не хватает только круглых скобок:^^

~~~js
window['first']()
~~~

^^Используя этот факт, мы можем вызывать функцию, имя которой нам передано в переменной типа "_string_":^^

~~~js
for (var funcName of ['first', 'second', 'third']) window[funcName]()
~~~

^^^

____________________________

### ![ico-20 icon] Ссылка на контекст вызова

При вызове бригады скорой помощи она получает ссылку на объект вызова.

Бригаде нужно знать, куда ехать, симптомы больного, возраст и т.д.

Точно так же функция должна иметь доступ к объекту, который ее вызывает, его свойствам, которые могут быть необходимы для нормальной работы функции.

Внутри функции ключевое слово  **~this~** является ссылкой на объект, в контексте которого вызвана функция (т.е. на контекст вызова).

![ico-25 cap] Например, для функции ![ico-20 ambulance]

^^![ico-20 green-ok] this.адрес^^
^^![ico-20 green-ok] this.этаж^^
^^![ico-20 green-ok] this.квартира^^
^^![ico-20 green-ok] this.больной.имя^^
^^![ico-20 green-ok] this.больной.возраст^^
^^![ico-20 green-ok] this.больной.симптомы^^
...

^^Если бы не  **~this~**, вряд ли функция могла бы помочь "больному" ![ico-20 smile].^^

_________________________________________

## ![ico-25 icon] Контекст исполнения

![ico-20 warn] Каждый вызов функции приводит к созданию нового контекста выполнения.

Создание контекста выполнения происходит до начала выполнения кода.

При каждом возврате (**~return~**) происходит выход из контекста выполнения.
Пока выполнение функции не завершено, ее контекст будет активным.
Поскольку функции могут вызывать друг друга, их контекст помещается в стек.
![](illustrations/function-object-01.png)
^^(очередь: последним пришел - первым ушел)^^
Верхним в этом стеке всегда будет текущий контекст исполнения.

![](illustrations/function-object-02.png)

Что же будет в этом контексте?

![ico-20 green-ok] LexicalEnvironment
![ico-20 green-ok] Цепочка областей видимости
![ico-20 green-ok] ~this~

_____________________________________________

### ![ico-20 icon] Lexical Environment

^^Когда происходит вызов функции, она активируется.^^
^^Ей нужно где-то безопасно "разместить" свои данные, с которыми она будет работать.^^
^^Кроме аргументов, которые она получит при вызове, у нее могут быть свои внутренние данные, которые нужны для временного хранения промежуточных результатов вычислений.^^

При вызове функции создается объект, содержащий все необходимые переменные.
Этот объект в спецификации языка называется **~LexicalEnvironment~.**

~Lexical Environment~ содержит аргументы функции и все объявленные внутри функции переменные (включая функции).

^^поэтому его еще называют _объектом переменных_ или _объектом активации_.^^

^^Таким образом, объект активации можно сравнить со шкафчиком для хранения "личных вещей" функции.^^

^^![ico-20 warn] Получить доступ к объекту активации невозможно.^^

______________________________________________

### ![ico-20 icon] hoisting

Итак, после вызова функции:

| ** 1** |   | **Формируется контекст исполнения**                      |
|        | • | ^^создается объект активации ( ~Lexical Environment~ )^^ |
|        | • | ^^определяется область видимости^^                       |
|        | • | ^^устанавливается значение **~this~**^^                  |
| ** 2** |   | **Код интерпретируется и выполняется**                   |

![ico-20 warn] Обратите внимание на тот факт, что объявления всех внутренних переменных и вложенных функций происходит раньше, чем код начинает выполняться, независимо от порядка их появления в коде.
![ico-20 warn] А вот присвоение переменным значений происходит, когда код начинает выполняться.
Это приводит к "поднятию" (**hoisting**) объявлений переменных и функций.

^^^[Пример 7]

![ico-25 cap] ** 7 **

~~~js
function delegat () {
  console.log(x)
  y = x + 5
  console.log(y)
  x = 5, y = 10

  return  x * 4 +  y / 2

  var x = 1, y = 1
}
~~~

^^Хотя объявление переменных  **_~ x~_** и **_~ y~_** стоит в коде после оператора ~return~, при формировании контекста исполнения на первом этапе будет формироваться объект активации (Lexical Environment), и все переменные, объявленные внутри функции, будут включены в этот объект.^^

^^Таким образом, объявление переменных **_~ x~_** и **_~ y~_** "поднимется" (произойдет до начала выполнения кода функции).^^

^^Но присваивание значений происходит уже на втором этапе, и код будет выполняться последовательно, то есть на момент исполнения кода.^^

~~~js
console.log(x)
~~~

^^значение переменной  **_~ x~_**  еще не будет определено, поэтому в консоли будет ~undefined~.^^

^^Аналогично, на момент выполнения кода^^

~~~js
y = x + 5
~~~

^^значение переменной  **_~ x~_**  будет  ~undefined~, поэтому результатом операции присваивания будет  **~NaN~**,  что и выдаст в консоль код.^^

~~~js
console.log(y)
~~~

^^После этого будет выполнен код^^

~~~js
x = 5, y = 10
~~~

^^Переменные **_~ x~_** и **_~ y~_** получат значения.^^

^^Поэтому функция вернет значение **25**.^^

^^Присваивание значений^^

~~~js
x = 1, y = 1
~~~

^^не произойдет, поскольку выход из контекста выполнения будет раньше этого кода.^^

^^^

^^^[Пример 8]

![ico-25 cap] ** 8**

~~~js
var treg = 5

function delegat () {
  treg = 10
  return

  function treg () {
    return
  }
}
delegat()
console.log(treg)  // 5
~~~

^^В этом случае объявление функции  **~treg~**  попадет в _Lexical Environment_ функции  **~delegat~** на этапе создания ее контекста выполнения, и не затронет переменную  **~treg~**,  объявленную в глобальном контексте.^^

^^Это будут разные переменные,  хотя идентификаторы у них совпадают.^^

^^Поэтому  в результате в консоли будет ** 5**.^^

^^^

________________________________

### ![ico-20 icon] Область видимости

Область видимости (**~scope~**) ограничивает действие идентификаторов переменных и функций.

^^^[scope]

^^Представьте себе двух человек по имени Саша: 👨‍💼 парня и 🙎 девушку^^

^^Есть две комнаты, ^^
^^и парень Саша  👨‍💼 находится в первой комнате, ^^
^^а девушка Саша 🙎 - во второй^^

^^В каждой комнате есть наблюдатель^^

^^Если мы спросим наблюдателя из первой комнаты: ^^
^^_"Кем является Саша?"_, ^^
^^то он ответит: _"Парень"_ 👨‍💼^^

^^Зададим аналогичный вопрос наблюдателю из второй комнаты, ^^
^^и получим ответ: _"Девушка"_ 🙎^^

^^Это происходит потому, что у каждой комнаты есть своя область видимости^^

_________________________________

^^Однако область видимости вложенных функций будет несколько иной^^

^^Предположим, что вложенные функции - коробки со стенками из тонированного стекла^^
^^Наши функции-коробки вложены одна в другую, как матрешки: ^^
^^вторая коробка находится внутри первой,^^
^^третья - внутри второй, и так далее...^^

^^Наблюдатель в коробке 2 будет видеть не только содержимое коробки 2, ^^
^^но и содержимое коробки 1 ^^
^^и комнаты, внутри которой находятся все коробки^^

^^но он не может увидеть содержимое коробки 3, ^^
^^хотя наблюдатель в коробке 3 его отлично видит... ^^
^^как и наблюдателей во всех остальных коробках ^^
^^и в комнате^^

____________________________

^^Таким образом, если внутри функции будет обращение к переменной, то сначала функция будет искать эту переменную в своем "шкафчике для личных вещей", и если не найдет, то не постесняется "позаимствовать" эту переменную из внешнего шкафчика, внутри которого она находится^^

___________________________

^^![ico-20 warn] Все доступные ей чужие "шкафчики" представляют собой ![ico-20 pin] **_цепочку областей видимости_** функции, которая является частью ее ![ico-20 pin] **контекста выполнения**.^^

^^^

^^^[Пример 9]

![ico-25 cap] ** 9**

~~~js
var sample = 1

function changeSample () {
  sample = 10
}

changeSample()
~~~

^^переменная **~sample~**   объявлена в глобальной области видимости, в которой  также объявлена функция **~changeSample~**.^^

^^При объявлении переменной **~sample~** присвоено значение 1.^^

^^Поскольку внутри функции **~changeSample~**  нет объявления переменной **~sample~**, то при формировании контекста выполнения функции **~changeSample~** эта переменная не попадает в объект активации ("шкафчик для личных вещей") функции **~changeSample~**.^^

^^Тогда при выполнении присваивания^^

~~~js
sample = 10
~~~

^^происходит следующее:^^

^^функция **~changeSample~**, не найдя такой переменной в собственном "шкафчике", обращается к внешнему "шкафчику", где такая переменная есть, ей-то и будет присвоено значение 10.^^

^^Таким образом, для каждого контекста выполнения существует своя  цепочка областей видимости.^^

^^Цепочка областей видимости включает области видимости всех предыдущих контекстов в стеке.^^

^^^

^^^[Пример 10]

![ico-25 cap] **10**

~~~js
var sample = 1

function showSample () {
  console.info('We are in the execution context of the function "showSample"')
  console.info(`sample === ${sample}`)

  return

  function sample () {}
}

showSample()

console.info('We left the execution context of the function "showSample"')
console.info(`Now sample === ${sample}`)
~~~

**Результат в консоли:**

~~~console
We are in the execution context of the function "showSample"
sample === function sample () {}
We left the execution context of the function "showSample"
Now sample === 1
~~~

^^В этом примере показано, как работает механизм **hoisting**.^^
^^Переменная **~sample~**  объявляется в глобальной области видимости с присвоением ей значения 1.^^
^^Внутри тела функции **~showSample~** после оператора return объявляется функция **~sample~**.^^
^^На первый взгляд, при последовательном выполнении кода это объявление не должно сработать, поскольку оператор ~return~ стоит выше.^^
^^Однако все объявления собираются в объект активации до того, как код начинает выполняться.^^
^^Поэтому на момент, когда начнется выполнение кода функции **~showSample~**, функция **~sample~** будет уже  объявлена и будет благополучно находиться в ~Lexical Environment~ функции **~showSample~**.^^
^^Благодаря этому объявления переменных и функций "поднимаются" в области видимости "родителя" (в нашем случае "родителем" является функция **~showSample~**).^^
^^Убедиться в этом позволяет вывод в консоль переменной **~sample~**.^^
^^После завершения выполнения кода функции **~showSample~** ее контекст будет "демонтирован", и опять активным станет глобальный контекст, в котором  переменная **~sample~**  имеет значение 1.^^

^^^

^^^[Пример 11]

![ico-25 cap] **11**

~~~js
var sample = 1

function showSample () {
  console.info('We are in the execution context of the function "showSample"')
  console.info(`(1) ${sample}`)
  sample()
  console.info(`(2) ${sample}`)
  sample = 10
  console.info(`(3) ${sample}`)

  return

  function sample () { sample = 5 }
}

showSample()

console.info(`(global) ${sample}`)
~~~

^^Здесь так же происходит поднятие объявления функции  **~sample()~**.^^
^^Но функция  **~sample()~**  переопределяет значение  переменной  **~sample~**.^^
^^В контексте выполнения функции  **~showSample~** на момент присваивания переменной **~sample~** значения 5 нет другой объявленной переменной **~sample~**, кроме самой функции  **~sample()~**.^^
^^Таким образом, до вызова функции  **~sample()~** в консоль будет выведена функция.^^
^^После вызова функции  **~sample()~** в консоль будет выведено новое значение (5) переменной **~sample~**.^^
^^После этого будет выполнено присваивание нового значения переменной **~sample~**  и вывод в консоль (10).^^
^^Когда функция **~showSample~** завершит работу, и ее контекст будет "демонтирован", станет активным глобальный контекст, в котором переменная **~sample~** имеет значение 1.^^

^^В этом примере функция **~sample()~** переопределила саму себя (была "function", стала "number").^^

^^^

____________________________________

### ![ico-20 icon] Цепочка областей видимости

Итак, функция может использовать какие-то переменные, которых нет в ее ~LexicalEnvironment~.

^^Они являются внешними, и находятся в другом контексте.^^
^^Но они доступны функции.^^
^^Функция "видит" их, поэтому они находятся в ее _области видимости_.^^

^^Когда внутри функции происходит обращение к переменной или функции, в первую очередь движок будет искать эту переменную в ~LexicalEnvironment~ функции, если ее там не окажется - то поиск будет продолжен по цепочке областей видимости.^^

^^Если переменная (или функция) не будет обнаружена, будет сгенерировано исключение ![ico-20 err] ~ReferenceError~.^^

_______________________________________

### ![ico-20 icon] this

**~this~** - это еще одна составляющая контекста исполнения функции.

**~this~** является ссылкой на контекст вызова функции.

![](images/reference-is-a-lockpick.svg)

С помощью ключевого слова  **~this~**  можно получить доступ из функции (или метода) к свойствам объекта, в контексте которого была вызвана функция.

_______________________________

![ico-25 cap] **12**

~~~js
function func () {
  console.log(this)
}
~~~

при вызове функции  **~func()~** в консоль будет выведен объект  ~window~.
Внутри  функции  **~func()~** ~this~ указывает на объект  ~window~.

________________________________

![ico-25 cap] **13**

~~~js
function func () {
  child()

  function child () {
    console.log('child this: ', this)
  }
}

func()  // window
~~~

___________________________________

![ico-25 cap] **14**

Если же функция является методом объекта, то ее контекстом вызова будет этот объект.

~~~js
var human = {
  name: 'Ivan',
  say: function () {
    console.log('this: ', this)
  }
}

human.say() // будет выведен объект  human
~~~

________________________________

![ico-25 cap] **15**

Теперь посмотрим на функцию как на объект.

~~~js
function say () {
  console.log('function say: this: ', this)
}

function girl () {
  console.log('function girl: this: ', this)
}
~~~

Добавим функции  **~girl~**  свойство  **~say~** и вызовем функцию ~girl~ и ее свойство ~say~:

~~~js
girl.say = say
girl.say()     //  girl
girl()         // window
~~~

________________________________________

## ![ico-25 icon] prototype

• Функцию как **_объект_** нельзя вывести с помощью метода ~console.log~
• Для этой цели следует использовать метод **~console.dir~**

~~~js
function sample () {}

console.dir(sample)
~~~

В консоли мы получим следующую картинку:
~~~console
▼ ƒ sample()
      arguments: null
      caller: null
      length: 0
      name: "sample"
    ▼ prototype:
        ▶ constructor: ƒ sample()
        ▶ __proto__: Object
    ▶ __proto__: ƒ ()
      [[FunctionLocation]]: VM476:1
    ▼ [[Scopes]]: Scopes[1]
        ▶ 0: Global {type: "global", name: "", object: Window}
~~~

![ico-25 warn] Обратите внимание на свойство **_~prototype~_**, которое есть **только у функций**.
![](images/function-balls.svg)
![ico-20 pin] свойство **_~prototype~_** функций - это объект.
![ico-20 pin] в этом объекте есть свойство **~constructor~**.
![ico-20 pin] свойство **~constructor~** - это ссылка на саму функцию **_~sample()~_**.

Таким образом, функция генетически является конструктором, что явным образом прописано в ее свойстве **_~prototype~_**.

_____________________

Обратите также внимание на свойство **~&#95;&#95;proto&#95;&#95;~**, которое мы разберем далее
![ico-20 pin] это **ссылка** на объект, от которого функция унаследовала свои свойства и методы
![ico-20 pin] любая функция создается встроенным нативным объектом (конструктором) **Function**
^^(что свидетельствует о том, что функция - это **объект**).^^
![ico-20 pin] свойство **~constructor~** в **~&#95;&#95;proto&#95;&#95;~** - это ссылка на **Function**.

^^~[[FunctionLocation]]~ и ~[[Scopes]]~ добавляет Chrome DevTools для целей отладки^^

___________________________________

## [![ico-30 hw] Упражнения](test/functionObject)

[![ico-20 link] ^^w3schools^^](https://www.w3schools.com/js/js_scope.asp)
